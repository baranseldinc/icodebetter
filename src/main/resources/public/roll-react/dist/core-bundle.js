(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.window = global.window || {}));
}(this, function (exports) { 'use strict';

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
  	if (val === null || val === undefined) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}

  	return Object(val);
  }

  function shouldUseNative() {
  	try {
  		if (!Object.assign) {
  			return false;
  		}

  		// Detect buggy property enumeration order in older V8 versions.

  		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
  		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
  		test1[5] = 'de';
  		if (Object.getOwnPropertyNames(test1)[0] === '5') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test2 = {};
  		for (var i = 0; i < 10; i++) {
  			test2['_' + String.fromCharCode(i)] = i;
  		}
  		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
  			return test2[n];
  		});
  		if (order2.join('') !== '0123456789') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test3 = {};
  		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
  			test3[letter] = letter;
  		});
  		if (Object.keys(Object.assign({}, test3)).join('') !==
  				'abcdefghijklmnopqrst') {
  			return false;
  		}

  		return true;
  	} catch (err) {
  		// We don't expect any of the above to throw, but better to be safe.
  		return false;
  	}
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  	var from;
  	var to = toObject(target);
  	var symbols;

  	for (var s = 1; s < arguments.length; s++) {
  		from = Object(arguments[s]);

  		for (var key in from) {
  			if (hasOwnProperty.call(from, key)) {
  				to[key] = from[key];
  			}
  		}

  		if (getOwnPropertySymbols) {
  			symbols = getOwnPropertySymbols(from);
  			for (var i = 0; i < symbols.length; i++) {
  				if (propIsEnumerable.call(from, symbols[i])) {
  					to[symbols[i]] = from[symbols[i]];
  				}
  			}
  		}
  	}

  	return to;
  };

  var n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.concurrent_mode"):60111,y=n?Symbol.for("react.forward_ref"):60112,z=n?Symbol.for("react.suspense"):60113,aa=n?Symbol.for("react.memo"):
  60115,ba=n?Symbol.for("react.lazy"):60116,A="function"===typeof Symbol&&Symbol.iterator;function ca(a,b,d,c,e,g,h,f){if(!a){a=void 0;if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[d,c,e,g,h,f],m=0;a=Error(b.replace(/%s/g,function(){return l[m++]}));a.name="Invariant Violation";}a.framesToPop=1;throw a;}}
  function B(a){for(var b=arguments.length-1,d="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=0;c<b;c++)d+="&args[]="+encodeURIComponent(arguments[c+1]);ca(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",d);}var C={isMounted:function(){return !1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},D={};
  function E(a,b,d){this.props=a;this.context=b;this.refs=D;this.updater=d||C;}E.prototype.isReactComponent={};E.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?B("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState");};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};function F(){}F.prototype=E.prototype;function G(a,b,d){this.props=a;this.context=b;this.refs=D;this.updater=d||C;}var H=G.prototype=new F;
  H.constructor=G;objectAssign(H,E.prototype);H.isPureReactComponent=!0;var I={current:null},J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
  function M(a,b,d){var c=void 0,e={},g=null,h=null;if(null!=b)for(c in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=b[c]);var f=arguments.length-2;if(1===f)e.children=d;else if(1<f){for(var l=Array(f),m=0;m<f;m++)l[m]=arguments[m+2];e.children=l;}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===e[c]&&(e[c]=f[c]);return {$$typeof:p,type:a,key:g,ref:h,props:e,_owner:J.current}}
  function da(a,b){return {$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return "object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return "$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var O=/\/+/g,P=[];function Q(a,b,d,c){if(P.length){var e=P.pop();e.result=a;e.keyPrefix=b;e.func=d;e.context=c;e.count=0;return e}return {result:a,keyPrefix:b,func:d,context:c,count:0}}
  function R(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>P.length&&P.push(a);}
  function S(a,b,d,c){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var g=!1;if(null===a)g=!0;else switch(e){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0;}}if(g)return d(c,a,""===b?"."+T(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var h=0;h<a.length;h++){e=a[h];var f=b+T(e,h);g+=S(e,f,d,c);}else if(null===a||"object"!==typeof a?f=null:(f=A&&a[A]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),h=
  0;!(e=a.next()).done;)e=e.value,f=b+T(e,h++),g+=S(e,f,d,c);else"object"===e&&(d=""+a,B("31","[object Object]"===d?"object with keys {"+Object.keys(a).join(", ")+"}":d,""));return g}function U(a,b,d){return null==a?0:S(a,"",b,d)}function T(a,b){return "object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function ea(a,b){a.func.call(a.context,b,a.count++);}
  function fa(a,b,d){var c=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?V(a,c,d,function(a){return a}):null!=a&&(N(a)&&(a=da(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(O,"$&/")+"/")+d)),c.push(a));}function V(a,b,d,c,e){var g="";null!=d&&(g=(""+d).replace(O,"$&/")+"/");b=Q(b,g,c,e);U(a,fa,b);R(b);}function W(){var a=I.current;null===a?B("321"):void 0;return a}
  var X={Children:{map:function(a,b,d){if(null==a)return a;var c=[];V(a,c,null,b,d);return c},forEach:function(a,b,d){if(null==a)return a;b=Q(null,null,b,d);U(a,ea,b);R(b);},count:function(a){return U(a,function(){return null},null)},toArray:function(a){var b=[];V(a,b,null,function(a){return a});return b},only:function(a){N(a)?void 0:B("143");return a}},createRef:function(){return {current:null}},Component:E,PureComponent:G,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,
  _currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a},forwardRef:function(a){return {$$typeof:y,render:a}},lazy:function(a){return {$$typeof:ba,_ctor:a,_status:-1,_result:null}},memo:function(a,b){return {$$typeof:aa,type:a,compare:void 0===b?null:b}},useCallback:function(a,b){return W().useCallback(a,b)},useContext:function(a,b){return W().useContext(a,b)},useEffect:function(a,b){return W().useEffect(a,b)},useImperativeHandle:function(a,
  b,d){return W().useImperativeHandle(a,b,d)},useDebugValue:function(){},useLayoutEffect:function(a,b){return W().useLayoutEffect(a,b)},useMemo:function(a,b){return W().useMemo(a,b)},useReducer:function(a,b,d){return W().useReducer(a,b,d)},useRef:function(a){return W().useRef(a)},useState:function(a){return W().useState(a)},Fragment:r,StrictMode:t,Suspense:z,createElement:M,cloneElement:function(a,b,d){null===a||void 0===a?B("267",a):void 0;var c=void 0,e=objectAssign({},a.props),g=a.key,h=a.ref,f=a._owner;if(null!=
  b){void 0!==b.ref&&(h=b.ref,f=J.current);void 0!==b.key&&(g=""+b.key);var l=void 0;a.type&&a.type.defaultProps&&(l=a.type.defaultProps);for(c in b)K.call(b,c)&&!L.hasOwnProperty(c)&&(e[c]=void 0===b[c]&&void 0!==l?l[c]:b[c]);}c=arguments.length-2;if(1===c)e.children=d;else if(1<c){l=Array(c);for(var m=0;m<c;m++)l[m]=arguments[m+2];e.children=l;}return {$$typeof:p,type:a.type,key:g,ref:h,props:e,_owner:f}},createFactory:function(a){var b=M.bind(null,a);b.type=a;return b},isValidElement:N,version:"16.8.6",
  unstable_ConcurrentMode:x,unstable_Profiler:u,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentDispatcher:I,ReactCurrentOwner:J,assign:objectAssign}},Y={default:X},Z=Y&&X||Y;var react_production_min=Z.default||Z;

  var react = createCommonjsModule(function (module) {

  {
    module.exports = react_production_min;
  }
  });
  var react_1 = react.Children;
  var react_2 = react.Component;
  var react_3 = react.Fragment;
  var react_4 = react.PureComponent;
  var react_5 = react.StrictMode;
  var react_6 = react.Suspense;
  var react_7 = react.cloneElement;
  var react_8 = react.createContext;
  var react_9 = react.createElement;
  var react_10 = react.createFactory;
  var react_11 = react.createRef;
  var react_12 = react.forwardRef;
  var react_13 = react.isValidElement;
  var react_14 = react.lazy;
  var react_15 = react.memo;
  var react_16 = react.unstable_ConcurrentMode;
  var react_17 = react.unstable_Profiler;
  var react_18 = react.useCallback;
  var react_19 = react.useContext;
  var react_20 = react.useDebugValue;
  var react_21 = react.useEffect;
  var react_22 = react.useImperativeHandle;
  var react_23 = react.useLayoutEffect;
  var react_24 = react.useMemo;
  var react_25 = react.useReducer;
  var react_26 = react.useRef;
  var react_27 = react.useState;
  var react_28 = react.version;
  var react_29 = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  function findRouteName(url) {
    return routes[url];
  }
  var getPaths = function getPaths(pathname) {
    var paths = ["/"];
    if (pathname === "/") return paths;
    pathname.split("/").reduce(function (prev, curr, index) {
      var currPath = prev + "/" + curr;
      paths.push(currPath);
      return currPath;
    });
    return paths;
  };
  var BreadcrumbsItem = function BreadcrumbsItem(_ref) {
    var match = _ref.match;
    var routeName = findRouteName(match.url);

    if (routeName) {
      //	  if(routeName=='Home')routeName=createElement('i',{className:'icon-home'});
      if (routeName == "Home") routeName = react_9(Button, {
        className: "btn-round-shadow",
        color: "home",
        style: {
          marginTop: "-8px"
        }
      }, react_9("i", {
        className: "icon-home"
      }));
      return match.isExact ? react_9(BreadcrumbItem, {
        active: true
      }, routeName) : react_9(BreadcrumbItem, null, react_9(Link, {
        to: match.url || ""
      }, routeName));
    }

    return null;
  };
  var Breadcrumbs = function Breadcrumbs(_ref2) {
    var pathname = _ref2.location.pathname,
        match = _ref2.match;
    var paths = getPaths(pathname);
    var items = paths.map(function (path, i) {
      return react_9(Route, {
        key: i++,
        path: path,
        component: BreadcrumbsItem
      });
    });
    return react_9(Breadcrumb, null, react_9("h3", {
      id: "id-breed"
    }, _scd.projectName || "iCodeBetter"), react_9("span", {
      style: {
        width: "20px"
      }
    }, " "), items);
  };
  var Breadcrumb2$1 = function Breadcrumb2(props) {
    return react_9("div", {
      className: "d-md-down-none"
    }, react_9(Route, Object.assign({
      path: "/:path",
      component: Breadcrumbs
    }, props)));
  };
  /*
  export default props => (
    <div>
      <Route path="/:path" component={Breadcrumbs} {...props} />
    </div>
  );
  */

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

  function _typeof(obj) {
    if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
      _typeof = function _typeof(obj) {
        return _typeof2(obj);
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
      };
    }

    return _typeof(obj);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  var Header =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Header, _Component);

    function Header(props) {
      var _this;

      _classCallCheck(this, Header);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Header).call(this, props));
      _this.toggleRoles = _this.toggleRoles.bind(_assertThisInitialized(_this));
      _this.selectNewRole = _this.selectNewRole.bind(_assertThisInitialized(_this));
      _this.state = {
        rolesOpen: false
      };
      return _this;
    }

    _createClass(Header, [{
      key: "toggleRoles",
      value: function toggleRoles() {
        this.setState({
          rolesOpen: !this.state.rolesOpen
        });
      }
    }, {
      key: "selectNewRole",
      value: function selectNewRole(e) {
        var userRoleId = e.target.getAttribute("ur");
        if (userRoleId && 1 * userRoleId) iwb.request({
          url: "ajaxSelectUserRole?userRoleId=" + userRoleId + "&userCustomizationId=" + _scd.userCustomizationId,
          successCallback: function successCallback() {
            document.location = "main.htm?.r=" + new Date().getTime();
          }
        });
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        document.getElementById("id-iwb-logo").innerHTML = iwb.logo + " <span>iCodeBetter</span>";
      }
    }, {
      key: "render",
      value: function render() {
        var self = this;
        return react_9("div", {
          id: "id-header",
          className: "app-header navbar"
        }, react_9(NavbarToggler, {
          className: "d-lg-none",
          onClick: iwb.mobileSidebarToggle
        }, react_9("i", {
          className: "oi oi-menu",
          style: {
            fontSize: "16px"
          }
        })), react_9(NavbarBrand, {
          href: "#",
          id: "id-iwb-logo"
        }), react_9(NavbarToggler, {
          className: "d-md-down-none",
          onClick: iwb.sidebarMinimize
        }, react_9("i", {
          className: "oi oi-menu",
          style: {
            fontSize: "16px"
          }
        })), react_9(Breadcrumb2, {
          className: "d-md-down-none"
        }), react_9(Nav, {
          className: "d-md-down-none mr-auto",
          navbar: true
        }), _scd.session && _scd.sessionId != "nosession" && react_9("ul", {
          className: "ml-auto navbar-nav"
        }, react_9(NavItem, {
          className: "d-md-down-none nav-link"
        }, react_9("input", {
          type: "text",
          autoComplete: "off",
          id: "id-global-search",
          className: "global-search",
          onChange: iwb.onGlobalSearch,
          placeholder: "Quick search...",
          defaultValue: ""
        }), react_9("i", {
          onClick: function onClick() {
            var c = document.getElementById("id-global-search");
            c.focus();
          },
          style: {
            cursor: "pointer",
            fontSize: "17px",
            fontWeight: "bold",
            position: "absolute",
            top: "17px",
            right: "10px"
          },
          className: "icon-magnifier"
        })), react_9(NavItem, null, react_9("a", {
          href: "#",
          className: "nav-link",
          title: _scd.completeName + "\n" + _scd.roleDsc
        }, react_9("img", {
          src: "sf/pic" + _scd.userId + ".png",
          className: "img-avatar",
          style: {
            border: ".5px solid #cecece"
          },
          alt: _scd.email
        }))), react_9(NavItem, {
          className: "d-md-down-none"
        }, react_9("a", {
          "aria-haspopup": "true",
          href: "#",
          className: "nav-link",
          onClick: iwb.asideToggle
        }, react_9("i", {
          style: {
            fontSize: "18px"
          },
          className: "icon-bubbles"
        }), react_9("span", {
          className: "badge badge-danger badge-pill"
        }, "7"))), react_9(NavItem, null, react_9(Dropdown, {
          isOpen: this.state.rolesOpen,
          toggle: this.toggleRoles
        }, react_9(DropdownToggle, {
          tag: "i",
          className: "nav-link oi oi-grid-three-up",
          style: {
            fontSize: "18px",
            cursor: "pointer"
          }
        }), this.state.rolesOpen && qry_select_user_role1.data.length > 0 && react_9(DropdownMenu, {
          className: this.state.rolesOpen ? "show" : ""
        }, this.state.rolesOpen && react_9("div", {
          style: {
            padding: "7px 13px",
            background: "#afafaf",
            color: "#44423f",
            fontWeight: "500",
            fontSize: " 16px"
          }
        }, "Roller"), qry_select_user_role1.data.map(function (o, qi) {
          return react_9(DropdownItem, {
            ur: o.user_role_id,
            onClick: self.selectNewRole
          }, react_9("i", {
            className: "icon-drop",
            style: {
              marginRight: "5px",
              fontSize: "12px",
              color: "#777"
            }
          }), o.role_id_qw_);
        }))))), " ");
      }
    }]);

    return Header;
  }(react_2);

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var immutable = createCommonjsModule(function (module, exports) {
  /**
   *  Copyright (c) 2014-2015, Facebook, Inc.
   *  All rights reserved.
   *
   *  This source code is licensed under the BSD-style license found in the
   *  LICENSE file in the root directory of this source tree. An additional grant
   *  of patent rights can be found in the PATENTS file in the same directory.
   */

  (function (global, factory) {
    module.exports = factory();
  }(commonjsGlobal, function () {var SLICE$0 = Array.prototype.slice;

    function createClass(ctor, superClass) {
      if (superClass) {
        ctor.prototype = Object.create(superClass.prototype);
      }
      ctor.prototype.constructor = ctor;
    }

    function Iterable(value) {
        return isIterable(value) ? value : Seq(value);
      }


    createClass(KeyedIterable, Iterable);
      function KeyedIterable(value) {
        return isKeyed(value) ? value : KeyedSeq(value);
      }


    createClass(IndexedIterable, Iterable);
      function IndexedIterable(value) {
        return isIndexed(value) ? value : IndexedSeq(value);
      }


    createClass(SetIterable, Iterable);
      function SetIterable(value) {
        return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
      }



    function isIterable(maybeIterable) {
      return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
    }

    function isKeyed(maybeKeyed) {
      return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
    }

    function isIndexed(maybeIndexed) {
      return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
    }

    function isAssociative(maybeAssociative) {
      return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
    }

    function isOrdered(maybeOrdered) {
      return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
    }

    Iterable.isIterable = isIterable;
    Iterable.isKeyed = isKeyed;
    Iterable.isIndexed = isIndexed;
    Iterable.isAssociative = isAssociative;
    Iterable.isOrdered = isOrdered;

    Iterable.Keyed = KeyedIterable;
    Iterable.Indexed = IndexedIterable;
    Iterable.Set = SetIterable;


    var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
    var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
    var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
    var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

    // Used for setting prototype methods that IE8 chokes on.
    var DELETE = 'delete';

    // Constants describing the size of trie nodes.
    var SHIFT = 5; // Resulted in best performance after ______?
    var SIZE = 1 << SHIFT;
    var MASK = SIZE - 1;

    // A consistent shared value representing "not set" which equals nothing other
    // than itself, and nothing that could be provided externally.
    var NOT_SET = {};

    // Boolean references, Rough equivalent of `bool &`.
    var CHANGE_LENGTH = { value: false };
    var DID_ALTER = { value: false };

    function MakeRef(ref) {
      ref.value = false;
      return ref;
    }

    function SetRef(ref) {
      ref && (ref.value = true);
    }

    // A function which returns a value representing an "owner" for transient writes
    // to tries. The return value will only ever equal itself, and will not equal
    // the return of any subsequent call of this function.
    function OwnerID() {}

    // http://jsperf.com/copy-array-inline
    function arrCopy(arr, offset) {
      offset = offset || 0;
      var len = Math.max(0, arr.length - offset);
      var newArr = new Array(len);
      for (var ii = 0; ii < len; ii++) {
        newArr[ii] = arr[ii + offset];
      }
      return newArr;
    }

    function ensureSize(iter) {
      if (iter.size === undefined) {
        iter.size = iter.__iterate(returnTrue);
      }
      return iter.size;
    }

    function wrapIndex(iter, index) {
      // This implements "is array index" which the ECMAString spec defines as:
      //
      //     A String property name P is an array index if and only if
      //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
      //     to 2^32−1.
      //
      // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
      if (typeof index !== 'number') {
        var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
        if ('' + uint32Index !== index || uint32Index === 4294967295) {
          return NaN;
        }
        index = uint32Index;
      }
      return index < 0 ? ensureSize(iter) + index : index;
    }

    function returnTrue() {
      return true;
    }

    function wholeSlice(begin, end, size) {
      return (begin === 0 || (size !== undefined && begin <= -size)) &&
        (end === undefined || (size !== undefined && end >= size));
    }

    function resolveBegin(begin, size) {
      return resolveIndex(begin, size, 0);
    }

    function resolveEnd(end, size) {
      return resolveIndex(end, size, size);
    }

    function resolveIndex(index, size, defaultIndex) {
      return index === undefined ?
        defaultIndex :
        index < 0 ?
          Math.max(0, size + index) :
          size === undefined ?
            index :
            Math.min(size, index);
    }

    /* global Symbol */

    var ITERATE_KEYS = 0;
    var ITERATE_VALUES = 1;
    var ITERATE_ENTRIES = 2;

    var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


    function Iterator(next) {
        this.next = next;
      }

      Iterator.prototype.toString = function() {
        return '[Iterator]';
      };


    Iterator.KEYS = ITERATE_KEYS;
    Iterator.VALUES = ITERATE_VALUES;
    Iterator.ENTRIES = ITERATE_ENTRIES;

    Iterator.prototype.inspect =
    Iterator.prototype.toSource = function () { return this.toString(); };
    Iterator.prototype[ITERATOR_SYMBOL] = function () {
      return this;
    };


    function iteratorValue(type, k, v, iteratorResult) {
      var value = type === 0 ? k : type === 1 ? v : [k, v];
      iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
        value: value, done: false
      });
      return iteratorResult;
    }

    function iteratorDone() {
      return { value: undefined, done: true };
    }

    function hasIterator(maybeIterable) {
      return !!getIteratorFn(maybeIterable);
    }

    function isIterator(maybeIterator) {
      return maybeIterator && typeof maybeIterator.next === 'function';
    }

    function getIterator(iterable) {
      var iteratorFn = getIteratorFn(iterable);
      return iteratorFn && iteratorFn.call(iterable);
    }

    function getIteratorFn(iterable) {
      var iteratorFn = iterable && (
        (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
        iterable[FAUX_ITERATOR_SYMBOL]
      );
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    function isArrayLike(value) {
      return value && typeof value.length === 'number';
    }

    createClass(Seq, Iterable);
      function Seq(value) {
        return value === null || value === undefined ? emptySequence() :
          isIterable(value) ? value.toSeq() : seqFromValue(value);
      }

      Seq.of = function(/*...values*/) {
        return Seq(arguments);
      };

      Seq.prototype.toSeq = function() {
        return this;
      };

      Seq.prototype.toString = function() {
        return this.__toString('Seq {', '}');
      };

      Seq.prototype.cacheResult = function() {
        if (!this._cache && this.__iterateUncached) {
          this._cache = this.entrySeq().toArray();
          this.size = this._cache.length;
        }
        return this;
      };

      // abstract __iterateUncached(fn, reverse)

      Seq.prototype.__iterate = function(fn, reverse) {
        return seqIterate(this, fn, reverse, true);
      };

      // abstract __iteratorUncached(type, reverse)

      Seq.prototype.__iterator = function(type, reverse) {
        return seqIterator(this, type, reverse, true);
      };



    createClass(KeyedSeq, Seq);
      function KeyedSeq(value) {
        return value === null || value === undefined ?
          emptySequence().toKeyedSeq() :
          isIterable(value) ?
            (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
            keyedSeqFromValue(value);
      }

      KeyedSeq.prototype.toKeyedSeq = function() {
        return this;
      };



    createClass(IndexedSeq, Seq);
      function IndexedSeq(value) {
        return value === null || value === undefined ? emptySequence() :
          !isIterable(value) ? indexedSeqFromValue(value) :
          isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
      }

      IndexedSeq.of = function(/*...values*/) {
        return IndexedSeq(arguments);
      };

      IndexedSeq.prototype.toIndexedSeq = function() {
        return this;
      };

      IndexedSeq.prototype.toString = function() {
        return this.__toString('Seq [', ']');
      };

      IndexedSeq.prototype.__iterate = function(fn, reverse) {
        return seqIterate(this, fn, reverse, false);
      };

      IndexedSeq.prototype.__iterator = function(type, reverse) {
        return seqIterator(this, type, reverse, false);
      };



    createClass(SetSeq, Seq);
      function SetSeq(value) {
        return (
          value === null || value === undefined ? emptySequence() :
          !isIterable(value) ? indexedSeqFromValue(value) :
          isKeyed(value) ? value.entrySeq() : value
        ).toSetSeq();
      }

      SetSeq.of = function(/*...values*/) {
        return SetSeq(arguments);
      };

      SetSeq.prototype.toSetSeq = function() {
        return this;
      };



    Seq.isSeq = isSeq;
    Seq.Keyed = KeyedSeq;
    Seq.Set = SetSeq;
    Seq.Indexed = IndexedSeq;

    var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

    Seq.prototype[IS_SEQ_SENTINEL] = true;



    createClass(ArraySeq, IndexedSeq);
      function ArraySeq(array) {
        this._array = array;
        this.size = array.length;
      }

      ArraySeq.prototype.get = function(index, notSetValue) {
        return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
      };

      ArraySeq.prototype.__iterate = function(fn, reverse) {
        var array = this._array;
        var maxIndex = array.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
            return ii + 1;
          }
        }
        return ii;
      };

      ArraySeq.prototype.__iterator = function(type, reverse) {
        var array = this._array;
        var maxIndex = array.length - 1;
        var ii = 0;
        return new Iterator(function() 
          {return ii > maxIndex ?
            iteratorDone() :
            iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
        );
      };



    createClass(ObjectSeq, KeyedSeq);
      function ObjectSeq(object) {
        var keys = Object.keys(object);
        this._object = object;
        this._keys = keys;
        this.size = keys.length;
      }

      ObjectSeq.prototype.get = function(key, notSetValue) {
        if (notSetValue !== undefined && !this.has(key)) {
          return notSetValue;
        }
        return this._object[key];
      };

      ObjectSeq.prototype.has = function(key) {
        return this._object.hasOwnProperty(key);
      };

      ObjectSeq.prototype.__iterate = function(fn, reverse) {
        var object = this._object;
        var keys = this._keys;
        var maxIndex = keys.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var key = keys[reverse ? maxIndex - ii : ii];
          if (fn(object[key], key, this) === false) {
            return ii + 1;
          }
        }
        return ii;
      };

      ObjectSeq.prototype.__iterator = function(type, reverse) {
        var object = this._object;
        var keys = this._keys;
        var maxIndex = keys.length - 1;
        var ii = 0;
        return new Iterator(function()  {
          var key = keys[reverse ? maxIndex - ii : ii];
          return ii++ > maxIndex ?
            iteratorDone() :
            iteratorValue(type, key, object[key]);
        });
      };

    ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


    createClass(IterableSeq, IndexedSeq);
      function IterableSeq(iterable) {
        this._iterable = iterable;
        this.size = iterable.length || iterable.size;
      }

      IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var iterable = this._iterable;
        var iterator = getIterator(iterable);
        var iterations = 0;
        if (isIterator(iterator)) {
          var step;
          while (!(step = iterator.next()).done) {
            if (fn(step.value, iterations++, this) === false) {
              break;
            }
          }
        }
        return iterations;
      };

      IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterable = this._iterable;
        var iterator = getIterator(iterable);
        if (!isIterator(iterator)) {
          return new Iterator(iteratorDone);
        }
        var iterations = 0;
        return new Iterator(function()  {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type, iterations++, step.value);
        });
      };



    createClass(IteratorSeq, IndexedSeq);
      function IteratorSeq(iterator) {
        this._iterator = iterator;
        this._iteratorCache = [];
      }

      IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var iterator = this._iterator;
        var cache = this._iteratorCache;
        var iterations = 0;
        while (iterations < cache.length) {
          if (fn(cache[iterations], iterations++, this) === false) {
            return iterations;
          }
        }
        var step;
        while (!(step = iterator.next()).done) {
          var val = step.value;
          cache[iterations] = val;
          if (fn(val, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };

      IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = this._iterator;
        var cache = this._iteratorCache;
        var iterations = 0;
        return new Iterator(function()  {
          if (iterations >= cache.length) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            cache[iterations] = step.value;
          }
          return iteratorValue(type, iterations, cache[iterations++]);
        });
      };




    // # pragma Helper functions

    function isSeq(maybeSeq) {
      return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
    }

    var EMPTY_SEQ;

    function emptySequence() {
      return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
    }

    function keyedSeqFromValue(value) {
      var seq =
        Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
        isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
        hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
        typeof value === 'object' ? new ObjectSeq(value) :
        undefined;
      if (!seq) {
        throw new TypeError(
          'Expected Array or iterable object of [k, v] entries, '+
          'or keyed object: ' + value
        );
      }
      return seq;
    }

    function indexedSeqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value);
      if (!seq) {
        throw new TypeError(
          'Expected Array or iterable object of values: ' + value
        );
      }
      return seq;
    }

    function seqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value) ||
        (typeof value === 'object' && new ObjectSeq(value));
      if (!seq) {
        throw new TypeError(
          'Expected Array or iterable object of values, or keyed object: ' + value
        );
      }
      return seq;
    }

    function maybeIndexedSeqFromValue(value) {
      return (
        isArrayLike(value) ? new ArraySeq(value) :
        isIterator(value) ? new IteratorSeq(value) :
        hasIterator(value) ? new IterableSeq(value) :
        undefined
      );
    }

    function seqIterate(seq, fn, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var entry = cache[reverse ? maxIndex - ii : ii];
          if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
            return ii + 1;
          }
        }
        return ii;
      }
      return seq.__iterateUncached(fn, reverse);
    }

    function seqIterator(seq, type, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        var ii = 0;
        return new Iterator(function()  {
          var entry = cache[reverse ? maxIndex - ii : ii];
          return ii++ > maxIndex ?
            iteratorDone() :
            iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
        });
      }
      return seq.__iteratorUncached(type, reverse);
    }

    function fromJS(json, converter) {
      return converter ?
        fromJSWith(converter, json, '', {'': json}) :
        fromJSDefault(json);
    }

    function fromJSWith(converter, json, key, parentJSON) {
      if (Array.isArray(json)) {
        return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
      }
      if (isPlainObj(json)) {
        return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
      }
      return json;
    }

    function fromJSDefault(json) {
      if (Array.isArray(json)) {
        return IndexedSeq(json).map(fromJSDefault).toList();
      }
      if (isPlainObj(json)) {
        return KeyedSeq(json).map(fromJSDefault).toMap();
      }
      return json;
    }

    function isPlainObj(value) {
      return value && (value.constructor === Object || value.constructor === undefined);
    }

    /**
     * An extension of the "same-value" algorithm as [described for use by ES6 Map
     * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
     *
     * NaN is considered the same as NaN, however -0 and 0 are considered the same
     * value, which is different from the algorithm described by
     * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
     *
     * This is extended further to allow Objects to describe the values they
     * represent, by way of `valueOf` or `equals` (and `hashCode`).
     *
     * Note: because of this extension, the key equality of Immutable.Map and the
     * value equality of Immutable.Set will differ from ES6 Map and Set.
     *
     * ### Defining custom values
     *
     * The easiest way to describe the value an object represents is by implementing
     * `valueOf`. For example, `Date` represents a value by returning a unix
     * timestamp for `valueOf`:
     *
     *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
     *     var date2 = new Date(1234567890000);
     *     date1.valueOf(); // 1234567890000
     *     assert( date1 !== date2 );
     *     assert( Immutable.is( date1, date2 ) );
     *
     * Note: overriding `valueOf` may have other implications if you use this object
     * where JavaScript expects a primitive, such as implicit string coercion.
     *
     * For more complex types, especially collections, implementing `valueOf` may
     * not be performant. An alternative is to implement `equals` and `hashCode`.
     *
     * `equals` takes another object, presumably of similar type, and returns true
     * if the it is equal. Equality is symmetrical, so the same result should be
     * returned if this and the argument are flipped.
     *
     *     assert( a.equals(b) === b.equals(a) );
     *
     * `hashCode` returns a 32bit integer number representing the object which will
     * be used to determine how to store the value object in a Map or Set. You must
     * provide both or neither methods, one must not exist without the other.
     *
     * Also, an important relationship between these methods must be upheld: if two
     * values are equal, they *must* return the same hashCode. If the values are not
     * equal, they might have the same hashCode; this is called a hash collision,
     * and while undesirable for performance reasons, it is acceptable.
     *
     *     if (a.equals(b)) {
     *       assert( a.hashCode() === b.hashCode() );
     *     }
     *
     * All Immutable collections implement `equals` and `hashCode`.
     *
     */
    function is(valueA, valueB) {
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
      if (typeof valueA.valueOf === 'function' &&
          typeof valueB.valueOf === 'function') {
        valueA = valueA.valueOf();
        valueB = valueB.valueOf();
        if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
          return true;
        }
        if (!valueA || !valueB) {
          return false;
        }
      }
      if (typeof valueA.equals === 'function' &&
          typeof valueB.equals === 'function' &&
          valueA.equals(valueB)) {
        return true;
      }
      return false;
    }

    function deepEqual(a, b) {
      if (a === b) {
        return true;
      }

      if (
        !isIterable(b) ||
        a.size !== undefined && b.size !== undefined && a.size !== b.size ||
        a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
        isKeyed(a) !== isKeyed(b) ||
        isIndexed(a) !== isIndexed(b) ||
        isOrdered(a) !== isOrdered(b)
      ) {
        return false;
      }

      if (a.size === 0 && b.size === 0) {
        return true;
      }

      var notAssociative = !isAssociative(a);

      if (isOrdered(a)) {
        var entries = a.entries();
        return b.every(function(v, k)  {
          var entry = entries.next().value;
          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
        }) && entries.next().done;
      }

      var flipped = false;

      if (a.size === undefined) {
        if (b.size === undefined) {
          if (typeof a.cacheResult === 'function') {
            a.cacheResult();
          }
        } else {
          flipped = true;
          var _ = a;
          a = b;
          b = _;
        }
      }

      var allEqual = true;
      var bSize = b.__iterate(function(v, k)  {
        if (notAssociative ? !a.has(v) :
            flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
          allEqual = false;
          return false;
        }
      });

      return allEqual && a.size === bSize;
    }

    createClass(Repeat, IndexedSeq);

      function Repeat(value, times) {
        if (!(this instanceof Repeat)) {
          return new Repeat(value, times);
        }
        this._value = value;
        this.size = times === undefined ? Infinity : Math.max(0, times);
        if (this.size === 0) {
          if (EMPTY_REPEAT) {
            return EMPTY_REPEAT;
          }
          EMPTY_REPEAT = this;
        }
      }

      Repeat.prototype.toString = function() {
        if (this.size === 0) {
          return 'Repeat []';
        }
        return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
      };

      Repeat.prototype.get = function(index, notSetValue) {
        return this.has(index) ? this._value : notSetValue;
      };

      Repeat.prototype.includes = function(searchValue) {
        return is(this._value, searchValue);
      };

      Repeat.prototype.slice = function(begin, end) {
        var size = this.size;
        return wholeSlice(begin, end, size) ? this :
          new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
      };

      Repeat.prototype.reverse = function() {
        return this;
      };

      Repeat.prototype.indexOf = function(searchValue) {
        if (is(this._value, searchValue)) {
          return 0;
        }
        return -1;
      };

      Repeat.prototype.lastIndexOf = function(searchValue) {
        if (is(this._value, searchValue)) {
          return this.size;
        }
        return -1;
      };

      Repeat.prototype.__iterate = function(fn, reverse) {
        for (var ii = 0; ii < this.size; ii++) {
          if (fn(this._value, ii, this) === false) {
            return ii + 1;
          }
        }
        return ii;
      };

      Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
        var ii = 0;
        return new Iterator(function() 
          {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
        );
      };

      Repeat.prototype.equals = function(other) {
        return other instanceof Repeat ?
          is(this._value, other._value) :
          deepEqual(other);
      };


    var EMPTY_REPEAT;

    function invariant(condition, error) {
      if (!condition) throw new Error(error);
    }

    createClass(Range, IndexedSeq);

      function Range(start, end, step) {
        if (!(this instanceof Range)) {
          return new Range(start, end, step);
        }
        invariant(step !== 0, 'Cannot step a Range by 0');
        start = start || 0;
        if (end === undefined) {
          end = Infinity;
        }
        step = step === undefined ? 1 : Math.abs(step);
        if (end < start) {
          step = -step;
        }
        this._start = start;
        this._end = end;
        this._step = step;
        this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
        if (this.size === 0) {
          if (EMPTY_RANGE) {
            return EMPTY_RANGE;
          }
          EMPTY_RANGE = this;
        }
      }

      Range.prototype.toString = function() {
        if (this.size === 0) {
          return 'Range []';
        }
        return 'Range [ ' +
          this._start + '...' + this._end +
          (this._step > 1 ? ' by ' + this._step : '') +
        ' ]';
      };

      Range.prototype.get = function(index, notSetValue) {
        return this.has(index) ?
          this._start + wrapIndex(this, index) * this._step :
          notSetValue;
      };

      Range.prototype.includes = function(searchValue) {
        var possibleIndex = (searchValue - this._start) / this._step;
        return possibleIndex >= 0 &&
          possibleIndex < this.size &&
          possibleIndex === Math.floor(possibleIndex);
      };

      Range.prototype.slice = function(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        begin = resolveBegin(begin, this.size);
        end = resolveEnd(end, this.size);
        if (end <= begin) {
          return new Range(0, 0);
        }
        return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
      };

      Range.prototype.indexOf = function(searchValue) {
        var offsetValue = searchValue - this._start;
        if (offsetValue % this._step === 0) {
          var index = offsetValue / this._step;
          if (index >= 0 && index < this.size) {
            return index
          }
        }
        return -1;
      };

      Range.prototype.lastIndexOf = function(searchValue) {
        return this.indexOf(searchValue);
      };

      Range.prototype.__iterate = function(fn, reverse) {
        var maxIndex = this.size - 1;
        var step = this._step;
        var value = reverse ? this._start + maxIndex * step : this._start;
        for (var ii = 0; ii <= maxIndex; ii++) {
          if (fn(value, ii, this) === false) {
            return ii + 1;
          }
          value += reverse ? -step : step;
        }
        return ii;
      };

      Range.prototype.__iterator = function(type, reverse) {
        var maxIndex = this.size - 1;
        var step = this._step;
        var value = reverse ? this._start + maxIndex * step : this._start;
        var ii = 0;
        return new Iterator(function()  {
          var v = value;
          value += reverse ? -step : step;
          return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
        });
      };

      Range.prototype.equals = function(other) {
        return other instanceof Range ?
          this._start === other._start &&
          this._end === other._end &&
          this._step === other._step :
          deepEqual(this, other);
      };


    var EMPTY_RANGE;

    createClass(Collection, Iterable);
      function Collection() {
        throw TypeError('Abstract');
      }


    createClass(KeyedCollection, Collection);function KeyedCollection() {}

    createClass(IndexedCollection, Collection);function IndexedCollection() {}

    createClass(SetCollection, Collection);function SetCollection() {}


    Collection.Keyed = KeyedCollection;
    Collection.Indexed = IndexedCollection;
    Collection.Set = SetCollection;

    var imul =
      typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
      Math.imul :
      function imul(a, b) {
        a = a | 0; // int
        b = b | 0; // int
        var c = a & 0xffff;
        var d = b & 0xffff;
        // Shift by 0 fixes the sign on the high part.
        return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
      };

    // v8 has an optimization for storing 31-bit signed numbers.
    // Values which have either 00 or 11 as the high order bits qualify.
    // This function drops the highest order bit in a signed number, maintaining
    // the sign bit.
    function smi(i32) {
      return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
    }

    function hash(o) {
      if (o === false || o === null || o === undefined) {
        return 0;
      }
      if (typeof o.valueOf === 'function') {
        o = o.valueOf();
        if (o === false || o === null || o === undefined) {
          return 0;
        }
      }
      if (o === true) {
        return 1;
      }
      var type = typeof o;
      if (type === 'number') {
        var h = o | 0;
        if (h !== o) {
          h ^= o * 0xFFFFFFFF;
        }
        while (o > 0xFFFFFFFF) {
          o /= 0xFFFFFFFF;
          h ^= o;
        }
        return smi(h);
      }
      if (type === 'string') {
        return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
      }
      if (typeof o.hashCode === 'function') {
        return o.hashCode();
      }
      if (type === 'object') {
        return hashJSObj(o);
      }
      if (typeof o.toString === 'function') {
        return hashString(o.toString());
      }
      throw new Error('Value type ' + type + ' cannot be hashed.');
    }

    function cachedHashString(string) {
      var hash = stringHashCache[string];
      if (hash === undefined) {
        hash = hashString(string);
        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
          STRING_HASH_CACHE_SIZE = 0;
          stringHashCache = {};
        }
        STRING_HASH_CACHE_SIZE++;
        stringHashCache[string] = hash;
      }
      return hash;
    }

    // http://jsperf.com/hashing-strings
    function hashString(string) {
      // This is the hash from JVM
      // The hash code for a string is computed as
      // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
      // where s[i] is the ith character of the string and n is the length of
      // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
      // (exclusive) by dropping high bits.
      var hash = 0;
      for (var ii = 0; ii < string.length; ii++) {
        hash = 31 * hash + string.charCodeAt(ii) | 0;
      }
      return smi(hash);
    }

    function hashJSObj(obj) {
      var hash;
      if (usingWeakMap) {
        hash = weakMap.get(obj);
        if (hash !== undefined) {
          return hash;
        }
      }

      hash = obj[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      if (!canDefineProperty) {
        hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
        if (hash !== undefined) {
          return hash;
        }

        hash = getIENodeHash(obj);
        if (hash !== undefined) {
          return hash;
        }
      }

      hash = ++objHashUID;
      if (objHashUID & 0x40000000) {
        objHashUID = 0;
      }

      if (usingWeakMap) {
        weakMap.set(obj, hash);
      } else if (isExtensible !== undefined && isExtensible(obj) === false) {
        throw new Error('Non-extensible objects are not allowed as keys.');
      } else if (canDefineProperty) {
        Object.defineProperty(obj, UID_HASH_KEY, {
          'enumerable': false,
          'configurable': false,
          'writable': false,
          'value': hash
        });
      } else if (obj.propertyIsEnumerable !== undefined &&
                 obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
        // Since we can't define a non-enumerable property on the object
        // we'll hijack one of the less-used non-enumerable properties to
        // save our hash on it. Since this is a function it will not show up in
        // `JSON.stringify` which is what we want.
        obj.propertyIsEnumerable = function() {
          return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
        };
        obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
      } else if (obj.nodeType !== undefined) {
        // At this point we couldn't get the IE `uniqueID` to use as a hash
        // and we couldn't use a non-enumerable property to exploit the
        // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
        // itself.
        obj[UID_HASH_KEY] = hash;
      } else {
        throw new Error('Unable to set a non-enumerable property on object.');
      }

      return hash;
    }

    // Get references to ES5 object methods.
    var isExtensible = Object.isExtensible;

    // True if Object.defineProperty works as expected. IE8 fails this test.
    var canDefineProperty = (function() {
      try {
        Object.defineProperty({}, '@', {});
        return true;
      } catch (e) {
        return false;
      }
    }());

    // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
    // and avoid memory leaks from the IE cloneNode bug.
    function getIENodeHash(node) {
      if (node && node.nodeType > 0) {
        switch (node.nodeType) {
          case 1: // Element
            return node.uniqueID;
          case 9: // Document
            return node.documentElement && node.documentElement.uniqueID;
        }
      }
    }

    // If possible, use a WeakMap.
    var usingWeakMap = typeof WeakMap === 'function';
    var weakMap;
    if (usingWeakMap) {
      weakMap = new WeakMap();
    }

    var objHashUID = 0;

    var UID_HASH_KEY = '__immutablehash__';
    if (typeof Symbol === 'function') {
      UID_HASH_KEY = Symbol(UID_HASH_KEY);
    }

    var STRING_HASH_CACHE_MIN_STRLEN = 16;
    var STRING_HASH_CACHE_MAX_SIZE = 255;
    var STRING_HASH_CACHE_SIZE = 0;
    var stringHashCache = {};

    function assertNotInfinite(size) {
      invariant(
        size !== Infinity,
        'Cannot perform this action with an infinite size.'
      );
    }

    createClass(Map, KeyedCollection);

      // @pragma Construction

      function Map(value) {
        return value === null || value === undefined ? emptyMap() :
          isMap(value) && !isOrdered(value) ? value :
          emptyMap().withMutations(function(map ) {
            var iter = KeyedIterable(value);
            assertNotInfinite(iter.size);
            iter.forEach(function(v, k)  {return map.set(k, v)});
          });
      }

      Map.prototype.toString = function() {
        return this.__toString('Map {', '}');
      };

      // @pragma Access

      Map.prototype.get = function(k, notSetValue) {
        return this._root ?
          this._root.get(0, undefined, k, notSetValue) :
          notSetValue;
      };

      // @pragma Modification

      Map.prototype.set = function(k, v) {
        return updateMap(this, k, v);
      };

      Map.prototype.setIn = function(keyPath, v) {
        return this.updateIn(keyPath, NOT_SET, function()  {return v});
      };

      Map.prototype.remove = function(k) {
        return updateMap(this, k, NOT_SET);
      };

      Map.prototype.deleteIn = function(keyPath) {
        return this.updateIn(keyPath, function()  {return NOT_SET});
      };

      Map.prototype.update = function(k, notSetValue, updater) {
        return arguments.length === 1 ?
          k(this) :
          this.updateIn([k], notSetValue, updater);
      };

      Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
        if (!updater) {
          updater = notSetValue;
          notSetValue = undefined;
        }
        var updatedValue = updateInDeepMap(
          this,
          forceIterator(keyPath),
          notSetValue,
          updater
        );
        return updatedValue === NOT_SET ? undefined : updatedValue;
      };

      Map.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._root = null;
          this.__hash = undefined;
          this.__altered = true;
          return this;
        }
        return emptyMap();
      };

      // @pragma Composition

      Map.prototype.merge = function(/*...iters*/) {
        return mergeIntoMapWith(this, undefined, arguments);
      };

      Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
        return mergeIntoMapWith(this, merger, iters);
      };

      Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
        return this.updateIn(
          keyPath,
          emptyMap(),
          function(m ) {return typeof m.merge === 'function' ?
            m.merge.apply(m, iters) :
            iters[iters.length - 1]}
        );
      };

      Map.prototype.mergeDeep = function(/*...iters*/) {
        return mergeIntoMapWith(this, deepMerger, arguments);
      };

      Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
        return mergeIntoMapWith(this, deepMergerWith(merger), iters);
      };

      Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
        return this.updateIn(
          keyPath,
          emptyMap(),
          function(m ) {return typeof m.mergeDeep === 'function' ?
            m.mergeDeep.apply(m, iters) :
            iters[iters.length - 1]}
        );
      };

      Map.prototype.sort = function(comparator) {
        // Late binding
        return OrderedMap(sortFactory(this, comparator));
      };

      Map.prototype.sortBy = function(mapper, comparator) {
        // Late binding
        return OrderedMap(sortFactory(this, comparator, mapper));
      };

      // @pragma Mutability

      Map.prototype.withMutations = function(fn) {
        var mutable = this.asMutable();
        fn(mutable);
        return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
      };

      Map.prototype.asMutable = function() {
        return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
      };

      Map.prototype.asImmutable = function() {
        return this.__ensureOwner();
      };

      Map.prototype.wasAltered = function() {
        return this.__altered;
      };

      Map.prototype.__iterator = function(type, reverse) {
        return new MapIterator(this, type, reverse);
      };

      Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
        var iterations = 0;
        this._root && this._root.iterate(function(entry ) {
          iterations++;
          return fn(entry[1], entry[0], this$0);
        }, reverse);
        return iterations;
      };

      Map.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeMap(this.size, this._root, ownerID, this.__hash);
      };


    function isMap(maybeMap) {
      return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
    }

    Map.isMap = isMap;

    var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

    var MapPrototype = Map.prototype;
    MapPrototype[IS_MAP_SENTINEL] = true;
    MapPrototype[DELETE] = MapPrototype.remove;
    MapPrototype.removeIn = MapPrototype.deleteIn;


    // #pragma Trie Nodes



      function ArrayMapNode(ownerID, entries) {
        this.ownerID = ownerID;
        this.entries = entries;
      }

      ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
        var entries = this.entries;
        for (var ii = 0, len = entries.length; ii < len; ii++) {
          if (is(key, entries[ii][0])) {
            return entries[ii][1];
          }
        }
        return notSetValue;
      };

      ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        var removed = value === NOT_SET;

        var entries = this.entries;
        var idx = 0;
        for (var len = entries.length; idx < len; idx++) {
          if (is(key, entries[idx][0])) {
            break;
          }
        }
        var exists = idx < len;

        if (exists ? entries[idx][1] === value : removed) {
          return this;
        }

        SetRef(didAlter);
        (removed || !exists) && SetRef(didChangeSize);

        if (removed && entries.length === 1) {
          return; // undefined
        }

        if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
          return createNodes(ownerID, entries, key, value);
        }

        var isEditable = ownerID && ownerID === this.ownerID;
        var newEntries = isEditable ? entries : arrCopy(entries);

        if (exists) {
          if (removed) {
            idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
          } else {
            newEntries[idx] = [key, value];
          }
        } else {
          newEntries.push([key, value]);
        }

        if (isEditable) {
          this.entries = newEntries;
          return this;
        }

        return new ArrayMapNode(ownerID, newEntries);
      };




      function BitmapIndexedNode(ownerID, bitmap, nodes) {
        this.ownerID = ownerID;
        this.bitmap = bitmap;
        this.nodes = nodes;
      }

      BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
        if (keyHash === undefined) {
          keyHash = hash(key);
        }
        var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
        var bitmap = this.bitmap;
        return (bitmap & bit) === 0 ? notSetValue :
          this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
      };

      BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === undefined) {
          keyHash = hash(key);
        }
        var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var bit = 1 << keyHashFrag;
        var bitmap = this.bitmap;
        var exists = (bitmap & bit) !== 0;

        if (!exists && value === NOT_SET) {
          return this;
        }

        var idx = popCount(bitmap & (bit - 1));
        var nodes = this.nodes;
        var node = exists ? nodes[idx] : undefined;
        var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

        if (newNode === node) {
          return this;
        }

        if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
          return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
        }

        if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
          return nodes[idx ^ 1];
        }

        if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
          return newNode;
        }

        var isEditable = ownerID && ownerID === this.ownerID;
        var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
        var newNodes = exists ? newNode ?
          setIn(nodes, idx, newNode, isEditable) :
          spliceOut(nodes, idx, isEditable) :
          spliceIn(nodes, idx, newNode, isEditable);

        if (isEditable) {
          this.bitmap = newBitmap;
          this.nodes = newNodes;
          return this;
        }

        return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
      };




      function HashArrayMapNode(ownerID, count, nodes) {
        this.ownerID = ownerID;
        this.count = count;
        this.nodes = nodes;
      }

      HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
        if (keyHash === undefined) {
          keyHash = hash(key);
        }
        var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var node = this.nodes[idx];
        return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
      };

      HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === undefined) {
          keyHash = hash(key);
        }
        var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var removed = value === NOT_SET;
        var nodes = this.nodes;
        var node = nodes[idx];

        if (removed && !node) {
          return this;
        }

        var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
        if (newNode === node) {
          return this;
        }

        var newCount = this.count;
        if (!node) {
          newCount++;
        } else if (!newNode) {
          newCount--;
          if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
            return packNodes(ownerID, nodes, newCount, idx);
          }
        }

        var isEditable = ownerID && ownerID === this.ownerID;
        var newNodes = setIn(nodes, idx, newNode, isEditable);

        if (isEditable) {
          this.count = newCount;
          this.nodes = newNodes;
          return this;
        }

        return new HashArrayMapNode(ownerID, newCount, newNodes);
      };




      function HashCollisionNode(ownerID, keyHash, entries) {
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entries = entries;
      }

      HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
        var entries = this.entries;
        for (var ii = 0, len = entries.length; ii < len; ii++) {
          if (is(key, entries[ii][0])) {
            return entries[ii][1];
          }
        }
        return notSetValue;
      };

      HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        if (keyHash === undefined) {
          keyHash = hash(key);
        }

        var removed = value === NOT_SET;

        if (keyHash !== this.keyHash) {
          if (removed) {
            return this;
          }
          SetRef(didAlter);
          SetRef(didChangeSize);
          return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
        }

        var entries = this.entries;
        var idx = 0;
        for (var len = entries.length; idx < len; idx++) {
          if (is(key, entries[idx][0])) {
            break;
          }
        }
        var exists = idx < len;

        if (exists ? entries[idx][1] === value : removed) {
          return this;
        }

        SetRef(didAlter);
        (removed || !exists) && SetRef(didChangeSize);

        if (removed && len === 2) {
          return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
        }

        var isEditable = ownerID && ownerID === this.ownerID;
        var newEntries = isEditable ? entries : arrCopy(entries);

        if (exists) {
          if (removed) {
            idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
          } else {
            newEntries[idx] = [key, value];
          }
        } else {
          newEntries.push([key, value]);
        }

        if (isEditable) {
          this.entries = newEntries;
          return this;
        }

        return new HashCollisionNode(ownerID, this.keyHash, newEntries);
      };




      function ValueNode(ownerID, keyHash, entry) {
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entry = entry;
      }

      ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
        return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
      };

      ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
        var removed = value === NOT_SET;
        var keyMatch = is(key, this.entry[0]);
        if (keyMatch ? value === this.entry[1] : removed) {
          return this;
        }

        SetRef(didAlter);

        if (removed) {
          SetRef(didChangeSize);
          return; // undefined
        }

        if (keyMatch) {
          if (ownerID && ownerID === this.ownerID) {
            this.entry[1] = value;
            return this;
          }
          return new ValueNode(ownerID, this.keyHash, [key, value]);
        }

        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
      };



    // #pragma Iterators

    ArrayMapNode.prototype.iterate =
    HashCollisionNode.prototype.iterate = function (fn, reverse) {
      var entries = this.entries;
      for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };

    BitmapIndexedNode.prototype.iterate =
    HashArrayMapNode.prototype.iterate = function (fn, reverse) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse) === false) {
          return false;
        }
      }
    };

    ValueNode.prototype.iterate = function (fn, reverse) {
      return fn(this.entry);
    };

    createClass(MapIterator, Iterator);

      function MapIterator(map, type, reverse) {
        this._type = type;
        this._reverse = reverse;
        this._stack = map._root && mapIteratorFrame(map._root);
      }

      MapIterator.prototype.next = function() {
        var type = this._type;
        var stack = this._stack;
        while (stack) {
          var node = stack.node;
          var index = stack.index++;
          var maxIndex;
          if (node.entry) {
            if (index === 0) {
              return mapIteratorValue(type, node.entry);
            }
          } else if (node.entries) {
            maxIndex = node.entries.length - 1;
            if (index <= maxIndex) {
              return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
            }
          } else {
            maxIndex = node.nodes.length - 1;
            if (index <= maxIndex) {
              var subNode = node.nodes[this._reverse ? maxIndex - index : index];
              if (subNode) {
                if (subNode.entry) {
                  return mapIteratorValue(type, subNode.entry);
                }
                stack = this._stack = mapIteratorFrame(subNode, stack);
              }
              continue;
            }
          }
          stack = this._stack = this._stack.__prev;
        }
        return iteratorDone();
      };


    function mapIteratorValue(type, entry) {
      return iteratorValue(type, entry[0], entry[1]);
    }

    function mapIteratorFrame(node, prev) {
      return {
        node: node,
        index: 0,
        __prev: prev
      };
    }

    function makeMap(size, root, ownerID, hash) {
      var map = Object.create(MapPrototype);
      map.size = size;
      map._root = root;
      map.__ownerID = ownerID;
      map.__hash = hash;
      map.__altered = false;
      return map;
    }

    var EMPTY_MAP;
    function emptyMap() {
      return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
    }

    function updateMap(map, k, v) {
      var newRoot;
      var newSize;
      if (!map._root) {
        if (v === NOT_SET) {
          return map;
        }
        newSize = 1;
        newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
      } else {
        var didChangeSize = MakeRef(CHANGE_LENGTH);
        var didAlter = MakeRef(DID_ALTER);
        newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
        if (!didAlter.value) {
          return map;
        }
        newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
      }
      if (map.__ownerID) {
        map.size = newSize;
        map._root = newRoot;
        map.__hash = undefined;
        map.__altered = true;
        return map;
      }
      return newRoot ? makeMap(newSize, newRoot) : emptyMap();
    }

    function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (!node) {
        if (value === NOT_SET) {
          return node;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return new ValueNode(ownerID, keyHash, [key, value]);
      }
      return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
    }

    function isLeafNode(node) {
      return node.constructor === ValueNode || node.constructor === HashCollisionNode;
    }

    function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
      if (node.keyHash === keyHash) {
        return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
      }

      var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
      var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

      var newNode;
      var nodes = idx1 === idx2 ?
        [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
        ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

      return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
    }

    function createNodes(ownerID, entries, key, value) {
      if (!ownerID) {
        ownerID = new OwnerID();
      }
      var node = new ValueNode(ownerID, hash(key), [key, value]);
      for (var ii = 0; ii < entries.length; ii++) {
        var entry = entries[ii];
        node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
      }
      return node;
    }

    function packNodes(ownerID, nodes, count, excluding) {
      var bitmap = 0;
      var packedII = 0;
      var packedNodes = new Array(count);
      for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
        var node = nodes[ii];
        if (node !== undefined && ii !== excluding) {
          bitmap |= bit;
          packedNodes[packedII++] = node;
        }
      }
      return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
    }

    function expandNodes(ownerID, nodes, bitmap, including, node) {
      var count = 0;
      var expandedNodes = new Array(SIZE);
      for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
        expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
      }
      expandedNodes[including] = node;
      return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
    }

    function mergeIntoMapWith(map, merger, iterables) {
      var iters = [];
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = KeyedIterable(value);
        if (!isIterable(value)) {
          iter = iter.map(function(v ) {return fromJS(v)});
        }
        iters.push(iter);
      }
      return mergeIntoCollectionWith(map, merger, iters);
    }

    function deepMerger(existing, value, key) {
      return existing && existing.mergeDeep && isIterable(value) ?
        existing.mergeDeep(value) :
        is(existing, value) ? existing : value;
    }

    function deepMergerWith(merger) {
      return function(existing, value, key)  {
        if (existing && existing.mergeDeepWith && isIterable(value)) {
          return existing.mergeDeepWith(merger, value);
        }
        var nextValue = merger(existing, value, key);
        return is(existing, nextValue) ? existing : nextValue;
      };
    }

    function mergeIntoCollectionWith(collection, merger, iters) {
      iters = iters.filter(function(x ) {return x.size !== 0});
      if (iters.length === 0) {
        return collection;
      }
      if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
        return collection.constructor(iters[0]);
      }
      return collection.withMutations(function(collection ) {
        var mergeIntoMap = merger ?
          function(value, key)  {
            collection.update(key, NOT_SET, function(existing )
              {return existing === NOT_SET ? value : merger(existing, value, key)}
            );
          } :
          function(value, key)  {
            collection.set(key, value);
          };
        for (var ii = 0; ii < iters.length; ii++) {
          iters[ii].forEach(mergeIntoMap);
        }
      });
    }

    function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
      var isNotSet = existing === NOT_SET;
      var step = keyPathIter.next();
      if (step.done) {
        var existingValue = isNotSet ? notSetValue : existing;
        var newValue = updater(existingValue);
        return newValue === existingValue ? existing : newValue;
      }
      invariant(
        isNotSet || (existing && existing.set),
        'invalid keyPath'
      );
      var key = step.value;
      var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
      var nextUpdated = updateInDeepMap(
        nextExisting,
        keyPathIter,
        notSetValue,
        updater
      );
      return nextUpdated === nextExisting ? existing :
        nextUpdated === NOT_SET ? existing.remove(key) :
        (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
    }

    function popCount(x) {
      x = x - ((x >> 1) & 0x55555555);
      x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
      x = (x + (x >> 4)) & 0x0f0f0f0f;
      x = x + (x >> 8);
      x = x + (x >> 16);
      return x & 0x7f;
    }

    function setIn(array, idx, val, canEdit) {
      var newArray = canEdit ? array : arrCopy(array);
      newArray[idx] = val;
      return newArray;
    }

    function spliceIn(array, idx, val, canEdit) {
      var newLen = array.length + 1;
      if (canEdit && idx + 1 === newLen) {
        array[idx] = val;
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          newArray[ii] = val;
          after = -1;
        } else {
          newArray[ii] = array[ii + after];
        }
      }
      return newArray;
    }

    function spliceOut(array, idx, canEdit) {
      var newLen = array.length - 1;
      if (canEdit && idx === newLen) {
        array.pop();
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          after = 1;
        }
        newArray[ii] = array[ii + after];
      }
      return newArray;
    }

    var MAX_ARRAY_MAP_SIZE = SIZE / 4;
    var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
    var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

    createClass(List, IndexedCollection);

      // @pragma Construction

      function List(value) {
        var empty = emptyList();
        if (value === null || value === undefined) {
          return empty;
        }
        if (isList(value)) {
          return value;
        }
        var iter = IndexedIterable(value);
        var size = iter.size;
        if (size === 0) {
          return empty;
        }
        assertNotInfinite(size);
        if (size > 0 && size < SIZE) {
          return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
        }
        return empty.withMutations(function(list ) {
          list.setSize(size);
          iter.forEach(function(v, i)  {return list.set(i, v)});
        });
      }

      List.of = function(/*...values*/) {
        return this(arguments);
      };

      List.prototype.toString = function() {
        return this.__toString('List [', ']');
      };

      // @pragma Access

      List.prototype.get = function(index, notSetValue) {
        index = wrapIndex(this, index);
        if (index >= 0 && index < this.size) {
          index += this._origin;
          var node = listNodeFor(this, index);
          return node && node.array[index & MASK];
        }
        return notSetValue;
      };

      // @pragma Modification

      List.prototype.set = function(index, value) {
        return updateList(this, index, value);
      };

      List.prototype.remove = function(index) {
        return !this.has(index) ? this :
          index === 0 ? this.shift() :
          index === this.size - 1 ? this.pop() :
          this.splice(index, 1);
      };

      List.prototype.insert = function(index, value) {
        return this.splice(index, 0, value);
      };

      List.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = this._origin = this._capacity = 0;
          this._level = SHIFT;
          this._root = this._tail = null;
          this.__hash = undefined;
          this.__altered = true;
          return this;
        }
        return emptyList();
      };

      List.prototype.push = function(/*...values*/) {
        var values = arguments;
        var oldSize = this.size;
        return this.withMutations(function(list ) {
          setListBounds(list, 0, oldSize + values.length);
          for (var ii = 0; ii < values.length; ii++) {
            list.set(oldSize + ii, values[ii]);
          }
        });
      };

      List.prototype.pop = function() {
        return setListBounds(this, 0, -1);
      };

      List.prototype.unshift = function(/*...values*/) {
        var values = arguments;
        return this.withMutations(function(list ) {
          setListBounds(list, -values.length);
          for (var ii = 0; ii < values.length; ii++) {
            list.set(ii, values[ii]);
          }
        });
      };

      List.prototype.shift = function() {
        return setListBounds(this, 1);
      };

      // @pragma Composition

      List.prototype.merge = function(/*...iters*/) {
        return mergeIntoListWith(this, undefined, arguments);
      };

      List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
        return mergeIntoListWith(this, merger, iters);
      };

      List.prototype.mergeDeep = function(/*...iters*/) {
        return mergeIntoListWith(this, deepMerger, arguments);
      };

      List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
        return mergeIntoListWith(this, deepMergerWith(merger), iters);
      };

      List.prototype.setSize = function(size) {
        return setListBounds(this, 0, size);
      };

      // @pragma Iteration

      List.prototype.slice = function(begin, end) {
        var size = this.size;
        if (wholeSlice(begin, end, size)) {
          return this;
        }
        return setListBounds(
          this,
          resolveBegin(begin, size),
          resolveEnd(end, size)
        );
      };

      List.prototype.__iterator = function(type, reverse) {
        var index = 0;
        var values = iterateList(this, reverse);
        return new Iterator(function()  {
          var value = values();
          return value === DONE ?
            iteratorDone() :
            iteratorValue(type, index++, value);
        });
      };

      List.prototype.__iterate = function(fn, reverse) {
        var index = 0;
        var values = iterateList(this, reverse);
        var value;
        while ((value = values()) !== DONE) {
          if (fn(value, index++, this) === false) {
            break;
          }
        }
        return index;
      };

      List.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          this.__ownerID = ownerID;
          return this;
        }
        return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
      };


    function isList(maybeList) {
      return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
    }

    List.isList = isList;

    var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

    var ListPrototype = List.prototype;
    ListPrototype[IS_LIST_SENTINEL] = true;
    ListPrototype[DELETE] = ListPrototype.remove;
    ListPrototype.setIn = MapPrototype.setIn;
    ListPrototype.deleteIn =
    ListPrototype.removeIn = MapPrototype.removeIn;
    ListPrototype.update = MapPrototype.update;
    ListPrototype.updateIn = MapPrototype.updateIn;
    ListPrototype.mergeIn = MapPrototype.mergeIn;
    ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    ListPrototype.withMutations = MapPrototype.withMutations;
    ListPrototype.asMutable = MapPrototype.asMutable;
    ListPrototype.asImmutable = MapPrototype.asImmutable;
    ListPrototype.wasAltered = MapPrototype.wasAltered;



      function VNode(array, ownerID) {
        this.array = array;
        this.ownerID = ownerID;
      }

      // TODO: seems like these methods are very similar

      VNode.prototype.removeBefore = function(ownerID, level, index) {
        if (index === level ? 1 << level : this.array.length === 0) {
          return this;
        }
        var originIndex = (index >>> level) & MASK;
        if (originIndex >= this.array.length) {
          return new VNode([], ownerID);
        }
        var removingFirst = originIndex === 0;
        var newChild;
        if (level > 0) {
          var oldChild = this.array[originIndex];
          newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
          if (newChild === oldChild && removingFirst) {
            return this;
          }
        }
        if (removingFirst && !newChild) {
          return this;
        }
        var editable = editableVNode(this, ownerID);
        if (!removingFirst) {
          for (var ii = 0; ii < originIndex; ii++) {
            editable.array[ii] = undefined;
          }
        }
        if (newChild) {
          editable.array[originIndex] = newChild;
        }
        return editable;
      };

      VNode.prototype.removeAfter = function(ownerID, level, index) {
        if (index === (level ? 1 << level : 0) || this.array.length === 0) {
          return this;
        }
        var sizeIndex = ((index - 1) >>> level) & MASK;
        if (sizeIndex >= this.array.length) {
          return this;
        }

        var newChild;
        if (level > 0) {
          var oldChild = this.array[sizeIndex];
          newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
          if (newChild === oldChild && sizeIndex === this.array.length - 1) {
            return this;
          }
        }

        var editable = editableVNode(this, ownerID);
        editable.array.splice(sizeIndex + 1);
        if (newChild) {
          editable.array[sizeIndex] = newChild;
        }
        return editable;
      };



    var DONE = {};

    function iterateList(list, reverse) {
      var left = list._origin;
      var right = list._capacity;
      var tailPos = getTailOffset(right);
      var tail = list._tail;

      return iterateNodeOrLeaf(list._root, list._level, 0);

      function iterateNodeOrLeaf(node, level, offset) {
        return level === 0 ?
          iterateLeaf(node, offset) :
          iterateNode(node, level, offset);
      }

      function iterateLeaf(node, offset) {
        var array = offset === tailPos ? tail && tail.array : node && node.array;
        var from = offset > left ? 0 : left - offset;
        var to = right - offset;
        if (to > SIZE) {
          to = SIZE;
        }
        return function()  {
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          return array && array[idx];
        };
      }

      function iterateNode(node, level, offset) {
        var values;
        var array = node && node.array;
        var from = offset > left ? 0 : (left - offset) >> level;
        var to = ((right - offset) >> level) + 1;
        if (to > SIZE) {
          to = SIZE;
        }
        return function()  {
          do {
            if (values) {
              var value = values();
              if (value !== DONE) {
                return value;
              }
              values = null;
            }
            if (from === to) {
              return DONE;
            }
            var idx = reverse ? --to : from++;
            values = iterateNodeOrLeaf(
              array && array[idx], level - SHIFT, offset + (idx << level)
            );
          } while (true);
        };
      }
    }

    function makeList(origin, capacity, level, root, tail, ownerID, hash) {
      var list = Object.create(ListPrototype);
      list.size = capacity - origin;
      list._origin = origin;
      list._capacity = capacity;
      list._level = level;
      list._root = root;
      list._tail = tail;
      list.__ownerID = ownerID;
      list.__hash = hash;
      list.__altered = false;
      return list;
    }

    var EMPTY_LIST;
    function emptyList() {
      return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
    }

    function updateList(list, index, value) {
      index = wrapIndex(list, index);

      if (index !== index) {
        return list;
      }

      if (index >= list.size || index < 0) {
        return list.withMutations(function(list ) {
          index < 0 ?
            setListBounds(list, index).set(0, value) :
            setListBounds(list, 0, index + 1).set(index, value);
        });
      }

      index += list._origin;

      var newTail = list._tail;
      var newRoot = list._root;
      var didAlter = MakeRef(DID_ALTER);
      if (index >= getTailOffset(list._capacity)) {
        newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
      } else {
        newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
      }

      if (!didAlter.value) {
        return list;
      }

      if (list.__ownerID) {
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
      }
      return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
    }

    function updateVNode(node, ownerID, level, index, value, didAlter) {
      var idx = (index >>> level) & MASK;
      var nodeHas = node && idx < node.array.length;
      if (!nodeHas && value === undefined) {
        return node;
      }

      var newNode;

      if (level > 0) {
        var lowerNode = node && node.array[idx];
        var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
        if (newLowerNode === lowerNode) {
          return node;
        }
        newNode = editableVNode(node, ownerID);
        newNode.array[idx] = newLowerNode;
        return newNode;
      }

      if (nodeHas && node.array[idx] === value) {
        return node;
      }

      SetRef(didAlter);

      newNode = editableVNode(node, ownerID);
      if (value === undefined && idx === newNode.array.length - 1) {
        newNode.array.pop();
      } else {
        newNode.array[idx] = value;
      }
      return newNode;
    }

    function editableVNode(node, ownerID) {
      if (ownerID && node && ownerID === node.ownerID) {
        return node;
      }
      return new VNode(node ? node.array.slice() : [], ownerID);
    }

    function listNodeFor(list, rawIndex) {
      if (rawIndex >= getTailOffset(list._capacity)) {
        return list._tail;
      }
      if (rawIndex < 1 << (list._level + SHIFT)) {
        var node = list._root;
        var level = list._level;
        while (node && level > 0) {
          node = node.array[(rawIndex >>> level) & MASK];
          level -= SHIFT;
        }
        return node;
      }
    }

    function setListBounds(list, begin, end) {
      // Sanitize begin & end using this shorthand for ToInt32(argument)
      // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
      if (begin !== undefined) {
        begin = begin | 0;
      }
      if (end !== undefined) {
        end = end | 0;
      }
      var owner = list.__ownerID || new OwnerID();
      var oldOrigin = list._origin;
      var oldCapacity = list._capacity;
      var newOrigin = oldOrigin + begin;
      var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
      if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
        return list;
      }

      // If it's going to end after it starts, it's empty.
      if (newOrigin >= newCapacity) {
        return list.clear();
      }

      var newLevel = list._level;
      var newRoot = list._root;

      // New origin might need creating a higher root.
      var offsetShift = 0;
      while (newOrigin + offsetShift < 0) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
        newLevel += SHIFT;
        offsetShift += 1 << newLevel;
      }
      if (offsetShift) {
        newOrigin += offsetShift;
        oldOrigin += offsetShift;
        newCapacity += offsetShift;
        oldCapacity += offsetShift;
      }

      var oldTailOffset = getTailOffset(oldCapacity);
      var newTailOffset = getTailOffset(newCapacity);

      // New size might need creating a higher root.
      while (newTailOffset >= 1 << (newLevel + SHIFT)) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
        newLevel += SHIFT;
      }

      // Locate or create the new tail.
      var oldTail = list._tail;
      var newTail = newTailOffset < oldTailOffset ?
        listNodeFor(list, newCapacity - 1) :
        newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

      // Merge Tail into tree.
      if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
        newRoot = editableVNode(newRoot, owner);
        var node = newRoot;
        for (var level = newLevel; level > SHIFT; level -= SHIFT) {
          var idx = (oldTailOffset >>> level) & MASK;
          node = node.array[idx] = editableVNode(node.array[idx], owner);
        }
        node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
      }

      // If the size has been reduced, there's a chance the tail needs to be trimmed.
      if (newCapacity < oldCapacity) {
        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
      }

      // If the new origin is within the tail, then we do not need a root.
      if (newOrigin >= newTailOffset) {
        newOrigin -= newTailOffset;
        newCapacity -= newTailOffset;
        newLevel = SHIFT;
        newRoot = null;
        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

      // Otherwise, if the root has been trimmed, garbage collect.
      } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
        offsetShift = 0;

        // Identify the new top root node of the subtree of the old root.
        while (newRoot) {
          var beginIndex = (newOrigin >>> newLevel) & MASK;
          if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
            break;
          }
          if (beginIndex) {
            offsetShift += (1 << newLevel) * beginIndex;
          }
          newLevel -= SHIFT;
          newRoot = newRoot.array[beginIndex];
        }

        // Trim the new sides of the new root.
        if (newRoot && newOrigin > oldOrigin) {
          newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
        }
        if (newRoot && newTailOffset < oldTailOffset) {
          newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
        }
        if (offsetShift) {
          newOrigin -= offsetShift;
          newCapacity -= offsetShift;
        }
      }

      if (list.__ownerID) {
        list.size = newCapacity - newOrigin;
        list._origin = newOrigin;
        list._capacity = newCapacity;
        list._level = newLevel;
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
      }
      return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
    }

    function mergeIntoListWith(list, merger, iterables) {
      var iters = [];
      var maxSize = 0;
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = IndexedIterable(value);
        if (iter.size > maxSize) {
          maxSize = iter.size;
        }
        if (!isIterable(value)) {
          iter = iter.map(function(v ) {return fromJS(v)});
        }
        iters.push(iter);
      }
      if (maxSize > list.size) {
        list = list.setSize(maxSize);
      }
      return mergeIntoCollectionWith(list, merger, iters);
    }

    function getTailOffset(size) {
      return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
    }

    createClass(OrderedMap, Map);

      // @pragma Construction

      function OrderedMap(value) {
        return value === null || value === undefined ? emptyOrderedMap() :
          isOrderedMap(value) ? value :
          emptyOrderedMap().withMutations(function(map ) {
            var iter = KeyedIterable(value);
            assertNotInfinite(iter.size);
            iter.forEach(function(v, k)  {return map.set(k, v)});
          });
      }

      OrderedMap.of = function(/*...values*/) {
        return this(arguments);
      };

      OrderedMap.prototype.toString = function() {
        return this.__toString('OrderedMap {', '}');
      };

      // @pragma Access

      OrderedMap.prototype.get = function(k, notSetValue) {
        var index = this._map.get(k);
        return index !== undefined ? this._list.get(index)[1] : notSetValue;
      };

      // @pragma Modification

      OrderedMap.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._map.clear();
          this._list.clear();
          return this;
        }
        return emptyOrderedMap();
      };

      OrderedMap.prototype.set = function(k, v) {
        return updateOrderedMap(this, k, v);
      };

      OrderedMap.prototype.remove = function(k) {
        return updateOrderedMap(this, k, NOT_SET);
      };

      OrderedMap.prototype.wasAltered = function() {
        return this._map.wasAltered() || this._list.wasAltered();
      };

      OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
        return this._list.__iterate(
          function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
          reverse
        );
      };

      OrderedMap.prototype.__iterator = function(type, reverse) {
        return this._list.fromEntrySeq().__iterator(type, reverse);
      };

      OrderedMap.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        var newList = this._list.__ensureOwner(ownerID);
        if (!ownerID) {
          this.__ownerID = ownerID;
          this._map = newMap;
          this._list = newList;
          return this;
        }
        return makeOrderedMap(newMap, newList, ownerID, this.__hash);
      };


    function isOrderedMap(maybeOrderedMap) {
      return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
    }

    OrderedMap.isOrderedMap = isOrderedMap;

    OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



    function makeOrderedMap(map, list, ownerID, hash) {
      var omap = Object.create(OrderedMap.prototype);
      omap.size = map ? map.size : 0;
      omap._map = map;
      omap._list = list;
      omap.__ownerID = ownerID;
      omap.__hash = hash;
      return omap;
    }

    var EMPTY_ORDERED_MAP;
    function emptyOrderedMap() {
      return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
    }

    function updateOrderedMap(omap, k, v) {
      var map = omap._map;
      var list = omap._list;
      var i = map.get(k);
      var has = i !== undefined;
      var newMap;
      var newList;
      if (v === NOT_SET) { // removed
        if (!has) {
          return omap;
        }
        if (list.size >= SIZE && list.size >= map.size * 2) {
          newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
          newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
          if (omap.__ownerID) {
            newMap.__ownerID = newList.__ownerID = omap.__ownerID;
          }
        } else {
          newMap = map.remove(k);
          newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
        }
      } else {
        if (has) {
          if (v === list.get(i)[1]) {
            return omap;
          }
          newMap = map;
          newList = list.set(i, [k, v]);
        } else {
          newMap = map.set(k, list.size);
          newList = list.set(list.size, [k, v]);
        }
      }
      if (omap.__ownerID) {
        omap.size = newMap.size;
        omap._map = newMap;
        omap._list = newList;
        omap.__hash = undefined;
        return omap;
      }
      return makeOrderedMap(newMap, newList);
    }

    createClass(ToKeyedSequence, KeyedSeq);
      function ToKeyedSequence(indexed, useKeys) {
        this._iter = indexed;
        this._useKeys = useKeys;
        this.size = indexed.size;
      }

      ToKeyedSequence.prototype.get = function(key, notSetValue) {
        return this._iter.get(key, notSetValue);
      };

      ToKeyedSequence.prototype.has = function(key) {
        return this._iter.has(key);
      };

      ToKeyedSequence.prototype.valueSeq = function() {
        return this._iter.valueSeq();
      };

      ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
        var reversedSequence = reverseFactory(this, true);
        if (!this._useKeys) {
          reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
        }
        return reversedSequence;
      };

      ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
        var mappedSequence = mapFactory(this, mapper, context);
        if (!this._useKeys) {
          mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
        }
        return mappedSequence;
      };

      ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
        var ii;
        return this._iter.__iterate(
          this._useKeys ?
            function(v, k)  {return fn(v, k, this$0)} :
            ((ii = reverse ? resolveSize(this) : 0),
              function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
          reverse
        );
      };

      ToKeyedSequence.prototype.__iterator = function(type, reverse) {
        if (this._useKeys) {
          return this._iter.__iterator(type, reverse);
        }
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
        var ii = reverse ? resolveSize(this) : 0;
        return new Iterator(function()  {
          var step = iterator.next();
          return step.done ? step :
            iteratorValue(type, reverse ? --ii : ii++, step.value, step);
        });
      };

    ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


    createClass(ToIndexedSequence, IndexedSeq);
      function ToIndexedSequence(iter) {
        this._iter = iter;
        this.size = iter.size;
      }

      ToIndexedSequence.prototype.includes = function(value) {
        return this._iter.includes(value);
      };

      ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
        var iterations = 0;
        return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
      };

      ToIndexedSequence.prototype.__iterator = function(type, reverse) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
        var iterations = 0;
        return new Iterator(function()  {
          var step = iterator.next();
          return step.done ? step :
            iteratorValue(type, iterations++, step.value, step)
        });
      };



    createClass(ToSetSequence, SetSeq);
      function ToSetSequence(iter) {
        this._iter = iter;
        this.size = iter.size;
      }

      ToSetSequence.prototype.has = function(key) {
        return this._iter.includes(key);
      };

      ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
        return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
      };

      ToSetSequence.prototype.__iterator = function(type, reverse) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          return step.done ? step :
            iteratorValue(type, step.value, step.value, step);
        });
      };



    createClass(FromEntriesSequence, KeyedSeq);
      function FromEntriesSequence(entries) {
        this._iter = entries;
        this.size = entries.size;
      }

      FromEntriesSequence.prototype.entrySeq = function() {
        return this._iter.toSeq();
      };

      FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
        return this._iter.__iterate(function(entry ) {
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return fn(
              indexedIterable ? entry.get(1) : entry[1],
              indexedIterable ? entry.get(0) : entry[0],
              this$0
            );
          }
        }, reverse);
      };

      FromEntriesSequence.prototype.__iterator = function(type, reverse) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
        return new Iterator(function()  {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            // Check if entry exists first so array access doesn't throw for holes
            // in the parent iteration.
            if (entry) {
              validateEntry(entry);
              var indexedIterable = isIterable(entry);
              return iteratorValue(
                type,
                indexedIterable ? entry.get(0) : entry[0],
                indexedIterable ? entry.get(1) : entry[1],
                step
              );
            }
          }
        });
      };


    ToIndexedSequence.prototype.cacheResult =
    ToKeyedSequence.prototype.cacheResult =
    ToSetSequence.prototype.cacheResult =
    FromEntriesSequence.prototype.cacheResult =
      cacheResultThrough;


    function flipFactory(iterable) {
      var flipSequence = makeSequence(iterable);
      flipSequence._iter = iterable;
      flipSequence.size = iterable.size;
      flipSequence.flip = function()  {return iterable};
      flipSequence.reverse = function () {
        var reversedSequence = iterable.reverse.apply(this); // super.reverse()
        reversedSequence.flip = function()  {return iterable.reverse()};
        return reversedSequence;
      };
      flipSequence.has = function(key ) {return iterable.includes(key)};
      flipSequence.includes = function(key ) {return iterable.has(key)};
      flipSequence.cacheResult = cacheResultThrough;
      flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
        return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
      };
      flipSequence.__iteratorUncached = function(type, reverse) {
        if (type === ITERATE_ENTRIES) {
          var iterator = iterable.__iterator(type, reverse);
          return new Iterator(function()  {
            var step = iterator.next();
            if (!step.done) {
              var k = step.value[0];
              step.value[0] = step.value[1];
              step.value[1] = k;
            }
            return step;
          });
        }
        return iterable.__iterator(
          type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
          reverse
        );
      };
      return flipSequence;
    }


    function mapFactory(iterable, mapper, context) {
      var mappedSequence = makeSequence(iterable);
      mappedSequence.size = iterable.size;
      mappedSequence.has = function(key ) {return iterable.has(key)};
      mappedSequence.get = function(key, notSetValue)  {
        var v = iterable.get(key, NOT_SET);
        return v === NOT_SET ?
          notSetValue :
          mapper.call(context, v, key, iterable);
      };
      mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
        return iterable.__iterate(
          function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
          reverse
        );
      };
      mappedSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          return iteratorValue(
            type,
            key,
            mapper.call(context, entry[1], key, iterable),
            step
          );
        });
      };
      return mappedSequence;
    }


    function reverseFactory(iterable, useKeys) {
      var reversedSequence = makeSequence(iterable);
      reversedSequence._iter = iterable;
      reversedSequence.size = iterable.size;
      reversedSequence.reverse = function()  {return iterable};
      if (iterable.flip) {
        reversedSequence.flip = function () {
          var flipSequence = flipFactory(iterable);
          flipSequence.reverse = function()  {return iterable.flip()};
          return flipSequence;
        };
      }
      reversedSequence.get = function(key, notSetValue) 
        {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
      reversedSequence.has = function(key )
        {return iterable.has(useKeys ? key : -1 - key)};
      reversedSequence.includes = function(value ) {return iterable.includes(value)};
      reversedSequence.cacheResult = cacheResultThrough;
      reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
        return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
      };
      reversedSequence.__iterator =
        function(type, reverse)  {return iterable.__iterator(type, !reverse)};
      return reversedSequence;
    }


    function filterFactory(iterable, predicate, context, useKeys) {
      var filterSequence = makeSequence(iterable);
      if (useKeys) {
        filterSequence.has = function(key ) {
          var v = iterable.get(key, NOT_SET);
          return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
        };
        filterSequence.get = function(key, notSetValue)  {
          var v = iterable.get(key, NOT_SET);
          return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
            v : notSetValue;
        };
      }
      filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function(v, k, c)  {
          if (predicate.call(context, v, k, c)) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        }, reverse);
        return iterations;
      };
      filterSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterations = 0;
        return new Iterator(function()  {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var key = entry[0];
            var value = entry[1];
            if (predicate.call(context, value, key, iterable)) {
              return iteratorValue(type, useKeys ? key : iterations++, value, step);
            }
          }
        });
      };
      return filterSequence;
    }


    function countByFactory(iterable, grouper, context) {
      var groups = Map().asMutable();
      iterable.__iterate(function(v, k)  {
        groups.update(
          grouper.call(context, v, k, iterable),
          0,
          function(a ) {return a + 1}
        );
      });
      return groups.asImmutable();
    }


    function groupByFactory(iterable, grouper, context) {
      var isKeyedIter = isKeyed(iterable);
      var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
      iterable.__iterate(function(v, k)  {
        groups.update(
          grouper.call(context, v, k, iterable),
          function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
        );
      });
      var coerce = iterableClass(iterable);
      return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
    }


    function sliceFactory(iterable, begin, end, useKeys) {
      var originalSize = iterable.size;

      // Sanitize begin & end using this shorthand for ToInt32(argument)
      // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
      if (begin !== undefined) {
        begin = begin | 0;
      }
      if (end !== undefined) {
        end = end | 0;
      }

      if (wholeSlice(begin, end, originalSize)) {
        return iterable;
      }

      var resolvedBegin = resolveBegin(begin, originalSize);
      var resolvedEnd = resolveEnd(end, originalSize);

      // begin or end will be NaN if they were provided as negative numbers and
      // this iterable's size is unknown. In that case, cache first so there is
      // a known size and these do not resolve to NaN.
      if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
        return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
      }

      // Note: resolvedEnd is undefined when the original sequence's length is
      // unknown and this slice did not supply an end and should contain all
      // elements after resolvedBegin.
      // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
      var resolvedSize = resolvedEnd - resolvedBegin;
      var sliceSize;
      if (resolvedSize === resolvedSize) {
        sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
      }

      var sliceSeq = makeSequence(iterable);

      // If iterable.size is undefined, the size of the realized sliceSeq is
      // unknown at this point unless the number of items to slice is 0
      sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

      if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
        sliceSeq.get = function (index, notSetValue) {
          index = wrapIndex(this, index);
          return index >= 0 && index < sliceSize ?
            iterable.get(index + resolvedBegin, notSetValue) :
            notSetValue;
        };
      }

      sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
        if (sliceSize === 0) {
          return 0;
        }
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var skipped = 0;
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v, k)  {
          if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
                   iterations !== sliceSize;
          }
        });
        return iterations;
      };

      sliceSeq.__iteratorUncached = function(type, reverse) {
        if (sliceSize !== 0 && reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        // Don't bother instantiating parent iterator if taking 0.
        var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
        var skipped = 0;
        var iterations = 0;
        return new Iterator(function()  {
          while (skipped++ < resolvedBegin) {
            iterator.next();
          }
          if (++iterations > sliceSize) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          } else if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations - 1, undefined, step);
          } else {
            return iteratorValue(type, iterations - 1, step.value[1], step);
          }
        });
      };

      return sliceSeq;
    }


    function takeWhileFactory(iterable, predicate, context) {
      var takeSequence = makeSequence(iterable);
      takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var iterations = 0;
        iterable.__iterate(function(v, k, c) 
          {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
        );
        return iterations;
      };
      takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterating = true;
        return new Iterator(function()  {
          if (!iterating) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var k = entry[0];
          var v = entry[1];
          if (!predicate.call(context, v, k, this$0)) {
            iterating = false;
            return iteratorDone();
          }
          return type === ITERATE_ENTRIES ? step :
            iteratorValue(type, k, v, step);
        });
      };
      return takeSequence;
    }


    function skipWhileFactory(iterable, predicate, context, useKeys) {
      var skipSequence = makeSequence(iterable);
      skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v, k, c)  {
          if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        });
        return iterations;
      };
      skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var skipping = true;
        var iterations = 0;
        return new Iterator(function()  {
          var step, k, v;
          do {
            step = iterator.next();
            if (step.done) {
              if (useKeys || type === ITERATE_VALUES) {
                return step;
              } else if (type === ITERATE_KEYS) {
                return iteratorValue(type, iterations++, undefined, step);
              } else {
                return iteratorValue(type, iterations++, step.value[1], step);
              }
            }
            var entry = step.value;
            k = entry[0];
            v = entry[1];
            skipping && (skipping = predicate.call(context, v, k, this$0));
          } while (skipping);
          return type === ITERATE_ENTRIES ? step :
            iteratorValue(type, k, v, step);
        });
      };
      return skipSequence;
    }


    function concatFactory(iterable, values) {
      var isKeyedIterable = isKeyed(iterable);
      var iters = [iterable].concat(values).map(function(v ) {
        if (!isIterable(v)) {
          v = isKeyedIterable ?
            keyedSeqFromValue(v) :
            indexedSeqFromValue(Array.isArray(v) ? v : [v]);
        } else if (isKeyedIterable) {
          v = KeyedIterable(v);
        }
        return v;
      }).filter(function(v ) {return v.size !== 0});

      if (iters.length === 0) {
        return iterable;
      }

      if (iters.length === 1) {
        var singleton = iters[0];
        if (singleton === iterable ||
            isKeyedIterable && isKeyed(singleton) ||
            isIndexed(iterable) && isIndexed(singleton)) {
          return singleton;
        }
      }

      var concatSeq = new ArraySeq(iters);
      if (isKeyedIterable) {
        concatSeq = concatSeq.toKeyedSeq();
      } else if (!isIndexed(iterable)) {
        concatSeq = concatSeq.toSetSeq();
      }
      concatSeq = concatSeq.flatten(true);
      concatSeq.size = iters.reduce(
        function(sum, seq)  {
          if (sum !== undefined) {
            var size = seq.size;
            if (size !== undefined) {
              return sum + size;
            }
          }
        },
        0
      );
      return concatSeq;
    }


    function flattenFactory(iterable, depth, useKeys) {
      var flatSequence = makeSequence(iterable);
      flatSequence.__iterateUncached = function(fn, reverse) {
        var iterations = 0;
        var stopped = false;
        function flatDeep(iter, currentDepth) {var this$0 = this;
          iter.__iterate(function(v, k)  {
            if ((!depth || currentDepth < depth) && isIterable(v)) {
              flatDeep(v, currentDepth + 1);
            } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
              stopped = true;
            }
            return !stopped;
          }, reverse);
        }
        flatDeep(iterable, 0);
        return iterations;
      };
      flatSequence.__iteratorUncached = function(type, reverse) {
        var iterator = iterable.__iterator(type, reverse);
        var stack = [];
        var iterations = 0;
        return new Iterator(function()  {
          while (iterator) {
            var step = iterator.next();
            if (step.done !== false) {
              iterator = stack.pop();
              continue;
            }
            var v = step.value;
            if (type === ITERATE_ENTRIES) {
              v = v[1];
            }
            if ((!depth || stack.length < depth) && isIterable(v)) {
              stack.push(iterator);
              iterator = v.__iterator(type, reverse);
            } else {
              return useKeys ? step : iteratorValue(type, iterations++, v, step);
            }
          }
          return iteratorDone();
        });
      };
      return flatSequence;
    }


    function flatMapFactory(iterable, mapper, context) {
      var coerce = iterableClass(iterable);
      return iterable.toSeq().map(
        function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
      ).flatten(true);
    }


    function interposeFactory(iterable, separator) {
      var interposedSequence = makeSequence(iterable);
      interposedSequence.size = iterable.size && iterable.size * 2 -1;
      interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function(v, k) 
          {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
          fn(v, iterations++, this$0) !== false},
          reverse
        );
        return iterations;
      };
      interposedSequence.__iteratorUncached = function(type, reverse) {
        var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
        var iterations = 0;
        var step;
        return new Iterator(function()  {
          if (!step || iterations % 2) {
            step = iterator.next();
            if (step.done) {
              return step;
            }
          }
          return iterations % 2 ?
            iteratorValue(type, iterations++, separator) :
            iteratorValue(type, iterations++, step.value, step);
        });
      };
      return interposedSequence;
    }


    function sortFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      var isKeyedIterable = isKeyed(iterable);
      var index = 0;
      var entries = iterable.toSeq().map(
        function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
      ).toArray();
      entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
        isKeyedIterable ?
        function(v, i)  { entries[i].length = 2; } :
        function(v, i)  { entries[i] = v[1]; }
      );
      return isKeyedIterable ? KeyedSeq(entries) :
        isIndexed(iterable) ? IndexedSeq(entries) :
        SetSeq(entries);
    }


    function maxFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      if (mapper) {
        var entry = iterable.toSeq()
          .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
          .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
        return entry && entry[0];
      } else {
        return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
      }
    }

    function maxCompare(comparator, a, b) {
      var comp = comparator(b, a);
      // b is considered the new max if the comparator declares them equal, but
      // they are not equal and b is in fact a nullish value.
      return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
    }


    function zipWithFactory(keyIter, zipper, iters) {
      var zipSequence = makeSequence(keyIter);
      zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
      // Note: this a generic base implementation of __iterate in terms of
      // __iterator which may be more generically useful in the future.
      zipSequence.__iterate = function(fn, reverse) {
        /* generic:
        var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          iterations++;
          if (fn(step.value[1], step.value[0], this) === false) {
            break;
          }
        }
        return iterations;
        */
        // indexed:
        var iterator = this.__iterator(ITERATE_VALUES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };
      zipSequence.__iteratorUncached = function(type, reverse) {
        var iterators = iters.map(function(i )
          {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
        );
        var iterations = 0;
        var isDone = false;
        return new Iterator(function()  {
          var steps;
          if (!isDone) {
            steps = iterators.map(function(i ) {return i.next()});
            isDone = steps.some(function(s ) {return s.done});
          }
          if (isDone) {
            return iteratorDone();
          }
          return iteratorValue(
            type,
            iterations++,
            zipper.apply(null, steps.map(function(s ) {return s.value}))
          );
        });
      };
      return zipSequence
    }


    // #pragma Helper Functions

    function reify(iter, seq) {
      return isSeq(iter) ? seq : iter.constructor(seq);
    }

    function validateEntry(entry) {
      if (entry !== Object(entry)) {
        throw new TypeError('Expected [K, V] tuple: ' + entry);
      }
    }

    function resolveSize(iter) {
      assertNotInfinite(iter.size);
      return ensureSize(iter);
    }

    function iterableClass(iterable) {
      return isKeyed(iterable) ? KeyedIterable :
        isIndexed(iterable) ? IndexedIterable :
        SetIterable;
    }

    function makeSequence(iterable) {
      return Object.create(
        (
          isKeyed(iterable) ? KeyedSeq :
          isIndexed(iterable) ? IndexedSeq :
          SetSeq
        ).prototype
      );
    }

    function cacheResultThrough() {
      if (this._iter.cacheResult) {
        this._iter.cacheResult();
        this.size = this._iter.size;
        return this;
      } else {
        return Seq.prototype.cacheResult.call(this);
      }
    }

    function defaultComparator(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }

    function forceIterator(keyPath) {
      var iter = getIterator(keyPath);
      if (!iter) {
        // Array might not be iterable in this environment, so we need a fallback
        // to our wrapped type.
        if (!isArrayLike(keyPath)) {
          throw new TypeError('Expected iterable or array-like: ' + keyPath);
        }
        iter = getIterator(Iterable(keyPath));
      }
      return iter;
    }

    createClass(Record, KeyedCollection);

      function Record(defaultValues, name) {
        var hasInitialized;

        var RecordType = function Record(values) {
          if (values instanceof RecordType) {
            return values;
          }
          if (!(this instanceof RecordType)) {
            return new RecordType(values);
          }
          if (!hasInitialized) {
            hasInitialized = true;
            var keys = Object.keys(defaultValues);
            setProps(RecordTypePrototype, keys);
            RecordTypePrototype.size = keys.length;
            RecordTypePrototype._name = name;
            RecordTypePrototype._keys = keys;
            RecordTypePrototype._defaultValues = defaultValues;
          }
          this._map = Map(values);
        };

        var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
        RecordTypePrototype.constructor = RecordType;

        return RecordType;
      }

      Record.prototype.toString = function() {
        return this.__toString(recordName(this) + ' {', '}');
      };

      // @pragma Access

      Record.prototype.has = function(k) {
        return this._defaultValues.hasOwnProperty(k);
      };

      Record.prototype.get = function(k, notSetValue) {
        if (!this.has(k)) {
          return notSetValue;
        }
        var defaultVal = this._defaultValues[k];
        return this._map ? this._map.get(k, defaultVal) : defaultVal;
      };

      // @pragma Modification

      Record.prototype.clear = function() {
        if (this.__ownerID) {
          this._map && this._map.clear();
          return this;
        }
        var RecordType = this.constructor;
        return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
      };

      Record.prototype.set = function(k, v) {
        if (!this.has(k)) {
          throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
        }
        var newMap = this._map && this._map.set(k, v);
        if (this.__ownerID || newMap === this._map) {
          return this;
        }
        return makeRecord(this, newMap);
      };

      Record.prototype.remove = function(k) {
        if (!this.has(k)) {
          return this;
        }
        var newMap = this._map && this._map.remove(k);
        if (this.__ownerID || newMap === this._map) {
          return this;
        }
        return makeRecord(this, newMap);
      };

      Record.prototype.wasAltered = function() {
        return this._map.wasAltered();
      };

      Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
        return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
      };

      Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
        return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
      };

      Record.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map && this._map.__ensureOwner(ownerID);
        if (!ownerID) {
          this.__ownerID = ownerID;
          this._map = newMap;
          return this;
        }
        return makeRecord(this, newMap, ownerID);
      };


    var RecordPrototype = Record.prototype;
    RecordPrototype[DELETE] = RecordPrototype.remove;
    RecordPrototype.deleteIn =
    RecordPrototype.removeIn = MapPrototype.removeIn;
    RecordPrototype.merge = MapPrototype.merge;
    RecordPrototype.mergeWith = MapPrototype.mergeWith;
    RecordPrototype.mergeIn = MapPrototype.mergeIn;
    RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
    RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
    RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    RecordPrototype.setIn = MapPrototype.setIn;
    RecordPrototype.update = MapPrototype.update;
    RecordPrototype.updateIn = MapPrototype.updateIn;
    RecordPrototype.withMutations = MapPrototype.withMutations;
    RecordPrototype.asMutable = MapPrototype.asMutable;
    RecordPrototype.asImmutable = MapPrototype.asImmutable;


    function makeRecord(likeRecord, map, ownerID) {
      var record = Object.create(Object.getPrototypeOf(likeRecord));
      record._map = map;
      record.__ownerID = ownerID;
      return record;
    }

    function recordName(record) {
      return record._name || record.constructor.name || 'Record';
    }

    function setProps(prototype, names) {
      try {
        names.forEach(setProp.bind(undefined, prototype));
      } catch (error) {
        // Object.defineProperty failed. Probably IE8.
      }
    }

    function setProp(prototype, name) {
      Object.defineProperty(prototype, name, {
        get: function() {
          return this.get(name);
        },
        set: function(value) {
          invariant(this.__ownerID, 'Cannot set on an immutable record.');
          this.set(name, value);
        }
      });
    }

    createClass(Set, SetCollection);

      // @pragma Construction

      function Set(value) {
        return value === null || value === undefined ? emptySet() :
          isSet(value) && !isOrdered(value) ? value :
          emptySet().withMutations(function(set ) {
            var iter = SetIterable(value);
            assertNotInfinite(iter.size);
            iter.forEach(function(v ) {return set.add(v)});
          });
      }

      Set.of = function(/*...values*/) {
        return this(arguments);
      };

      Set.fromKeys = function(value) {
        return this(KeyedIterable(value).keySeq());
      };

      Set.prototype.toString = function() {
        return this.__toString('Set {', '}');
      };

      // @pragma Access

      Set.prototype.has = function(value) {
        return this._map.has(value);
      };

      // @pragma Modification

      Set.prototype.add = function(value) {
        return updateSet(this, this._map.set(value, true));
      };

      Set.prototype.remove = function(value) {
        return updateSet(this, this._map.remove(value));
      };

      Set.prototype.clear = function() {
        return updateSet(this, this._map.clear());
      };

      // @pragma Composition

      Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
        iters = iters.filter(function(x ) {return x.size !== 0});
        if (iters.length === 0) {
          return this;
        }
        if (this.size === 0 && !this.__ownerID && iters.length === 1) {
          return this.constructor(iters[0]);
        }
        return this.withMutations(function(set ) {
          for (var ii = 0; ii < iters.length; ii++) {
            SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
          }
        });
      };

      Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter ) {return SetIterable(iter)});
        var originalSet = this;
        return this.withMutations(function(set ) {
          originalSet.forEach(function(value ) {
            if (!iters.every(function(iter ) {return iter.includes(value)})) {
              set.remove(value);
            }
          });
        });
      };

      Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter ) {return SetIterable(iter)});
        var originalSet = this;
        return this.withMutations(function(set ) {
          originalSet.forEach(function(value ) {
            if (iters.some(function(iter ) {return iter.includes(value)})) {
              set.remove(value);
            }
          });
        });
      };

      Set.prototype.merge = function() {
        return this.union.apply(this, arguments);
      };

      Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
        return this.union.apply(this, iters);
      };

      Set.prototype.sort = function(comparator) {
        // Late binding
        return OrderedSet(sortFactory(this, comparator));
      };

      Set.prototype.sortBy = function(mapper, comparator) {
        // Late binding
        return OrderedSet(sortFactory(this, comparator, mapper));
      };

      Set.prototype.wasAltered = function() {
        return this._map.wasAltered();
      };

      Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
        return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
      };

      Set.prototype.__iterator = function(type, reverse) {
        return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
      };

      Set.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        if (!ownerID) {
          this.__ownerID = ownerID;
          this._map = newMap;
          return this;
        }
        return this.__make(newMap, ownerID);
      };


    function isSet(maybeSet) {
      return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
    }

    Set.isSet = isSet;

    var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

    var SetPrototype = Set.prototype;
    SetPrototype[IS_SET_SENTINEL] = true;
    SetPrototype[DELETE] = SetPrototype.remove;
    SetPrototype.mergeDeep = SetPrototype.merge;
    SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
    SetPrototype.withMutations = MapPrototype.withMutations;
    SetPrototype.asMutable = MapPrototype.asMutable;
    SetPrototype.asImmutable = MapPrototype.asImmutable;

    SetPrototype.__empty = emptySet;
    SetPrototype.__make = makeSet;

    function updateSet(set, newMap) {
      if (set.__ownerID) {
        set.size = newMap.size;
        set._map = newMap;
        return set;
      }
      return newMap === set._map ? set :
        newMap.size === 0 ? set.__empty() :
        set.__make(newMap);
    }

    function makeSet(map, ownerID) {
      var set = Object.create(SetPrototype);
      set.size = map ? map.size : 0;
      set._map = map;
      set.__ownerID = ownerID;
      return set;
    }

    var EMPTY_SET;
    function emptySet() {
      return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
    }

    createClass(OrderedSet, Set);

      // @pragma Construction

      function OrderedSet(value) {
        return value === null || value === undefined ? emptyOrderedSet() :
          isOrderedSet(value) ? value :
          emptyOrderedSet().withMutations(function(set ) {
            var iter = SetIterable(value);
            assertNotInfinite(iter.size);
            iter.forEach(function(v ) {return set.add(v)});
          });
      }

      OrderedSet.of = function(/*...values*/) {
        return this(arguments);
      };

      OrderedSet.fromKeys = function(value) {
        return this(KeyedIterable(value).keySeq());
      };

      OrderedSet.prototype.toString = function() {
        return this.__toString('OrderedSet {', '}');
      };


    function isOrderedSet(maybeOrderedSet) {
      return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
    }

    OrderedSet.isOrderedSet = isOrderedSet;

    var OrderedSetPrototype = OrderedSet.prototype;
    OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

    OrderedSetPrototype.__empty = emptyOrderedSet;
    OrderedSetPrototype.__make = makeOrderedSet;

    function makeOrderedSet(map, ownerID) {
      var set = Object.create(OrderedSetPrototype);
      set.size = map ? map.size : 0;
      set._map = map;
      set.__ownerID = ownerID;
      return set;
    }

    var EMPTY_ORDERED_SET;
    function emptyOrderedSet() {
      return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
    }

    createClass(Stack, IndexedCollection);

      // @pragma Construction

      function Stack(value) {
        return value === null || value === undefined ? emptyStack() :
          isStack(value) ? value :
          emptyStack().unshiftAll(value);
      }

      Stack.of = function(/*...values*/) {
        return this(arguments);
      };

      Stack.prototype.toString = function() {
        return this.__toString('Stack [', ']');
      };

      // @pragma Access

      Stack.prototype.get = function(index, notSetValue) {
        var head = this._head;
        index = wrapIndex(this, index);
        while (head && index--) {
          head = head.next;
        }
        return head ? head.value : notSetValue;
      };

      Stack.prototype.peek = function() {
        return this._head && this._head.value;
      };

      // @pragma Modification

      Stack.prototype.push = function(/*...values*/) {
        if (arguments.length === 0) {
          return this;
        }
        var newSize = this.size + arguments.length;
        var head = this._head;
        for (var ii = arguments.length - 1; ii >= 0; ii--) {
          head = {
            value: arguments[ii],
            next: head
          };
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = undefined;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };

      Stack.prototype.pushAll = function(iter) {
        iter = IndexedIterable(iter);
        if (iter.size === 0) {
          return this;
        }
        assertNotInfinite(iter.size);
        var newSize = this.size;
        var head = this._head;
        iter.reverse().forEach(function(value ) {
          newSize++;
          head = {
            value: value,
            next: head
          };
        });
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = undefined;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };

      Stack.prototype.pop = function() {
        return this.slice(1);
      };

      Stack.prototype.unshift = function(/*...values*/) {
        return this.push.apply(this, arguments);
      };

      Stack.prototype.unshiftAll = function(iter) {
        return this.pushAll(iter);
      };

      Stack.prototype.shift = function() {
        return this.pop.apply(this, arguments);
      };

      Stack.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._head = undefined;
          this.__hash = undefined;
          this.__altered = true;
          return this;
        }
        return emptyStack();
      };

      Stack.prototype.slice = function(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        var resolvedBegin = resolveBegin(begin, this.size);
        var resolvedEnd = resolveEnd(end, this.size);
        if (resolvedEnd !== this.size) {
          // super.slice(begin, end);
          return IndexedCollection.prototype.slice.call(this, begin, end);
        }
        var newSize = this.size - resolvedBegin;
        var head = this._head;
        while (resolvedBegin--) {
          head = head.next;
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = undefined;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };

      // @pragma Mutability

      Stack.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeStack(this.size, this._head, ownerID, this.__hash);
      };

      // @pragma Iteration

      Stack.prototype.__iterate = function(fn, reverse) {
        if (reverse) {
          return this.reverse().__iterate(fn);
        }
        var iterations = 0;
        var node = this._head;
        while (node) {
          if (fn(node.value, iterations++, this) === false) {
            break;
          }
          node = node.next;
        }
        return iterations;
      };

      Stack.prototype.__iterator = function(type, reverse) {
        if (reverse) {
          return this.reverse().__iterator(type);
        }
        var iterations = 0;
        var node = this._head;
        return new Iterator(function()  {
          if (node) {
            var value = node.value;
            node = node.next;
            return iteratorValue(type, iterations++, value);
          }
          return iteratorDone();
        });
      };


    function isStack(maybeStack) {
      return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
    }

    Stack.isStack = isStack;

    var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

    var StackPrototype = Stack.prototype;
    StackPrototype[IS_STACK_SENTINEL] = true;
    StackPrototype.withMutations = MapPrototype.withMutations;
    StackPrototype.asMutable = MapPrototype.asMutable;
    StackPrototype.asImmutable = MapPrototype.asImmutable;
    StackPrototype.wasAltered = MapPrototype.wasAltered;


    function makeStack(size, head, ownerID, hash) {
      var map = Object.create(StackPrototype);
      map.size = size;
      map._head = head;
      map.__ownerID = ownerID;
      map.__hash = hash;
      map.__altered = false;
      return map;
    }

    var EMPTY_STACK;
    function emptyStack() {
      return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
    }

    /**
     * Contributes additional methods to a constructor
     */
    function mixin(ctor, methods) {
      var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
      Object.keys(methods).forEach(keyCopier);
      Object.getOwnPropertySymbols &&
        Object.getOwnPropertySymbols(methods).forEach(keyCopier);
      return ctor;
    }

    Iterable.Iterator = Iterator;

    mixin(Iterable, {

      // ### Conversion to other types

      toArray: function() {
        assertNotInfinite(this.size);
        var array = new Array(this.size || 0);
        this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
        return array;
      },

      toIndexedSeq: function() {
        return new ToIndexedSequence(this);
      },

      toJS: function() {
        return this.toSeq().map(
          function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
        ).__toJS();
      },

      toJSON: function() {
        return this.toSeq().map(
          function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
        ).__toJS();
      },

      toKeyedSeq: function() {
        return new ToKeyedSequence(this, true);
      },

      toMap: function() {
        // Use Late Binding here to solve the circular dependency.
        return Map(this.toKeyedSeq());
      },

      toObject: function() {
        assertNotInfinite(this.size);
        var object = {};
        this.__iterate(function(v, k)  { object[k] = v; });
        return object;
      },

      toOrderedMap: function() {
        // Use Late Binding here to solve the circular dependency.
        return OrderedMap(this.toKeyedSeq());
      },

      toOrderedSet: function() {
        // Use Late Binding here to solve the circular dependency.
        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
      },

      toSet: function() {
        // Use Late Binding here to solve the circular dependency.
        return Set(isKeyed(this) ? this.valueSeq() : this);
      },

      toSetSeq: function() {
        return new ToSetSequence(this);
      },

      toSeq: function() {
        return isIndexed(this) ? this.toIndexedSeq() :
          isKeyed(this) ? this.toKeyedSeq() :
          this.toSetSeq();
      },

      toStack: function() {
        // Use Late Binding here to solve the circular dependency.
        return Stack(isKeyed(this) ? this.valueSeq() : this);
      },

      toList: function() {
        // Use Late Binding here to solve the circular dependency.
        return List(isKeyed(this) ? this.valueSeq() : this);
      },


      // ### Common JavaScript methods and properties

      toString: function() {
        return '[Iterable]';
      },

      __toString: function(head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
      },


      // ### ES6 Collection methods (ES6 Array and Map)

      concat: function() {var values = SLICE$0.call(arguments, 0);
        return reify(this, concatFactory(this, values));
      },

      includes: function(searchValue) {
        return this.some(function(value ) {return is(value, searchValue)});
      },

      entries: function() {
        return this.__iterator(ITERATE_ENTRIES);
      },

      every: function(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = true;
        this.__iterate(function(v, k, c)  {
          if (!predicate.call(context, v, k, c)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },

      filter: function(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, true));
      },

      find: function(predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
      },

      findEntry: function(predicate, context) {
        var found;
        this.__iterate(function(v, k, c)  {
          if (predicate.call(context, v, k, c)) {
            found = [k, v];
            return false;
          }
        });
        return found;
      },

      findLastEntry: function(predicate, context) {
        return this.toSeq().reverse().findEntry(predicate, context);
      },

      forEach: function(sideEffect, context) {
        assertNotInfinite(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
      },

      join: function(separator) {
        assertNotInfinite(this.size);
        separator = separator !== undefined ? '' + separator : ',';
        var joined = '';
        var isFirst = true;
        this.__iterate(function(v ) {
          isFirst ? (isFirst = false) : (joined += separator);
          joined += v !== null && v !== undefined ? v.toString() : '';
        });
        return joined;
      },

      keys: function() {
        return this.__iterator(ITERATE_KEYS);
      },

      map: function(mapper, context) {
        return reify(this, mapFactory(this, mapper, context));
      },

      reduce: function(reducer, initialReduction, context) {
        assertNotInfinite(this.size);
        var reduction;
        var useFirst;
        if (arguments.length < 2) {
          useFirst = true;
        } else {
          reduction = initialReduction;
        }
        this.__iterate(function(v, k, c)  {
          if (useFirst) {
            useFirst = false;
            reduction = v;
          } else {
            reduction = reducer.call(context, reduction, v, k, c);
          }
        });
        return reduction;
      },

      reduceRight: function(reducer, initialReduction, context) {
        var reversed = this.toKeyedSeq().reverse();
        return reversed.reduce.apply(reversed, arguments);
      },

      reverse: function() {
        return reify(this, reverseFactory(this, true));
      },

      slice: function(begin, end) {
        return reify(this, sliceFactory(this, begin, end, true));
      },

      some: function(predicate, context) {
        return !this.every(not(predicate), context);
      },

      sort: function(comparator) {
        return reify(this, sortFactory(this, comparator));
      },

      values: function() {
        return this.__iterator(ITERATE_VALUES);
      },


      // ### More sequential methods

      butLast: function() {
        return this.slice(0, -1);
      },

      isEmpty: function() {
        return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
      },

      count: function(predicate, context) {
        return ensureSize(
          predicate ? this.toSeq().filter(predicate, context) : this
        );
      },

      countBy: function(grouper, context) {
        return countByFactory(this, grouper, context);
      },

      equals: function(other) {
        return deepEqual(this, other);
      },

      entrySeq: function() {
        var iterable = this;
        if (iterable._cache) {
          // We cache as an entries array, so we can just return the cache!
          return new ArraySeq(iterable._cache);
        }
        var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
        entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
        return entriesSequence;
      },

      filterNot: function(predicate, context) {
        return this.filter(not(predicate), context);
      },

      findLast: function(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
      },

      first: function() {
        return this.find(returnTrue);
      },

      flatMap: function(mapper, context) {
        return reify(this, flatMapFactory(this, mapper, context));
      },

      flatten: function(depth) {
        return reify(this, flattenFactory(this, depth, true));
      },

      fromEntrySeq: function() {
        return new FromEntriesSequence(this);
      },

      get: function(searchKey, notSetValue) {
        return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
      },

      getIn: function(searchKeyPath, notSetValue) {
        var nested = this;
        // Note: in an ES6 environment, we would prefer:
        // for (var key of searchKeyPath) {
        var iter = forceIterator(searchKeyPath);
        var step;
        while (!(step = iter.next()).done) {
          var key = step.value;
          nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
          if (nested === NOT_SET) {
            return notSetValue;
          }
        }
        return nested;
      },

      groupBy: function(grouper, context) {
        return groupByFactory(this, grouper, context);
      },

      has: function(searchKey) {
        return this.get(searchKey, NOT_SET) !== NOT_SET;
      },

      hasIn: function(searchKeyPath) {
        return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
      },

      isSubset: function(iter) {
        iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
        return this.every(function(value ) {return iter.includes(value)});
      },

      isSuperset: function(iter) {
        iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
        return iter.isSubset(this);
      },

      keySeq: function() {
        return this.toSeq().map(keyMapper).toIndexedSeq();
      },

      last: function() {
        return this.toSeq().reverse().first();
      },

      max: function(comparator) {
        return maxFactory(this, comparator);
      },

      maxBy: function(mapper, comparator) {
        return maxFactory(this, comparator, mapper);
      },

      min: function(comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
      },

      minBy: function(mapper, comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
      },

      rest: function() {
        return this.slice(1);
      },

      skip: function(amount) {
        return this.slice(Math.max(0, amount));
      },

      skipLast: function(amount) {
        return reify(this, this.toSeq().reverse().skip(amount).reverse());
      },

      skipWhile: function(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, true));
      },

      skipUntil: function(predicate, context) {
        return this.skipWhile(not(predicate), context);
      },

      sortBy: function(mapper, comparator) {
        return reify(this, sortFactory(this, comparator, mapper));
      },

      take: function(amount) {
        return this.slice(0, Math.max(0, amount));
      },

      takeLast: function(amount) {
        return reify(this, this.toSeq().reverse().take(amount).reverse());
      },

      takeWhile: function(predicate, context) {
        return reify(this, takeWhileFactory(this, predicate, context));
      },

      takeUntil: function(predicate, context) {
        return this.takeWhile(not(predicate), context);
      },

      valueSeq: function() {
        return this.toIndexedSeq();
      },


      // ### Hashable Object

      hashCode: function() {
        return this.__hash || (this.__hash = hashIterable(this));
      }


      // ### Internal

      // abstract __iterate(fn, reverse)

      // abstract __iterator(type, reverse)
    });

    // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
    // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
    // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
    // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

    var IterablePrototype = Iterable.prototype;
    IterablePrototype[IS_ITERABLE_SENTINEL] = true;
    IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
    IterablePrototype.__toJS = IterablePrototype.toArray;
    IterablePrototype.__toStringMapper = quoteString;
    IterablePrototype.inspect =
    IterablePrototype.toSource = function() { return this.toString(); };
    IterablePrototype.chain = IterablePrototype.flatMap;
    IterablePrototype.contains = IterablePrototype.includes;

    // Temporary warning about using length
    (function () {
      try {
        Object.defineProperty(IterablePrototype, 'length', {
          get: function () {
            if (!Iterable.noLengthWarning) {
              var stack;
              try {
                throw new Error();
              } catch (error) {
                stack = error.stack;
              }
              if (stack.indexOf('_wrapObject') === -1) {
                console && console.warn && console.warn(
                  'iterable.length has been deprecated, '+
                  'use iterable.size or iterable.count(). '+
                  'This warning will become a silent error in a future version. ' +
                  stack
                );
                return this.size;
              }
            }
          }
        });
      } catch (e) {}
    })();



    mixin(KeyedIterable, {

      // ### More sequential methods

      flip: function() {
        return reify(this, flipFactory(this));
      },

      findKey: function(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
      },

      findLastKey: function(predicate, context) {
        return this.toSeq().reverse().findKey(predicate, context);
      },

      keyOf: function(searchValue) {
        return this.findKey(function(value ) {return is(value, searchValue)});
      },

      lastKeyOf: function(searchValue) {
        return this.findLastKey(function(value ) {return is(value, searchValue)});
      },

      mapEntries: function(mapper, context) {var this$0 = this;
        var iterations = 0;
        return reify(this,
          this.toSeq().map(
            function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
          ).fromEntrySeq()
        );
      },

      mapKeys: function(mapper, context) {var this$0 = this;
        return reify(this,
          this.toSeq().flip().map(
            function(k, v)  {return mapper.call(context, k, v, this$0)}
          ).flip()
        );
      }

    });

    var KeyedIterablePrototype = KeyedIterable.prototype;
    KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
    KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
    KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
    KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



    mixin(IndexedIterable, {

      // ### Conversion to other types

      toKeyedSeq: function() {
        return new ToKeyedSequence(this, false);
      },


      // ### ES6 Collection methods (ES6 Array and Map)

      filter: function(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, false));
      },

      findIndex: function(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
      },

      indexOf: function(searchValue) {
        var key = this.toKeyedSeq().keyOf(searchValue);
        return key === undefined ? -1 : key;
      },

      lastIndexOf: function(searchValue) {
        var key = this.toKeyedSeq().reverse().keyOf(searchValue);
        return key === undefined ? -1 : key;

        // var index =
        // return this.toSeq().reverse().indexOf(searchValue);
      },

      reverse: function() {
        return reify(this, reverseFactory(this, false));
      },

      slice: function(begin, end) {
        return reify(this, sliceFactory(this, begin, end, false));
      },

      splice: function(index, removeNum /*, ...values*/) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum | 0, 0);
        if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
          return this;
        }
        // If index is negative, it should resolve relative to the size of the
        // collection. However size may be expensive to compute if not cached, so
        // only call count() if the number is in fact negative.
        index = resolveBegin(index, index < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index);
        return reify(
          this,
          numArgs === 1 ?
            spliced :
            spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
        );
      },


      // ### More collection methods

      findLastIndex: function(predicate, context) {
        var key = this.toKeyedSeq().findLastKey(predicate, context);
        return key === undefined ? -1 : key;
      },

      first: function() {
        return this.get(0);
      },

      flatten: function(depth) {
        return reify(this, flattenFactory(this, depth, false));
      },

      get: function(index, notSetValue) {
        index = wrapIndex(this, index);
        return (index < 0 || (this.size === Infinity ||
            (this.size !== undefined && index > this.size))) ?
          notSetValue :
          this.find(function(_, key)  {return key === index}, undefined, notSetValue);
      },

      has: function(index) {
        index = wrapIndex(this, index);
        return index >= 0 && (this.size !== undefined ?
          this.size === Infinity || index < this.size :
          this.indexOf(index) !== -1
        );
      },

      interpose: function(separator) {
        return reify(this, interposeFactory(this, separator));
      },

      interleave: function(/*...iterables*/) {
        var iterables = [this].concat(arrCopy(arguments));
        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * iterables.length;
        }
        return reify(this, interleaved);
      },

      last: function() {
        return this.get(-1);
      },

      skipWhile: function(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, false));
      },

      zip: function(/*, ...iterables */) {
        var iterables = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, iterables));
      },

      zipWith: function(zipper/*, ...iterables */) {
        var iterables = arrCopy(arguments);
        iterables[0] = this;
        return reify(this, zipWithFactory(this, zipper, iterables));
      }

    });

    IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
    IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



    mixin(SetIterable, {

      // ### ES6 Collection methods (ES6 Array and Map)

      get: function(value, notSetValue) {
        return this.has(value) ? value : notSetValue;
      },

      includes: function(value) {
        return this.has(value);
      },


      // ### More sequential methods

      keySeq: function() {
        return this.valueSeq();
      }

    });

    SetIterable.prototype.has = IterablePrototype.includes;


    // Mixin subclasses

    mixin(KeyedSeq, KeyedIterable.prototype);
    mixin(IndexedSeq, IndexedIterable.prototype);
    mixin(SetSeq, SetIterable.prototype);

    mixin(KeyedCollection, KeyedIterable.prototype);
    mixin(IndexedCollection, IndexedIterable.prototype);
    mixin(SetCollection, SetIterable.prototype);


    // #pragma Helper functions

    function keyMapper(v, k) {
      return k;
    }

    function entryMapper(v, k) {
      return [k, v];
    }

    function not(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      }
    }

    function neg(predicate) {
      return function() {
        return -predicate.apply(this, arguments);
      }
    }

    function quoteString(value) {
      return typeof value === 'string' ? JSON.stringify(value) : value;
    }

    function defaultZipper() {
      return arrCopy(arguments);
    }

    function defaultNegComparator(a, b) {
      return a < b ? 1 : a > b ? -1 : 0;
    }

    function hashIterable(iterable) {
      if (iterable.size === Infinity) {
        return 0;
      }
      var ordered = isOrdered(iterable);
      var keyed = isKeyed(iterable);
      var h = ordered ? 1 : 0;
      var size = iterable.__iterate(
        keyed ?
          ordered ?
            function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
            function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
          ordered ?
            function(v ) { h = 31 * h + hash(v) | 0; } :
            function(v ) { h = h + hash(v) | 0; }
      );
      return murmurHashOfSize(size, h);
    }

    function murmurHashOfSize(size, h) {
      h = imul(h, 0xCC9E2D51);
      h = imul(h << 15 | h >>> -15, 0x1B873593);
      h = imul(h << 13 | h >>> -13, 5);
      h = (h + 0xE6546B64 | 0) ^ size;
      h = imul(h ^ h >>> 16, 0x85EBCA6B);
      h = imul(h ^ h >>> 13, 0xC2B2AE35);
      h = smi(h ^ h >>> 16);
      return h;
    }

    function hashMerge(a, b) {
      return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
    }

    var Immutable = {

      Iterable: Iterable,

      Seq: Seq,
      Collection: Collection,
      Map: Map,
      OrderedMap: OrderedMap,
      List: List,
      Stack: Stack,
      Set: Set,
      OrderedSet: OrderedSet,

      Record: Record,
      Range: Range,
      Repeat: Repeat,

      is: is,
      fromJS: fromJS

    };

    return Immutable;

  }));
  });

  var OrderedMap = immutable.OrderedMap;


  var BlockMapBuilder = {
    createFromArray: function createFromArray(blocks) {
      return OrderedMap(blocks.map(function (block) {
        return [block.getKey(), block];
      }));
    }
  };

  var BlockMapBuilder_1 = BlockMapBuilder;

  function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var Map$1 = immutable.Map,
      OrderedSet = immutable.OrderedSet,
      Record = immutable.Record;

  // Immutable.map is typed such that the value for every key in the map
  // must be the same type


  var EMPTY_SET = OrderedSet();

  var defaultRecord = {
    style: EMPTY_SET,
    entity: null
  };

  var CharacterMetadataRecord = Record(defaultRecord);

  var CharacterMetadata = function (_CharacterMetadataRec) {
    _inherits$1(CharacterMetadata, _CharacterMetadataRec);

    function CharacterMetadata() {
      _classCallCheck$1(this, CharacterMetadata);

      return _possibleConstructorReturn$1(this, _CharacterMetadataRec.apply(this, arguments));
    }

    CharacterMetadata.prototype.getStyle = function getStyle() {
      return this.get('style');
    };

    CharacterMetadata.prototype.getEntity = function getEntity() {
      return this.get('entity');
    };

    CharacterMetadata.prototype.hasStyle = function hasStyle(style) {
      return this.getStyle().includes(style);
    };

    CharacterMetadata.applyStyle = function applyStyle(record, style) {
      var withStyle = record.set('style', record.getStyle().add(style));
      return CharacterMetadata.create(withStyle);
    };

    CharacterMetadata.removeStyle = function removeStyle(record, style) {
      var withoutStyle = record.set('style', record.getStyle().remove(style));
      return CharacterMetadata.create(withoutStyle);
    };

    CharacterMetadata.applyEntity = function applyEntity(record, entityKey) {
      var withEntity = record.getEntity() === entityKey ? record : record.set('entity', entityKey);
      return CharacterMetadata.create(withEntity);
    };

    /**
     * Use this function instead of the `CharacterMetadata` constructor.
     * Since most content generally uses only a very small number of
     * style/entity permutations, we can reuse these objects as often as
     * possible.
     */


    CharacterMetadata.create = function create(config) {
      if (!config) {
        return EMPTY;
      }

      var defaultConfig = {
        style: EMPTY_SET,
        entity: null
      };

      // Fill in unspecified properties, if necessary.
      var configMap = Map$1(defaultConfig).merge(config);

      var existing = pool.get(configMap);
      if (existing) {
        return existing;
      }

      var newCharacter = new CharacterMetadata(configMap);
      pool = pool.set(configMap, newCharacter);
      return newCharacter;
    };

    return CharacterMetadata;
  }(CharacterMetadataRecord);

  var EMPTY = new CharacterMetadata();
  var pool = Map$1([[Map$1(defaultRecord), EMPTY]]);

  CharacterMetadata.EMPTY = EMPTY;

  var CharacterMetadata_1 = CharacterMetadata;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule findRangesImmutable
   * @format
   * 
   */

  /**
   * Search through an array to find contiguous stretches of elements that
   * match a specified filter function.
   *
   * When ranges are found, execute a specified `found` function to supply
   * the values to the caller.
   */
  function findRangesImmutable(haystack, areEqualFn, filterFn, foundFn) {
    if (!haystack.size) {
      return;
    }

    var cursor = 0;

    haystack.reduce(function (value, nextValue, nextIndex) {
      if (!areEqualFn(value, nextValue)) {
        if (filterFn(value)) {
          foundFn(cursor, nextIndex);
        }
        cursor = nextIndex;
      }
      return nextValue;
    });

    filterFn(haystack.last()) && foundFn(cursor, haystack.count());
  }

  var findRangesImmutable_1 = findRangesImmutable;

  function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






  var List = immutable.List,
      Map$2 = immutable.Map,
      OrderedSet$1 = immutable.OrderedSet,
      Record$1 = immutable.Record,
      Repeat = immutable.Repeat;


  var EMPTY_SET$1 = OrderedSet$1();

  var defaultRecord$1 = {
    key: '',
    type: 'unstyled',
    text: '',
    characterList: List(),
    depth: 0,
    data: Map$2()
  };

  var ContentBlockRecord = Record$1(defaultRecord$1);

  var decorateCharacterList = function decorateCharacterList(config) {
    if (!config) {
      return config;
    }

    var characterList = config.characterList,
        text = config.text;


    if (text && !characterList) {
      config.characterList = List(Repeat(CharacterMetadata_1.EMPTY, text.length));
    }

    return config;
  };

  var ContentBlock = function (_ContentBlockRecord) {
    _inherits$2(ContentBlock, _ContentBlockRecord);

    function ContentBlock(config) {
      _classCallCheck$2(this, ContentBlock);

      return _possibleConstructorReturn$2(this, _ContentBlockRecord.call(this, decorateCharacterList(config)));
    }

    ContentBlock.prototype.getKey = function getKey() {
      return this.get('key');
    };

    ContentBlock.prototype.getType = function getType() {
      return this.get('type');
    };

    ContentBlock.prototype.getText = function getText() {
      return this.get('text');
    };

    ContentBlock.prototype.getCharacterList = function getCharacterList() {
      return this.get('characterList');
    };

    ContentBlock.prototype.getLength = function getLength() {
      return this.getText().length;
    };

    ContentBlock.prototype.getDepth = function getDepth() {
      return this.get('depth');
    };

    ContentBlock.prototype.getData = function getData() {
      return this.get('data');
    };

    ContentBlock.prototype.getInlineStyleAt = function getInlineStyleAt(offset) {
      var character = this.getCharacterList().get(offset);
      return character ? character.getStyle() : EMPTY_SET$1;
    };

    ContentBlock.prototype.getEntityAt = function getEntityAt(offset) {
      var character = this.getCharacterList().get(offset);
      return character ? character.getEntity() : null;
    };

    /**
     * Execute a callback for every contiguous range of styles within the block.
     */


    ContentBlock.prototype.findStyleRanges = function findStyleRanges(filterFn, callback) {
      findRangesImmutable_1(this.getCharacterList(), haveEqualStyle, filterFn, callback);
    };

    /**
     * Execute a callback for every contiguous range of entities within the block.
     */


    ContentBlock.prototype.findEntityRanges = function findEntityRanges(filterFn, callback) {
      findRangesImmutable_1(this.getCharacterList(), haveEqualEntity, filterFn, callback);
    };

    return ContentBlock;
  }(ContentBlockRecord);

  function haveEqualStyle(charA, charB) {
    return charA.getStyle() === charB.getStyle();
  }

  function haveEqualEntity(charA, charB) {
    return charA.getEntity() === charB.getEntity();
  }

  var ContentBlock_1 = ContentBlock;

  function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






  var List$1 = immutable.List,
      Map$3 = immutable.Map,
      OrderedSet$2 = immutable.OrderedSet,
      Record$2 = immutable.Record,
      Repeat$1 = immutable.Repeat;


  var EMPTY_SET$2 = OrderedSet$2();

  var defaultRecord$2 = {
    parent: null,
    characterList: List$1(),
    data: Map$3(),
    depth: 0,
    key: '',
    text: '',
    type: 'unstyled',
    children: List$1(),
    prevSibling: null,
    nextSibling: null
  };

  var haveEqualStyle$1 = function haveEqualStyle(charA, charB) {
    return charA.getStyle() === charB.getStyle();
  };

  var haveEqualEntity$1 = function haveEqualEntity(charA, charB) {
    return charA.getEntity() === charB.getEntity();
  };

  var decorateCharacterList$1 = function decorateCharacterList(config) {
    if (!config) {
      return config;
    }

    var characterList = config.characterList,
        text = config.text;


    if (text && !characterList) {
      config.characterList = List$1(Repeat$1(CharacterMetadata_1.EMPTY, text.length));
    }

    return config;
  };

  var ContentBlockNode = function (_Record) {
    _inherits$3(ContentBlockNode, _Record);

    function ContentBlockNode() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultRecord$2;

      _classCallCheck$3(this, ContentBlockNode);

      return _possibleConstructorReturn$3(this, _Record.call(this, decorateCharacterList$1(props)));
    }

    ContentBlockNode.prototype.getKey = function getKey() {
      return this.get('key');
    };

    ContentBlockNode.prototype.getType = function getType() {
      return this.get('type');
    };

    ContentBlockNode.prototype.getText = function getText() {
      return this.get('text');
    };

    ContentBlockNode.prototype.getCharacterList = function getCharacterList() {
      return this.get('characterList');
    };

    ContentBlockNode.prototype.getLength = function getLength() {
      return this.getText().length;
    };

    ContentBlockNode.prototype.getDepth = function getDepth() {
      return this.get('depth');
    };

    ContentBlockNode.prototype.getData = function getData() {
      return this.get('data');
    };

    ContentBlockNode.prototype.getInlineStyleAt = function getInlineStyleAt(offset) {
      var character = this.getCharacterList().get(offset);
      return character ? character.getStyle() : EMPTY_SET$2;
    };

    ContentBlockNode.prototype.getEntityAt = function getEntityAt(offset) {
      var character = this.getCharacterList().get(offset);
      return character ? character.getEntity() : null;
    };

    ContentBlockNode.prototype.getChildKeys = function getChildKeys() {
      return this.get('children');
    };

    ContentBlockNode.prototype.getParentKey = function getParentKey() {
      return this.get('parent');
    };

    ContentBlockNode.prototype.getPrevSiblingKey = function getPrevSiblingKey() {
      return this.get('prevSibling');
    };

    ContentBlockNode.prototype.getNextSiblingKey = function getNextSiblingKey() {
      return this.get('nextSibling');
    };

    ContentBlockNode.prototype.findStyleRanges = function findStyleRanges(filterFn, callback) {
      findRangesImmutable_1(this.getCharacterList(), haveEqualStyle$1, filterFn, callback);
    };

    ContentBlockNode.prototype.findEntityRanges = function findEntityRanges(filterFn, callback) {
      findRangesImmutable_1(this.getCharacterList(), haveEqualEntity$1, filterFn, callback);
    };

    return ContentBlockNode;
  }(Record$2(defaultRecord$2));

  var ContentBlockNode_1 = ContentBlockNode;

  /**
   * Copyright 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule DraftFeatureFlags-core
   * @format
   * 
   */

  var DraftFeatureFlags = {
    draft_killswitch_allow_nontextnodes: false,
    draft_segmented_entities_behavior: false,
    draft_handlebeforeinput_composed_text: false,
    draft_tree_data_support: false
  };

  var DraftFeatureFlagsCore = DraftFeatureFlags;

  var DraftFeatureFlags_1 = DraftFeatureFlagsCore;

  var Map$4 = immutable.Map;

  var ContentStateInlineStyle = {
    add: function add(contentState, selectionState, inlineStyle) {
      return modifyInlineStyle(contentState, selectionState, inlineStyle, true);
    },

    remove: function remove(contentState, selectionState, inlineStyle) {
      return modifyInlineStyle(contentState, selectionState, inlineStyle, false);
    }
  };

  function modifyInlineStyle(contentState, selectionState, inlineStyle, addOrRemove) {
    var blockMap = contentState.getBlockMap();
    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();

    var newBlocks = blockMap.skipUntil(function (_, k) {
      return k === startKey;
    }).takeUntil(function (_, k) {
      return k === endKey;
    }).concat(Map$4([[endKey, blockMap.get(endKey)]])).map(function (block, blockKey) {
      var sliceStart;
      var sliceEnd;

      if (startKey === endKey) {
        sliceStart = startOffset;
        sliceEnd = endOffset;
      } else {
        sliceStart = blockKey === startKey ? startOffset : 0;
        sliceEnd = blockKey === endKey ? endOffset : block.getLength();
      }

      var chars = block.getCharacterList();
      var current;
      while (sliceStart < sliceEnd) {
        current = chars.get(sliceStart);
        chars = chars.set(sliceStart, addOrRemove ? CharacterMetadata_1.applyStyle(current, inlineStyle) : CharacterMetadata_1.removeStyle(current, inlineStyle));
        sliceStart++;
      }

      return block.set('characterList', chars);
    });

    return contentState.merge({
      blockMap: blockMap.merge(newBlocks),
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  }

  var ContentStateInlineStyle_1 = ContentStateInlineStyle;

  function applyEntityToContentBlock(contentBlock, start, end, entityKey) {
    var characterList = contentBlock.getCharacterList();
    while (start < end) {
      characterList = characterList.set(start, CharacterMetadata_1.applyEntity(characterList.get(start), entityKey));
      start++;
    }
    return contentBlock.set('characterList', characterList);
  }

  var applyEntityToContentBlock_1 = applyEntityToContentBlock;

  function applyEntityToContentState(contentState, selectionState, entityKey) {
    var blockMap = contentState.getBlockMap();
    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();

    var newBlocks = blockMap.skipUntil(function (_, k) {
      return k === startKey;
    }).takeUntil(function (_, k) {
      return k === endKey;
    }).toOrderedMap().merge(immutable.OrderedMap([[endKey, blockMap.get(endKey)]])).map(function (block, blockKey) {
      var sliceStart = blockKey === startKey ? startOffset : 0;
      var sliceEnd = blockKey === endKey ? endOffset : block.getLength();
      return applyEntityToContentBlock_1(block, sliceStart, sliceEnd, entityKey);
    });

    return contentState.merge({
      blockMap: blockMap.merge(newBlocks),
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  }

  var applyEntityToContentState_1 = applyEntityToContentState;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule DraftEntitySegments
   * @format
   * 
   */

  /**
   * Identify the range to delete from a segmented entity.
   *
   * Rules:
   *
   *  Example: 'John F. Kennedy'
   *
   *   - Deletion from within any non-whitespace (i.e. ['John', 'F.', 'Kennedy'])
   *     will return the range of that text.
   *
   *       'John F. Kennedy' -> 'John F.'
   *                  ^
   *
   *   - Forward deletion of whitespace will remove the following section:
   *
   *       'John F. Kennedy' -> 'John Kennedy'
   *            ^
   *
   *   - Backward deletion of whitespace will remove the previous section:
   *
   *       'John F. Kennedy' -> 'F. Kennedy'
   *            ^
   */
  var DraftEntitySegments = {
    getRemovalRange: function getRemovalRange(selectionStart, selectionEnd, text, entityStart, direction) {
      var segments = text.split(' ');
      segments = segments.map(function ( /*string*/segment, /*number*/ii) {
        if (direction === 'forward') {
          if (ii > 0) {
            return ' ' + segment;
          }
        } else if (ii < segments.length - 1) {
          return segment + ' ';
        }
        return segment;
      });

      var segmentStart = entityStart;
      var segmentEnd;
      var segment;
      var removalStart = null;
      var removalEnd = null;

      for (var jj = 0; jj < segments.length; jj++) {
        segment = segments[jj];
        segmentEnd = segmentStart + segment.length;

        // Our selection overlaps this segment.
        if (selectionStart < segmentEnd && segmentStart < selectionEnd) {
          if (removalStart !== null) {
            removalEnd = segmentEnd;
          } else {
            removalStart = segmentStart;
            removalEnd = segmentEnd;
          }
        } else if (removalStart !== null) {
          break;
        }

        segmentStart = segmentEnd;
      }

      var entityEnd = entityStart + text.length;
      var atStart = removalStart === entityStart;
      var atEnd = removalEnd === entityEnd;

      if (!atStart && atEnd || atStart && !atEnd) {
        if (direction === 'forward') {
          if (removalEnd !== entityEnd) {
            removalEnd++;
          }
        } else if (removalStart !== entityStart) {
          removalStart--;
        }
      }

      return {
        start: removalStart,
        end: removalEnd
      };
    }
  };

  var DraftEntitySegments_1 = DraftEntitySegments;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */

  var validateFormat = function validateFormat(format) {};

  function invariant(condition, format, a, b, c, d, e, f) {
    validateFormat(format);

    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  }

  var invariant_1 = invariant;

  /**
   * Obtain the start and end positions of the range that has the
   * specified entity applied to it.
   *
   * Entity keys are applied only to contiguous stretches of text, so this
   * method searches for the first instance of the entity key and returns
   * the subsequent range.
   */
  function getRangesForDraftEntity(block, key) {
    var ranges = [];
    block.findEntityRanges(function (c) {
      return c.getEntity() === key;
    }, function (start, end) {
      ranges.push({ start: start, end: end });
    });

    !!!ranges.length ? invariant_1(false) : void 0;

    return ranges;
  }

  var getRangesForDraftEntity_1 = getRangesForDraftEntity;

  /**
   * Given a SelectionState and a removal direction, determine the entire range
   * that should be removed from a ContentState. This is based on any entities
   * within the target, with their `mutability` values taken into account.
   *
   * For instance, if we are attempting to remove part of an "immutable" entity
   * range, the entire entity must be removed. The returned `SelectionState`
   * will be adjusted accordingly.
   */
  function getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {
    var start = selectionState.getStartOffset();
    var end = selectionState.getEndOffset();
    var startEntityKey = startBlock.getEntityAt(start);
    var endEntityKey = endBlock.getEntityAt(end - 1);
    if (!startEntityKey && !endEntityKey) {
      return selectionState;
    }
    var newSelectionState = selectionState;
    if (startEntityKey && startEntityKey === endEntityKey) {
      newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);
    } else if (startEntityKey && endEntityKey) {
      var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
      var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
      newSelectionState = newSelectionState.merge({
        anchorOffset: startSelectionState.getAnchorOffset(),
        focusOffset: endSelectionState.getFocusOffset(),
        isBackward: false
      });
    } else if (startEntityKey) {
      var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
      newSelectionState = newSelectionState.merge({
        anchorOffset: _startSelectionState.getStartOffset(),
        isBackward: false
      });
    } else if (endEntityKey) {
      var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
      newSelectionState = newSelectionState.merge({
        focusOffset: _endSelectionState.getEndOffset(),
        isBackward: false
      });
    }
    return newSelectionState;
  }

  function getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {
    var start = selectionState.getStartOffset();
    var end = selectionState.getEndOffset();
    var entity = entityMap.__get(entityKey);
    var mutability = entity.getMutability();
    var sideToConsider = isEntityAtStart ? start : end;

    // `MUTABLE` entities can just have the specified range of text removed
    // directly. No adjustments are needed.
    if (mutability === 'MUTABLE') {
      return selectionState;
    }

    // Find the entity range that overlaps with our removal range.
    var entityRanges = getRangesForDraftEntity_1(block, entityKey).filter(function (range) {
      return sideToConsider <= range.end && sideToConsider >= range.start;
    });

    !(entityRanges.length == 1) ? invariant_1(false) : void 0;

    var entityRange = entityRanges[0];

    // For `IMMUTABLE` entity types, we will remove the entire entity range.
    if (mutability === 'IMMUTABLE') {
      return selectionState.merge({
        anchorOffset: entityRange.start,
        focusOffset: entityRange.end,
        isBackward: false
      });
    }

    // For `SEGMENTED` entity types, determine the appropriate segment to
    // remove.
    if (!isEntireSelectionWithinEntity) {
      if (isEntityAtStart) {
        end = entityRange.end;
      } else {
        start = entityRange.start;
      }
    }

    var removalRange = DraftEntitySegments_1.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);

    return selectionState.merge({
      anchorOffset: removalRange.start,
      focusOffset: removalRange.end,
      isBackward: false
    });
  }

  var getCharacterRemovalRange_1 = getCharacterRemovalRange;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule generateRandomKey
   * @format
   * 
   */

  var seenKeys = {};
  var MULTIPLIER = Math.pow(2, 24);

  function generateRandomKey() {
    var key = void 0;
    while (key === undefined || seenKeys.hasOwnProperty(key) || !isNaN(+key)) {
      key = Math.floor(Math.random() * MULTIPLIER).toString(32);
    }
    seenKeys[key] = true;
    return key;
  }

  var generateRandomKey_1 = generateRandomKey;

  var OrderedMap$1 = immutable.OrderedMap;


  var randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {
    var newKeysRef = {};

    // we keep track of root blocks in order to update subsequent sibling links
    var lastRootBlock = void 0;

    return OrderedMap$1(blockMap.withMutations(function (blockMapState) {
      blockMapState.forEach(function (block, index) {
        var oldKey = block.getKey();
        var nextKey = block.getNextSiblingKey();
        var prevKey = block.getPrevSiblingKey();
        var childrenKeys = block.getChildKeys();
        var parentKey = block.getParentKey();

        // new key that we will use to build linking
        var key = generateRandomKey_1();

        // we will add it here to re-use it later
        newKeysRef[oldKey] = key;

        if (nextKey) {
          var nextBlock = blockMapState.get(nextKey);
          if (nextBlock) {
            blockMapState.setIn([nextKey, 'prevSibling'], key);
          } else {
            // this can happen when generating random keys for fragments
            blockMapState.setIn([oldKey, 'nextSibling'], null);
          }
        }

        if (prevKey) {
          var prevBlock = blockMapState.get(prevKey);
          if (prevBlock) {
            blockMapState.setIn([prevKey, 'nextSibling'], key);
          } else {
            // this can happen when generating random keys for fragments
            blockMapState.setIn([oldKey, 'prevSibling'], null);
          }
        }

        if (parentKey && blockMapState.get(parentKey)) {
          var parentBlock = blockMapState.get(parentKey);
          var parentChildrenList = parentBlock.getChildKeys();
          blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));
        } else {
          // blocks will then be treated as root block nodes
          blockMapState.setIn([oldKey, 'parent'], null);

          if (lastRootBlock) {
            blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);
            blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);
          }

          lastRootBlock = blockMapState.get(oldKey);
        }

        childrenKeys.forEach(function (childKey) {
          var childBlock = blockMapState.get(childKey);
          if (childBlock) {
            blockMapState.setIn([childKey, 'parent'], key);
          } else {
            blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {
              return child !== childKey;
            }));
          }
        });
      });
    }).toArray().map(function (block) {
      return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];
    }));
  };

  var randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {
    return OrderedMap$1(blockMap.toArray().map(function (block) {
      var key = generateRandomKey_1();
      return [key, block.set('key', key)];
    }));
  };

  var randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {
    var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode_1;

    if (!isTreeBasedBlockMap) {
      return randomizeContentBlockKeys(blockMap);
    }

    return randomizeContentBlockNodeKeys(blockMap);
  };

  var randomizeBlockMapKeys_1 = randomizeBlockMapKeys;

  function removeEntitiesAtEdges(contentState, selectionState) {
    var blockMap = contentState.getBlockMap();
    var entityMap = contentState.getEntityMap();

    var updatedBlocks = {};

    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var startBlock = blockMap.get(startKey);
    var updatedStart = removeForBlock(entityMap, startBlock, startOffset);

    if (updatedStart !== startBlock) {
      updatedBlocks[startKey] = updatedStart;
    }

    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();
    var endBlock = blockMap.get(endKey);
    if (startKey === endKey) {
      endBlock = updatedStart;
    }

    var updatedEnd = removeForBlock(entityMap, endBlock, endOffset);

    if (updatedEnd !== endBlock) {
      updatedBlocks[endKey] = updatedEnd;
    }

    if (!Object.keys(updatedBlocks).length) {
      return contentState.set('selectionAfter', selectionState);
    }

    return contentState.merge({
      blockMap: blockMap.merge(updatedBlocks),
      selectionAfter: selectionState
    });
  }

  function getRemovalRange(characters, key, offset) {
    var removalRange;
    findRangesImmutable_1(characters, function (a, b) {
      return a.getEntity() === b.getEntity();
    }, function (element) {
      return element.getEntity() === key;
    }, function (start, end) {
      if (start <= offset && end >= offset) {
        removalRange = { start: start, end: end };
      }
    });
    !(typeof removalRange === 'object') ? invariant_1(false) : void 0;
    return removalRange;
  }

  function removeForBlock(entityMap, block, offset) {
    var chars = block.getCharacterList();
    var charBefore = offset > 0 ? chars.get(offset - 1) : undefined;
    var charAfter = offset < chars.count() ? chars.get(offset) : undefined;
    var entityBeforeCursor = charBefore ? charBefore.getEntity() : undefined;
    var entityAfterCursor = charAfter ? charAfter.getEntity() : undefined;

    if (entityAfterCursor && entityAfterCursor === entityBeforeCursor) {
      var entity = entityMap.__get(entityAfterCursor);
      if (entity.getMutability() !== 'MUTABLE') {
        var _getRemovalRange = getRemovalRange(chars, entityAfterCursor, offset),
            start = _getRemovalRange.start,
            end = _getRemovalRange.end;

        var current;
        while (start < end) {
          current = chars.get(start);
          chars = chars.set(start, CharacterMetadata_1.applyEntity(current, null));
          start++;
        }
        return block.set('characterList', chars);
      }
    }

    return block;
  }

  var removeEntitiesAtEdges_1 = removeEntitiesAtEdges;

  var getContentStateFragment = function getContentStateFragment(contentState, selectionState) {
    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();

    // Edge entities should be stripped to ensure that we don't preserve
    // invalid partial entities when the fragment is reused. We do, however,
    // preserve entities that are entirely within the selection range.
    var contentWithoutEdgeEntities = removeEntitiesAtEdges_1(contentState, selectionState);

    var blockMap = contentWithoutEdgeEntities.getBlockMap();
    var blockKeys = blockMap.keySeq();
    var startIndex = blockKeys.indexOf(startKey);
    var endIndex = blockKeys.indexOf(endKey) + 1;

    return randomizeBlockMapKeys_1(blockMap.slice(startIndex, endIndex).map(function (block, blockKey) {
      var text = block.getText();
      var chars = block.getCharacterList();

      if (startKey === endKey) {
        return block.merge({
          text: text.slice(startOffset, endOffset),
          characterList: chars.slice(startOffset, endOffset)
        });
      }

      if (blockKey === startKey) {
        return block.merge({
          text: text.slice(startOffset),
          characterList: chars.slice(startOffset)
        });
      }

      if (blockKey === endKey) {
        return block.merge({
          text: text.slice(0, endOffset),
          characterList: chars.slice(0, endOffset)
        });
      }

      return block;
    }));
  };

  var getContentStateFragment_1 = getContentStateFragment;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule insertIntoList
   * @format
   * 
   */

  /**
   * Maintain persistence for target list when appending and prepending.
   */
  function insertIntoList(targetList, toInsert, offset) {
    if (offset === targetList.count()) {
      toInsert.forEach(function (c) {
        targetList = targetList.push(c);
      });
    } else if (offset === 0) {
      toInsert.reverse().forEach(function (c) {
        targetList = targetList.unshift(c);
      });
    } else {
      var head = targetList.slice(0, offset);
      var tail = targetList.slice(offset);
      targetList = head.concat(toInsert, tail).toList();
    }
    return targetList;
  }

  var insertIntoList_1 = insertIntoList;

  var List$2 = immutable.List;


  var updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {
    var targetBlock = blockMap.get(targetKey);
    var text = targetBlock.getText();
    var chars = targetBlock.getCharacterList();
    var finalKey = targetKey;
    var finalOffset = targetOffset + fragmentBlock.getText().length;

    var newBlock = targetBlock.merge({
      text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),
      characterList: insertIntoList_1(chars, fragmentBlock.getCharacterList(), targetOffset),
      data: fragmentBlock.getData()
    });

    return contentState.merge({
      blockMap: blockMap.set(targetKey, newBlock),
      selectionBefore: selectionState,
      selectionAfter: selectionState.merge({
        anchorKey: finalKey,
        anchorOffset: finalOffset,
        focusKey: finalKey,
        focusOffset: finalOffset,
        isBackward: false
      })
    });
  };

  /**
   * Appends text/characterList from the fragment first block to
   * target block.
   */
  var updateHead = function updateHead(block, targetOffset, fragment) {
    var text = block.getText();
    var chars = block.getCharacterList();

    // Modify head portion of block.
    var headText = text.slice(0, targetOffset);
    var headCharacters = chars.slice(0, targetOffset);
    var appendToHead = fragment.first();

    return block.merge({
      text: headText + appendToHead.getText(),
      characterList: headCharacters.concat(appendToHead.getCharacterList()),
      type: headText ? block.getType() : appendToHead.getType(),
      data: appendToHead.getData()
    });
  };

  /**
   * Appends offset text/characterList from the target block to the last
   * fragment block.
   */
  var updateTail = function updateTail(block, targetOffset, fragment) {
    // Modify tail portion of block.
    var text = block.getText();
    var chars = block.getCharacterList();

    // Modify head portion of block.
    var blockSize = text.length;
    var tailText = text.slice(targetOffset, blockSize);
    var tailCharacters = chars.slice(targetOffset, blockSize);
    var prependToTail = fragment.last();

    return prependToTail.merge({
      text: prependToTail.getText() + tailText,
      characterList: prependToTail.getCharacterList().concat(tailCharacters),
      data: prependToTail.getData()
    });
  };

  var getRootBlocks = function getRootBlocks(block, blockMap) {
    var headKey = block.getKey();
    var rootBlock = block;
    var rootBlocks = [];

    // sometimes the fragment head block will not be part of the blockMap itself this can happen when
    // the fragment head is used to update the target block, however when this does not happen we need
    // to make sure that we include it on the rootBlocks since the first block of a fragment is always a
    // fragment root block
    if (blockMap.get(headKey)) {
      rootBlocks.push(headKey);
    }

    while (rootBlock && rootBlock.getNextSiblingKey()) {
      var lastSiblingKey = rootBlock.getNextSiblingKey();

      if (!lastSiblingKey) {
        break;
      }

      rootBlocks.push(lastSiblingKey);
      rootBlock = blockMap.get(lastSiblingKey);
    }

    return rootBlocks;
  };

  var updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {
    return blockMap.withMutations(function (blockMapState) {
      var targetKey = targetBlock.getKey();
      var headKey = fragmentHeadBlock.getKey();
      var targetNextKey = targetBlock.getNextSiblingKey();
      var targetParentKey = targetBlock.getParentKey();
      var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);
      var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];

      if (blockMapState.get(headKey)) {
        // update the fragment head when it is part of the blockMap otherwise
        blockMapState.setIn([targetKey, 'nextSibling'], headKey);
        blockMapState.setIn([headKey, 'prevSibling'], targetKey);
      } else {
        // update the target block that had the fragment head contents merged into it
        blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());
        blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);
      }

      // update the last root block fragment
      blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);

      // update the original target next block
      if (targetNextKey) {
        blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);
      }

      // update fragment parent links
      fragmentRootBlocks.forEach(function (blockKey) {
        return blockMapState.setIn([blockKey, 'parent'], targetParentKey);
      });

      // update targetBlock parent child links
      if (targetParentKey) {
        var targetParent = blockMap.get(targetParentKey);
        var originalTargetParentChildKeys = targetParent.getChildKeys();

        var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);
        var insertionIndex = targetBlockIndex + 1;

        var newChildrenKeysArray = originalTargetParentChildKeys.toArray();

        // insert fragment children
        newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));

        blockMapState.setIn([targetParentKey, 'children'], List$2(newChildrenKeysArray));
      }
    });
  };

  var insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {
    var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode_1;
    var newBlockArr = [];
    var fragmentSize = fragment.size;
    var target = blockMap.get(targetKey);
    var head = fragment.first();
    var tail = fragment.last();
    var finalOffset = tail.getLength();
    var finalKey = tail.getKey();
    var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());

    blockMap.forEach(function (block, blockKey) {
      if (blockKey !== targetKey) {
        newBlockArr.push(block);
        return;
      }

      if (shouldNotUpdateFromFragmentBlock) {
        newBlockArr.push(block);
      } else {
        newBlockArr.push(updateHead(block, targetOffset, fragment));
      }

      // Insert fragment blocks after the head and before the tail.
      fragment
      // when we are updating the target block with the head fragment block we skip the first fragment
      // head since its contents have already been merged with the target block otherwise we include
      // the whole fragment
      .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {
        return newBlockArr.push(fragmentBlock);
      });

      // update tail
      newBlockArr.push(updateTail(block, targetOffset, fragment));
    });

    var updatedBlockMap = BlockMapBuilder_1.createFromArray(newBlockArr);

    if (isTreeBasedBlockMap) {
      updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);
    }

    return contentState.merge({
      blockMap: updatedBlockMap,
      selectionBefore: selectionState,
      selectionAfter: selectionState.merge({
        anchorKey: finalKey,
        anchorOffset: finalOffset,
        focusKey: finalKey,
        focusOffset: finalOffset,
        isBackward: false
      })
    });
  };

  var insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {
    !selectionState.isCollapsed() ? invariant_1(false) : void 0;

    var blockMap = contentState.getBlockMap();
    var fragment = randomizeBlockMapKeys_1(fragmentBlockMap);
    var targetKey = selectionState.getStartKey();
    var targetOffset = selectionState.getStartOffset();

    var targetBlock = blockMap.get(targetKey);

    if (targetBlock instanceof ContentBlockNode_1) {
      !targetBlock.getChildKeys().isEmpty() ? invariant_1(false) : void 0;
    }

    // When we insert a fragment with a single block we simply update the target block
    // with the contents of the inserted fragment block
    if (fragment.size === 1) {
      return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);
    }

    return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);
  };

  var insertFragmentIntoContentState_1 = insertFragmentIntoContentState;

  var Repeat$2 = immutable.Repeat;


  function insertTextIntoContentState(contentState, selectionState, text, characterMetadata) {
    !selectionState.isCollapsed() ? invariant_1(false) : void 0;

    var len = text.length;
    if (!len) {
      return contentState;
    }

    var blockMap = contentState.getBlockMap();
    var key = selectionState.getStartKey();
    var offset = selectionState.getStartOffset();
    var block = blockMap.get(key);
    var blockText = block.getText();

    var newBlock = block.merge({
      text: blockText.slice(0, offset) + text + blockText.slice(offset, block.getLength()),
      characterList: insertIntoList_1(block.getCharacterList(), Repeat$2(characterMetadata, len).toList(), offset)
    });

    var newOffset = offset + len;

    return contentState.merge({
      blockMap: blockMap.set(key, newBlock),
      selectionAfter: selectionState.merge({
        anchorOffset: newOffset,
        focusOffset: newOffset
      })
    });
  }

  var insertTextIntoContentState_1 = insertTextIntoContentState;

  var Map$5 = immutable.Map;


  function modifyBlockForContentState(contentState, selectionState, operation) {
    var startKey = selectionState.getStartKey();
    var endKey = selectionState.getEndKey();
    var blockMap = contentState.getBlockMap();
    var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {
      return k === startKey;
    }).takeUntil(function (_, k) {
      return k === endKey;
    }).concat(Map$5([[endKey, blockMap.get(endKey)]])).map(operation);

    return contentState.merge({
      blockMap: blockMap.merge(newBlocks),
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  }

  var modifyBlockForContentState_1 = modifyBlockForContentState;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule getNextDelimiterBlockKey
   * @format
   * 
   *
   * This is unstable and not part of the public API and should not be used by
   * production systems. This file may be update/removed without notice.
   */



  var getNextDelimiterBlockKey = function getNextDelimiterBlockKey(block, blockMap) {
    var isExperimentalTreeBlock = block instanceof ContentBlockNode_1;

    if (!isExperimentalTreeBlock) {
      return null;
    }

    var nextSiblingKey = block.getNextSiblingKey();

    if (nextSiblingKey) {
      return nextSiblingKey;
    }

    var parent = block.getParentKey();

    if (!parent) {
      return null;
    }

    var nextNonDescendantBlock = blockMap.get(parent);
    while (nextNonDescendantBlock && !nextNonDescendantBlock.getNextSiblingKey()) {
      var parentKey = nextNonDescendantBlock.getParentKey();
      nextNonDescendantBlock = parentKey ? blockMap.get(parentKey) : null;
    }

    if (!nextNonDescendantBlock) {
      return null;
    }

    return nextNonDescendantBlock.getNextSiblingKey();
  };

  var getNextDelimiterBlockKey_1 = getNextDelimiterBlockKey;

  var List$3 = immutable.List,
      Map$6 = immutable.Map;


  var transformBlock = function transformBlock(key, blockMap, func) {
    if (!key) {
      return;
    }

    var block = blockMap.get(key);

    if (!block) {
      return;
    }

    blockMap.set(key, func(block));
  };

  /**
   * Ancestors needs to be preserved when there are non selected
   * children to make sure we do not leave any orphans behind
   */
  var getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {
    var parents = [];

    if (!blockKey) {
      return parents;
    }

    var blockNode = blockMap.get(blockKey);
    while (blockNode && blockNode.getParentKey()) {
      var parentKey = blockNode.getParentKey();
      if (parentKey) {
        parents.push(parentKey);
      }
      blockNode = parentKey ? blockMap.get(parentKey) : null;
    }

    return parents;
  };

  /**
   * Get all next delimiter keys until we hit a root delimiter and return
   * an array of key references
   */
  var getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {
    var nextDelimiters = [];

    if (!block) {
      return nextDelimiters;
    }

    var nextDelimiter = getNextDelimiterBlockKey_1(block, blockMap);
    while (nextDelimiter && blockMap.get(nextDelimiter)) {
      var _block = blockMap.get(nextDelimiter);
      nextDelimiters.push(nextDelimiter);

      // we do not need to keep checking all root node siblings, just the first occurance
      nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey_1(_block, blockMap) : null;
    }

    return nextDelimiters;
  };

  var getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {
    if (!block) {
      return null;
    }

    // note that we need to make sure we refer to the original block since this
    // function is called within a withMutations
    var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();

    while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {
      nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;
    }

    return nextValidSiblingKey;
  };

  var getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {
    if (!block) {
      return null;
    }

    // note that we need to make sure we refer to the original block since this
    // function is called within a withMutations
    var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();

    while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {
      prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;
    }

    return prevValidSiblingKey;
  };

  var updateBlockMapLinks$1 = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {
    return blockMap.withMutations(function (blocks) {
      // update start block if its retained
      transformBlock(startBlock.getKey(), blocks, function (block) {
        return block.merge({
          nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(startBlock, blocks, originalBlockMap)
        });
      });

      // update endblock if its retained
      transformBlock(endBlock.getKey(), blocks, function (block) {
        return block.merge({
          nextSibling: getNextValidSibling(endBlock, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)
        });
      });

      // update start block parent ancestors
      getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {
        return transformBlock(parentKey, blocks, function (block) {
          return block.merge({
            children: block.getChildKeys().filter(function (key) {
              return blocks.get(key);
            }),
            nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
            prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
          });
        });
      });

      // update start block next - can only happen if startBlock == endBlock
      transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {
        return block.merge({
          prevSibling: startBlock.getPrevSiblingKey()
        });
      });

      // update start block prev
      transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {
        return block.merge({
          nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap)
        });
      });

      // update end block next
      transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {
        return block.merge({
          prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)
        });
      });

      // update end block prev
      transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {
        return block.merge({
          nextSibling: endBlock.getNextSiblingKey()
        });
      });

      // update end block parent ancestors
      getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {
        transformBlock(parentKey, blocks, function (block) {
          return block.merge({
            children: block.getChildKeys().filter(function (key) {
              return blocks.get(key);
            }),
            nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
            prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
          });
        });
      });

      // update next delimiters all the way to a root delimiter
      getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {
        return transformBlock(delimiterKey, blocks, function (block) {
          return block.merge({
            nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
            prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
          });
        });
      });
    });
  };

  var removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {
    if (selectionState.isCollapsed()) {
      return contentState;
    }

    var blockMap = contentState.getBlockMap();
    var startKey = selectionState.getStartKey();
    var startOffset = selectionState.getStartOffset();
    var endKey = selectionState.getEndKey();
    var endOffset = selectionState.getEndOffset();

    var startBlock = blockMap.get(startKey);
    var endBlock = blockMap.get(endKey);

    // we assume that ContentBlockNode and ContentBlocks are not mixed together
    var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode_1;

    // used to retain blocks that should not be deleted to avoid orphan children
    var parentAncestors = [];

    if (isExperimentalTreeBlock) {
      var endBlockchildrenKeys = endBlock.getChildKeys();
      var endBlockAncestors = getAncestorsKeys(endKey, blockMap);

      // endBlock has unselected sibblings so we can not remove its ancestors parents
      if (endBlock.getNextSiblingKey()) {
        parentAncestors = parentAncestors.concat(endBlockAncestors);
      }

      // endBlock has children so can not remove this block or any of its ancestors
      if (!endBlockchildrenKeys.isEmpty()) {
        parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));
      }

      // we need to retain all ancestors of the next delimiter block
      parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey_1(endBlock, blockMap), blockMap));
    }

    var characterList = void 0;

    if (startBlock === endBlock) {
      characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);
    } else {
      characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));
    }

    var modifiedStart = startBlock.merge({
      text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),
      characterList: characterList
    });

    var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {
      return k === startKey;
    }).takeUntil(function (_, k) {
      return k === endKey;
    }).filter(function (_, k) {
      return parentAncestors.indexOf(k) === -1;
    }).concat(Map$6([[endKey, null]])).map(function (_, k) {
      return k === startKey ? modifiedStart : null;
    });

    var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {
      return !!block;
    });

    if (isExperimentalTreeBlock) {
      updatedBlockMap = updateBlockMapLinks$1(updatedBlockMap, startBlock, endBlock, blockMap);
    }

    return contentState.merge({
      blockMap: updatedBlockMap,
      selectionBefore: selectionState,
      selectionAfter: selectionState.merge({
        anchorKey: startKey,
        anchorOffset: startOffset,
        focusKey: startKey,
        focusOffset: startOffset,
        isBackward: false
      })
    });
  };

  /**
   * Maintain persistence for target list when removing characters on the
   * head and tail of the character list.
   */
  var removeFromList = function removeFromList(targetList, startOffset, endOffset) {
    if (startOffset === 0) {
      while (startOffset < endOffset) {
        targetList = targetList.shift();
        startOffset++;
      }
    } else if (endOffset === targetList.count()) {
      while (endOffset > startOffset) {
        targetList = targetList.pop();
        endOffset--;
      }
    } else {
      var head = targetList.slice(0, startOffset);
      var tail = targetList.slice(endOffset);
      targetList = head.concat(tail).toList();
    }
    return targetList;
  };

  var removeRangeFromContentState_1 = removeRangeFromContentState;

  var List$4 = immutable.List,
      Map$7 = immutable.Map;


  var transformBlock$1 = function transformBlock(key, blockMap, func) {
    if (!key) {
      return;
    }

    var block = blockMap.get(key);

    if (!block) {
      return;
    }

    blockMap.set(key, func(block));
  };

  var updateBlockMapLinks$2 = function updateBlockMapLinks(blockMap, originalBlock, belowBlock) {
    return blockMap.withMutations(function (blocks) {
      var originalBlockKey = originalBlock.getKey();
      var belowBlockKey = belowBlock.getKey();

      // update block parent
      transformBlock$1(originalBlock.getParentKey(), blocks, function (block) {
        var parentChildrenList = block.getChildKeys();
        var insertionIndex = parentChildrenList.indexOf(originalBlockKey) + 1;
        var newChildrenArray = parentChildrenList.toArray();

        newChildrenArray.splice(insertionIndex, 0, belowBlockKey);

        return block.merge({
          children: List$4(newChildrenArray)
        });
      });

      // update original next block
      transformBlock$1(originalBlock.getNextSiblingKey(), blocks, function (block) {
        return block.merge({
          prevSibling: belowBlockKey
        });
      });

      // update original block
      transformBlock$1(originalBlockKey, blocks, function (block) {
        return block.merge({
          nextSibling: belowBlockKey
        });
      });

      // update below block
      transformBlock$1(belowBlockKey, blocks, function (block) {
        return block.merge({
          prevSibling: originalBlockKey
        });
      });
    });
  };

  var splitBlockInContentState = function splitBlockInContentState(contentState, selectionState) {
    !selectionState.isCollapsed() ? invariant_1(false) : void 0;

    var key = selectionState.getAnchorKey();
    var offset = selectionState.getAnchorOffset();
    var blockMap = contentState.getBlockMap();
    var blockToSplit = blockMap.get(key);
    var text = blockToSplit.getText();
    var chars = blockToSplit.getCharacterList();
    var keyBelow = generateRandomKey_1();
    var isExperimentalTreeBlock = blockToSplit instanceof ContentBlockNode_1;

    var blockAbove = blockToSplit.merge({
      text: text.slice(0, offset),
      characterList: chars.slice(0, offset)
    });
    var blockBelow = blockAbove.merge({
      key: keyBelow,
      text: text.slice(offset),
      characterList: chars.slice(offset),
      data: Map$7()
    });

    var blocksBefore = blockMap.toSeq().takeUntil(function (v) {
      return v === blockToSplit;
    });
    var blocksAfter = blockMap.toSeq().skipUntil(function (v) {
      return v === blockToSplit;
    }).rest();
    var newBlocks = blocksBefore.concat([[key, blockAbove], [keyBelow, blockBelow]], blocksAfter).toOrderedMap();

    if (isExperimentalTreeBlock) {
      !blockToSplit.getChildKeys().isEmpty() ? invariant_1(false) : void 0;

      newBlocks = updateBlockMapLinks$2(newBlocks, blockAbove, blockBelow);
    }

    return contentState.merge({
      blockMap: newBlocks,
      selectionBefore: selectionState,
      selectionAfter: selectionState.merge({
        anchorKey: keyBelow,
        anchorOffset: 0,
        focusKey: keyBelow,
        focusOffset: 0,
        isBackward: false
      })
    });
  };

  var splitBlockInContentState_1 = splitBlockInContentState;

  var OrderedSet$3 = immutable.OrderedSet;

  /**
   * `DraftModifier` provides a set of convenience methods that apply
   * modifications to a `ContentState` object based on a target `SelectionState`.
   *
   * Any change to a `ContentState` should be decomposable into a series of
   * transaction functions that apply the required changes and return output
   * `ContentState` objects.
   *
   * These functions encapsulate some of the most common transaction sequences.
   */

  var DraftModifier = {
    replaceText: function replaceText(contentState, rangeToReplace, text, inlineStyle, entityKey) {
      var withoutEntities = removeEntitiesAtEdges_1(contentState, rangeToReplace);
      var withoutText = removeRangeFromContentState_1(withoutEntities, rangeToReplace);

      var character = CharacterMetadata_1.create({
        style: inlineStyle || OrderedSet$3(),
        entity: entityKey || null
      });

      return insertTextIntoContentState_1(withoutText, withoutText.getSelectionAfter(), text, character);
    },

    insertText: function insertText(contentState, targetRange, text, inlineStyle, entityKey) {
      !targetRange.isCollapsed() ? invariant_1(false) : void 0;
      return DraftModifier.replaceText(contentState, targetRange, text, inlineStyle, entityKey);
    },

    moveText: function moveText(contentState, removalRange, targetRange) {
      var movedFragment = getContentStateFragment_1(contentState, removalRange);

      var afterRemoval = DraftModifier.removeRange(contentState, removalRange, 'backward');

      return DraftModifier.replaceWithFragment(afterRemoval, targetRange, movedFragment);
    },

    replaceWithFragment: function replaceWithFragment(contentState, targetRange, fragment) {
      var withoutEntities = removeEntitiesAtEdges_1(contentState, targetRange);
      var withoutText = removeRangeFromContentState_1(withoutEntities, targetRange);

      return insertFragmentIntoContentState_1(withoutText, withoutText.getSelectionAfter(), fragment);
    },

    removeRange: function removeRange(contentState, rangeToRemove, removalDirection) {
      var startKey = void 0,
          endKey = void 0,
          startBlock = void 0,
          endBlock = void 0;
      if (rangeToRemove.getIsBackward()) {
        rangeToRemove = rangeToRemove.merge({
          anchorKey: rangeToRemove.getFocusKey(),
          anchorOffset: rangeToRemove.getFocusOffset(),
          focusKey: rangeToRemove.getAnchorKey(),
          focusOffset: rangeToRemove.getAnchorOffset(),
          isBackward: false
        });
      }
      startKey = rangeToRemove.getAnchorKey();
      endKey = rangeToRemove.getFocusKey();
      startBlock = contentState.getBlockForKey(startKey);
      endBlock = contentState.getBlockForKey(endKey);
      var startOffset = rangeToRemove.getStartOffset();
      var endOffset = rangeToRemove.getEndOffset();

      var startEntityKey = startBlock.getEntityAt(startOffset);
      var endEntityKey = endBlock.getEntityAt(endOffset - 1);

      // Check whether the selection state overlaps with a single entity.
      // If so, try to remove the appropriate substring of the entity text.
      if (startKey === endKey) {
        if (startEntityKey && startEntityKey === endEntityKey) {
          var _adjustedRemovalRange = getCharacterRemovalRange_1(contentState.getEntityMap(), startBlock, endBlock, rangeToRemove, removalDirection);
          return removeRangeFromContentState_1(contentState, _adjustedRemovalRange);
        }
      }
      var adjustedRemovalRange = rangeToRemove;

      var withoutEntities = removeEntitiesAtEdges_1(contentState, adjustedRemovalRange);
      return removeRangeFromContentState_1(withoutEntities, adjustedRemovalRange);
    },

    splitBlock: function splitBlock(contentState, selectionState) {
      var withoutEntities = removeEntitiesAtEdges_1(contentState, selectionState);
      var withoutText = removeRangeFromContentState_1(withoutEntities, selectionState);

      return splitBlockInContentState_1(withoutText, withoutText.getSelectionAfter());
    },

    applyInlineStyle: function applyInlineStyle(contentState, selectionState, inlineStyle) {
      return ContentStateInlineStyle_1.add(contentState, selectionState, inlineStyle);
    },

    removeInlineStyle: function removeInlineStyle(contentState, selectionState, inlineStyle) {
      return ContentStateInlineStyle_1.remove(contentState, selectionState, inlineStyle);
    },

    setBlockType: function setBlockType(contentState, selectionState, blockType) {
      return modifyBlockForContentState_1(contentState, selectionState, function (block) {
        return block.merge({ type: blockType, depth: 0 });
      });
    },

    setBlockData: function setBlockData(contentState, selectionState, blockData) {
      return modifyBlockForContentState_1(contentState, selectionState, function (block) {
        return block.merge({ data: blockData });
      });
    },

    mergeBlockData: function mergeBlockData(contentState, selectionState, blockData) {
      return modifyBlockForContentState_1(contentState, selectionState, function (block) {
        return block.merge({ data: block.getData().merge(blockData) });
      });
    },

    applyEntity: function applyEntity(contentState, selectionState, entityKey) {
      var withoutEntities = removeEntitiesAtEdges_1(contentState, selectionState);
      return applyEntityToContentState_1(withoutEntities, selectionState, entityKey);
    }
  };

  var DraftModifier_1 = DraftModifier;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }

  /**
   * This function accepts and discards inputs; it has no side effects. This is
   * primarily useful idiomatically for overridable function endpoints which
   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
   */
  var emptyFunction = function emptyFunction() {};

  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function () {
    return this;
  };
  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };

  var emptyFunction_1 = emptyFunction;

  var List$5 = immutable.List,
      Repeat$3 = immutable.Repeat,
      Record$3 = immutable.Record;


  var returnTrue = emptyFunction_1.thatReturnsTrue;

  var FINGERPRINT_DELIMITER = '-';

  var defaultLeafRange = {
    start: null,
    end: null
  };

  var LeafRange = Record$3(defaultLeafRange);

  var defaultDecoratorRange = {
    start: null,
    end: null,
    decoratorKey: null,
    leaves: null
  };

  var DecoratorRange = Record$3(defaultDecoratorRange);

  var BlockTree = {
    /**
     * Generate a block tree for a given ContentBlock/decorator pair.
     */
    generate: function generate(contentState, block, decorator) {
      var textLength = block.getLength();
      if (!textLength) {
        return List$5.of(new DecoratorRange({
          start: 0,
          end: 0,
          decoratorKey: null,
          leaves: List$5.of(new LeafRange({ start: 0, end: 0 }))
        }));
      }

      var leafSets = [];
      var decorations = decorator ? decorator.getDecorations(block, contentState) : List$5(Repeat$3(null, textLength));

      var chars = block.getCharacterList();

      findRangesImmutable_1(decorations, areEqual, returnTrue, function (start, end) {
        leafSets.push(new DecoratorRange({
          start: start,
          end: end,
          decoratorKey: decorations.get(start),
          leaves: generateLeaves(chars.slice(start, end).toList(), start)
        }));
      });

      return List$5(leafSets);
    },

    /**
     * Create a string representation of the given tree map. This allows us
     * to rapidly determine whether a tree has undergone a significant
     * structural change.
     */
    getFingerprint: function getFingerprint(tree) {
      return tree.map(function (leafSet) {
        var decoratorKey = leafSet.get('decoratorKey');
        var fingerprintString = decoratorKey !== null ? decoratorKey + '.' + (leafSet.get('end') - leafSet.get('start')) : '';
        return '' + fingerprintString + '.' + leafSet.get('leaves').size;
      }).join(FINGERPRINT_DELIMITER);
    }
  };

  /**
   * Generate LeafRange records for a given character list.
   */
  function generateLeaves(characters, offset) {
    var leaves = [];
    var inlineStyles = characters.map(function (c) {
      return c.getStyle();
    }).toList();
    findRangesImmutable_1(inlineStyles, areEqual, returnTrue, function (start, end) {
      leaves.push(new LeafRange({
        start: start + offset,
        end: end + offset
      }));
    });
    return List$5(leaves);
  }

  function areEqual(a, b) {
    return a === b;
  }

  var BlockTree_1 = BlockTree;

  function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$4(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



  var Record$4 = immutable.Record;


  var DraftEntityInstanceRecord = Record$4({
    type: 'TOKEN',
    mutability: 'IMMUTABLE',
    data: Object
  });

  /**
   * An instance of a document entity, consisting of a `type` and relevant
   * `data`, metadata about the entity.
   *
   * For instance, a "link" entity might provide a URI, and a "mention"
   * entity might provide the mentioned user's ID. These pieces of data
   * may be used when rendering the entity as part of a ContentBlock DOM
   * representation. For a link, the data would be used as an href for
   * the rendered anchor. For a mention, the ID could be used to retrieve
   * a hovercard.
   */

  var DraftEntityInstance = function (_DraftEntityInstanceR) {
    _inherits$4(DraftEntityInstance, _DraftEntityInstanceR);

    function DraftEntityInstance() {
      _classCallCheck$4(this, DraftEntityInstance);

      return _possibleConstructorReturn$4(this, _DraftEntityInstanceR.apply(this, arguments));
    }

    DraftEntityInstance.prototype.getType = function getType() {
      return this.get('type');
    };

    DraftEntityInstance.prototype.getMutability = function getMutability() {
      return this.get('mutability');
    };

    DraftEntityInstance.prototype.getData = function getData() {
      return this.get('data');
    };

    return DraftEntityInstance;
  }(DraftEntityInstanceRecord);

  var DraftEntityInstance_1 = DraftEntityInstance;

  var _extends = objectAssign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule DraftEntity
   * @format
   * 
   */






  var Map$8 = immutable.Map;


  var instances = Map$8();
  var instanceKey = 0;

  /**
   * Temporary utility for generating the warnings
   */
  function logWarning(oldMethodCall, newMethodCall) {
    console.warn('WARNING: ' + oldMethodCall + ' will be deprecated soon!\nPlease use "' + newMethodCall + '" instead.');
  }

  /**
   * A "document entity" is an object containing metadata associated with a
   * piece of text in a ContentBlock.
   *
   * For example, a `link` entity might include a `uri` property. When a
   * ContentBlock is rendered in the browser, text that refers to that link
   * entity may be rendered as an anchor, with the `uri` as the href value.
   *
   * In a ContentBlock, every position in the text may correspond to zero
   * or one entities. This correspondence is tracked using a key string,
   * generated via DraftEntity.create() and used to obtain entity metadata
   * via DraftEntity.get().
   */
  var DraftEntity = {
    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.getLastCreatedEntityKey' instead.
     * ---
     * Get the random key string from whatever entity was last created.
     * We need this to support the new API, as part of transitioning to put Entity
     * storage in contentState.
     */
    getLastCreatedEntityKey: function getLastCreatedEntityKey() {
      logWarning('DraftEntity.getLastCreatedEntityKey', 'contentState.getLastCreatedEntityKey');
      return DraftEntity.__getLastCreatedEntityKey();
    },

    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.createEntity' instead.
     * ---
     * Create a DraftEntityInstance and store it for later retrieval.
     *
     * A random key string will be generated and returned. This key may
     * be used to track the entity's usage in a ContentBlock, and for
     * retrieving data about the entity at render time.
     */
    create: function create(type, mutability, data) {
      logWarning('DraftEntity.create', 'contentState.createEntity');
      return DraftEntity.__create(type, mutability, data);
    },

    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.addEntity' instead.
     * ---
     * Add an existing DraftEntityInstance to the DraftEntity map. This is
     * useful when restoring instances from the server.
     */
    add: function add(instance) {
      logWarning('DraftEntity.add', 'contentState.addEntity');
      return DraftEntity.__add(instance);
    },

    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.getEntity' instead.
     * ---
     * Retrieve the entity corresponding to the supplied key string.
     */
    get: function get(key) {
      logWarning('DraftEntity.get', 'contentState.getEntity');
      return DraftEntity.__get(key);
    },

    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.mergeEntityData' instead.
     * ---
     * Entity instances are immutable. If you need to update the data for an
     * instance, this method will merge your data updates and return a new
     * instance.
     */
    mergeData: function mergeData(key, toMerge) {
      logWarning('DraftEntity.mergeData', 'contentState.mergeEntityData');
      return DraftEntity.__mergeData(key, toMerge);
    },

    /**
     * WARNING: This method will be deprecated soon!
     * Please use 'contentState.replaceEntityData' instead.
     * ---
     * Completely replace the data for a given instance.
     */
    replaceData: function replaceData(key, newData) {
      logWarning('DraftEntity.replaceData', 'contentState.replaceEntityData');
      return DraftEntity.__replaceData(key, newData);
    },

    // ***********************************WARNING******************************
    // --- the above public API will be deprecated in the next version of Draft!
    // The methods below this line are private - don't call them directly.

    /**
     * Get the random key string from whatever entity was last created.
     * We need this to support the new API, as part of transitioning to put Entity
     * storage in contentState.
     */
    __getLastCreatedEntityKey: function __getLastCreatedEntityKey() {
      return '' + instanceKey;
    },

    /**
     * Create a DraftEntityInstance and store it for later retrieval.
     *
     * A random key string will be generated and returned. This key may
     * be used to track the entity's usage in a ContentBlock, and for
     * retrieving data about the entity at render time.
     */
    __create: function __create(type, mutability, data) {
      return DraftEntity.__add(new DraftEntityInstance_1({ type: type, mutability: mutability, data: data || {} }));
    },

    /**
     * Add an existing DraftEntityInstance to the DraftEntity map. This is
     * useful when restoring instances from the server.
     */
    __add: function __add(instance) {
      var key = '' + ++instanceKey;
      instances = instances.set(key, instance);
      return key;
    },

    /**
     * Retrieve the entity corresponding to the supplied key string.
     */
    __get: function __get(key) {
      var instance = instances.get(key);
      !!!instance ? invariant_1(false) : void 0;
      return instance;
    },

    /**
     * Entity instances are immutable. If you need to update the data for an
     * instance, this method will merge your data updates and return a new
     * instance.
     */
    __mergeData: function __mergeData(key, toMerge) {
      var instance = DraftEntity.__get(key);
      var newData = _extends({}, instance.getData(), toMerge);
      var newInstance = instance.set('data', newData);
      instances = instances.set(key, newInstance);
      return newInstance;
    },

    /**
     * Completely replace the data for a given instance.
     */
    __replaceData: function __replaceData(key, newData) {
      var instance = DraftEntity.__get(key);
      var newInstance = instance.set('data', newData);
      instances = instances.set(key, newInstance);
      return newInstance;
    }
  };

  var DraftEntity_1 = DraftEntity;

  function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$5(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$5(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



  var Record$5 = immutable.Record;


  var defaultRecord$3 = {
    anchorKey: '',
    anchorOffset: 0,
    focusKey: '',
    focusOffset: 0,
    isBackward: false,
    hasFocus: false
  };

  var SelectionStateRecord = Record$5(defaultRecord$3);

  var SelectionState = function (_SelectionStateRecord) {
    _inherits$5(SelectionState, _SelectionStateRecord);

    function SelectionState() {
      _classCallCheck$5(this, SelectionState);

      return _possibleConstructorReturn$5(this, _SelectionStateRecord.apply(this, arguments));
    }

    SelectionState.prototype.serialize = function serialize() {
      return 'Anchor: ' + this.getAnchorKey() + ':' + this.getAnchorOffset() + ', ' + 'Focus: ' + this.getFocusKey() + ':' + this.getFocusOffset() + ', ' + 'Is Backward: ' + String(this.getIsBackward()) + ', ' + 'Has Focus: ' + String(this.getHasFocus());
    };

    SelectionState.prototype.getAnchorKey = function getAnchorKey() {
      return this.get('anchorKey');
    };

    SelectionState.prototype.getAnchorOffset = function getAnchorOffset() {
      return this.get('anchorOffset');
    };

    SelectionState.prototype.getFocusKey = function getFocusKey() {
      return this.get('focusKey');
    };

    SelectionState.prototype.getFocusOffset = function getFocusOffset() {
      return this.get('focusOffset');
    };

    SelectionState.prototype.getIsBackward = function getIsBackward() {
      return this.get('isBackward');
    };

    SelectionState.prototype.getHasFocus = function getHasFocus() {
      return this.get('hasFocus');
    };

    /**
     * Return whether the specified range overlaps with an edge of the
     * SelectionState.
     */


    SelectionState.prototype.hasEdgeWithin = function hasEdgeWithin(blockKey, start, end) {
      var anchorKey = this.getAnchorKey();
      var focusKey = this.getFocusKey();

      if (anchorKey === focusKey && anchorKey === blockKey) {
        var selectionStart = this.getStartOffset();
        var selectionEnd = this.getEndOffset();
        return start <= selectionEnd && selectionStart <= end;
      }

      if (blockKey !== anchorKey && blockKey !== focusKey) {
        return false;
      }

      var offsetToCheck = blockKey === anchorKey ? this.getAnchorOffset() : this.getFocusOffset();

      return start <= offsetToCheck && end >= offsetToCheck;
    };

    SelectionState.prototype.isCollapsed = function isCollapsed() {
      return this.getAnchorKey() === this.getFocusKey() && this.getAnchorOffset() === this.getFocusOffset();
    };

    SelectionState.prototype.getStartKey = function getStartKey() {
      return this.getIsBackward() ? this.getFocusKey() : this.getAnchorKey();
    };

    SelectionState.prototype.getStartOffset = function getStartOffset() {
      return this.getIsBackward() ? this.getFocusOffset() : this.getAnchorOffset();
    };

    SelectionState.prototype.getEndKey = function getEndKey() {
      return this.getIsBackward() ? this.getAnchorKey() : this.getFocusKey();
    };

    SelectionState.prototype.getEndOffset = function getEndOffset() {
      return this.getIsBackward() ? this.getAnchorOffset() : this.getFocusOffset();
    };

    SelectionState.createEmpty = function createEmpty(key) {
      return new SelectionState({
        anchorKey: key,
        anchorOffset: 0,
        focusKey: key,
        focusOffset: 0,
        isBackward: false,
        hasFocus: false
      });
    };

    return SelectionState;
  }(SelectionStateRecord);

  var SelectionState_1 = SelectionState;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule sanitizeDraftText
   * @format
   * 
   */

  var REGEX_BLOCK_DELIMITER = new RegExp('\r', 'g');

  function sanitizeDraftText(input) {
    return input.replace(REGEX_BLOCK_DELIMITER, '');
  }

  var sanitizeDraftText_1 = sanitizeDraftText;

  function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$6(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$6(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }













  var List$6 = immutable.List,
      Record$6 = immutable.Record,
      Repeat$4 = immutable.Repeat;

  var defaultRecord$4 = {
    entityMap: null,
    blockMap: null,
    selectionBefore: null,
    selectionAfter: null
  };

  var ContentBlockNodeRecord = ContentBlock_1;

  var ContentStateRecord = Record$6(defaultRecord$4);

  var ContentState = function (_ContentStateRecord) {
    _inherits$6(ContentState, _ContentStateRecord);

    function ContentState() {
      _classCallCheck$6(this, ContentState);

      return _possibleConstructorReturn$6(this, _ContentStateRecord.apply(this, arguments));
    }

    ContentState.prototype.getEntityMap = function getEntityMap() {
      // TODO: update this when we fully remove DraftEntity
      return DraftEntity_1;
    };

    ContentState.prototype.getBlockMap = function getBlockMap() {
      return this.get('blockMap');
    };

    ContentState.prototype.getSelectionBefore = function getSelectionBefore() {
      return this.get('selectionBefore');
    };

    ContentState.prototype.getSelectionAfter = function getSelectionAfter() {
      return this.get('selectionAfter');
    };

    ContentState.prototype.getBlockForKey = function getBlockForKey(key) {
      var block = this.getBlockMap().get(key);
      return block;
    };

    ContentState.prototype.getKeyBefore = function getKeyBefore(key) {
      return this.getBlockMap().reverse().keySeq().skipUntil(function (v) {
        return v === key;
      }).skip(1).first();
    };

    ContentState.prototype.getKeyAfter = function getKeyAfter(key) {
      return this.getBlockMap().keySeq().skipUntil(function (v) {
        return v === key;
      }).skip(1).first();
    };

    ContentState.prototype.getBlockAfter = function getBlockAfter(key) {
      return this.getBlockMap().skipUntil(function (_, k) {
        return k === key;
      }).skip(1).first();
    };

    ContentState.prototype.getBlockBefore = function getBlockBefore(key) {
      return this.getBlockMap().reverse().skipUntil(function (_, k) {
        return k === key;
      }).skip(1).first();
    };

    ContentState.prototype.getBlocksAsArray = function getBlocksAsArray() {
      return this.getBlockMap().toArray();
    };

    ContentState.prototype.getFirstBlock = function getFirstBlock() {
      return this.getBlockMap().first();
    };

    ContentState.prototype.getLastBlock = function getLastBlock() {
      return this.getBlockMap().last();
    };

    ContentState.prototype.getPlainText = function getPlainText(delimiter) {
      return this.getBlockMap().map(function (block) {
        return block ? block.getText() : '';
      }).join(delimiter || '\n');
    };

    ContentState.prototype.getLastCreatedEntityKey = function getLastCreatedEntityKey() {
      // TODO: update this when we fully remove DraftEntity
      return DraftEntity_1.__getLastCreatedEntityKey();
    };

    ContentState.prototype.hasText = function hasText() {
      var blockMap = this.getBlockMap();
      return blockMap.size > 1 || blockMap.first().getLength() > 0;
    };

    ContentState.prototype.createEntity = function createEntity(type, mutability, data) {
      // TODO: update this when we fully remove DraftEntity
      DraftEntity_1.__create(type, mutability, data);
      return this;
    };

    ContentState.prototype.mergeEntityData = function mergeEntityData(key, toMerge) {
      // TODO: update this when we fully remove DraftEntity
      DraftEntity_1.__mergeData(key, toMerge);
      return this;
    };

    ContentState.prototype.replaceEntityData = function replaceEntityData(key, newData) {
      // TODO: update this when we fully remove DraftEntity
      DraftEntity_1.__replaceData(key, newData);
      return this;
    };

    ContentState.prototype.addEntity = function addEntity(instance) {
      // TODO: update this when we fully remove DraftEntity
      DraftEntity_1.__add(instance);
      return this;
    };

    ContentState.prototype.getEntity = function getEntity(key) {
      // TODO: update this when we fully remove DraftEntity
      return DraftEntity_1.__get(key);
    };

    ContentState.createFromBlockArray = function createFromBlockArray(
    // TODO: update flow type when we completely deprecate the old entity API
    blocks, entityMap) {
      // TODO: remove this when we completely deprecate the old entity API
      var theBlocks = Array.isArray(blocks) ? blocks : blocks.contentBlocks;
      var blockMap = BlockMapBuilder_1.createFromArray(theBlocks);
      var selectionState = blockMap.isEmpty() ? new SelectionState_1() : SelectionState_1.createEmpty(blockMap.first().getKey());
      return new ContentState({
        blockMap: blockMap,
        entityMap: entityMap || DraftEntity_1,
        selectionBefore: selectionState,
        selectionAfter: selectionState
      });
    };

    ContentState.createFromText = function createFromText(text) {
      var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\r\n?|\n/g;

      var strings = text.split(delimiter);
      var blocks = strings.map(function (block) {
        block = sanitizeDraftText_1(block);
        return new ContentBlockNodeRecord({
          key: generateRandomKey_1(),
          text: block,
          type: 'unstyled',
          characterList: List$6(Repeat$4(CharacterMetadata_1.EMPTY, block.length))
        });
      });
      return ContentState.createFromBlockArray(blocks);
    };

    return ContentState;
  }(ContentStateRecord);

  var ContentState_1 = ContentState;

  var NEUTRAL = 'NEUTRAL'; // No strong direction
  var LTR = 'LTR'; // Left-to-Right direction
  var RTL = 'RTL'; // Right-to-Left direction

  var globalDir = null;

  // == Helpers ==

  /**
   * Check if a directionality value is a Strong one
   */
  function isStrong(dir) {
    return dir === LTR || dir === RTL;
  }

  /**
   * Get string value to be used for `dir` HTML attribute or `direction` CSS
   * property.
   */
  function getHTMLDir(dir) {
    !isStrong(dir) ? invariant_1(false) : void 0;
    return dir === LTR ? 'ltr' : 'rtl';
  }

  /**
   * Get string value to be used for `dir` HTML attribute or `direction` CSS
   * property, but returns null if `dir` has same value as `otherDir`.
   * `null`.
   */
  function getHTMLDirIfDifferent(dir, otherDir) {
    !isStrong(dir) ? invariant_1(false) : void 0;
    !isStrong(otherDir) ? invariant_1(false) : void 0;
    return dir === otherDir ? null : getHTMLDir(dir);
  }

  // == Global Direction ==

  /**
   * Set the global direction.
   */
  function setGlobalDir(dir) {
    globalDir = dir;
  }

  /**
   * Initialize the global direction
   */
  function initGlobalDir() {
    setGlobalDir(LTR);
  }

  /**
   * Get the global direction
   */
  function getGlobalDir() {
    if (!globalDir) {
      this.initGlobalDir();
    }
    !globalDir ? invariant_1(false) : void 0;
    return globalDir;
  }

  var UnicodeBidiDirection = {
    // Values
    NEUTRAL: NEUTRAL,
    LTR: LTR,
    RTL: RTL,
    // Helpers
    isStrong: isStrong,
    getHTMLDir: getHTMLDir,
    getHTMLDirIfDifferent: getHTMLDirIfDifferent,
    // Global Direction
    setGlobalDir: setGlobalDir,
    initGlobalDir: initGlobalDir,
    getGlobalDir: getGlobalDir
  };

  var UnicodeBidiDirection_1 = UnicodeBidiDirection;

  /**
   * RegExp ranges of characters with a *Strong* Bidi_Class value.
   *
   * Data is based on DerivedBidiClass.txt in UCD version 7.0.0.
   *
   * NOTE: For performance reasons, we only support Unicode's
   *       Basic Multilingual Plane (BMP) for now.
   */
  var RANGE_BY_BIDI_TYPE = {

    L: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u01BA\u01BB' + '\u01BC-\u01BF\u01C0-\u01C3\u01C4-\u0293\u0294\u0295-\u02AF\u02B0-\u02B8' + '\u02BB-\u02C1\u02D0-\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376-\u0377' + '\u037A\u037B-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1' + '\u03A3-\u03F5\u03F7-\u0481\u0482\u048A-\u052F\u0531-\u0556\u0559' + '\u055A-\u055F\u0561-\u0587\u0589\u0903\u0904-\u0939\u093B\u093D' + '\u093E-\u0940\u0949-\u094C\u094E-\u094F\u0950\u0958-\u0961\u0964-\u0965' + '\u0966-\u096F\u0970\u0971\u0972-\u0980\u0982-\u0983\u0985-\u098C' + '\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD' + '\u09BE-\u09C0\u09C7-\u09C8\u09CB-\u09CC\u09CE\u09D7\u09DC-\u09DD' + '\u09DF-\u09E1\u09E6-\u09EF\u09F0-\u09F1\u09F4-\u09F9\u09FA\u0A03' + '\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33' + '\u0A35-\u0A36\u0A38-\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F' + '\u0A72-\u0A74\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0' + '\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0ABE-\u0AC0\u0AC9\u0ACB-\u0ACC\u0AD0' + '\u0AE0-\u0AE1\u0AE6-\u0AEF\u0AF0\u0B02-\u0B03\u0B05-\u0B0C\u0B0F-\u0B10' + '\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40' + '\u0B47-\u0B48\u0B4B-\u0B4C\u0B57\u0B5C-\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F' + '\u0B70\u0B71\u0B72-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95' + '\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9' + '\u0BBE-\u0BBF\u0BC1-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7' + '\u0BE6-\u0BEF\u0BF0-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10' + '\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C59\u0C60-\u0C61' + '\u0C66-\u0C6F\u0C7F\u0C82-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8' + '\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CBE\u0CBF\u0CC0-\u0CC4\u0CC6' + '\u0CC7-\u0CC8\u0CCA-\u0CCB\u0CD5-\u0CD6\u0CDE\u0CE0-\u0CE1\u0CE6-\u0CEF' + '\u0CF1-\u0CF2\u0D02-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D' + '\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D57\u0D60-\u0D61' + '\u0D66-\u0D6F\u0D70-\u0D75\u0D79\u0D7A-\u0D7F\u0D82-\u0D83\u0D85-\u0D96' + '\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF' + '\u0DE6-\u0DEF\u0DF2-\u0DF3\u0DF4\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E45' + '\u0E46\u0E4F\u0E50-\u0E59\u0E5A-\u0E5B\u0E81-\u0E82\u0E84\u0E87-\u0E88' + '\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7' + '\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6' + '\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F01-\u0F03\u0F04-\u0F12\u0F13\u0F14' + '\u0F15-\u0F17\u0F1A-\u0F1F\u0F20-\u0F29\u0F2A-\u0F33\u0F34\u0F36\u0F38' + '\u0F3E-\u0F3F\u0F40-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C' + '\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FCF\u0FD0-\u0FD4\u0FD5-\u0FD8' + '\u0FD9-\u0FDA\u1000-\u102A\u102B-\u102C\u1031\u1038\u103B-\u103C\u103F' + '\u1040-\u1049\u104A-\u104F\u1050-\u1055\u1056-\u1057\u105A-\u105D\u1061' + '\u1062-\u1064\u1065-\u1066\u1067-\u106D\u106E-\u1070\u1075-\u1081' + '\u1083-\u1084\u1087-\u108C\u108E\u108F\u1090-\u1099\u109A-\u109C' + '\u109E-\u109F\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FB\u10FC' + '\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288' + '\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5' + '\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u1368' + '\u1369-\u137C\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166D-\u166E' + '\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EB-\u16ED\u16EE-\u16F0' + '\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1735-\u1736' + '\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5' + '\u17C7-\u17C8\u17D4-\u17D6\u17D7\u17D8-\u17DA\u17DC\u17E0-\u17E9' + '\u1810-\u1819\u1820-\u1842\u1843\u1844-\u1877\u1880-\u18A8\u18AA' + '\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930-\u1931' + '\u1933-\u1938\u1946-\u194F\u1950-\u196D\u1970-\u1974\u1980-\u19AB' + '\u19B0-\u19C0\u19C1-\u19C7\u19C8-\u19C9\u19D0-\u19D9\u19DA\u1A00-\u1A16' + '\u1A19-\u1A1A\u1A1E-\u1A1F\u1A20-\u1A54\u1A55\u1A57\u1A61\u1A63-\u1A64' + '\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AA6\u1AA7\u1AA8-\u1AAD' + '\u1B04\u1B05-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B44\u1B45-\u1B4B' + '\u1B50-\u1B59\u1B5A-\u1B60\u1B61-\u1B6A\u1B74-\u1B7C\u1B82\u1B83-\u1BA0' + '\u1BA1\u1BA6-\u1BA7\u1BAA\u1BAE-\u1BAF\u1BB0-\u1BB9\u1BBA-\u1BE5\u1BE7' + '\u1BEA-\u1BEC\u1BEE\u1BF2-\u1BF3\u1BFC-\u1BFF\u1C00-\u1C23\u1C24-\u1C2B' + '\u1C34-\u1C35\u1C3B-\u1C3F\u1C40-\u1C49\u1C4D-\u1C4F\u1C50-\u1C59' + '\u1C5A-\u1C77\u1C78-\u1C7D\u1C7E-\u1C7F\u1CC0-\u1CC7\u1CD3\u1CE1' + '\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF2-\u1CF3\u1CF5-\u1CF6\u1D00-\u1D2B' + '\u1D2C-\u1D6A\u1D6B-\u1D77\u1D78\u1D79-\u1D9A\u1D9B-\u1DBF\u1E00-\u1F15' + '\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D' + '\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC' + '\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E' + '\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D' + '\u2124\u2126\u2128\u212A-\u212D\u212F-\u2134\u2135-\u2138\u2139' + '\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2182\u2183-\u2184' + '\u2185-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF' + '\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C7B\u2C7C-\u2C7D\u2C7E-\u2CE4' + '\u2CEB-\u2CEE\u2CF2-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F' + '\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE' + '\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005\u3006\u3007' + '\u3021-\u3029\u302E-\u302F\u3031-\u3035\u3038-\u303A\u303B\u303C' + '\u3041-\u3096\u309D-\u309E\u309F\u30A1-\u30FA\u30FC-\u30FE\u30FF' + '\u3105-\u312D\u3131-\u318E\u3190-\u3191\u3192-\u3195\u3196-\u319F' + '\u31A0-\u31BA\u31F0-\u31FF\u3200-\u321C\u3220-\u3229\u322A-\u3247' + '\u3248-\u324F\u3260-\u327B\u327F\u3280-\u3289\u328A-\u32B0\u32C0-\u32CB' + '\u32D0-\u32FE\u3300-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DB5' + '\u4E00-\u9FCC\uA000-\uA014\uA015\uA016-\uA48C\uA4D0-\uA4F7\uA4F8-\uA4FD' + '\uA4FE-\uA4FF\uA500-\uA60B\uA60C\uA610-\uA61F\uA620-\uA629\uA62A-\uA62B' + '\uA640-\uA66D\uA66E\uA680-\uA69B\uA69C-\uA69D\uA6A0-\uA6E5\uA6E6-\uA6EF' + '\uA6F2-\uA6F7\uA722-\uA76F\uA770\uA771-\uA787\uA789-\uA78A\uA78B-\uA78E' + '\uA790-\uA7AD\uA7B0-\uA7B1\uA7F7\uA7F8-\uA7F9\uA7FA\uA7FB-\uA801' + '\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA823-\uA824\uA827\uA830-\uA835' + '\uA836-\uA837\uA840-\uA873\uA880-\uA881\uA882-\uA8B3\uA8B4-\uA8C3' + '\uA8CE-\uA8CF\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8F8-\uA8FA\uA8FB\uA900-\uA909' + '\uA90A-\uA925\uA92E-\uA92F\uA930-\uA946\uA952-\uA953\uA95F\uA960-\uA97C' + '\uA983\uA984-\uA9B2\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uA9C0\uA9C1-\uA9CD' + '\uA9CF\uA9D0-\uA9D9\uA9DE-\uA9DF\uA9E0-\uA9E4\uA9E6\uA9E7-\uA9EF' + '\uA9F0-\uA9F9\uA9FA-\uA9FE\uAA00-\uAA28\uAA2F-\uAA30\uAA33-\uAA34' + '\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F\uAA60-\uAA6F' + '\uAA70\uAA71-\uAA76\uAA77-\uAA79\uAA7A\uAA7B\uAA7D\uAA7E-\uAAAF\uAAB1' + '\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADC\uAADD\uAADE-\uAADF' + '\uAAE0-\uAAEA\uAAEB\uAAEE-\uAAEF\uAAF0-\uAAF1\uAAF2\uAAF3-\uAAF4\uAAF5' + '\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E' + '\uAB30-\uAB5A\uAB5B\uAB5C-\uAB5F\uAB64-\uAB65\uABC0-\uABE2\uABE3-\uABE4' + '\uABE6-\uABE7\uABE9-\uABEA\uABEB\uABEC\uABF0-\uABF9\uAC00-\uD7A3' + '\uD7B0-\uD7C6\uD7CB-\uD7FB\uE000-\uF8FF\uF900-\uFA6D\uFA70-\uFAD9' + '\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFF6F\uFF70' + '\uFF71-\uFF9D\uFF9E-\uFF9F\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF' + '\uFFD2-\uFFD7\uFFDA-\uFFDC',

    R: '\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05D0-\u05EA\u05EB-\u05EF' + '\u05F0-\u05F2\u05F3-\u05F4\u05F5-\u05FF\u07C0-\u07C9\u07CA-\u07EA' + '\u07F4-\u07F5\u07FA\u07FB-\u07FF\u0800-\u0815\u081A\u0824\u0828' + '\u082E-\u082F\u0830-\u083E\u083F\u0840-\u0858\u085C-\u085D\u085E' + '\u085F-\u089F\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB37\uFB38-\uFB3C' + '\uFB3D\uFB3E\uFB3F\uFB40-\uFB41\uFB42\uFB43-\uFB44\uFB45\uFB46-\uFB4F',

    AL: '\u0608\u060B\u060D\u061B\u061C\u061D\u061E-\u061F\u0620-\u063F\u0640' + '\u0641-\u064A\u066D\u066E-\u066F\u0671-\u06D3\u06D4\u06D5\u06E5-\u06E6' + '\u06EE-\u06EF\u06FA-\u06FC\u06FD-\u06FE\u06FF\u0700-\u070D\u070E\u070F' + '\u0710\u0712-\u072F\u074B-\u074C\u074D-\u07A5\u07B1\u07B2-\u07BF' + '\u08A0-\u08B2\u08B3-\u08E3\uFB50-\uFBB1\uFBB2-\uFBC1\uFBC2-\uFBD2' + '\uFBD3-\uFD3D\uFD40-\uFD4F\uFD50-\uFD8F\uFD90-\uFD91\uFD92-\uFDC7' + '\uFDC8-\uFDCF\uFDF0-\uFDFB\uFDFC\uFDFE-\uFDFF\uFE70-\uFE74\uFE75' + '\uFE76-\uFEFC\uFEFD-\uFEFE'

  };

  var REGEX_STRONG = new RegExp('[' + RANGE_BY_BIDI_TYPE.L + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + ']');

  var REGEX_RTL = new RegExp('[' + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + ']');

  /**
   * Returns the first strong character (has Bidi_Class value of L, R, or AL).
   *
   * @param str  A text block; e.g. paragraph, table cell, tag
   * @return     A character with strong bidi direction, or null if not found
   */
  function firstStrongChar(str) {
    var match = REGEX_STRONG.exec(str);
    return match == null ? null : match[0];
  }

  /**
   * Returns the direction of a block of text, based on the direction of its
   * first strong character (has Bidi_Class value of L, R, or AL).
   *
   * @param str  A text block; e.g. paragraph, table cell, tag
   * @return     The resolved direction
   */
  function firstStrongCharDir(str) {
    var strongChar = firstStrongChar(str);
    if (strongChar == null) {
      return UnicodeBidiDirection_1.NEUTRAL;
    }
    return REGEX_RTL.exec(strongChar) ? UnicodeBidiDirection_1.RTL : UnicodeBidiDirection_1.LTR;
  }

  /**
   * Returns the direction of a block of text, based on the direction of its
   * first strong character (has Bidi_Class value of L, R, or AL), or a fallback
   * direction, if no strong character is found.
   *
   * This function is supposed to be used in respect to Higher-Level Protocol
   * rule HL1. (http://www.unicode.org/reports/tr9/#HL1)
   *
   * @param str       A text block; e.g. paragraph, table cell, tag
   * @param fallback  Fallback direction, used if no strong direction detected
   *                  for the block (default = NEUTRAL)
   * @return          The resolved direction
   */
  function resolveBlockDir(str, fallback) {
    fallback = fallback || UnicodeBidiDirection_1.NEUTRAL;
    if (!str.length) {
      return fallback;
    }
    var blockDir = firstStrongCharDir(str);
    return blockDir === UnicodeBidiDirection_1.NEUTRAL ? fallback : blockDir;
  }

  /**
   * Returns the direction of a block of text, based on the direction of its
   * first strong character (has Bidi_Class value of L, R, or AL), or a fallback
   * direction, if no strong character is found.
   *
   * NOTE: This function is similar to resolveBlockDir(), but uses the global
   * direction as the fallback, so it *always* returns a Strong direction,
   * making it useful for integration in places that you need to make the final
   * decision, like setting some CSS class.
   *
   * This function is supposed to be used in respect to Higher-Level Protocol
   * rule HL1. (http://www.unicode.org/reports/tr9/#HL1)
   *
   * @param str             A text block; e.g. paragraph, table cell
   * @param strongFallback  Fallback direction, used if no strong direction
   *                        detected for the block (default = global direction)
   * @return                The resolved Strong direction
   */
  function getDirection(str, strongFallback) {
    if (!strongFallback) {
      strongFallback = UnicodeBidiDirection_1.getGlobalDir();
    }
    !UnicodeBidiDirection_1.isStrong(strongFallback) ? invariant_1(false) : void 0;
    return resolveBlockDir(str, strongFallback);
  }

  /**
   * Returns true if getDirection(arguments...) returns LTR.
   *
   * @param str             A text block; e.g. paragraph, table cell
   * @param strongFallback  Fallback direction, used if no strong direction
   *                        detected for the block (default = global direction)
   * @return                True if the resolved direction is LTR
   */
  function isDirectionLTR(str, strongFallback) {
    return getDirection(str, strongFallback) === UnicodeBidiDirection_1.LTR;
  }

  /**
   * Returns true if getDirection(arguments...) returns RTL.
   *
   * @param str             A text block; e.g. paragraph, table cell
   * @param strongFallback  Fallback direction, used if no strong direction
   *                        detected for the block (default = global direction)
   * @return                True if the resolved direction is RTL
   */
  function isDirectionRTL(str, strongFallback) {
    return getDirection(str, strongFallback) === UnicodeBidiDirection_1.RTL;
  }

  var UnicodeBidi = {
    firstStrongChar: firstStrongChar,
    firstStrongCharDir: firstStrongCharDir,
    resolveBlockDir: resolveBlockDir,
    getDirection: getDirection,
    isDirectionLTR: isDirectionLTR,
    isDirectionRTL: isDirectionRTL
  };

  var UnicodeBidi_1 = UnicodeBidi;

  function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }






  var UnicodeBidiService = function () {

    /**
     * Stateful class for paragraph direction detection
     *
     * @param defaultDir  Default direction of the service
     */
    function UnicodeBidiService(defaultDir) {
      _classCallCheck$7(this, UnicodeBidiService);

      if (!defaultDir) {
        defaultDir = UnicodeBidiDirection_1.getGlobalDir();
      } else {
        !UnicodeBidiDirection_1.isStrong(defaultDir) ? invariant_1(false) : void 0;
      }
      this._defaultDir = defaultDir;
      this.reset();
    }

    /**
     * Reset the internal state
     *
     * Instead of creating a new instance, you can just reset() your instance
     * everytime you start a new loop.
     */


    UnicodeBidiService.prototype.reset = function reset() {
      this._lastDir = this._defaultDir;
    };

    /**
     * Returns the direction of a block of text, and remembers it as the
     * fall-back direction for the next paragraph.
     *
     * @param str  A text block, e.g. paragraph, table cell, tag
     * @return     The resolved direction
     */


    UnicodeBidiService.prototype.getDirection = function getDirection(str) {
      this._lastDir = UnicodeBidi_1.getDirection(str, this._lastDir);
      return this._lastDir;
    };

    return UnicodeBidiService;
  }();

  var UnicodeBidiService_1 = UnicodeBidiService;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var nullthrows = function nullthrows(x) {
    if (x != null) {
      return x;
    }
    throw new Error("Got unexpected null or undefined");
  };

  var nullthrows_1 = nullthrows;

  var OrderedMap$2 = immutable.OrderedMap;


  var bidiService;

  var EditorBidiService = {
    getDirectionMap: function getDirectionMap(content, prevBidiMap) {
      if (!bidiService) {
        bidiService = new UnicodeBidiService_1();
      } else {
        bidiService.reset();
      }

      var blockMap = content.getBlockMap();
      var nextBidi = blockMap.valueSeq().map(function (block) {
        return nullthrows_1(bidiService).getDirection(block.getText());
      });
      var bidiMap = OrderedMap$2(blockMap.keySeq().zip(nextBidi));

      if (prevBidiMap != null && immutable.is(prevBidiMap, bidiMap)) {
        return prevBidiMap;
      }

      return bidiMap;
    }
  };

  var EditorBidiService_1 = EditorBidiService;

  var _extends$1 = objectAssign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }







  var OrderedSet$4 = immutable.OrderedSet,
      Record$7 = immutable.Record,
      Stack = immutable.Stack;


  var defaultRecord$5 = {
    allowUndo: true,
    currentContent: null,
    decorator: null,
    directionMap: null,
    forceSelection: false,
    inCompositionMode: false,
    inlineStyleOverride: null,
    lastChangeType: null,
    nativelyRenderedContent: null,
    redoStack: Stack(),
    selection: null,
    treeMap: null,
    undoStack: Stack()
  };

  var EditorStateRecord = Record$7(defaultRecord$5);

  var EditorState = function () {
    EditorState.createEmpty = function createEmpty(decorator) {
      return EditorState.createWithContent(ContentState_1.createFromText(''), decorator);
    };

    EditorState.createWithContent = function createWithContent(contentState, decorator) {
      var firstKey = contentState.getBlockMap().first().getKey();
      return EditorState.create({
        currentContent: contentState,
        undoStack: Stack(),
        redoStack: Stack(),
        decorator: decorator || null,
        selection: SelectionState_1.createEmpty(firstKey)
      });
    };

    EditorState.create = function create(config) {
      var currentContent = config.currentContent,
          decorator = config.decorator;

      var recordConfig = _extends$1({}, config, {
        treeMap: generateNewTreeMap(currentContent, decorator),
        directionMap: EditorBidiService_1.getDirectionMap(currentContent)
      });
      return new EditorState(new EditorStateRecord(recordConfig));
    };

    EditorState.set = function set(editorState, put) {
      var map = editorState.getImmutable().withMutations(function (state) {
        var existingDecorator = state.get('decorator');
        var decorator = existingDecorator;
        if (put.decorator === null) {
          decorator = null;
        } else if (put.decorator) {
          decorator = put.decorator;
        }

        var newContent = put.currentContent || editorState.getCurrentContent();

        if (decorator !== existingDecorator) {
          var treeMap = state.get('treeMap');
          var newTreeMap;
          if (decorator && existingDecorator) {
            newTreeMap = regenerateTreeForNewDecorator(newContent, newContent.getBlockMap(), treeMap, decorator, existingDecorator);
          } else {
            newTreeMap = generateNewTreeMap(newContent, decorator);
          }

          state.merge({
            decorator: decorator,
            treeMap: newTreeMap,
            nativelyRenderedContent: null
          });
          return;
        }

        var existingContent = editorState.getCurrentContent();
        if (newContent !== existingContent) {
          state.set('treeMap', regenerateTreeForNewBlocks(editorState, newContent.getBlockMap(), newContent.getEntityMap(), decorator));
        }

        state.merge(put);
      });

      return new EditorState(map);
    };

    EditorState.prototype.toJS = function toJS() {
      return this.getImmutable().toJS();
    };

    EditorState.prototype.getAllowUndo = function getAllowUndo() {
      return this.getImmutable().get('allowUndo');
    };

    EditorState.prototype.getCurrentContent = function getCurrentContent() {
      return this.getImmutable().get('currentContent');
    };

    EditorState.prototype.getUndoStack = function getUndoStack() {
      return this.getImmutable().get('undoStack');
    };

    EditorState.prototype.getRedoStack = function getRedoStack() {
      return this.getImmutable().get('redoStack');
    };

    EditorState.prototype.getSelection = function getSelection() {
      return this.getImmutable().get('selection');
    };

    EditorState.prototype.getDecorator = function getDecorator() {
      return this.getImmutable().get('decorator');
    };

    EditorState.prototype.isInCompositionMode = function isInCompositionMode() {
      return this.getImmutable().get('inCompositionMode');
    };

    EditorState.prototype.mustForceSelection = function mustForceSelection() {
      return this.getImmutable().get('forceSelection');
    };

    EditorState.prototype.getNativelyRenderedContent = function getNativelyRenderedContent() {
      return this.getImmutable().get('nativelyRenderedContent');
    };

    EditorState.prototype.getLastChangeType = function getLastChangeType() {
      return this.getImmutable().get('lastChangeType');
    };

    /**
     * While editing, the user may apply inline style commands with a collapsed
     * cursor, intending to type text that adopts the specified style. In this
     * case, we track the specified style as an "override" that takes precedence
     * over the inline style of the text adjacent to the cursor.
     *
     * If null, there is no override in place.
     */


    EditorState.prototype.getInlineStyleOverride = function getInlineStyleOverride() {
      return this.getImmutable().get('inlineStyleOverride');
    };

    EditorState.setInlineStyleOverride = function setInlineStyleOverride(editorState, inlineStyleOverride) {
      return EditorState.set(editorState, { inlineStyleOverride: inlineStyleOverride });
    };

    /**
     * Get the appropriate inline style for the editor state. If an
     * override is in place, use it. Otherwise, the current style is
     * based on the location of the selection state.
     */


    EditorState.prototype.getCurrentInlineStyle = function getCurrentInlineStyle() {
      var override = this.getInlineStyleOverride();
      if (override != null) {
        return override;
      }

      var content = this.getCurrentContent();
      var selection = this.getSelection();

      if (selection.isCollapsed()) {
        return getInlineStyleForCollapsedSelection(content, selection);
      }

      return getInlineStyleForNonCollapsedSelection(content, selection);
    };

    EditorState.prototype.getBlockTree = function getBlockTree(blockKey) {
      return this.getImmutable().getIn(['treeMap', blockKey]);
    };

    EditorState.prototype.isSelectionAtStartOfContent = function isSelectionAtStartOfContent() {
      var firstKey = this.getCurrentContent().getBlockMap().first().getKey();
      return this.getSelection().hasEdgeWithin(firstKey, 0, 0);
    };

    EditorState.prototype.isSelectionAtEndOfContent = function isSelectionAtEndOfContent() {
      var content = this.getCurrentContent();
      var blockMap = content.getBlockMap();
      var last = blockMap.last();
      var end = last.getLength();
      return this.getSelection().hasEdgeWithin(last.getKey(), end, end);
    };

    EditorState.prototype.getDirectionMap = function getDirectionMap() {
      return this.getImmutable().get('directionMap');
    };

    /**
     * Incorporate native DOM selection changes into the EditorState. This
     * method can be used when we simply want to accept whatever the DOM
     * has given us to represent selection, and we do not need to re-render
     * the editor.
     *
     * To forcibly move the DOM selection, see `EditorState.forceSelection`.
     */


    EditorState.acceptSelection = function acceptSelection(editorState, selection) {
      return updateSelection(editorState, selection, false);
    };

    /**
     * At times, we need to force the DOM selection to be where we
     * need it to be. This can occur when the anchor or focus nodes
     * are non-text nodes, for instance. In this case, we want to trigger
     * a re-render of the editor, which in turn forces selection into
     * the correct place in the DOM. The `forceSelection` method
     * accomplishes this.
     *
     * This method should be used in cases where you need to explicitly
     * move the DOM selection from one place to another without a change
     * in ContentState.
     */


    EditorState.forceSelection = function forceSelection(editorState, selection) {
      if (!selection.getHasFocus()) {
        selection = selection.set('hasFocus', true);
      }
      return updateSelection(editorState, selection, true);
    };

    /**
     * Move selection to the end of the editor without forcing focus.
     */


    EditorState.moveSelectionToEnd = function moveSelectionToEnd(editorState) {
      var content = editorState.getCurrentContent();
      var lastBlock = content.getLastBlock();
      var lastKey = lastBlock.getKey();
      var length = lastBlock.getLength();

      return EditorState.acceptSelection(editorState, new SelectionState_1({
        anchorKey: lastKey,
        anchorOffset: length,
        focusKey: lastKey,
        focusOffset: length,
        isBackward: false
      }));
    };

    /**
     * Force focus to the end of the editor. This is useful in scenarios
     * where we want to programmatically focus the input and it makes sense
     * to allow the user to continue working seamlessly.
     */


    EditorState.moveFocusToEnd = function moveFocusToEnd(editorState) {
      var afterSelectionMove = EditorState.moveSelectionToEnd(editorState);
      return EditorState.forceSelection(afterSelectionMove, afterSelectionMove.getSelection());
    };

    /**
     * Push the current ContentState onto the undo stack if it should be
     * considered a boundary state, and set the provided ContentState as the
     * new current content.
     */


    EditorState.push = function push(editorState, contentState, changeType) {
      if (editorState.getCurrentContent() === contentState) {
        return editorState;
      }

      var forceSelection = changeType !== 'insert-characters';
      var directionMap = EditorBidiService_1.getDirectionMap(contentState, editorState.getDirectionMap());

      if (!editorState.getAllowUndo()) {
        return EditorState.set(editorState, {
          currentContent: contentState,
          directionMap: directionMap,
          lastChangeType: changeType,
          selection: contentState.getSelectionAfter(),
          forceSelection: forceSelection,
          inlineStyleOverride: null
        });
      }

      var selection = editorState.getSelection();
      var currentContent = editorState.getCurrentContent();
      var undoStack = editorState.getUndoStack();
      var newContent = contentState;

      if (selection !== currentContent.getSelectionAfter() || mustBecomeBoundary(editorState, changeType)) {
        undoStack = undoStack.push(currentContent);
        newContent = newContent.set('selectionBefore', selection);
      } else if (changeType === 'insert-characters' || changeType === 'backspace-character' || changeType === 'delete-character') {
        // Preserve the previous selection.
        newContent = newContent.set('selectionBefore', currentContent.getSelectionBefore());
      }

      var inlineStyleOverride = editorState.getInlineStyleOverride();

      // Don't discard inline style overrides for the following change types:
      var overrideChangeTypes = ['adjust-depth', 'change-block-type', 'split-block'];

      if (overrideChangeTypes.indexOf(changeType) === -1) {
        inlineStyleOverride = null;
      }

      var editorStateChanges = {
        currentContent: newContent,
        directionMap: directionMap,
        undoStack: undoStack,
        redoStack: Stack(),
        lastChangeType: changeType,
        selection: contentState.getSelectionAfter(),
        forceSelection: forceSelection,
        inlineStyleOverride: inlineStyleOverride
      };

      return EditorState.set(editorState, editorStateChanges);
    };

    /**
     * Make the top ContentState in the undo stack the new current content and
     * push the current content onto the redo stack.
     */


    EditorState.undo = function undo(editorState) {
      if (!editorState.getAllowUndo()) {
        return editorState;
      }

      var undoStack = editorState.getUndoStack();
      var newCurrentContent = undoStack.peek();
      if (!newCurrentContent) {
        return editorState;
      }

      var currentContent = editorState.getCurrentContent();
      var directionMap = EditorBidiService_1.getDirectionMap(newCurrentContent, editorState.getDirectionMap());

      return EditorState.set(editorState, {
        currentContent: newCurrentContent,
        directionMap: directionMap,
        undoStack: undoStack.shift(),
        redoStack: editorState.getRedoStack().push(currentContent),
        forceSelection: true,
        inlineStyleOverride: null,
        lastChangeType: 'undo',
        nativelyRenderedContent: null,
        selection: currentContent.getSelectionBefore()
      });
    };

    /**
     * Make the top ContentState in the redo stack the new current content and
     * push the current content onto the undo stack.
     */


    EditorState.redo = function redo(editorState) {
      if (!editorState.getAllowUndo()) {
        return editorState;
      }

      var redoStack = editorState.getRedoStack();
      var newCurrentContent = redoStack.peek();
      if (!newCurrentContent) {
        return editorState;
      }

      var currentContent = editorState.getCurrentContent();
      var directionMap = EditorBidiService_1.getDirectionMap(newCurrentContent, editorState.getDirectionMap());

      return EditorState.set(editorState, {
        currentContent: newCurrentContent,
        directionMap: directionMap,
        undoStack: editorState.getUndoStack().push(currentContent),
        redoStack: redoStack.shift(),
        forceSelection: true,
        inlineStyleOverride: null,
        lastChangeType: 'redo',
        nativelyRenderedContent: null,
        selection: newCurrentContent.getSelectionAfter()
      });
    };

    /**
     * Not for public consumption.
     */


    function EditorState(immutable) {
      _classCallCheck$8(this, EditorState);

      this._immutable = immutable;
    }

    /**
     * Not for public consumption.
     */


    EditorState.prototype.getImmutable = function getImmutable() {
      return this._immutable;
    };

    return EditorState;
  }();

  /**
   * Set the supplied SelectionState as the new current selection, and set
   * the `force` flag to trigger manual selection placement by the view.
   */


  function updateSelection(editorState, selection, forceSelection) {
    return EditorState.set(editorState, {
      selection: selection,
      forceSelection: forceSelection,
      nativelyRenderedContent: null,
      inlineStyleOverride: null
    });
  }

  /**
   * Regenerate the entire tree map for a given ContentState and decorator.
   * Returns an OrderedMap that maps all available ContentBlock objects.
   */
  function generateNewTreeMap(contentState, decorator) {
    return contentState.getBlockMap().map(function (block) {
      return BlockTree_1.generate(contentState, block, decorator);
    }).toOrderedMap();
  }

  /**
   * Regenerate tree map objects for all ContentBlocks that have changed
   * between the current editorState and newContent. Returns an OrderedMap
   * with only changed regenerated tree map objects.
   */
  function regenerateTreeForNewBlocks(editorState, newBlockMap, newEntityMap, decorator) {
    var contentState = editorState.getCurrentContent().set('entityMap', newEntityMap);
    var prevBlockMap = contentState.getBlockMap();
    var prevTreeMap = editorState.getImmutable().get('treeMap');
    return prevTreeMap.merge(newBlockMap.toSeq().filter(function (block, key) {
      return block !== prevBlockMap.get(key);
    }).map(function (block) {
      return BlockTree_1.generate(contentState, block, decorator);
    }));
  }

  /**
   * Generate tree map objects for a new decorator object, preserving any
   * decorations that are unchanged from the previous decorator.
   *
   * Note that in order for this to perform optimally, decoration Lists for
   * decorators should be preserved when possible to allow for direct immutable
   * List comparison.
   */
  function regenerateTreeForNewDecorator(content, blockMap, previousTreeMap, decorator, existingDecorator) {
    return previousTreeMap.merge(blockMap.toSeq().filter(function (block) {
      return decorator.getDecorations(block, content) !== existingDecorator.getDecorations(block, content);
    }).map(function (block) {
      return BlockTree_1.generate(content, block, decorator);
    }));
  }

  /**
   * Return whether a change should be considered a boundary state, given
   * the previous change type. Allows us to discard potential boundary states
   * during standard typing or deletion behavior.
   */
  function mustBecomeBoundary(editorState, changeType) {
    var lastChangeType = editorState.getLastChangeType();
    return changeType !== lastChangeType || changeType !== 'insert-characters' && changeType !== 'backspace-character' && changeType !== 'delete-character';
  }

  function getInlineStyleForCollapsedSelection(content, selection) {
    var startKey = selection.getStartKey();
    var startOffset = selection.getStartOffset();
    var startBlock = content.getBlockForKey(startKey);

    // If the cursor is not at the start of the block, look backward to
    // preserve the style of the preceding character.
    if (startOffset > 0) {
      return startBlock.getInlineStyleAt(startOffset - 1);
    }

    // The caret is at position zero in this block. If the block has any
    // text at all, use the style of the first character.
    if (startBlock.getLength()) {
      return startBlock.getInlineStyleAt(0);
    }

    // Otherwise, look upward in the document to find the closest character.
    return lookUpwardForInlineStyle(content, startKey);
  }

  function getInlineStyleForNonCollapsedSelection(content, selection) {
    var startKey = selection.getStartKey();
    var startOffset = selection.getStartOffset();
    var startBlock = content.getBlockForKey(startKey);

    // If there is a character just inside the selection, use its style.
    if (startOffset < startBlock.getLength()) {
      return startBlock.getInlineStyleAt(startOffset);
    }

    // Check if the selection at the end of a non-empty block. Use the last
    // style in the block.
    if (startOffset > 0) {
      return startBlock.getInlineStyleAt(startOffset - 1);
    }

    // Otherwise, look upward in the document to find the closest character.
    return lookUpwardForInlineStyle(content, startKey);
  }

  function lookUpwardForInlineStyle(content, fromKey) {
    var lastNonEmpty = content.getBlockMap().reverse().skipUntil(function (_, k) {
      return k === fromKey;
    }).skip(1).skipUntil(function (block, _) {
      return block.getLength();
    }).first();

    if (lastNonEmpty) return lastNonEmpty.getInlineStyleAt(lastNonEmpty.getLength() - 1);
    return OrderedSet$4();
  }

  var EditorState_1 = EditorState;

  var OrderedMap$3 = immutable.OrderedMap,
      List$7 = immutable.List;


  var transformBlock$2 = function transformBlock(key, blockMap, func) {
    if (!key) {
      return;
    }

    var block = blockMap.get(key);

    if (!block) {
      return;
    }

    blockMap.set(key, func(block));
  };

  var updateBlockMapLinks$3 = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {
    if (!isExperimentalTreeBlock) {
      return blockMap;
    }
    // possible values of 'insertionMode' are: 'after', 'before'
    var isInsertedAfterTarget = insertionMode === 'after';

    var originalBlockKey = originalBlockToBeMoved.getKey();
    var originalTargetKey = originalTargetBlock.getKey();
    var originalParentKey = originalBlockToBeMoved.getParentKey();
    var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();
    var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();
    var newParentKey = originalTargetBlock.getParentKey();
    var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;
    var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();

    return blockMap.withMutations(function (blocks) {
      // update old parent
      transformBlock$2(originalParentKey, blocks, function (block) {
        var parentChildrenList = block.getChildKeys();
        return block.merge({
          children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))
        });
      });

      // update old prev
      transformBlock$2(originalPrevSiblingKey, blocks, function (block) {
        return block.merge({
          nextSibling: originalNextSiblingKey
        });
      });

      // update old next
      transformBlock$2(originalNextSiblingKey, blocks, function (block) {
        return block.merge({
          prevSibling: originalPrevSiblingKey
        });
      });

      // update new next
      transformBlock$2(newNextSiblingKey, blocks, function (block) {
        return block.merge({
          prevSibling: originalBlockKey
        });
      });

      // update new prev
      transformBlock$2(newPrevSiblingKey, blocks, function (block) {
        return block.merge({
          nextSibling: originalBlockKey
        });
      });

      // update new parent
      transformBlock$2(newParentKey, blocks, function (block) {
        var newParentChildrenList = block.getChildKeys();
        var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);

        var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;

        var newChildrenArray = newParentChildrenList.toArray();
        newChildrenArray.splice(insertionIndex, 0, originalBlockKey);

        return block.merge({
          children: List$7(newChildrenArray)
        });
      });

      // update block
      transformBlock$2(originalBlockKey, blocks, function (block) {
        return block.merge({
          nextSibling: newNextSiblingKey,
          prevSibling: newPrevSiblingKey,
          parent: newParentKey
        });
      });
    });
  };

  var moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {
    !(insertionMode !== 'replace') ? invariant_1(false) : void 0;

    var targetKey = targetBlock.getKey();
    var blockKey = blockToBeMoved.getKey();

    !(blockKey !== targetKey) ? invariant_1(false) : void 0;

    var blockMap = contentState.getBlockMap();
    var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode_1;

    var blocksToBeMoved = [blockToBeMoved];
    var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);

    if (isExperimentalTreeBlock) {
      blocksToBeMoved = [];
      blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {
        var nextSiblingKey = blockToBeMoved.getNextSiblingKey();
        var nextDelimiterBlockKey = getNextDelimiterBlockKey_1(blockToBeMoved, blocks);

        blocks.toSeq().skipUntil(function (block) {
          return block.getKey() === blockKey;
        }).takeWhile(function (block) {
          var key = block.getKey();
          var isBlockToBeMoved = key === blockKey;
          var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;
          var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);

          return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);
        }).forEach(function (block) {
          blocksToBeMoved.push(block);
          blocks['delete'](block.getKey());
        });
      });
    }

    var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {
      return v === targetBlock;
    });

    var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {
      return v === targetBlock;
    }).skip(1);

    var slicedBlocks = blocksToBeMoved.map(function (block) {
      return [block.getKey(), block];
    });

    var newBlocks = OrderedMap$3();

    if (insertionMode === 'before') {
      var blockBefore = contentState.getBlockBefore(targetKey);

      !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? invariant_1(false) : void 0;

      newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();
    } else if (insertionMode === 'after') {
      var blockAfter = contentState.getBlockAfter(targetKey);

      !(!blockAfter || blockAfter.getKey() !== blockKey) ? invariant_1(false) : void 0;

      newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();
    }

    return contentState.merge({
      blockMap: updateBlockMapLinks$3(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),
      selectionBefore: contentState.getSelectionAfter(),
      selectionAfter: contentState.getSelectionAfter().merge({
        anchorKey: blockKey,
        focusKey: blockKey
      })
    });
  };

  var moveBlockInContentState_1 = moveBlockInContentState;

  var ContentBlockRecord$1 = ContentBlock_1;

  var List$8 = immutable.List,
      Repeat$5 = immutable.Repeat;


  var AtomicBlockUtils = {
    insertAtomicBlock: function insertAtomicBlock(editorState, entityKey, character) {
      var contentState = editorState.getCurrentContent();
      var selectionState = editorState.getSelection();

      var afterRemoval = DraftModifier_1.removeRange(contentState, selectionState, 'backward');

      var targetSelection = afterRemoval.getSelectionAfter();
      var afterSplit = DraftModifier_1.splitBlock(afterRemoval, targetSelection);
      var insertionTarget = afterSplit.getSelectionAfter();

      var asAtomicBlock = DraftModifier_1.setBlockType(afterSplit, insertionTarget, 'atomic');

      var charData = CharacterMetadata_1.create({ entity: entityKey });

      var atomicBlockConfig = {
        key: generateRandomKey_1(),
        type: 'atomic',
        text: character,
        characterList: List$8(Repeat$5(charData, character.length))
      };

      var atomicDividerBlockConfig = {
        key: generateRandomKey_1(),
        type: 'unstyled'
      };

      var fragmentArray = [new ContentBlockRecord$1(atomicBlockConfig), new ContentBlockRecord$1(atomicDividerBlockConfig)];

      var fragment = BlockMapBuilder_1.createFromArray(fragmentArray);

      var withAtomicBlock = DraftModifier_1.replaceWithFragment(asAtomicBlock, insertionTarget, fragment);

      var newContent = withAtomicBlock.merge({
        selectionBefore: selectionState,
        selectionAfter: withAtomicBlock.getSelectionAfter().set('hasFocus', true)
      });

      return EditorState_1.push(editorState, newContent, 'insert-fragment');
    },

    moveAtomicBlock: function moveAtomicBlock(editorState, atomicBlock, targetRange, insertionMode) {
      var contentState = editorState.getCurrentContent();
      var selectionState = editorState.getSelection();

      var withMovedAtomicBlock = void 0;

      if (insertionMode === 'before' || insertionMode === 'after') {
        var targetBlock = contentState.getBlockForKey(insertionMode === 'before' ? targetRange.getStartKey() : targetRange.getEndKey());

        withMovedAtomicBlock = moveBlockInContentState_1(contentState, atomicBlock, targetBlock, insertionMode);
      } else {
        var afterRemoval = DraftModifier_1.removeRange(contentState, targetRange, 'backward');

        var selectionAfterRemoval = afterRemoval.getSelectionAfter();
        var _targetBlock = afterRemoval.getBlockForKey(selectionAfterRemoval.getFocusKey());

        if (selectionAfterRemoval.getStartOffset() === 0) {
          withMovedAtomicBlock = moveBlockInContentState_1(afterRemoval, atomicBlock, _targetBlock, 'before');
        } else if (selectionAfterRemoval.getEndOffset() === _targetBlock.getLength()) {
          withMovedAtomicBlock = moveBlockInContentState_1(afterRemoval, atomicBlock, _targetBlock, 'after');
        } else {
          var afterSplit = DraftModifier_1.splitBlock(afterRemoval, selectionAfterRemoval);

          var selectionAfterSplit = afterSplit.getSelectionAfter();
          var _targetBlock2 = afterSplit.getBlockForKey(selectionAfterSplit.getFocusKey());

          withMovedAtomicBlock = moveBlockInContentState_1(afterSplit, atomicBlock, _targetBlock2, 'before');
        }
      }

      var newContent = withMovedAtomicBlock.merge({
        selectionBefore: selectionState,
        selectionAfter: withMovedAtomicBlock.getSelectionAfter().set('hasFocus', true)
      });

      return EditorState_1.push(editorState, newContent, 'move-block');
    }
  };

  var AtomicBlockUtils_1 = AtomicBlockUtils;

  function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



  var List$9 = immutable.List;


  var DELIMITER = '.';

  /**
   * A CompositeDraftDecorator traverses through a list of DraftDecorator
   * instances to identify sections of a ContentBlock that should be rendered
   * in a "decorated" manner. For example, hashtags, mentions, and links may
   * be intended to stand out visually, be rendered as anchors, etc.
   *
   * The list of decorators supplied to the constructor will be used in the
   * order they are provided. This allows the caller to specify a priority for
   * string matching, in case of match collisions among decorators.
   *
   * For instance, I may have a link with a `#` in its text. Though this section
   * of text may match our hashtag decorator, it should not be treated as a
   * hashtag. I should therefore list my link DraftDecorator
   * before my hashtag DraftDecorator when constructing this composite
   * decorator instance.
   *
   * Thus, when a collision like this is encountered, the earlier match is
   * preserved and the new match is discarded.
   */

  var CompositeDraftDecorator = function () {
    function CompositeDraftDecorator(decorators) {
      _classCallCheck$9(this, CompositeDraftDecorator);

      // Copy the decorator array, since we use this array order to determine
      // precedence of decoration matching. If the array is mutated externally,
      // we don't want to be affected here.
      this._decorators = decorators.slice();
    }

    CompositeDraftDecorator.prototype.getDecorations = function getDecorations(block, contentState) {
      var decorations = Array(block.getText().length).fill(null);

      this._decorators.forEach(function ( /*object*/decorator, /*number*/ii) {
        var counter = 0;
        var strategy = decorator.strategy;
        var callback = function callback( /*number*/start, /*number*/end) {
          // Find out if any of our matching range is already occupied
          // by another decorator. If so, discard the match. Otherwise, store
          // the component key for rendering.
          if (canOccupySlice(decorations, start, end)) {
            occupySlice(decorations, start, end, ii + DELIMITER + counter);
            counter++;
          }
        };
        strategy(block, callback, contentState);
      });

      return List$9(decorations);
    };

    CompositeDraftDecorator.prototype.getComponentForKey = function getComponentForKey(key) {
      var componentKey = parseInt(key.split(DELIMITER)[0], 10);
      return this._decorators[componentKey].component;
    };

    CompositeDraftDecorator.prototype.getPropsForKey = function getPropsForKey(key) {
      var componentKey = parseInt(key.split(DELIMITER)[0], 10);
      return this._decorators[componentKey].props;
    };

    return CompositeDraftDecorator;
  }();

  /**
   * Determine whether we can occupy the specified slice of the decorations
   * array.
   */


  function canOccupySlice(decorations, start, end) {
    for (var ii = start; ii < end; ii++) {
      if (decorations[ii] != null) {
        return false;
      }
    }
    return true;
  }

  /**
   * Splice the specified component into our decoration array at the desired
   * range.
   */
  function occupySlice(targetArr, start, end, componentKey) {
    for (var ii = start; ii < end; ii++) {
      targetArr[ii] = componentKey;
    }
  }

  var CompositeDraftDecorator_1 = CompositeDraftDecorator;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  /**
   * This function is used to mark string literals representing CSS class names
   * so that they can be transformed statically. This allows for modularization
   * and minification of CSS class names.
   *
   * In static_upstream, this function is actually implemented, but it should
   * eventually be replaced with something more descriptive, and the transform
   * that is used in the main stack should be ported for use elsewhere.
   *
   * @param string|object className to modularize, or an object of key/values.
   *                      In the object case, the values are conditions that
   *                      determine if the className keys should be included.
   * @param [string ...]  Variable list of classNames in the string case.
   * @return string       Renderable space-separated CSS className.
   */
  function cx(classNames) {
    if (typeof classNames == 'object') {
      return Object.keys(classNames).filter(function (className) {
        return classNames[className];
      }).map(replace).join(' ');
    }
    return Array.prototype.map.call(arguments, replace).join(' ');
  }

  function replace(str) {
    return str.replace(/\//g, '-');
  }

  var cx_1 = cx;

  var Map$9 = immutable.Map;





  var UL_WRAP = react.createElement('ul', { className: cx_1('public/DraftStyleDefault/ul') });
  var OL_WRAP = react.createElement('ol', { className: cx_1('public/DraftStyleDefault/ol') });
  var PRE_WRAP = react.createElement('pre', { className: cx_1('public/DraftStyleDefault/pre') });

  var DefaultDraftBlockRenderMap = Map$9({
    'header-one': {
      element: 'h1'
    },
    'header-two': {
      element: 'h2'
    },
    'header-three': {
      element: 'h3'
    },
    'header-four': {
      element: 'h4'
    },
    'header-five': {
      element: 'h5'
    },
    'header-six': {
      element: 'h6'
    },
    'unordered-list-item': {
      element: 'li',
      wrapper: UL_WRAP
    },
    'ordered-list-item': {
      element: 'li',
      wrapper: OL_WRAP
    },
    blockquote: {
      element: 'blockquote'
    },
    atomic: {
      element: 'figure'
    },
    'code-block': {
      element: 'pre',
      wrapper: PRE_WRAP
    },
    unstyled: {
      element: 'div',
      aliasedElements: ['p']
    }
  });

  var DefaultDraftBlockRenderMap_1 = DefaultDraftBlockRenderMap;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule DefaultDraftInlineStyle
   * @format
   * 
   */

  var DefaultDraftInlineStyle = {
    BOLD: {
      fontWeight: 'bold'
    },

    CODE: {
      fontFamily: 'monospace',
      wordWrap: 'break-word'
    },

    ITALIC: {
      fontStyle: 'italic'
    },

    STRIKETHROUGH: {
      textDecoration: 'line-through'
    },

    UNDERLINE: {
      textDecoration: 'underline'
    }
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  var Keys = {
    BACKSPACE: 8,
    TAB: 9,
    RETURN: 13,
    ALT: 18,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    DELETE: 46,
    COMMA: 188,
    PERIOD: 190,
    A: 65,
    Z: 90,
    ZERO: 48,
    NUMPAD_0: 96,
    NUMPAD_9: 105
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule getEntityKeyForSelection
   * @format
   * 
   */

  /**
   * Return the entity key that should be used when inserting text for the
   * specified target selection, only if the entity is `MUTABLE`. `IMMUTABLE`
   * and `SEGMENTED` entities should not be used for insertion behavior.
   */
  function getEntityKeyForSelection(contentState, targetSelection) {
    var entityKey;

    if (targetSelection.isCollapsed()) {
      var key = targetSelection.getAnchorKey();
      var offset = targetSelection.getAnchorOffset();
      if (offset > 0) {
        entityKey = contentState.getBlockForKey(key).getEntityAt(offset - 1);
        if (entityKey !== contentState.getBlockForKey(key).getEntityAt(offset)) {
          return null;
        }
        return filterKey(contentState.getEntityMap(), entityKey);
      }
      return null;
    }

    var startKey = targetSelection.getStartKey();
    var startOffset = targetSelection.getStartOffset();
    var startBlock = contentState.getBlockForKey(startKey);

    entityKey = startOffset === startBlock.getLength() ? null : startBlock.getEntityAt(startOffset);

    return filterKey(contentState.getEntityMap(), entityKey);
  }

  /**
   * Determine whether an entity key corresponds to a `MUTABLE` entity. If so,
   * return it. If not, return null.
   */
  function filterKey(entityMap, entityKey) {
    if (entityKey) {
      var entity = entityMap.__get(entityKey);
      return entity.getMutability() === 'MUTABLE' ? entityKey : null;
    }
    return null;
  }

  var getEntityKeyForSelection_1 = getEntityKeyForSelection;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule isEventHandled
   * @format
   * 
   */

  /**
   * Utility method for determining whether or not the value returned
   * from a handler indicates that it was handled.
   */
  function isEventHandled(value) {
    return value === 'handled' || value === true;
  }

  var isEventHandled_1 = isEventHandled;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule isSelectionAtLeafStart
   * @format
   * 
   */

  function isSelectionAtLeafStart(editorState) {
    var selection = editorState.getSelection();
    var anchorKey = selection.getAnchorKey();
    var blockTree = editorState.getBlockTree(anchorKey);
    var offset = selection.getStartOffset();

    var isAtStart = false;

    blockTree.some(function (leafSet) {
      if (offset === leafSet.get('start')) {
        isAtStart = true;
        return true;
      }

      if (offset < leafSet.get('end')) {
        return leafSet.get('leaves').some(function (leaf) {
          var leafStart = leaf.get('start');
          if (offset === leafStart) {
            isAtStart = true;
            return true;
          }

          return false;
        });
      }

      return false;
    });

    return isAtStart;
  }

  var isSelectionAtLeafStart_1 = isSelectionAtLeafStart;

  /**
   * Millisecond delay to allow `compositionstart` to fire again upon
   * `compositionend`.
   *
   * This is used for Korean input to ensure that typing can continue without
   * the editor trying to render too quickly. More specifically, Safari 7.1+
   * triggers `compositionstart` a little slower than Chrome/FF, which
   * leads to composed characters being resolved and re-render occurring
   * sooner than we want.
   */
  var RESOLVE_DELAY = 20;

  /**
   * A handful of variables used to track the current composition and its
   * resolution status. These exist at the module level because it is not
   * possible to have compositions occurring in multiple editors simultaneously,
   * and it simplifies state management with respect to the DraftEditor component.
   */
  var resolved = false;
  var stillComposing = false;
  var textInputData = '';

  var DraftEditorCompositionHandler = {
    onBeforeInput: function onBeforeInput(editor, e) {
      textInputData = (textInputData || '') + e.data;
    },

    /**
     * A `compositionstart` event has fired while we're still in composition
     * mode. Continue the current composition session to prevent a re-render.
     */
    onCompositionStart: function onCompositionStart(editor) {
      stillComposing = true;
    },

    /**
     * Attempt to end the current composition session.
     *
     * Defer handling because browser will still insert the chars into active
     * element after `compositionend`. If a `compositionstart` event fires
     * before `resolveComposition` executes, our composition session will
     * continue.
     *
     * The `resolved` flag is useful because certain IME interfaces fire the
     * `compositionend` event multiple times, thus queueing up multiple attempts
     * at handling the composition. Since handling the same composition event
     * twice could break the DOM, we only use the first event. Example: Arabic
     * Google Input Tools on Windows 8.1 fires `compositionend` three times.
     */
    onCompositionEnd: function onCompositionEnd(editor) {
      resolved = false;
      stillComposing = false;
      setTimeout(function () {
        if (!resolved) {
          DraftEditorCompositionHandler.resolveComposition(editor);
        }
      }, RESOLVE_DELAY);
    },

    /**
     * In Safari, keydown events may fire when committing compositions. If
     * the arrow keys are used to commit, prevent default so that the cursor
     * doesn't move, otherwise it will jump back noticeably on re-render.
     */
    onKeyDown: function onKeyDown(editor, e) {
      if (!stillComposing) {
        // If a keydown event is received after compositionend but before the
        // 20ms timer expires (ex: type option-E then backspace, or type A then
        // backspace in 2-Set Korean), we should immediately resolve the
        // composition and reinterpret the key press in edit mode.
        DraftEditorCompositionHandler.resolveComposition(editor);
        editor._onKeyDown(e);
        return;
      }
      if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {
        e.preventDefault();
      }
    },

    /**
     * Keypress events may fire when committing compositions. In Firefox,
     * pressing RETURN commits the composition and inserts extra newline
     * characters that we do not want. `preventDefault` allows the composition
     * to be committed while preventing the extra characters.
     */
    onKeyPress: function onKeyPress(editor, e) {
      if (e.which === Keys.RETURN) {
        e.preventDefault();
      }
    },

    /**
     * Attempt to insert composed characters into the document.
     *
     * If we are still in a composition session, do nothing. Otherwise, insert
     * the characters into the document and terminate the composition session.
     *
     * If no characters were composed -- for instance, the user
     * deleted all composed characters and committed nothing new --
     * force a re-render. We also re-render when the composition occurs
     * at the beginning of a leaf, to ensure that if the browser has
     * created a new text node for the composition, we will discard it.
     *
     * Resetting innerHTML will move focus to the beginning of the editor,
     * so we update to force it back to the correct place.
     */
    resolveComposition: function resolveComposition(editor) {
      if (stillComposing) {
        return;
      }

      resolved = true;
      var composedChars = textInputData;
      textInputData = '';

      var editorState = EditorState_1.set(editor._latestEditorState, {
        inCompositionMode: false
      });

      var currentStyle = editorState.getCurrentInlineStyle();
      var entityKey = getEntityKeyForSelection_1(editorState.getCurrentContent(), editorState.getSelection());

      var mustReset = !composedChars || isSelectionAtLeafStart_1(editorState) || currentStyle.size > 0 || entityKey !== null;

      if (mustReset) {
        editor.restoreEditorDOM();
      }

      editor.exitCurrentMode();

      if (composedChars) {
        // If characters have been composed, re-rendering with the update
        // is sufficient to reset the editor.
        var contentState = DraftModifier_1.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);
        editor.update(EditorState_1.push(editorState, contentState, 'insert-characters'));
        return;
      }

      if (mustReset) {
        editor.update(EditorState_1.set(editorState, {
          nativelyRenderedContent: null,
          forceSelection: true
        }));
      }
    }
  };

  var DraftEditorCompositionHandler_1 = DraftEditorCompositionHandler;

  var scheduler_production_min = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports,"__esModule",{value:!0});var d=null,e=!1,g=3,k=-1,l=-1,m=!1,n=!1;function p(){if(!m){var a=d.expirationTime;n?q():n=!0;r(t,a);}}
  function u(){var a=d,b=d.next;if(d===b)d=null;else{var c=d.previous;d=c.next=b;b.previous=c;}a.next=a.previous=null;c=a.callback;b=a.expirationTime;a=a.priorityLevel;var f=g,Q=l;g=a;l=b;try{var h=c();}finally{g=f,l=Q;}if("function"===typeof h)if(h={callback:h,priorityLevel:a,expirationTime:b,next:null,previous:null},null===d)d=h.next=h.previous=h;else{c=null;a=d;do{if(a.expirationTime>=b){c=a;break}a=a.next;}while(a!==d);null===c?c=d:c===d&&(d=h,p());b=c.previous;b.next=c.previous=h;h.next=c;h.previous=
  b;}}function v(){if(-1===k&&null!==d&&1===d.priorityLevel){m=!0;try{do u();while(null!==d&&1===d.priorityLevel)}finally{m=!1,null!==d?p():n=!1;}}}function t(a){m=!0;var b=e;e=a;try{if(a)for(;null!==d;){var c=exports.unstable_now();if(d.expirationTime<=c){do u();while(null!==d&&d.expirationTime<=c)}else break}else if(null!==d){do u();while(null!==d&&!w())}}finally{m=!1,e=b,null!==d?p():n=!1,v();}}
  var x=Date,y="function"===typeof setTimeout?setTimeout:void 0,z="function"===typeof clearTimeout?clearTimeout:void 0,A="function"===typeof requestAnimationFrame?requestAnimationFrame:void 0,B="function"===typeof cancelAnimationFrame?cancelAnimationFrame:void 0,C,D;function E(a){C=A(function(b){z(D);a(b);});D=y(function(){B(C);a(exports.unstable_now());},100);}
  if("object"===typeof performance&&"function"===typeof performance.now){var F=performance;exports.unstable_now=function(){return F.now()};}else exports.unstable_now=function(){return x.now()};var r,q,w,G=null;"undefined"!==typeof window?G=window:"undefined"!==typeof commonjsGlobal&&(G=commonjsGlobal);
  if(G&&G._schedMock){var H=G._schedMock;r=H[0];q=H[1];w=H[2];exports.unstable_now=H[3];}else if("undefined"===typeof window||"function"!==typeof MessageChannel){var I=null,J=function(a){if(null!==I)try{I(a);}finally{I=null;}};r=function(a){null!==I?setTimeout(r,0,a):(I=a,setTimeout(J,0,!1));};q=function(){I=null;};w=function(){return !1};}else{"undefined"!==typeof console&&("function"!==typeof A&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
  "function"!==typeof B&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));var K=null,L=!1,M=-1,N=!1,O=!1,P=0,R=33,S=33;w=function(){return P<=exports.unstable_now()};var T=new MessageChannel,U=T.port2;T.port1.onmessage=function(){L=!1;var a=K,b=M;K=null;M=-1;var c=exports.unstable_now(),f=!1;if(0>=P-c)if(-1!==b&&b<=c)f=!0;else{N||(N=!0,E(V));K=a;M=b;return}if(null!==a){O=!0;try{a(f);}finally{O=!1;}}};
  var V=function(a){if(null!==K){E(V);var b=a-P+S;b<S&&R<S?(8>b&&(b=8),S=b<R?R:b):R=b;P=a+S;L||(L=!0,U.postMessage(void 0));}else N=!1;};r=function(a,b){K=a;M=b;O||0>b?U.postMessage(void 0):N||(N=!0,E(V));};q=function(){K=null;L=!1;M=-1;};}exports.unstable_ImmediatePriority=1;exports.unstable_UserBlockingPriority=2;exports.unstable_NormalPriority=3;exports.unstable_IdlePriority=5;exports.unstable_LowPriority=4;
  exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3;}var c=g,f=k;g=a;k=exports.unstable_now();try{return b()}finally{g=c,k=f,v();}};exports.unstable_next=function(a){switch(g){case 1:case 2:case 3:var b=3;break;default:b=g;}var c=g,f=k;g=b;k=exports.unstable_now();try{return a()}finally{g=c,k=f,v();}};
  exports.unstable_scheduleCallback=function(a,b){var c=-1!==k?k:exports.unstable_now();if("object"===typeof b&&null!==b&&"number"===typeof b.timeout)b=c+b.timeout;else switch(g){case 1:b=c+-1;break;case 2:b=c+250;break;case 5:b=c+1073741823;break;case 4:b=c+1E4;break;default:b=c+5E3;}a={callback:a,priorityLevel:g,expirationTime:b,next:null,previous:null};if(null===d)d=a.next=a.previous=a,p();else{c=null;var f=d;do{if(f.expirationTime>b){c=f;break}f=f.next;}while(f!==d);null===c?c=d:c===d&&(d=a,p());
  b=c.previous;b.next=c.previous=a;a.next=c;a.previous=b;}return a};exports.unstable_cancelCallback=function(a){var b=a.next;if(null!==b){if(b===a)d=null;else{a===d&&(d=b);var c=a.previous;c.next=b;b.previous=c;}a.next=a.previous=null;}};exports.unstable_wrapCallback=function(a){var b=g;return function(){var c=g,f=k;g=b;k=exports.unstable_now();try{return a.apply(this,arguments)}finally{g=c,k=f,v();}}};exports.unstable_getCurrentPriorityLevel=function(){return g};
  exports.unstable_shouldYield=function(){return !e&&(null!==d&&d.expirationTime<l||w())};exports.unstable_continueExecution=function(){null!==d&&p();};exports.unstable_pauseExecution=function(){};exports.unstable_getFirstCallbackNode=function(){return d};
  });

  unwrapExports(scheduler_production_min);
  var scheduler_production_min_1 = scheduler_production_min.unstable_now;
  var scheduler_production_min_2 = scheduler_production_min.unstable_ImmediatePriority;
  var scheduler_production_min_3 = scheduler_production_min.unstable_UserBlockingPriority;
  var scheduler_production_min_4 = scheduler_production_min.unstable_NormalPriority;
  var scheduler_production_min_5 = scheduler_production_min.unstable_IdlePriority;
  var scheduler_production_min_6 = scheduler_production_min.unstable_LowPriority;
  var scheduler_production_min_7 = scheduler_production_min.unstable_runWithPriority;
  var scheduler_production_min_8 = scheduler_production_min.unstable_next;
  var scheduler_production_min_9 = scheduler_production_min.unstable_scheduleCallback;
  var scheduler_production_min_10 = scheduler_production_min.unstable_cancelCallback;
  var scheduler_production_min_11 = scheduler_production_min.unstable_wrapCallback;
  var scheduler_production_min_12 = scheduler_production_min.unstable_getCurrentPriorityLevel;
  var scheduler_production_min_13 = scheduler_production_min.unstable_shouldYield;
  var scheduler_production_min_14 = scheduler_production_min.unstable_continueExecution;
  var scheduler_production_min_15 = scheduler_production_min.unstable_pauseExecution;
  var scheduler_production_min_16 = scheduler_production_min.unstable_getFirstCallbackNode;

  var scheduler = createCommonjsModule(function (module) {

  {
    module.exports = scheduler_production_min;
  }
  });

  function ba$1(a,b,c,d,e,f,g,h){if(!a){a=void 0;if(void 0===b)a=Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[c,d,e,f,g,h],k=0;a=Error(b.replace(/%s/g,function(){return l[k++]}));a.name="Invariant Violation";}a.framesToPop=1;throw a;}}
  function x$1(a){for(var b=arguments.length-1,c="https://reactjs.org/docs/error-decoder.html?invariant="+a,d=0;d<b;d++)c+="&args[]="+encodeURIComponent(arguments[d+1]);ba$1(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",c);}react?void 0:x$1("227");function ca$1(a,b,c,d,e,f,g,h,l){var k=Array.prototype.slice.call(arguments,3);try{b.apply(c,k);}catch(m){this.onError(m);}}
  var da$1=!1,ea$1=null,fa$1=!1,ha=null,ia={onError:function(a){da$1=!0;ea$1=a;}};function ja(a,b,c,d,e,f,g,h,l){da$1=!1;ea$1=null;ca$1.apply(ia,arguments);}function ka(a,b,c,d,e,f,g,h,l){ja.apply(this,arguments);if(da$1){if(da$1){var k=ea$1;da$1=!1;ea$1=null;}else x$1("198"),k=void 0;fa$1||(fa$1=!0,ha=k);}}var la=null,ma={};
  function na(){if(la)for(var a in ma){var b=ma[a],c=la.indexOf(a);-1<c?void 0:x$1("96",a);if(!oa[c]){b.extractEvents?void 0:x$1("97",a);oa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;pa.hasOwnProperty(h)?x$1("99",h):void 0;pa[h]=f;var l=f.phasedRegistrationNames;if(l){for(e in l)l.hasOwnProperty(e)&&qa(l[e],g,h);e=!0;}else f.registrationName?(qa(f.registrationName,g,h),e=!0):e=!1;e?void 0:x$1("98",d,a);}}}}
  function qa(a,b,c){ra[a]?x$1("100",a):void 0;ra[a]=b;sa[a]=b.eventTypes[c].dependencies;}var oa=[],pa={},ra={},sa={},ta=null,ua=null,va=null;function wa(a,b,c){var d=a.type||"unknown-event";a.currentTarget=va(c);ka(d,b,void 0,a);a.currentTarget=null;}function xa(a,b){null==b?x$1("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}
  function ya(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a);}var za=null;function Aa(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)wa(a,b[d],c[d]);else b&&wa(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a);}}
  var Ba={injectEventPluginOrder:function(a){la?x$1("101"):void 0;la=Array.prototype.slice.call(a);na();},injectEventPluginsByName:function(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];ma.hasOwnProperty(c)&&ma[c]===d||(ma[c]?x$1("102",c):void 0,ma[c]=d,b=!0);}b&&na();}};
  function Ca(a,b){var c=a.stateNode;if(!c)return null;var d=ta(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1;}if(a)return null;c&&"function"!==typeof c?x$1("231",b,typeof c):void 0;
  return c}function Da(a){null!==a&&(za=xa(za,a));a=za;za=null;if(a&&(ya(a,Aa),za?x$1("95"):void 0,fa$1))throw a=ha,fa$1=!1,ha=null,a;}var Ea=Math.random().toString(36).slice(2),Fa="__reactInternalInstance$"+Ea,Ga="__reactEventHandlers$"+Ea;function Ha(a){if(a[Fa])return a[Fa];for(;!a[Fa];)if(a.parentNode)a=a.parentNode;else return null;a=a[Fa];return 5===a.tag||6===a.tag?a:null}function Ia(a){a=a[Fa];return !a||5!==a.tag&&6!==a.tag?null:a}
  function Ja(a){if(5===a.tag||6===a.tag)return a.stateNode;x$1("33");}function Ka(a){return a[Ga]||null}function La(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function Ma(a,b,c){if(b=Ca(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=xa(c._dispatchListeners,b),c._dispatchInstances=xa(c._dispatchInstances,a);}
  function Na(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=La(b);for(b=c.length;0<b--;)Ma(c[b],"captured",a);for(b=0;b<c.length;b++)Ma(c[b],"bubbled",a);}}function Oa(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Ca(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=xa(c._dispatchListeners,b),c._dispatchInstances=xa(c._dispatchInstances,a));}function Pa(a){a&&a.dispatchConfig.registrationName&&Oa(a._targetInst,null,a);}
  function Qa(a){ya(a,Na);}var Ra=!("undefined"===typeof window||!window.document||!window.document.createElement);function Sa(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Ta={animationend:Sa("Animation","AnimationEnd"),animationiteration:Sa("Animation","AnimationIteration"),animationstart:Sa("Animation","AnimationStart"),transitionend:Sa("Transition","TransitionEnd")},Ua={},Va={};
  Ra&&(Va=document.createElement("div").style,"AnimationEvent"in window||(delete Ta.animationend.animation,delete Ta.animationiteration.animation,delete Ta.animationstart.animation),"TransitionEvent"in window||delete Ta.transitionend.transition);function Wa(a){if(Ua[a])return Ua[a];if(!Ta[a])return a;var b=Ta[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Va)return Ua[a]=b[c];return a}
  var Xa=Wa("animationend"),Ya=Wa("animationiteration"),Za=Wa("animationstart"),$a=Wa("transitionend"),ab="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),bb=null,cb=null,db=null;
  function eb(){if(db)return db;var a,b=cb,c=b.length,d,e="value"in bb?bb.value:bb.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return db=e.slice(a,1<d?1-d:void 0)}function fb(){return !0}function gb(){return !1}
  function y$1(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?fb:gb;this.isPropagationStopped=gb;return this}
  objectAssign(y$1.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=fb);},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=fb);},persist:function(){this.isPersistent=fb;},isPersistent:gb,destructor:function(){var a=this.constructor.Interface,
  b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=gb;this._dispatchInstances=this._dispatchListeners=null;}});y$1.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
  y$1.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;objectAssign(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=objectAssign({},d.Interface,a);c.extend=d.extend;hb(c);return c};hb(y$1);function ib(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function jb(a){a instanceof this?void 0:x$1("279");a.destructor();10>this.eventPool.length&&this.eventPool.push(a);}
  function hb(a){a.eventPool=[];a.getPooled=ib;a.release=jb;}var kb=y$1.extend({data:null}),lb=y$1.extend({data:null}),mb=[9,13,27,32],nb=Ra&&"CompositionEvent"in window,ob=null;Ra&&"documentMode"in document&&(ob=document.documentMode);
  var pb=Ra&&"TextEvent"in window&&!ob,qb=Ra&&(!nb||ob&&8<ob&&11>=ob),rb=String.fromCharCode(32),sb={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
  captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},tb=!1;
  function ub(a,b){switch(a){case "keyup":return -1!==mb.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return !0;default:return !1}}function vb(a){a=a.detail;return "object"===typeof a&&"data"in a?a.data:null}var wb=!1;function xb(a,b){switch(a){case "compositionend":return vb(b);case "keypress":if(32!==b.which)return null;tb=!0;return rb;case "textInput":return a=b.data,a===rb&&tb?null:a;default:return null}}
  function yb(a,b){if(wb)return "compositionend"===a||!nb&&ub(a,b)?(a=eb(),db=cb=bb=null,wb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return qb&&"ko"!==b.locale?null:b.data;default:return null}}
  var zb={eventTypes:sb,extractEvents:function(a,b,c,d){var e=void 0;var f=void 0;if(nb)b:{switch(a){case "compositionstart":e=sb.compositionStart;break b;case "compositionend":e=sb.compositionEnd;break b;case "compositionupdate":e=sb.compositionUpdate;break b}e=void 0;}else wb?ub(a,c)&&(e=sb.compositionEnd):"keydown"===a&&229===c.keyCode&&(e=sb.compositionStart);e?(qb&&"ko"!==c.locale&&(wb||e!==sb.compositionStart?e===sb.compositionEnd&&wb&&(f=eb()):(bb=d,cb="value"in bb?bb.value:bb.textContent,wb=
  !0)),e=kb.getPooled(e,b,c,d),f?e.data=f:(f=vb(c),null!==f&&(e.data=f)),Qa(e),f=e):f=null;(a=pb?xb(a,c):yb(a,c))?(b=lb.getPooled(sb.beforeInput,b,c,d),b.data=a,Qa(b)):b=null;return null===f?b:null===b?f:[f,b]}},Ab=null,Bb=null,Cb=null;function Db(a){if(a=ua(a)){"function"!==typeof Ab?x$1("280"):void 0;var b=ta(a.stateNode);Ab(a.stateNode,a.type,b);}}function Eb(a){Bb?Cb?Cb.push(a):Cb=[a]:Bb=a;}function Fb(){if(Bb){var a=Bb,b=Cb;Cb=Bb=null;Db(a);if(b)for(a=0;a<b.length;a++)Db(b[a]);}}
  function Gb(a,b){return a(b)}function Hb(a,b,c){return a(b,c)}function Ib(){}var Jb=!1;function Kb(a,b){if(Jb)return a(b);Jb=!0;try{return Gb(a,b)}finally{if(Jb=!1,null!==Bb||null!==Cb)Ib(),Fb();}}var Lb={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Mb(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return "input"===b?!!Lb[a.type]:"textarea"===b?!0:!1}
  function Nb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function Ob(a){if(!Ra)return !1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Pb(a){var b=a.type;return (a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
  function Qb(a){var b=Pb(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a);}});Object.defineProperty(a,b,{enumerable:c.enumerable});return {getValue:function(){return d},setValue:function(a){d=""+a;},stopTracking:function(){a._valueTracker=
  null;delete a[b];}}}}function Rb(a){a._valueTracker||(a._valueTracker=Qb(a));}function Sb(a){if(!a)return !1;var b=a._valueTracker;if(!b)return !0;var c=b.getValue();var d="";a&&(d=Pb(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Tb=react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;Tb.hasOwnProperty("ReactCurrentDispatcher")||(Tb.ReactCurrentDispatcher={current:null});
  var Ub=/^(.*)[\\\/]/,z$1="function"===typeof Symbol&&Symbol.for,Vb=z$1?Symbol.for("react.element"):60103,Wb=z$1?Symbol.for("react.portal"):60106,Xb=z$1?Symbol.for("react.fragment"):60107,Yb=z$1?Symbol.for("react.strict_mode"):60108,Zb=z$1?Symbol.for("react.profiler"):60114,$b=z$1?Symbol.for("react.provider"):60109,ac=z$1?Symbol.for("react.context"):60110,bc=z$1?Symbol.for("react.concurrent_mode"):60111,cc=z$1?Symbol.for("react.forward_ref"):60112,dc=z$1?Symbol.for("react.suspense"):60113,ec=z$1?Symbol.for("react.memo"):
  60115,fc=z$1?Symbol.for("react.lazy"):60116,gc="function"===typeof Symbol&&Symbol.iterator;function hc(a){if(null===a||"object"!==typeof a)return null;a=gc&&a[gc]||a["@@iterator"];return "function"===typeof a?a:null}
  function ic(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case bc:return "ConcurrentMode";case Xb:return "Fragment";case Wb:return "Portal";case Zb:return "Profiler";case Yb:return "StrictMode";case dc:return "Suspense"}if("object"===typeof a)switch(a.$$typeof){case ac:return "Context.Consumer";case $b:return "Context.Provider";case cc:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+
  ")":"ForwardRef");case ec:return ic(a.type);case fc:if(a=1===a._status?a._result:null)return ic(a)}return null}function jc(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=ic(a.type);c=null;d&&(c=ic(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(Ub,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f;}b+=c;a=a.return;}while(a);return b}
  var kc=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,lc=Object.prototype.hasOwnProperty,mc={},nc={};
  function oc(a){if(lc.call(nc,a))return !0;if(lc.call(mc,a))return !1;if(kc.test(a))return nc[a]=!0;mc[a]=!0;return !1}function pc(a,b,c,d){if(null!==c&&0===c.type)return !1;switch(typeof b){case "function":case "symbol":return !0;case "boolean":if(d)return !1;if(null!==c)return !c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return "data-"!==a&&"aria-"!==a;default:return !1}}
  function qc(a,b,c,d){if(null===b||"undefined"===typeof b||pc(a,b,c,d))return !0;if(d)return !1;if(null!==c)switch(c.type){case 3:return !b;case 4:return !1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return !1}function C$1(a,b,c,d,e){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;}var D$1={};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){D$1[a]=new C$1(a,0,!1,a,null);});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];D$1[b]=new C$1(b,1,!1,a[1],null);});["contentEditable","draggable","spellCheck","value"].forEach(function(a){D$1[a]=new C$1(a,2,!1,a.toLowerCase(),null);});
  ["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){D$1[a]=new C$1(a,2,!1,a,null);});"allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){D$1[a]=new C$1(a,3,!1,a.toLowerCase(),null);});["checked","multiple","muted","selected"].forEach(function(a){D$1[a]=new C$1(a,3,!0,a,null);});
  ["capture","download"].forEach(function(a){D$1[a]=new C$1(a,4,!1,a,null);});["cols","rows","size","span"].forEach(function(a){D$1[a]=new C$1(a,6,!1,a,null);});["rowSpan","start"].forEach(function(a){D$1[a]=new C$1(a,5,!1,a.toLowerCase(),null);});var rc=/[\-:]([a-z])/g;function sc(a){return a[1].toUpperCase()}
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(rc,
  sc);D$1[b]=new C$1(b,1,!1,a,null);});"xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(rc,sc);D$1[b]=new C$1(b,1,!1,a,"http://www.w3.org/1999/xlink");});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(rc,sc);D$1[b]=new C$1(b,1,!1,a,"http://www.w3.org/XML/1998/namespace");});["tabIndex","crossOrigin"].forEach(function(a){D$1[a]=new C$1(a,1,!1,a.toLowerCase(),null);});
  function tc(a,b,c,d){var e=D$1.hasOwnProperty(b)?D$1[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qc(b,c,e,d)&&(c=null),d||null===e?oc(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))));}
  function uc(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return ""}}function vc(a,b){var c=b.checked;return objectAssign({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}
  function wc(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=uc(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value};}function xc(a,b){b=b.checked;null!=b&&tc(a,"checked",b,!1);}
  function yc(a,b){xc(a,b);var c=uc(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c;}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?zc(a,b.type,c):b.hasOwnProperty("defaultValue")&&zc(a,b.type,uc(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked);}
  function Ac(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b;}c=a.name;""!==c&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c);}
  function zc(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c);}var Bc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function Cc(a,b,c){a=y$1.getPooled(Bc.change,a,b,c);a.type="change";Eb(c);Qa(a);return a}var Dc=null,Ec=null;function Fc(a){Da(a);}
  function Gc(a){var b=Ja(a);if(Sb(b))return a}function Hc(a,b){if("change"===a)return b}var Ic=!1;Ra&&(Ic=Ob("input")&&(!document.documentMode||9<document.documentMode));function Jc(){Dc&&(Dc.detachEvent("onpropertychange",Kc),Ec=Dc=null);}function Kc(a){"value"===a.propertyName&&Gc(Ec)&&(a=Cc(Ec,a,Nb(a)),Kb(Fc,a));}function Lc(a,b,c){"focus"===a?(Jc(),Dc=b,Ec=c,Dc.attachEvent("onpropertychange",Kc)):"blur"===a&&Jc();}function Mc(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return Gc(Ec)}
  function Nc(a,b){if("click"===a)return Gc(b)}function Oc(a,b){if("input"===a||"change"===a)return Gc(b)}
  var Pc={eventTypes:Bc,_isInputEventSupported:Ic,extractEvents:function(a,b,c,d){var e=b?Ja(b):window,f=void 0,g=void 0,h=e.nodeName&&e.nodeName.toLowerCase();"select"===h||"input"===h&&"file"===e.type?f=Hc:Mb(e)?Ic?f=Oc:(f=Mc,g=Lc):(h=e.nodeName)&&"input"===h.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(f=Nc);if(f&&(f=f(a,b)))return Cc(f,c,d);g&&g(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&zc(e,"number",e.value);}},Qc=y$1.extend({view:null,detail:null}),Rc={Alt:"altKey",
  Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Sc(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Rc[a])?!!b[a]:!1}function Tc(){return Sc}
  var Uc=0,Vc=0,Wc=!1,Xc=!1,Yc=Qc.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Tc,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=Uc;Uc=a.screenX;return Wc?"mousemove"===a.type?a.screenX-b:0:(Wc=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;
  var b=Vc;Vc=a.screenY;return Xc?"mousemove"===a.type?a.screenY-b:0:(Xc=!0,0)}}),Zc=Yc.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),$c={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",
  dependencies:["pointerout","pointerover"]}},ad={eventTypes:$c,extractEvents:function(a,b,c,d){var e="mouseover"===a||"pointerover"===a,f="mouseout"===a||"pointerout"===a;if(e&&(c.relatedTarget||c.fromElement)||!f&&!e)return null;e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;f?(f=b,b=(b=c.relatedTarget||c.toElement)?Ha(b):null):f=null;if(f===b)return null;var g=void 0,h=void 0,l=void 0,k=void 0;if("mouseout"===a||"mouseover"===a)g=Yc,h=$c.mouseLeave,l=$c.mouseEnter,k="mouse";
  else if("pointerout"===a||"pointerover"===a)g=Zc,h=$c.pointerLeave,l=$c.pointerEnter,k="pointer";var m=null==f?e:Ja(f);e=null==b?e:Ja(b);a=g.getPooled(h,f,c,d);a.type=k+"leave";a.target=m;a.relatedTarget=e;c=g.getPooled(l,b,c,d);c.type=k+"enter";c.target=e;c.relatedTarget=m;d=b;if(f&&d)a:{b=f;e=d;k=0;for(g=b;g;g=La(g))k++;g=0;for(l=e;l;l=La(l))g++;for(;0<k-g;)b=La(b),k--;for(;0<g-k;)e=La(e),g--;for(;k--;){if(b===e||b===e.alternate)break a;b=La(b);e=La(e);}b=null;}else b=null;e=b;for(b=[];f&&f!==e;){k=
  f.alternate;if(null!==k&&k===e)break;b.push(f);f=La(f);}for(f=[];d&&d!==e;){k=d.alternate;if(null!==k&&k===e)break;f.push(d);d=La(d);}for(d=0;d<b.length;d++)Oa(b[d],"bubbled",a);for(d=f.length;0<d--;)Oa(f[d],"captured",c);return [a,c]}};function bd(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var cd=Object.prototype.hasOwnProperty;
  function dd(a,b){if(bd(a,b))return !0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return !1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return !1;for(d=0;d<c.length;d++)if(!cd.call(b,c[d])||!bd(a[c[d]],b[c[d]]))return !1;return !0}function ed(a){var b=a;if(a.alternate)for(;b.return;)b=b.return;else{if(0!==(b.effectTag&2))return 1;for(;b.return;)if(b=b.return,0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function fd(a){2!==ed(a)?x$1("188"):void 0;}
  function gd(a){var b=a.alternate;if(!b)return b=ed(a),3===b?x$1("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c.return,f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return fd(e),a;if(g===d)return fd(e),b;g=g.sibling;}x$1("188");}if(c.return!==d.return)c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling;}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling;}g?
  void 0:x$1("189");}}c.alternate!==d?x$1("190"):void 0;}3!==c.tag?x$1("188"):void 0;return c.stateNode.current===c?a:b}function hd(a){a=gd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return;}b.sibling.return=b.return;b=b.sibling;}}return null}
  var id=y$1.extend({animationName:null,elapsedTime:null,pseudoElement:null}),jd=y$1.extend({clipboardData:function(a){return "clipboardData"in a?a.clipboardData:window.clipboardData}}),kd=Qc.extend({relatedTarget:null});function ld(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}
  var md={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
  116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},od=Qc.extend({key:function(a){if(a.key){var b=md[a.key]||a.key;if("Unidentified"!==b)return b}return "keypress"===a.type?(a=ld(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?nd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Tc,charCode:function(a){return "keypress"===
  a.type?ld(a):0},keyCode:function(a){return "keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return "keypress"===a.type?ld(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),pd=Yc.extend({dataTransfer:null}),qd=Qc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Tc}),rd=y$1.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),sd=Yc.extend({deltaX:function(a){return "deltaX"in a?a.deltaX:"wheelDeltaX"in
  a?-a.wheelDeltaX:0},deltaY:function(a){return "deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),td=[["abort","abort"],[Xa,"animationEnd"],[Ya,"animationIteration"],[Za,"animationStart"],["canplay","canPlay"],["canplaythrough","canPlayThrough"],["drag","drag"],["dragenter","dragEnter"],["dragexit","dragExit"],["dragleave","dragLeave"],["dragover","dragOver"],["durationchange","durationChange"],["emptied","emptied"],["encrypted","encrypted"],
  ["ended","ended"],["error","error"],["gotpointercapture","gotPointerCapture"],["load","load"],["loadeddata","loadedData"],["loadedmetadata","loadedMetadata"],["loadstart","loadStart"],["lostpointercapture","lostPointerCapture"],["mousemove","mouseMove"],["mouseout","mouseOut"],["mouseover","mouseOver"],["playing","playing"],["pointermove","pointerMove"],["pointerout","pointerOut"],["pointerover","pointerOver"],["progress","progress"],["scroll","scroll"],["seeking","seeking"],["stalled","stalled"],
  ["suspend","suspend"],["timeupdate","timeUpdate"],["toggle","toggle"],["touchmove","touchMove"],[$a,"transitionEnd"],["waiting","waiting"],["wheel","wheel"]],ud={},vd={};function wd(a,b){var c=a[0];a=a[1];var d="on"+(a[0].toUpperCase()+a.slice(1));b={phasedRegistrationNames:{bubbled:d,captured:d+"Capture"},dependencies:[c],isInteractive:b};ud[a]=b;vd[c]=b;}
  [["blur","blur"],["cancel","cancel"],["click","click"],["close","close"],["contextmenu","contextMenu"],["copy","copy"],["cut","cut"],["auxclick","auxClick"],["dblclick","doubleClick"],["dragend","dragEnd"],["dragstart","dragStart"],["drop","drop"],["focus","focus"],["input","input"],["invalid","invalid"],["keydown","keyDown"],["keypress","keyPress"],["keyup","keyUp"],["mousedown","mouseDown"],["mouseup","mouseUp"],["paste","paste"],["pause","pause"],["play","play"],["pointercancel","pointerCancel"],
  ["pointerdown","pointerDown"],["pointerup","pointerUp"],["ratechange","rateChange"],["reset","reset"],["seeked","seeked"],["submit","submit"],["touchcancel","touchCancel"],["touchend","touchEnd"],["touchstart","touchStart"],["volumechange","volumeChange"]].forEach(function(a){wd(a,!0);});td.forEach(function(a){wd(a,!1);});
  var xd={eventTypes:ud,isInteractiveTopLevelEventType:function(a){a=vd[a];return void 0!==a&&!0===a.isInteractive},extractEvents:function(a,b,c,d){var e=vd[a];if(!e)return null;switch(a){case "keypress":if(0===ld(c))return null;case "keydown":case "keyup":a=od;break;case "blur":case "focus":a=kd;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=Yc;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
  pd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=qd;break;case Xa:case Ya:case Za:a=id;break;case $a:a=rd;break;case "scroll":a=Qc;break;case "wheel":a=sd;break;case "copy":case "cut":case "paste":a=jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=Zc;break;default:a=y$1;}b=a.getPooled(e,b,c,d);Qa(b);return b}},yd=xd.isInteractiveTopLevelEventType,
  zd=[];function Ad(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d;for(d=c;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo;if(!d)break;a.ancestors.push(c);c=Ha(d);}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Nb(a.nativeEvent);d=a.topLevelType;for(var f=a.nativeEvent,g=null,h=0;h<oa.length;h++){var l=oa[h];l&&(l=l.extractEvents(d,b,f,e))&&(g=xa(g,l));}Da(g);}}var Bd=!0;
  function E$1(a,b){if(!b)return null;var c=(yd(a)?Cd:Dd).bind(null,a);b.addEventListener(a,c,!1);}function Ed(a,b){if(!b)return null;var c=(yd(a)?Cd:Dd).bind(null,a);b.addEventListener(a,c,!0);}function Cd(a,b){Hb(Dd,a,b);}
  function Dd(a,b){if(Bd){var c=Nb(b);c=Ha(c);null===c||"number"!==typeof c.tag||2===ed(c)||(c=null);if(zd.length){var d=zd.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d;}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{Kb(Ad,a);}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>zd.length&&zd.push(a);}}}var Fd={},Gd=0,Hd="_reactListenersID"+(""+Math.random()).slice(2);
  function Id(a){Object.prototype.hasOwnProperty.call(a,Hd)||(a[Hd]=Gd++,Fd[a[Hd]]={});return Fd[a[Hd]]}function Jd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function Kd(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
  function Ld(a,b){var c=Kd(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return {node:c,offset:b-a};a=d;}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode;}c=void 0;}c=Kd(c);}}function Md(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Md(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
  function Nd(){for(var a=window,b=Jd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href;}catch(d){c=!1;}if(c)a=b.contentWindow;else break;b=Jd(a.document);}return b}function Od(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
  function Pd(){var a=Nd();if(Od(a)){if("selectionStart"in a)var b={start:a.selectionStart,end:a.selectionEnd};else a:{b=(b=a.ownerDocument)&&b.defaultView||window;var c=b.getSelection&&b.getSelection();if(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType;}catch(A){b=null;break a}var f=0,g=-1,h=-1,l=0,k=0,m=a,p=null;b:for(;;){for(var t;;){m!==b||0!==d&&3!==m.nodeType||(g=f+d);m!==e||0!==c&&3!==m.nodeType||(h=f+c);3===m.nodeType&&(f+=m.nodeValue.length);
  if(null===(t=m.firstChild))break;p=m;m=t;}for(;;){if(m===a)break b;p===b&&++l===d&&(g=f);p===e&&++k===c&&(h=f);if(null!==(t=m.nextSibling))break;m=p;p=m.parentNode;}m=t;}b=-1===g||-1===h?null:{start:g,end:h};}else b=null;}b=b||{start:0,end:0};}else b=null;return {focusedElem:a,selectionRange:b}}
  function Qd(a){var b=Nd(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Md(c.ownerDocument.documentElement,c)){if(null!==d&&Od(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ld(c,f);var g=Ld(c,
  d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)));}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top;}}
  var Rd=Ra&&"documentMode"in document&&11>=document.documentMode,Sd={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},Td=null,Ud=null,Vd=null,Wd=!1;
  function Xd(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(Wd||null==Td||Td!==Jd(c))return null;c=Td;"selectionStart"in c&&Od(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Vd&&dd(Vd,c)?null:(Vd=c,a=y$1.getPooled(Sd.select,Ud,a,b),a.type="select",a.target=Td,Qa(a),a)}
  var Yd={eventTypes:Sd,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Id(e);f=sa.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0;}f=!e;}if(f)return null;e=b?Ja(b):window;switch(a){case "focus":if(Mb(e)||"true"===e.contentEditable)Td=e,Ud=b,Vd=null;break;case "blur":Vd=Ud=Td=null;break;case "mousedown":Wd=!0;break;case "contextmenu":case "mouseup":case "dragend":return Wd=!1,Xd(c,d);case "selectionchange":if(Rd)break;
  case "keydown":case "keyup":return Xd(c,d)}return null}};Ba.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));ta=Ka;ua=Ia;va=Ja;Ba.injectEventPluginsByName({SimpleEventPlugin:xd,EnterLeaveEventPlugin:ad,ChangeEventPlugin:Pc,SelectEventPlugin:Yd,BeforeInputEventPlugin:zb});function Zd(a){var b="";react.Children.forEach(a,function(a){null!=a&&(b+=a);});return b}
  function $d(a,b){a=objectAssign({children:void 0},b);if(b=Zd(b.children))a.children=b;return a}function ae(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0);}else{c=""+uc(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e]);}null!==b&&(b.selected=!0);}}
  function be(a,b){null!=b.dangerouslySetInnerHTML?x$1("91"):void 0;return objectAssign({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function ce(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?x$1("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:x$1("93"),b=b[0]),c=b),null==c&&(c=""));a._wrapperState={initialValue:uc(c)};}
  function de(a,b){var c=uc(b.value),d=uc(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d);}function ee(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b);}var fe={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
  function ge(a){switch(a){case "svg":return "http://www.w3.org/2000/svg";case "math":return "http://www.w3.org/1998/Math/MathML";default:return "http://www.w3.org/1999/xhtml"}}function he(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?ge(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
  var ie=void 0,je=function(a){return "undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)});}:a}(function(a,b){if(a.namespaceURI!==fe.svg||"innerHTML"in a)a.innerHTML=b;else{ie=ie||document.createElement("div");ie.innerHTML="<svg>"+b+"</svg>";for(b=ie.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild);}});
  function ke(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b;}
  var le={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
  floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},me=["Webkit","ms","Moz","O"];Object.keys(le).forEach(function(a){me.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);le[b]=le[a];});});function ne(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||le.hasOwnProperty(a)&&le[a]?(""+b).trim():b+"px"}
  function oe(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ne(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e;}}var pe=objectAssign({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
  function qe(a,b){b&&(pe[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?x$1("137",a,""):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?x$1("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:x$1("61")),null!=b.style&&"object"!==typeof b.style?x$1("62",""):void 0);}
  function re(a,b){if(-1===a.indexOf("-"))return "string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return !1;default:return !0}}
  function se(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Id(a);b=sa[b];for(var d=0;d<b.length;d++){var e=b[d];if(!c.hasOwnProperty(e)||!c[e]){switch(e){case "scroll":Ed("scroll",a);break;case "focus":case "blur":Ed("focus",a);Ed("blur",a);c.blur=!0;c.focus=!0;break;case "cancel":case "close":Ob(e)&&Ed(e,a);break;case "invalid":case "submit":case "reset":break;default:-1===ab.indexOf(e)&&E$1(e,a);}c[e]=!0;}}}function te(){}var ue=null,ve=null;
  function we(a,b){switch(a){case "button":case "input":case "select":case "textarea":return !!b.autoFocus}return !1}function xe(a,b){return "textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
  var ye="function"===typeof setTimeout?setTimeout:void 0,ze="function"===typeof clearTimeout?clearTimeout:void 0,Ae=scheduler.unstable_scheduleCallback,Be=scheduler.unstable_cancelCallback;
  function Ce(a,b,c,d,e){a[Ga]=e;"input"===c&&"radio"===e.type&&null!=e.name&&xc(a,e);re(c,d);d=re(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];"style"===g?oe(a,h):"dangerouslySetInnerHTML"===g?je(a,h):"children"===g?ke(a,h):tc(a,g,h,d);}switch(c){case "input":yc(a,e);break;case "textarea":de(a,e);break;case "select":b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?ae(a,!!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?ae(a,!!e.multiple,e.defaultValue,
  !0):ae(a,!!e.multiple,e.multiple?[]:"",!1));}}function De(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a}function Ee(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a}var Fe=[],Ge=-1;function F$1(a){0>Ge||(a.current=Fe[Ge],Fe[Ge]=null,Ge--);}function G$1(a,b){Ge++;Fe[Ge]=a.current;a.current=b;}var He={},H$1={current:He},I$1={current:!1},Ie=He;
  function Je(a,b){var c=a.type.contextTypes;if(!c)return He;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function J$1(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Ke(a){F$1(I$1,a);F$1(H$1,a);}function Le(a){F$1(I$1,a);F$1(H$1,a);}
  function Me(a,b,c){H$1.current!==He?x$1("168"):void 0;G$1(H$1,b,a);G$1(I$1,c,a);}function Ne(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)e in a?void 0:x$1("108",ic(b)||"Unknown",e);return objectAssign({},c,d)}function Oe(a){var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||He;Ie=H$1.current;G$1(H$1,b,a);G$1(I$1,I$1.current,a);return !0}
  function Pe(a,b,c){var d=a.stateNode;d?void 0:x$1("169");c?(b=Ne(a,b,Ie),d.__reactInternalMemoizedMergedChildContext=b,F$1(I$1,a),F$1(H$1,a),G$1(H$1,b,a)):F$1(I$1,a);G$1(I$1,c,a);}var Qe=null,Re=null;function Se(a){return function(b){try{return a(b)}catch(c){}}}
  function Te(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return !1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return !0;try{var c=b.inject(a);Qe=Se(function(a){return b.onCommitFiberRoot(c,a)});Re=Se(function(a){return b.onCommitFiberUnmount(c,a)});}catch(d){}return !0}
  function Ue(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.contextDependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null;}function K$1(a,b,c,d){return new Ue(a,b,c,d)}
  function Ve(a){a=a.prototype;return !(!a||!a.isReactComponent)}function We(a){if("function"===typeof a)return Ve(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===cc)return 11;if(a===ec)return 14}return 2}
  function Xe(a,b){var c=a.alternate;null===c?(c=K$1(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;c.contextDependencies=a.contextDependencies;c.sibling=a.sibling;
  c.index=a.index;c.ref=a.ref;return c}
  function Ye(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ve(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case Xb:return Ze(c.children,e,f,b);case bc:return $e(c,e|3,f,b);case Yb:return $e(c,e|2,f,b);case Zb:return a=K$1(12,c,b,e|4),a.elementType=Zb,a.type=Zb,a.expirationTime=f,a;case dc:return a=K$1(13,c,b,e),a.elementType=dc,a.type=dc,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case $b:g=10;break a;case ac:g=9;break a;case cc:g=11;break a;case ec:g=
  14;break a;case fc:g=16;d=null;break a}x$1("130",null==a?a:typeof a,"");}b=K$1(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ze(a,b,c,d){a=K$1(7,a,d,b);a.expirationTime=c;return a}function $e(a,b,c,d){a=K$1(8,a,d,b);b=0===(b&1)?Yb:bc;a.elementType=b;a.type=b;a.expirationTime=c;return a}function af(a,b,c){a=K$1(6,a,null,b);a.expirationTime=c;return a}
  function bf(a,b,c){b=K$1(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function cf(a,b){a.didError=!1;var c=a.earliestPendingTime;0===c?a.earliestPendingTime=a.latestPendingTime=b:c<b?a.earliestPendingTime=b:a.latestPendingTime>b&&(a.latestPendingTime=b);df(b,a);}
  function ef(a,b){a.didError=!1;if(0===b)a.earliestPendingTime=0,a.latestPendingTime=0,a.earliestSuspendedTime=0,a.latestSuspendedTime=0,a.latestPingedTime=0;else{b<a.latestPingedTime&&(a.latestPingedTime=0);var c=a.latestPendingTime;0!==c&&(c>b?a.earliestPendingTime=a.latestPendingTime=0:a.earliestPendingTime>b&&(a.earliestPendingTime=a.latestPendingTime));c=a.earliestSuspendedTime;0===c?cf(a,b):b<a.latestSuspendedTime?(a.earliestSuspendedTime=0,a.latestSuspendedTime=0,a.latestPingedTime=0,cf(a,b)):
  b>c&&cf(a,b);}df(0,a);}function ff(a,b){a.didError=!1;a.latestPingedTime>=b&&(a.latestPingedTime=0);var c=a.earliestPendingTime,d=a.latestPendingTime;c===b?a.earliestPendingTime=d===b?a.latestPendingTime=0:d:d===b&&(a.latestPendingTime=c);c=a.earliestSuspendedTime;d=a.latestSuspendedTime;0===c?a.earliestSuspendedTime=a.latestSuspendedTime=b:c<b?a.earliestSuspendedTime=b:d>b&&(a.latestSuspendedTime=b);df(b,a);}
  function gf(a,b){var c=a.earliestPendingTime;a=a.earliestSuspendedTime;c>b&&(b=c);a>b&&(b=a);return b}function df(a,b){var c=b.earliestSuspendedTime,d=b.latestSuspendedTime,e=b.earliestPendingTime,f=b.latestPingedTime;e=0!==e?e:f;0===e&&(0===a||d<a)&&(e=d);a=e;0!==a&&c>a&&(a=c);b.nextExpirationTimeToWorkOn=e;b.expirationTime=a;}function L$1(a,b){if(a&&a.defaultProps){b=objectAssign({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);}return b}
  function hf(a){var b=a._result;switch(a._status){case 1:return b;case 2:throw b;case 0:throw b;default:a._status=0;b=a._ctor;b=b();b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b);},function(b){0===a._status&&(a._status=2,a._result=b);});switch(a._status){case 1:return a._result;case 2:throw a._result;}a._result=b;throw b;}}var jf=(new react.Component).refs;
  function kf(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:objectAssign({},b,c);a.memoizedState=c;d=a.updateQueue;null!==d&&0===a.expirationTime&&(d.baseState=c);}
  var tf={isMounted:function(a){return (a=a._reactInternalFiber)?2===ed(a):!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=lf();d=mf(d,a);var e=nf(d);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);of();pf(a,e);qf(a,d);},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=lf();d=mf(d,a);var e=nf(d);e.tag=rf;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);of();pf(a,e);qf(a,d);},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=lf();c=mf(c,a);var d=nf(c);d.tag=
  sf;void 0!==b&&null!==b&&(d.callback=b);of();pf(a,d);qf(a,c);}};function uf(a,b,c,d,e,f,g){a=a.stateNode;return "function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!dd(c,d)||!dd(e,f):!0}
  function vf(a,b,c){var d=!1,e=He;var f=b.contextType;"object"===typeof f&&null!==f?f=M$1(f):(e=J$1(b)?Ie:H$1.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Je(a,e):He);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=tf;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
  function wf(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&tf.enqueueReplaceState(b,b.state,null);}
  function xf(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=jf;var f=b.contextType;"object"===typeof f&&null!==f?e.context=M$1(f):(f=J$1(b)?Ie:H$1.current,e.context=Je(a,f));f=a.updateQueue;null!==f&&(yf(a,f,c,e,d),e.state=a.memoizedState);f=b.getDerivedStateFromProps;"function"===typeof f&&(kf(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==
  typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&tf.enqueueReplaceState(e,e.state,null),f=a.updateQueue,null!==f&&(yf(a,f,c,e,d),e.state=a.memoizedState));"function"===typeof e.componentDidMount&&(a.effectTag|=4);}var zf=Array.isArray;
  function Af(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;var d=void 0;c&&(1!==c.tag?x$1("309"):void 0,d=c.stateNode);d?void 0:x$1("147",a);var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===jf&&(b=d.refs={});null===a?delete b[e]:b[e]=a;};b._stringRef=e;return b}"string"!==typeof a?x$1("284"):void 0;c._owner?void 0:x$1("290",a);}return a}
  function Bf(a,b){"textarea"!==a.type&&x$1("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"");}
  function Cf(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8;}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=Xe(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
  2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=af(c,a.mode,d),b.return=a,b;b=e(b,c,d);b.return=a;return b}function l(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props,d),d.ref=Af(a,b,c),d.return=a,d;d=Ye(c.type,c.key,c.props,null,a.mode,d);d.ref=Af(a,b,c);d.return=a;return d}function k(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
  c.implementation)return b=bf(c,a.mode,d),b.return=a,b;b=e(b,c.children||[],d);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ze(c,a.mode,d,f),b.return=a,b;b=e(b,c,d);b.return=a;return b}function p(a,b,c){if("string"===typeof b||"number"===typeof b)return b=af(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Vb:return c=Ye(b.type,b.key,b.props,null,a.mode,c),c.ref=Af(a,null,b),c.return=a,c;case Wb:return b=bf(b,a.mode,c),b.return=a,b}if(zf(b)||
  hc(b))return b=Ze(b,a.mode,c,null),b.return=a,b;Bf(a,b);}return null}function t(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Vb:return c.key===e?c.type===Xb?m(a,b,c.props.children,d,e):l(a,b,c,d):null;case Wb:return c.key===e?k(a,b,c,d):null}if(zf(c)||hc(c))return null!==e?null:m(a,b,c,d,null);Bf(a,c);}return null}function A(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=
  a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Vb:return a=a.get(null===d.key?c:d.key)||null,d.type===Xb?m(b,a,d.props.children,e,d.key):l(b,a,d,e);case Wb:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e)}if(zf(d)||hc(d))return a=a.get(c)||null,m(b,a,d,e,null);Bf(b,d);}return null}function v(e,g,h,k){for(var l=null,m=null,q=g,u=g=0,B=null;null!==q&&u<h.length;u++){q.index>u?(B=q,q=null):B=q.sibling;var w=t(e,q,h[u],k);if(null===w){null===q&&(q=B);break}a&&
  q&&null===w.alternate&&b(e,q);g=f(w,g,u);null===m?l=w:m.sibling=w;m=w;q=B;}if(u===h.length)return c(e,q),l;if(null===q){for(;u<h.length;u++)if(q=p(e,h[u],k))g=f(q,g,u),null===m?l=q:m.sibling=q,m=q;return l}for(q=d(e,q);u<h.length;u++)if(B=A(q,e,u,h[u],k))a&&null!==B.alternate&&q.delete(null===B.key?u:B.key),g=f(B,g,u),null===m?l=B:m.sibling=B,m=B;a&&q.forEach(function(a){return b(e,a)});return l}function R(e,g,h,k){var l=hc(h);"function"!==typeof l?x$1("150"):void 0;h=l.call(h);null==h?x$1("151"):void 0;
  for(var m=l=null,q=g,u=g=0,B=null,w=h.next();null!==q&&!w.done;u++,w=h.next()){q.index>u?(B=q,q=null):B=q.sibling;var v=t(e,q,w.value,k);if(null===v){q||(q=B);break}a&&q&&null===v.alternate&&b(e,q);g=f(v,g,u);null===m?l=v:m.sibling=v;m=v;q=B;}if(w.done)return c(e,q),l;if(null===q){for(;!w.done;u++,w=h.next())w=p(e,w.value,k),null!==w&&(g=f(w,g,u),null===m?l=w:m.sibling=w,m=w);return l}for(q=d(e,q);!w.done;u++,w=h.next())w=A(q,e,u,w.value,k),null!==w&&(a&&null!==w.alternate&&q.delete(null===w.key?u:
  w.key),g=f(w,g,u),null===m?l=w:m.sibling=w,m=w);a&&q.forEach(function(a){return b(e,a)});return l}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===Xb&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case Vb:a:{l=f.key;for(k=d;null!==k;){if(k.key===l)if(7===k.tag?f.type===Xb:k.elementType===f.type){c(a,k.sibling);d=e(k,f.type===Xb?f.props.children:f.props,h);d.ref=Af(a,k,f);d.return=a;a=d;break a}else{c(a,k);break}else b(a,k);k=
  k.sibling;}f.type===Xb?(d=Ze(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Ye(f.type,f.key,f.props,null,a.mode,h),h.ref=Af(a,d,f),h.return=a,a=h);}return g(a);case Wb:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling;}d=bf(f,a.mode,h);d.return=a;a=d;}return g(a)}if("string"===typeof f||"number"===typeof f)return f=
  ""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h),d.return=a,a=d):(c(a,d),d=af(f,a.mode,h),d.return=a,a=d),g(a);if(zf(f))return v(a,d,f,h);if(hc(f))return R(a,d,f,h);l&&Bf(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:h=a.type,x$1("152",h.displayName||h.name||"Component");}return c(a,d)}}var Df=Cf(!0),Ef=Cf(!1),Ff={},N$1={current:Ff},Gf={current:Ff},Hf={current:Ff};function If(a){a===Ff?x$1("174"):void 0;return a}
  function Jf(a,b){G$1(Hf,b,a);G$1(Gf,a,a);G$1(N$1,Ff,a);var c=b.nodeType;switch(c){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:he(null,"");break;default:c=8===c?b.parentNode:b,b=c.namespaceURI||null,c=c.tagName,b=he(b,c);}F$1(N$1,a);G$1(N$1,b,a);}function Kf(a){F$1(N$1,a);F$1(Gf,a);F$1(Hf,a);}function Lf(a){If(Hf.current);var b=If(N$1.current);var c=he(b,a.type);b!==c&&(G$1(Gf,a,a),G$1(N$1,c,a));}function Mf(a){Gf.current===a&&(F$1(N$1,a),F$1(Gf,a));}
  var Nf=0,Of=2,Pf=4,Qf=8,Rf=16,Sf=32,Tf=64,Uf=128,Vf=Tb.ReactCurrentDispatcher,Wf=0,Xf=null,O$1=null,P$1=null,Yf=null,Q$1=null,Zf=null,$f=0,ag=null,bg=0,cg=!1,dg=null,eg=0;function fg(){x$1("321");}function gg(a,b){if(null===b)return !1;for(var c=0;c<b.length&&c<a.length;c++)if(!bd(a[c],b[c]))return !1;return !0}
  function hg(a,b,c,d,e,f){Wf=f;Xf=b;P$1=null!==a?a.memoizedState:null;Vf.current=null===P$1?ig:jg;b=c(d,e);if(cg){do cg=!1,eg+=1,P$1=null!==a?a.memoizedState:null,Zf=Yf,ag=Q$1=O$1=null,Vf.current=jg,b=c(d,e);while(cg);dg=null;eg=0;}Vf.current=kg;a=Xf;a.memoizedState=Yf;a.expirationTime=$f;a.updateQueue=ag;a.effectTag|=bg;a=null!==O$1&&null!==O$1.next;Wf=0;Zf=Q$1=Yf=P$1=O$1=Xf=null;$f=0;ag=null;bg=0;a?x$1("300"):void 0;return b}function lg(){Vf.current=kg;Wf=0;Zf=Q$1=Yf=P$1=O$1=Xf=null;$f=0;ag=null;bg=0;cg=!1;dg=null;eg=0;}
  function mg(){var a={memoizedState:null,baseState:null,queue:null,baseUpdate:null,next:null};null===Q$1?Yf=Q$1=a:Q$1=Q$1.next=a;return Q$1}function ng(){if(null!==Zf)Q$1=Zf,Zf=Q$1.next,O$1=P$1,P$1=null!==O$1?O$1.next:null;else{null===P$1?x$1("310"):void 0;O$1=P$1;var a={memoizedState:O$1.memoizedState,baseState:O$1.baseState,queue:O$1.queue,baseUpdate:O$1.baseUpdate,next:null};Q$1=null===Q$1?Yf=a:Q$1.next=a;P$1=O$1.next;}return Q$1}function og(a,b){return "function"===typeof b?b(a):b}
  function pg(a){var b=ng(),c=b.queue;null===c?x$1("311"):void 0;c.lastRenderedReducer=a;if(0<eg){var d=c.dispatch;if(null!==dg){var e=dg.get(c);if(void 0!==e){dg.delete(c);var f=b.memoizedState;do f=a(f,e.action),e=e.next;while(null!==e);bd(f,b.memoizedState)||(qg=!0);b.memoizedState=f;b.baseUpdate===c.last&&(b.baseState=f);c.lastRenderedState=f;return [f,d]}}return [b.memoizedState,d]}d=c.last;var g=b.baseUpdate;f=b.baseState;null!==g?(null!==d&&(d.next=null),d=g.next):d=null!==d?d.next:null;if(null!==
  d){var h=e=null,l=d,k=!1;do{var m=l.expirationTime;m<Wf?(k||(k=!0,h=g,e=f),m>$f&&($f=m)):f=l.eagerReducer===a?l.eagerState:a(f,l.action);g=l;l=l.next;}while(null!==l&&l!==d);k||(h=g,e=f);bd(f,b.memoizedState)||(qg=!0);b.memoizedState=f;b.baseUpdate=h;b.baseState=e;c.lastRenderedState=f;}return [b.memoizedState,c.dispatch]}
  function rg(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};null===ag?(ag={lastEffect:null},ag.lastEffect=a.next=a):(b=ag.lastEffect,null===b?ag.lastEffect=a.next=a:(c=b.next,b.next=a,a.next=c,ag.lastEffect=a));return a}function sg(a,b,c,d){var e=mg();bg|=a;e.memoizedState=rg(b,c,void 0,void 0===d?null:d);}
  function tg(a,b,c,d){var e=ng();d=void 0===d?null:d;var f=void 0;if(null!==O$1){var g=O$1.memoizedState;f=g.destroy;if(null!==d&&gg(d,g.deps)){rg(Nf,c,f,d);return}}bg|=a;e.memoizedState=rg(b,c,f,d);}function ug(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null);};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null;}}function vg(){}
  function wg(a,b,c){25>eg?void 0:x$1("301");var d=a.alternate;if(a===Xf||null!==d&&d===Xf)if(cg=!0,a={expirationTime:Wf,action:c,eagerReducer:null,eagerState:null,next:null},null===dg&&(dg=new Map),c=dg.get(b),void 0===c)dg.set(b,a);else{for(b=c;null!==b.next;)b=b.next;b.next=a;}else{of();var e=lf();e=mf(e,a);var f={expirationTime:e,action:c,eagerReducer:null,eagerState:null,next:null},g=b.last;if(null===g)f.next=f;else{var h=g.next;null!==h&&(f.next=h);g.next=f;}b.last=f;if(0===a.expirationTime&&(null===
  d||0===d.expirationTime)&&(d=b.lastRenderedReducer,null!==d))try{var l=b.lastRenderedState,k=d(l,c);f.eagerReducer=d;f.eagerState=k;if(bd(k,l))return}catch(m){}finally{}qf(a,e);}}
  var kg={readContext:M$1,useCallback:fg,useContext:fg,useEffect:fg,useImperativeHandle:fg,useLayoutEffect:fg,useMemo:fg,useReducer:fg,useRef:fg,useState:fg,useDebugValue:fg},ig={readContext:M$1,useCallback:function(a,b){mg().memoizedState=[a,void 0===b?null:b];return a},useContext:M$1,useEffect:function(a,b){return sg(516,Uf|Tf,a,b)},useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return sg(4,Pf|Sf,ug.bind(null,b,a),c)},useLayoutEffect:function(a,b){return sg(4,Pf|Sf,a,b)},
  useMemo:function(a,b){var c=mg();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=mg();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={last:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=wg.bind(null,Xf,a);return [d.memoizedState,a]},useRef:function(a){var b=mg();a={current:a};return b.memoizedState=a},useState:function(a){var b=mg();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={last:null,dispatch:null,
  lastRenderedReducer:og,lastRenderedState:a};a=a.dispatch=wg.bind(null,Xf,a);return [b.memoizedState,a]},useDebugValue:vg},jg={readContext:M$1,useCallback:function(a,b){var c=ng();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&gg(b,d[1]))return d[0];c.memoizedState=[a,b];return a},useContext:M$1,useEffect:function(a,b){return tg(516,Uf|Tf,a,b)},useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return tg(4,Pf|Sf,ug.bind(null,b,a),c)},useLayoutEffect:function(a,
  b){return tg(4,Pf|Sf,a,b)},useMemo:function(a,b){var c=ng();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&gg(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a},useReducer:pg,useRef:function(){return ng().memoizedState},useState:function(a){return pg(og,a)},useDebugValue:vg},xg=null,yg=null,zg=!1;
  function Ag(a,b){var c=K$1(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c;}function Bg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return !1;default:return !1}}
  function Cg(a){if(zg){var b=yg;if(b){var c=b;if(!Bg(a,b)){b=De(c);if(!b||!Bg(a,b)){a.effectTag|=2;zg=!1;xg=a;return}Ag(xg,c);}xg=a;yg=Ee(b);}else a.effectTag|=2,zg=!1,xg=a;}}function Dg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&18!==a.tag;)a=a.return;xg=a;}function Eg(a){if(a!==xg)return !1;if(!zg)return Dg(a),zg=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!xe(b,a.memoizedProps))for(b=yg;b;)Ag(a,b),b=De(b);Dg(a);yg=xg?De(a.stateNode):null;return !0}function Fg(){yg=xg=null;zg=!1;}
  var Gg=Tb.ReactCurrentOwner,qg=!1;function S$1(a,b,c,d){b.child=null===a?Ef(b,null,c,d):Df(b,a.child,c,d);}function Hg(a,b,c,d,e){c=c.render;var f=b.ref;Ig(b,e);d=hg(a,b,c,d,f,e);if(null!==a&&!qg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),Jg(a,b,e);b.effectTag|=1;S$1(a,b,d,e);return b.child}
  function Kg(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ve(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,Lg(a,b,g,d,e,f);a=Ye(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:dd,c(e,d)&&a.ref===b.ref))return Jg(a,b,f);b.effectTag|=1;a=Xe(g,d,f);a.ref=b.ref;a.return=b;return b.child=a}
  function Lg(a,b,c,d,e,f){return null!==a&&dd(a.memoizedProps,d)&&a.ref===b.ref&&(qg=!1,e<f)?Jg(a,b,f):Mg(a,b,c,d,f)}function Ng(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128;}function Mg(a,b,c,d,e){var f=J$1(c)?Ie:H$1.current;f=Je(b,f);Ig(b,e);c=hg(a,b,c,d,f,e);if(null!==a&&!qg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),Jg(a,b,e);b.effectTag|=1;S$1(a,b,c,e);return b.child}
  function Og(a,b,c,d,e){if(J$1(c)){var f=!0;Oe(b);}else f=!1;Ig(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),vf(b,c,d,e),xf(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var l=g.context,k=c.contextType;"object"===typeof k&&null!==k?k=M$1(k):(k=J$1(c)?Ie:H$1.current,k=Je(b,k));var m=c.getDerivedStateFromProps,p="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;p||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
  "function"!==typeof g.componentWillReceiveProps||(h!==d||l!==k)&&wf(b,g,d,k);Pg=!1;var t=b.memoizedState;l=g.state=t;var A=b.updateQueue;null!==A&&(yf(b,A,d,g,e),l=b.memoizedState);h!==d||t!==l||I$1.current||Pg?("function"===typeof m&&(kf(b,c,m,d),l=b.memoizedState),(h=Pg||uf(b,c,h,d,t,l,k))?(p||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&
  g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=l),g.props=d,g.state=l,g.context=k,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1);}else g=b.stateNode,h=b.memoizedProps,g.props=b.type===b.elementType?h:L$1(b.type,h),l=g.context,k=c.contextType,"object"===typeof k&&null!==k?k=M$1(k):(k=J$1(c)?Ie:H$1.current,k=Je(b,k)),m=c.getDerivedStateFromProps,(p="function"===
  typeof m||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||l!==k)&&wf(b,g,d,k),Pg=!1,l=b.memoizedState,t=g.state=l,A=b.updateQueue,null!==A&&(yf(b,A,d,g,e),t=b.memoizedState),h!==d||l!==t||I$1.current||Pg?("function"===typeof m&&(kf(b,c,m,d),t=b.memoizedState),(m=Pg||uf(b,c,h,d,l,t,k))?(p||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===
  typeof g.componentWillUpdate&&g.componentWillUpdate(d,t,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,t,k)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&l===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&l===a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=
  t),g.props=d,g.state=t,g.context=k,d=m):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&l===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&l===a.memoizedState||(b.effectTag|=256),d=!1);return Qg(a,b,c,d,f,e)}
  function Qg(a,b,c,d,e,f){Ng(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Pe(b,c,!1),Jg(a,b,f);d=b.stateNode;Gg.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=Df(b,a.child,null,f),b.child=Df(b,null,h,f)):S$1(a,b,h,f);b.memoizedState=d.state;e&&Pe(b,c,!0);return b.child}function Rg(a){var b=a.stateNode;b.pendingContext?Me(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Me(a,b.context,!1);Jf(a,b.containerInfo);}
  function Sg(a,b,c){var d=b.mode,e=b.pendingProps,f=b.memoizedState;if(0===(b.effectTag&64)){f=null;var g=!1;}else f={timedOutAt:null!==f?f.timedOutAt:0},g=!0,b.effectTag&=-65;if(null===a)if(g){var h=e.fallback;a=Ze(null,d,0,null);0===(b.mode&1)&&(a.child=null!==b.memoizedState?b.child.child:b.child);d=Ze(h,d,c,null);a.sibling=d;c=a;c.return=d.return=b;}else c=d=Ef(b,null,e.children,c);else null!==a.memoizedState?(d=a.child,h=d.sibling,g?(c=e.fallback,e=Xe(d,d.pendingProps,0),0===(b.mode&1)&&(g=null!==
  b.memoizedState?b.child.child:b.child,g!==d.child&&(e.child=g)),d=e.sibling=Xe(h,c,h.expirationTime),c=e,e.childExpirationTime=0,c.return=d.return=b):c=d=Df(b,d.child,e.children,c)):(h=a.child,g?(g=e.fallback,e=Ze(null,d,0,null),e.child=h,0===(b.mode&1)&&(e.child=null!==b.memoizedState?b.child.child:b.child),d=e.sibling=Ze(g,d,c,null),d.effectTag|=2,c=e,e.childExpirationTime=0,c.return=d.return=b):d=c=Df(b,h,e.children,c)),b.stateNode=a.stateNode;b.memoizedState=f;b.child=c;return d}
  function Jg(a,b,c){null!==a&&(b.contextDependencies=a.contextDependencies);if(b.childExpirationTime<c)return null;null!==a&&b.child!==a.child?x$1("153"):void 0;if(null!==b.child){a=b.child;c=Xe(a,a.pendingProps,a.expirationTime);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Xe(a,a.pendingProps,a.expirationTime),c.return=b;c.sibling=null;}return b.child}
  function Tg(a,b,c){var d=b.expirationTime;if(null!==a)if(a.memoizedProps!==b.pendingProps||I$1.current)qg=!0;else{if(d<c){qg=!1;switch(b.tag){case 3:Rg(b);Fg();break;case 5:Lf(b);break;case 1:J$1(b.type)&&Oe(b);break;case 4:Jf(b,b.stateNode.containerInfo);break;case 10:Ug(b,b.memoizedProps.value);break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;if(0!==d&&d>=c)return Sg(a,b,c);b=Jg(a,b,c);return null!==b?b.sibling:null}}return Jg(a,b,c)}}else qg=!1;b.expirationTime=0;switch(b.tag){case 2:d=
  b.elementType;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;var e=Je(b,H$1.current);Ig(b,c);e=hg(null,b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;lg();if(J$1(d)){var f=!0;Oe(b);}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;var g=d.getDerivedStateFromProps;"function"===typeof g&&kf(b,d,g,a);e.updater=tf;b.stateNode=e;e._reactInternalFiber=b;xf(b,d,a,c);b=Qg(null,b,d,!0,f,
  c);}else b.tag=0,S$1(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);f=b.pendingProps;a=hf(e);b.type=a;e=b.tag=We(a);f=L$1(a,f);g=void 0;switch(e){case 0:g=Mg(null,b,a,f,c);break;case 1:g=Og(null,b,a,f,c);break;case 11:g=Hg(null,b,a,f,c);break;case 14:g=Kg(null,b,a,L$1(a.type,f),d,c);break;default:x$1("306",a,"");}return g;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:L$1(d,e),Mg(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,
  e=b.elementType===d?e:L$1(d,e),Og(a,b,d,e,c);case 3:Rg(b);d=b.updateQueue;null===d?x$1("282"):void 0;e=b.memoizedState;e=null!==e?e.element:null;yf(b,d,b.pendingProps,null,c);d=b.memoizedState.element;if(d===e)Fg(),b=Jg(a,b,c);else{e=b.stateNode;if(e=(null===a||null===a.child)&&e.hydrate)yg=Ee(b.stateNode.containerInfo),xg=b,e=zg=!0;e?(b.effectTag|=2,b.child=Ef(b,null,d,c)):(S$1(a,b,d,c),Fg());b=b.child;}return b;case 5:return Lf(b),null===a&&Cg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,
  g=e.children,xe(d,e)?g=null:null!==f&&xe(d,f)&&(b.effectTag|=16),Ng(a,b),1!==c&&b.mode&1&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(S$1(a,b,g,c),b=b.child),b;case 6:return null===a&&Cg(b),null;case 13:return Sg(a,b,c);case 4:return Jf(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Df(b,null,d,c):S$1(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:L$1(d,e),Hg(a,b,d,e,c);case 7:return S$1(a,b,b.pendingProps,c),b.child;case 8:return S$1(a,b,b.pendingProps.children,
  c),b.child;case 12:return S$1(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;Ug(b,f);if(null!==g){var h=g.value;f=bd(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0;if(0===f){if(g.children===e.children&&!I$1.current){b=Jg(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var l=h.contextDependencies;if(null!==l){g=h.child;for(var k=l.first;null!==k;){if(k.context===d&&0!==
  (k.observedBits&f)){1===h.tag&&(k=nf(c),k.tag=sf,pf(h,k));h.expirationTime<c&&(h.expirationTime=c);k=h.alternate;null!==k&&k.expirationTime<c&&(k.expirationTime=c);k=c;for(var m=h.return;null!==m;){var p=m.alternate;if(m.childExpirationTime<k)m.childExpirationTime=k,null!==p&&p.childExpirationTime<k&&(p.childExpirationTime=k);else if(null!==p&&p.childExpirationTime<k)p.childExpirationTime=k;else break;m=m.return;}l.expirationTime<c&&(l.expirationTime=c);break}k=k.next;}}else g=10===h.tag?h.type===b.type?
  null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return;}h=g;}}S$1(a,b,e.children,c);b=b.child;}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,Ig(b,c),e=M$1(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,S$1(a,b,d,c),b.child;case 14:return e=b.type,f=L$1(e,b.pendingProps),f=L$1(e.type,f),Kg(a,b,e,f,d,c);case 15:return Lg(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===
  d?e:L$1(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,J$1(d)?(a=!0,Oe(b)):a=!1,Ig(b,c),vf(b,d,e,c),xf(b,d,e,c),Qg(null,b,d,!0,a,c)}x$1("156");}var Vg={current:null},Wg=null,Xg=null,Yg=null;function Ug(a,b){var c=a.type._context;G$1(Vg,c._currentValue,a);c._currentValue=b;}function Zg(a){var b=Vg.current;F$1(Vg,a);a.type._context._currentValue=b;}function Ig(a,b){Wg=a;Yg=Xg=null;var c=a.contextDependencies;null!==c&&c.expirationTime>=b&&(qg=!0);a.contextDependencies=null;}
  function M$1(a,b){if(Yg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Yg=a,b=1073741823;b={context:a,observedBits:b,next:null};null===Xg?(null===Wg?x$1("308"):void 0,Xg=b,Wg.contextDependencies={first:b,expirationTime:0}):Xg=Xg.next=b;}return a._currentValue}var $g=0,rf=1,sf=2,ah=3,Pg=!1;function bh(a){return {baseState:a,firstUpdate:null,lastUpdate:null,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}
  function ch(a){return {baseState:a.baseState,firstUpdate:a.firstUpdate,lastUpdate:a.lastUpdate,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null}}function nf(a){return {expirationTime:a,tag:$g,payload:null,callback:null,next:null,nextEffect:null}}function dh(a,b){null===a.lastUpdate?a.firstUpdate=a.lastUpdate=b:(a.lastUpdate.next=b,a.lastUpdate=b);}
  function pf(a,b){var c=a.alternate;if(null===c){var d=a.updateQueue;var e=null;null===d&&(d=a.updateQueue=bh(a.memoizedState));}else d=a.updateQueue,e=c.updateQueue,null===d?null===e?(d=a.updateQueue=bh(a.memoizedState),e=c.updateQueue=bh(c.memoizedState)):d=a.updateQueue=ch(e):null===e&&(e=c.updateQueue=ch(d));null===e||d===e?dh(d,b):null===d.lastUpdate||null===e.lastUpdate?(dh(d,b),dh(e,b)):(dh(d,b),e.lastUpdate=b);}
  function eh(a,b){var c=a.updateQueue;c=null===c?a.updateQueue=bh(a.memoizedState):fh(a,c);null===c.lastCapturedUpdate?c.firstCapturedUpdate=c.lastCapturedUpdate=b:(c.lastCapturedUpdate.next=b,c.lastCapturedUpdate=b);}function fh(a,b){var c=a.alternate;null!==c&&b===c.updateQueue&&(b=a.updateQueue=ch(b));return b}
  function gh(a,b,c,d,e,f){switch(c.tag){case rf:return a=c.payload,"function"===typeof a?a.call(f,d,e):a;case ah:a.effectTag=a.effectTag&-2049|64;case $g:a=c.payload;e="function"===typeof a?a.call(f,d,e):a;if(null===e||void 0===e)break;return objectAssign({},d,e);case sf:Pg=!0;}return d}
  function yf(a,b,c,d,e){Pg=!1;b=fh(a,b);for(var f=b.baseState,g=null,h=0,l=b.firstUpdate,k=f;null!==l;){var m=l.expirationTime;m<e?(null===g&&(g=l,f=k),h<m&&(h=m)):(k=gh(a,b,l,k,c,d),null!==l.callback&&(a.effectTag|=32,l.nextEffect=null,null===b.lastEffect?b.firstEffect=b.lastEffect=l:(b.lastEffect.nextEffect=l,b.lastEffect=l)));l=l.next;}m=null;for(l=b.firstCapturedUpdate;null!==l;){var p=l.expirationTime;p<e?(null===m&&(m=l,null===g&&(f=k)),h<p&&(h=p)):(k=gh(a,b,l,k,c,d),null!==l.callback&&(a.effectTag|=
  32,l.nextEffect=null,null===b.lastCapturedEffect?b.firstCapturedEffect=b.lastCapturedEffect=l:(b.lastCapturedEffect.nextEffect=l,b.lastCapturedEffect=l)));l=l.next;}null===g&&(b.lastUpdate=null);null===m?b.lastCapturedUpdate=null:a.effectTag|=32;null===g&&null===m&&(f=k);b.baseState=f;b.firstUpdate=g;b.firstCapturedUpdate=m;a.expirationTime=h;a.memoizedState=k;}
  function hh(a,b,c){null!==b.firstCapturedUpdate&&(null!==b.lastUpdate&&(b.lastUpdate.next=b.firstCapturedUpdate,b.lastUpdate=b.lastCapturedUpdate),b.firstCapturedUpdate=b.lastCapturedUpdate=null);ih(b.firstEffect,c);b.firstEffect=b.lastEffect=null;ih(b.firstCapturedEffect,c);b.firstCapturedEffect=b.lastCapturedEffect=null;}function ih(a,b){for(;null!==a;){var c=a.callback;if(null!==c){a.callback=null;var d=b;"function"!==typeof c?x$1("191",c):void 0;c.call(d);}a=a.nextEffect;}}
  function jh(a,b){return {value:a,source:b,stack:jc(b)}}function kh(a){a.effectTag|=4;}var lh=void 0,mh=void 0,nh=void 0,oh=void 0;lh=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;}c.sibling.return=c.return;c=c.sibling;}};mh=function(){};
  nh=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;If(N$1.current);a=null;switch(c){case "input":f=vc(g,f);d=vc(g,d);a=[];break;case "option":f=$d(g,f);d=$d(g,d);a=[];break;case "select":f=objectAssign({},f,{value:void 0});d=objectAssign({},d,{value:void 0});a=[];break;case "textarea":f=be(g,f);d=be(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=te);}qe(c,d);g=c=void 0;var h=null;for(c in f)if(!d.hasOwnProperty(c)&&f.hasOwnProperty(c)&&null!=f[c])if("style"===
  c){var l=f[c];for(g in l)l.hasOwnProperty(g)&&(h||(h={}),h[g]="");}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(ra.hasOwnProperty(c)?a||(a=[]):(a=a||[]).push(c,null));for(c in d){var k=d[c];l=null!=f?f[c]:void 0;if(d.hasOwnProperty(c)&&k!==l&&(null!=k||null!=l))if("style"===c)if(l){for(g in l)!l.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(h||(h={}),h[g]="");for(g in k)k.hasOwnProperty(g)&&l[g]!==k[g]&&(h||
  (h={}),h[g]=k[g]);}else h||(a||(a=[]),a.push(c,h)),h=k;else"dangerouslySetInnerHTML"===c?(k=k?k.__html:void 0,l=l?l.__html:void 0,null!=k&&l!==k&&(a=a||[]).push(c,""+k)):"children"===c?l===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(c,""+k):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(ra.hasOwnProperty(c)?(null!=k&&se(e,c),a||l===k||(a=[])):(a=a||[]).push(c,k));}h&&(a=a||[]).push("style",h);e=a;(b.updateQueue=e)&&kh(b);}};oh=function(a,b,c,d){c!==d&&kh(b);};
  var ph="function"===typeof WeakSet?WeakSet:Set;function qh(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=jc(c));null!==c&&ic(c.type);b=b.value;null!==a&&1===a.tag&&ic(a.type);try{console.error(b);}catch(e){setTimeout(function(){throw e;});}}function rh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null);}catch(c){sh(a,c);}else b.current=null;}
  function th(a,b,c){c=c.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do{if((d.tag&a)!==Nf){var e=d.destroy;d.destroy=void 0;void 0!==e&&e();}(d.tag&b)!==Nf&&(e=d.create,d.destroy=e());d=d.next;}while(d!==c)}}
  function uh(a,b){for(var c=a;;){if(5===c.tag){var d=c.stateNode;if(b)d.style.display="none";else{d=c.stateNode;var e=c.memoizedProps.style;e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null;d.style.display=ne("display",e);}}else if(6===c.tag)c.stateNode.nodeValue=b?"":c.memoizedProps;else if(13===c.tag&&null!==c.memoizedState){d=c.child.sibling;d.return=c;c=d;continue}else if(null!==c.child){c.child.return=c;c=c.child;continue}if(c===a)break;for(;null===c.sibling;){if(null===c.return||
  c.return===a)return;c=c.return;}c.sibling.return=c.return;c=c.sibling;}}
  function vh(a){"function"===typeof Re&&Re(a);switch(a.tag){case 0:case 11:case 14:case 15:var b=a.updateQueue;if(null!==b&&(b=b.lastEffect,null!==b)){var c=b=b.next;do{var d=c.destroy;if(void 0!==d){var e=a;try{d();}catch(f){sh(e,f);}}c=c.next;}while(c!==b)}break;case 1:rh(a);b=a.stateNode;if("function"===typeof b.componentWillUnmount)try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount();}catch(f){sh(a,f);}break;case 5:rh(a);break;case 4:wh(a);}}
  function xh(a){return 5===a.tag||3===a.tag||4===a.tag}
  function yh(a){a:{for(var b=a.return;null!==b;){if(xh(b)){var c=b;break a}b=b.return;}x$1("160");c=void 0;}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:x$1("161");}c.effectTag&16&&(ke(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||xh(c.return)){c=null;break a}c=c.return;}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&
  2)continue b;if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child;}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)if(c)if(d){var f=b,g=e.stateNode,h=c;8===f.nodeType?f.parentNode.insertBefore(g,h):f.insertBefore(g,h);}else b.insertBefore(e.stateNode,c);else d?(g=b,h=e.stateNode,8===g.nodeType?(f=g.parentNode,f.insertBefore(h,g)):(f=g,f.appendChild(h)),g=g._reactRootContainer,null!==g&&void 0!==g||null!==f.onclick||(f.onclick=te)):b.appendChild(e.stateNode);
  else if(4!==e.tag&&null!==e.child){e.child.return=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e.return||e.return===a)return;e=e.return;}e.sibling.return=e.return;e=e.sibling;}}
  function wh(a){for(var b=a,c=!1,d=void 0,e=void 0;;){if(!c){c=b.return;a:for(;;){null===c?x$1("160"):void 0;switch(c.tag){case 5:d=c.stateNode;e=!1;break a;case 3:d=c.stateNode.containerInfo;e=!0;break a;case 4:d=c.stateNode.containerInfo;e=!0;break a}c=c.return;}c=!0;}if(5===b.tag||6===b.tag){a:for(var f=b,g=f;;)if(vh(g),null!==g.child&&4!==g.tag)g.child.return=g,g=g.child;else{if(g===f)break;for(;null===g.sibling;){if(null===g.return||g.return===f)break a;g=g.return;}g.sibling.return=g.return;g=g.sibling;}e?
  (f=d,g=b.stateNode,8===f.nodeType?f.parentNode.removeChild(g):f.removeChild(g)):d.removeChild(b.stateNode);}else if(4===b.tag){if(null!==b.child){d=b.stateNode.containerInfo;e=!0;b.child.return=b;b=b.child;continue}}else if(vh(b),null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return;b=b.return;4===b.tag&&(c=!1);}b.sibling.return=b.return;b=b.sibling;}}
  function zh(a,b){switch(b.tag){case 0:case 11:case 14:case 15:th(Pf,Qf,b);break;case 1:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&Ce(c,f,e,a,d,b);}break;case 6:null===b.stateNode?x$1("162"):void 0;b.stateNode.nodeValue=b.memoizedProps;break;case 3:break;case 12:break;case 13:c=b.memoizedState;d=void 0;a=b;null===c?d=!1:(d=!0,a=b.child,0===c.timedOutAt&&(c.timedOutAt=lf()));null!==a&&uh(a,d);c=
  b.updateQueue;if(null!==c){b.updateQueue=null;var g=b.stateNode;null===g&&(g=b.stateNode=new ph);c.forEach(function(a){var c=Ah.bind(null,b,a);g.has(a)||(g.add(a),a.then(c,c));});}break;case 17:break;default:x$1("163");}}var Bh="function"===typeof WeakMap?WeakMap:Map;function Ch(a,b,c){c=nf(c);c.tag=ah;c.payload={element:null};var d=b.value;c.callback=function(){Dh(d);qh(a,b);};return c}
  function Eh(a,b,c){c=nf(c);c.tag=ah;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===Fh?Fh=new Set([this]):Fh.add(this));var c=b.value,e=b.stack;qh(a,b);this.componentDidCatch(c,{componentStack:null!==e?e:""});});return c}
  function Gh(a){switch(a.tag){case 1:J$1(a.type)&&Ke(a);var b=a.effectTag;return b&2048?(a.effectTag=b&-2049|64,a):null;case 3:return Kf(a),Le(a),b=a.effectTag,0!==(b&64)?x$1("285"):void 0,a.effectTag=b&-2049|64,a;case 5:return Mf(a),null;case 13:return b=a.effectTag,b&2048?(a.effectTag=b&-2049|64,a):null;case 18:return null;case 4:return Kf(a),null;case 10:return Zg(a),null;default:return null}}
  var Hh=Tb.ReactCurrentDispatcher,Ih=Tb.ReactCurrentOwner,Jh=1073741822,Kh=!1,T$1=null,Lh=null,U$1=0,Mh=-1,Nh=!1,V$1=null,Oh=!1,Ph=null,Qh=null,Rh=null,Fh=null;function Sh(){if(null!==T$1)for(var a=T$1.return;null!==a;){var b=a;switch(b.tag){case 1:var c=b.type.childContextTypes;null!==c&&void 0!==c&&Ke(b);break;case 3:Kf(b);Le(b);break;case 5:Mf(b);break;case 4:Kf(b);break;case 10:Zg(b);}a=a.return;}Lh=null;U$1=0;Mh=-1;Nh=!1;T$1=null;}
  function Th(){for(;null!==V$1;){var a=V$1.effectTag;a&16&&ke(V$1.stateNode,"");if(a&128){var b=V$1.alternate;null!==b&&(b=b.ref,null!==b&&("function"===typeof b?b(null):b.current=null));}switch(a&14){case 2:yh(V$1);V$1.effectTag&=-3;break;case 6:yh(V$1);V$1.effectTag&=-3;zh(V$1.alternate,V$1);break;case 4:zh(V$1.alternate,V$1);break;case 8:a=V$1,wh(a),a.return=null,a.child=null,a.memoizedState=null,a.updateQueue=null,a=a.alternate,null!==a&&(a.return=null,a.child=null,a.memoizedState=null,a.updateQueue=null);}V$1=V$1.nextEffect;}}
  function Uh(){for(;null!==V$1;){if(V$1.effectTag&256)a:{var a=V$1.alternate,b=V$1;switch(b.tag){case 0:case 11:case 15:th(Of,Nf,b);break a;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:L$1(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b;}break a;case 3:case 5:case 6:case 4:case 17:break a;default:x$1("163");}}V$1=V$1.nextEffect;}}
  function Vh(a,b){for(;null!==V$1;){var c=V$1.effectTag;if(c&36){var d=V$1.alternate,e=V$1,f=b;switch(e.tag){case 0:case 11:case 15:th(Rf,Sf,e);break;case 1:var g=e.stateNode;if(e.effectTag&4)if(null===d)g.componentDidMount();else{var h=e.elementType===e.type?d.memoizedProps:L$1(e.type,d.memoizedProps);g.componentDidUpdate(h,d.memoizedState,g.__reactInternalSnapshotBeforeUpdate);}d=e.updateQueue;null!==d&&hh(e,d,g,f);break;case 3:d=e.updateQueue;if(null!==d){g=null;if(null!==e.child)switch(e.child.tag){case 5:g=
  e.child.stateNode;break;case 1:g=e.child.stateNode;}hh(e,d,g,f);}break;case 5:f=e.stateNode;null===d&&e.effectTag&4&&we(e.type,e.memoizedProps)&&f.focus();break;case 6:break;case 4:break;case 12:break;case 13:break;case 17:break;default:x$1("163");}}c&128&&(e=V$1.ref,null!==e&&(f=V$1.stateNode,"function"===typeof e?e(f):e.current=f));c&512&&(Ph=a);V$1=V$1.nextEffect;}}
  function Wh(a,b){Rh=Qh=Ph=null;var c=W$1;W$1=!0;do{if(b.effectTag&512){var d=!1,e=void 0;try{var f=b;th(Uf,Nf,f);th(Nf,Tf,f);}catch(g){d=!0,e=g;}d&&sh(b,e);}b=b.nextEffect;}while(null!==b);W$1=c;c=a.expirationTime;0!==c&&Xh(a,c);X$1||W$1||Yh(1073741823,!1);}function of(){null!==Qh&&Be(Qh);null!==Rh&&Rh();}
  function Zh(a,b){Oh=Kh=!0;a.current===b?x$1("177"):void 0;var c=a.pendingCommitExpirationTime;0===c?x$1("261"):void 0;a.pendingCommitExpirationTime=0;var d=b.expirationTime,e=b.childExpirationTime;ef(a,e>d?e:d);Ih.current=null;d=void 0;1<b.effectTag?null!==b.lastEffect?(b.lastEffect.nextEffect=b,d=b.firstEffect):d=b:d=b.firstEffect;ue=Bd;ve=Pd();Bd=!1;for(V$1=d;null!==V$1;){e=!1;var f=void 0;try{Uh();}catch(h){e=!0,f=h;}e&&(null===V$1?x$1("178"):void 0,sh(V$1,f),null!==V$1&&(V$1=V$1.nextEffect));}for(V$1=d;null!==V$1;){e=!1;
  f=void 0;try{Th();}catch(h){e=!0,f=h;}e&&(null===V$1?x$1("178"):void 0,sh(V$1,f),null!==V$1&&(V$1=V$1.nextEffect));}Qd(ve);ve=null;Bd=!!ue;ue=null;a.current=b;for(V$1=d;null!==V$1;){e=!1;f=void 0;try{Vh(a,c);}catch(h){e=!0,f=h;}e&&(null===V$1?x$1("178"):void 0,sh(V$1,f),null!==V$1&&(V$1=V$1.nextEffect));}if(null!==d&&null!==Ph){var g=Wh.bind(null,a,d);Qh=scheduler.unstable_runWithPriority(scheduler.unstable_NormalPriority,function(){return Ae(g)});Rh=g;}Kh=Oh=!1;"function"===typeof Qe&&Qe(b.stateNode);c=b.expirationTime;b=b.childExpirationTime;b=
  b>c?b:c;0===b&&(Fh=null);$h(a,b);}
  function ai(a){for(;;){var b=a.alternate,c=a.return,d=a.sibling;if(0===(a.effectTag&1024)){T$1=a;a:{var e=b;b=a;var f=U$1;var g=b.pendingProps;switch(b.tag){case 2:break;case 16:break;case 15:case 0:break;case 1:J$1(b.type)&&Ke(b);break;case 3:Kf(b);Le(b);g=b.stateNode;g.pendingContext&&(g.context=g.pendingContext,g.pendingContext=null);if(null===e||null===e.child)Eg(b),b.effectTag&=-3;mh(b);break;case 5:Mf(b);var h=If(Hf.current);f=b.type;if(null!==e&&null!=b.stateNode)nh(e,b,f,g,h),e.ref!==b.ref&&(b.effectTag|=
  128);else if(g){var l=If(N$1.current);if(Eg(b)){g=b;e=g.stateNode;var k=g.type,m=g.memoizedProps,p=h;e[Fa]=g;e[Ga]=m;f=void 0;h=k;switch(h){case "iframe":case "object":E$1("load",e);break;case "video":case "audio":for(k=0;k<ab.length;k++)E$1(ab[k],e);break;case "source":E$1("error",e);break;case "img":case "image":case "link":E$1("error",e);E$1("load",e);break;case "form":E$1("reset",e);E$1("submit",e);break;case "details":E$1("toggle",e);break;case "input":wc(e,m);E$1("invalid",e);se(p,"onChange");break;case "select":e._wrapperState=
  {wasMultiple:!!m.multiple};E$1("invalid",e);se(p,"onChange");break;case "textarea":ce(e,m),E$1("invalid",e),se(p,"onChange");}qe(h,m);k=null;for(f in m)m.hasOwnProperty(f)&&(l=m[f],"children"===f?"string"===typeof l?e.textContent!==l&&(k=["children",l]):"number"===typeof l&&e.textContent!==""+l&&(k=["children",""+l]):ra.hasOwnProperty(f)&&null!=l&&se(p,f));switch(h){case "input":Rb(e);Ac(e,m,!0);break;case "textarea":Rb(e);ee(e,m);break;case "select":case "option":break;default:"function"===typeof m.onClick&&
  (e.onclick=te);}f=k;g.updateQueue=f;g=null!==f?!0:!1;g&&kh(b);}else{m=b;p=f;e=g;k=9===h.nodeType?h:h.ownerDocument;l===fe.html&&(l=ge(p));l===fe.html?"script"===p?(e=k.createElement("div"),e.innerHTML="<script>\x3c/script>",k=e.removeChild(e.firstChild)):"string"===typeof e.is?k=k.createElement(p,{is:e.is}):(k=k.createElement(p),"select"===p&&(p=k,e.multiple?p.multiple=!0:e.size&&(p.size=e.size))):k=k.createElementNS(l,p);e=k;e[Fa]=m;e[Ga]=g;lh(e,b,!1,!1);p=e;k=f;m=g;var t=h,A=re(k,m);switch(k){case "iframe":case "object":E$1("load",
  p);h=m;break;case "video":case "audio":for(h=0;h<ab.length;h++)E$1(ab[h],p);h=m;break;case "source":E$1("error",p);h=m;break;case "img":case "image":case "link":E$1("error",p);E$1("load",p);h=m;break;case "form":E$1("reset",p);E$1("submit",p);h=m;break;case "details":E$1("toggle",p);h=m;break;case "input":wc(p,m);h=vc(p,m);E$1("invalid",p);se(t,"onChange");break;case "option":h=$d(p,m);break;case "select":p._wrapperState={wasMultiple:!!m.multiple};h=objectAssign({},m,{value:void 0});E$1("invalid",p);se(t,"onChange");break;case "textarea":ce(p,
  m);h=be(p,m);E$1("invalid",p);se(t,"onChange");break;default:h=m;}qe(k,h);l=void 0;var v=k,R=p,u=h;for(l in u)if(u.hasOwnProperty(l)){var q=u[l];"style"===l?oe(R,q):"dangerouslySetInnerHTML"===l?(q=q?q.__html:void 0,null!=q&&je(R,q)):"children"===l?"string"===typeof q?("textarea"!==v||""!==q)&&ke(R,q):"number"===typeof q&&ke(R,""+q):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ra.hasOwnProperty(l)?null!=q&&se(t,l):null!=q&&tc(R,l,q,A));}switch(k){case "input":Rb(p);
  Ac(p,m,!1);break;case "textarea":Rb(p);ee(p,m);break;case "option":null!=m.value&&p.setAttribute("value",""+uc(m.value));break;case "select":h=p;h.multiple=!!m.multiple;p=m.value;null!=p?ae(h,!!m.multiple,p,!1):null!=m.defaultValue&&ae(h,!!m.multiple,m.defaultValue,!0);break;default:"function"===typeof h.onClick&&(p.onclick=te);}(g=we(f,g))&&kh(b);b.stateNode=e;}null!==b.ref&&(b.effectTag|=128);}else null===b.stateNode?x$1("166"):void 0;break;case 6:e&&null!=b.stateNode?oh(e,b,e.memoizedProps,g):("string"!==
  typeof g&&(null===b.stateNode?x$1("166"):void 0),e=If(Hf.current),If(N$1.current),Eg(b)?(g=b,f=g.stateNode,e=g.memoizedProps,f[Fa]=g,(g=f.nodeValue!==e)&&kh(b)):(f=b,g=(9===e.nodeType?e:e.ownerDocument).createTextNode(g),g[Fa]=b,f.stateNode=g));break;case 11:break;case 13:g=b.memoizedState;if(0!==(b.effectTag&64)){b.expirationTime=f;T$1=b;break a}g=null!==g;f=null!==e&&null!==e.memoizedState;null!==e&&!g&&f&&(e=e.child.sibling,null!==e&&(h=b.firstEffect,null!==h?(b.firstEffect=e,e.nextEffect=h):(b.firstEffect=
  b.lastEffect=e,e.nextEffect=null),e.effectTag=8));if(g||f)b.effectTag|=4;break;case 7:break;case 8:break;case 12:break;case 4:Kf(b);mh(b);break;case 10:Zg(b);break;case 9:break;case 14:break;case 17:J$1(b.type)&&Ke(b);break;case 18:break;default:x$1("156");}T$1=null;}b=a;if(1===U$1||1!==b.childExpirationTime){g=0;for(f=b.child;null!==f;)e=f.expirationTime,h=f.childExpirationTime,e>g&&(g=e),h>g&&(g=h),f=f.sibling;b.childExpirationTime=g;}if(null!==T$1)return T$1;null!==c&&0===(c.effectTag&1024)&&(null===c.firstEffect&&
  (c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));}else{a=Gh(a,U$1);if(null!==a)return a.effectTag&=1023,a;null!==c&&(c.firstEffect=c.lastEffect=null,c.effectTag|=1024);}if(null!==d)return d;if(null!==c)a=c;else break}return null}
  function bi(a){var b=Tg(a.alternate,a,U$1);a.memoizedProps=a.pendingProps;null===b&&(b=ai(a));Ih.current=null;return b}
  function ci(a,b){Kh?x$1("243"):void 0;of();Kh=!0;var c=Hh.current;Hh.current=kg;var d=a.nextExpirationTimeToWorkOn;if(d!==U$1||a!==Lh||null===T$1)Sh(),Lh=a,U$1=d,T$1=Xe(Lh.current,null,U$1),a.pendingCommitExpirationTime=0;var e=!1;do{try{if(b)for(;null!==T$1&&!di();)T$1=bi(T$1);else for(;null!==T$1;)T$1=bi(T$1);}catch(u){if(Yg=Xg=Wg=null,lg(),null===T$1)e=!0,Dh(u);else{null===T$1?x$1("271"):void 0;var f=T$1,g=f.return;if(null===g)e=!0,Dh(u);else{a:{var h=a,l=g,k=f,m=u;g=U$1;k.effectTag|=1024;k.firstEffect=k.lastEffect=null;if(null!==
  m&&"object"===typeof m&&"function"===typeof m.then){var p=m;m=l;var t=-1,A=-1;do{if(13===m.tag){var v=m.alternate;if(null!==v&&(v=v.memoizedState,null!==v)){A=10*(1073741822-v.timedOutAt);break}v=m.pendingProps.maxDuration;if("number"===typeof v)if(0>=v)t=0;else if(-1===t||v<t)t=v;}m=m.return;}while(null!==m);m=l;do{if(v=13===m.tag)v=void 0===m.memoizedProps.fallback?!1:null===m.memoizedState;if(v){l=m.updateQueue;null===l?(l=new Set,l.add(p),m.updateQueue=l):l.add(p);if(0===(m.mode&1)){m.effectTag|=
  64;k.effectTag&=-1957;1===k.tag&&(null===k.alternate?k.tag=17:(g=nf(1073741823),g.tag=sf,pf(k,g)));k.expirationTime=1073741823;break a}k=h;l=g;var R=k.pingCache;null===R?(R=k.pingCache=new Bh,v=new Set,R.set(p,v)):(v=R.get(p),void 0===v&&(v=new Set,R.set(p,v)));v.has(l)||(v.add(l),k=ei.bind(null,k,p,l),p.then(k,k));-1===t?h=1073741823:(-1===A&&(A=10*(1073741822-gf(h,g))-5E3),h=A+t);0<=h&&Mh<h&&(Mh=h);m.effectTag|=2048;m.expirationTime=g;break a}m=m.return;}while(null!==m);m=Error((ic(k.type)||"A React component")+
  " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+jc(k));}Nh=!0;m=jh(m,k);h=l;do{switch(h.tag){case 3:h.effectTag|=2048;h.expirationTime=g;g=Ch(h,m,g);eh(h,g);break a;case 1:if(t=m,A=h.type,k=h.stateNode,0===(h.effectTag&64)&&("function"===typeof A.getDerivedStateFromError||null!==k&&"function"===typeof k.componentDidCatch&&(null===Fh||!Fh.has(k)))){h.effectTag|=2048;
  h.expirationTime=g;g=Eh(h,t,g);eh(h,g);break a}}h=h.return;}while(null!==h)}T$1=ai(f);continue}}}break}while(1);Kh=!1;Hh.current=c;Yg=Xg=Wg=null;lg();if(e)Lh=null,a.finishedWork=null;else if(null!==T$1)a.finishedWork=null;else{c=a.current.alternate;null===c?x$1("281"):void 0;Lh=null;if(Nh){e=a.latestPendingTime;f=a.latestSuspendedTime;g=a.latestPingedTime;if(0!==e&&e<d||0!==f&&f<d||0!==g&&g<d){ff(a,d);fi(a,c,d,a.expirationTime,-1);return}if(!a.didError&&b){a.didError=!0;d=a.nextExpirationTimeToWorkOn=d;
  b=a.expirationTime=1073741823;fi(a,c,d,b,-1);return}}b&&-1!==Mh?(ff(a,d),b=10*(1073741822-gf(a,d)),b<Mh&&(Mh=b),b=10*(1073741822-lf()),b=Mh-b,fi(a,c,d,a.expirationTime,0>b?0:b)):(a.pendingCommitExpirationTime=d,a.finishedWork=c);}}
  function sh(a,b){for(var c=a.return;null!==c;){switch(c.tag){case 1:var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Fh||!Fh.has(d))){a=jh(b,a);a=Eh(c,a,1073741823);pf(c,a);qf(c,1073741823);return}break;case 3:a=jh(b,a);a=Ch(c,a,1073741823);pf(c,a);qf(c,1073741823);return}c=c.return;}3===a.tag&&(c=jh(b,a),c=Ch(a,c,1073741823),pf(a,c),qf(a,1073741823));}
  function mf(a,b){var c=scheduler.unstable_getCurrentPriorityLevel(),d=void 0;if(0===(b.mode&1))d=1073741823;else if(Kh&&!Oh)d=U$1;else{switch(c){case scheduler.unstable_ImmediatePriority:d=1073741823;break;case scheduler.unstable_UserBlockingPriority:d=1073741822-10*(((1073741822-a+15)/10|0)+1);break;case scheduler.unstable_NormalPriority:d=1073741822-25*(((1073741822-a+500)/25|0)+1);break;case scheduler.unstable_LowPriority:case scheduler.unstable_IdlePriority:d=1;break;default:x$1("313");}null!==Lh&&d===U$1&&--d;}c===scheduler.unstable_UserBlockingPriority&&
  (0===gi||d<gi)&&(gi=d);return d}function ei(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);if(null!==Lh&&U$1===c)Lh=null;else if(b=a.earliestSuspendedTime,d=a.latestSuspendedTime,0!==b&&c<=b&&c>=d){a.didError=!1;b=a.latestPingedTime;if(0===b||b>c)a.latestPingedTime=c;df(c,a);c=a.expirationTime;0!==c&&Xh(a,c);}}function Ah(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=lf();b=mf(b,a);a=hi(a,b);null!==a&&(cf(a,b),b=a.expirationTime,0!==b&&Xh(a,b));}
  function hi(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return;}return e}
  function qf(a,b){a=hi(a,b);null!==a&&(!Kh&&0!==U$1&&b>U$1&&Sh(),cf(a,b),Kh&&!Oh&&Lh===a||Xh(a,a.expirationTime),ii>ji&&(ii=0,x$1("185")));}function ki(a,b,c,d,e){return scheduler.unstable_runWithPriority(scheduler.unstable_ImmediatePriority,function(){return a(b,c,d,e)})}var li=null,Y$1=null,mi=0,ni=void 0,W$1=!1,oi=null,Z$1=0,gi=0,pi=!1,qi=null,X$1=!1,ri=!1,si=null,ti=scheduler.unstable_now(),ui=1073741822-(ti/10|0),vi=ui,ji=50,ii=0,wi=null;function xi(){ui=1073741822-((scheduler.unstable_now()-ti)/10|0);}
  function yi(a,b){if(0!==mi){if(b<mi)return;null!==ni&&scheduler.unstable_cancelCallback(ni);}mi=b;a=scheduler.unstable_now()-ti;ni=scheduler.unstable_scheduleCallback(zi,{timeout:10*(1073741822-b)-a});}function fi(a,b,c,d,e){a.expirationTime=d;0!==e||di()?0<e&&(a.timeoutHandle=ye(Ai.bind(null,a,b,c),e)):(a.pendingCommitExpirationTime=c,a.finishedWork=b);}function Ai(a,b,c){a.pendingCommitExpirationTime=c;a.finishedWork=b;xi();vi=ui;Bi(a,c);}function $h(a,b){a.expirationTime=b;a.finishedWork=null;}
  function lf(){if(W$1)return vi;Ci();if(0===Z$1||1===Z$1)xi(),vi=ui;return vi}function Xh(a,b){null===a.nextScheduledRoot?(a.expirationTime=b,null===Y$1?(li=Y$1=a,a.nextScheduledRoot=a):(Y$1=Y$1.nextScheduledRoot=a,Y$1.nextScheduledRoot=li)):b>a.expirationTime&&(a.expirationTime=b);W$1||(X$1?ri&&(oi=a,Z$1=1073741823,Di(a,1073741823,!1)):1073741823===b?Yh(1073741823,!1):yi(a,b));}
  function Ci(){var a=0,b=null;if(null!==Y$1)for(var c=Y$1,d=li;null!==d;){var e=d.expirationTime;if(0===e){null===c||null===Y$1?x$1("244"):void 0;if(d===d.nextScheduledRoot){li=Y$1=d.nextScheduledRoot=null;break}else if(d===li)li=e=d.nextScheduledRoot,Y$1.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===Y$1){Y$1=c;Y$1.nextScheduledRoot=li;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot;}else{e>a&&(a=e,b=d);if(d===Y$1)break;if(1073741823===
  a)break;c=d;d=d.nextScheduledRoot;}}oi=b;Z$1=a;}var Ei=!1;function di(){return Ei?!0:scheduler.unstable_shouldYield()?Ei=!0:!1}function zi(){try{if(!di()&&null!==li){xi();var a=li;do{var b=a.expirationTime;0!==b&&ui<=b&&(a.nextExpirationTimeToWorkOn=ui);a=a.nextScheduledRoot;}while(a!==li)}Yh(0,!0);}finally{Ei=!1;}}
  function Yh(a,b){Ci();if(b)for(xi(),vi=ui;null!==oi&&0!==Z$1&&a<=Z$1&&!(Ei&&ui>Z$1);)Di(oi,Z$1,ui>Z$1),Ci(),xi(),vi=ui;else for(;null!==oi&&0!==Z$1&&a<=Z$1;)Di(oi,Z$1,!1),Ci();b&&(mi=0,ni=null);0!==Z$1&&yi(oi,Z$1);ii=0;wi=null;if(null!==si)for(a=si,si=null,b=0;b<a.length;b++){var c=a[b];try{c._onComplete();}catch(d){pi||(pi=!0,qi=d);}}if(pi)throw a=qi,qi=null,pi=!1,a;}function Bi(a,b){W$1?x$1("253"):void 0;oi=a;Z$1=b;Di(a,b,!1);Yh(1073741823,!1);}
  function Di(a,b,c){W$1?x$1("245"):void 0;W$1=!0;if(c){var d=a.finishedWork;null!==d?Fi(a,d,b):(a.finishedWork=null,d=a.timeoutHandle,-1!==d&&(a.timeoutHandle=-1,ze(d)),ci(a,c),d=a.finishedWork,null!==d&&(di()?a.finishedWork=d:Fi(a,d,b)));}else d=a.finishedWork,null!==d?Fi(a,d,b):(a.finishedWork=null,d=a.timeoutHandle,-1!==d&&(a.timeoutHandle=-1,ze(d)),ci(a,c),d=a.finishedWork,null!==d&&Fi(a,d,b));W$1=!1;}
  function Fi(a,b,c){var d=a.firstBatch;if(null!==d&&d._expirationTime>=c&&(null===si?si=[d]:si.push(d),d._defer)){a.finishedWork=b;a.expirationTime=0;return}a.finishedWork=null;a===wi?ii++:(wi=a,ii=0);scheduler.unstable_runWithPriority(scheduler.unstable_ImmediatePriority,function(){Zh(a,b);});}function Dh(a){null===oi?x$1("246"):void 0;oi.expirationTime=0;pi||(pi=!0,qi=a);}function Gi(a,b){var c=X$1;X$1=!0;try{return a(b)}finally{(X$1=c)||W$1||Yh(1073741823,!1);}}
  function Hi(a,b){if(X$1&&!ri){ri=!0;try{return a(b)}finally{ri=!1;}}return a(b)}function Ii(a,b,c){X$1||W$1||0===gi||(Yh(gi,!1),gi=0);var d=X$1;X$1=!0;try{return scheduler.unstable_runWithPriority(scheduler.unstable_UserBlockingPriority,function(){return a(b,c)})}finally{(X$1=d)||W$1||Yh(1073741823,!1);}}
  function Ji(a,b,c,d,e){var f=b.current;a:if(c){c=c._reactInternalFiber;b:{2===ed(c)&&1===c.tag?void 0:x$1("170");var g=c;do{switch(g.tag){case 3:g=g.stateNode.context;break b;case 1:if(J$1(g.type)){g=g.stateNode.__reactInternalMemoizedMergedChildContext;break b}}g=g.return;}while(null!==g);x$1("171");g=void 0;}if(1===c.tag){var h=c.type;if(J$1(h)){c=Ne(c,h,g);break a}}c=g;}else c=He;null===b.context?b.context=c:b.pendingContext=c;b=e;e=nf(d);e.payload={element:a};b=void 0===b?null:b;null!==b&&(e.callback=b);
  of();pf(f,e);qf(f,d);return d}function Ki(a,b,c,d){var e=b.current,f=lf();e=mf(f,e);return Ji(a,b,c,e,d)}function Li(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Mi(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return {$$typeof:Wb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
  Ab=function(a,b,c){switch(b){case "input":yc(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Ka(d);e?void 0:x$1("90");Sb(d);yc(d,e);}}}break;case "textarea":de(a,c);break;case "select":b=c.value,null!=b&&ae(a,!!c.multiple,b,!1);}};
  function Ni(a){var b=1073741822-25*(((1073741822-lf()+500)/25|0)+1);b>=Jh&&(b=Jh-1);this._expirationTime=Jh=b;this._root=a;this._callbacks=this._next=null;this._hasChildren=this._didComplete=!1;this._children=null;this._defer=!0;}Ni.prototype.render=function(a){this._defer?void 0:x$1("250");this._hasChildren=!0;this._children=a;var b=this._root._internalRoot,c=this._expirationTime,d=new Oi;Ji(a,b,null,c,d._onCommit);return d};
  Ni.prototype.then=function(a){if(this._didComplete)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a);}};
  Ni.prototype.commit=function(){var a=this._root._internalRoot,b=a.firstBatch;this._defer&&null!==b?void 0:x$1("251");if(this._hasChildren){var c=this._expirationTime;if(b!==this){this._hasChildren&&(c=this._expirationTime=b._expirationTime,this.render(this._children));for(var d=null,e=b;e!==this;)d=e,e=e._next;null===d?x$1("251"):void 0;d._next=e._next;this._next=b;a.firstBatch=this;}this._defer=!1;Bi(a,c);b=this._next;this._next=null;b=a.firstBatch=b;null!==b&&b._hasChildren&&b.render(b._children);}else this._next=
  null,this._defer=!1;};Ni.prototype._onComplete=function(){if(!this._didComplete){this._didComplete=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<a.length;b++)(0, a[b])();}};function Oi(){this._callbacks=null;this._didCommit=!1;this._onCommit=this._onCommit.bind(this);}Oi.prototype.then=function(a){if(this._didCommit)a();else{var b=this._callbacks;null===b&&(b=this._callbacks=[]);b.push(a);}};
  Oi.prototype._onCommit=function(){if(!this._didCommit){this._didCommit=!0;var a=this._callbacks;if(null!==a)for(var b=0;b<a.length;b++){var c=a[b];"function"!==typeof c?x$1("191",c):void 0;c();}}};
  function Pi(a,b,c){b=K$1(3,null,null,b?3:0);a={current:b,containerInfo:a,pendingChildren:null,pingCache:null,earliestPendingTime:0,latestPendingTime:0,earliestSuspendedTime:0,latestSuspendedTime:0,latestPingedTime:0,didError:!1,pendingCommitExpirationTime:0,finishedWork:null,timeoutHandle:-1,context:null,pendingContext:null,hydrate:c,nextExpirationTimeToWorkOn:0,expirationTime:0,firstBatch:null,nextScheduledRoot:null};this._internalRoot=b.stateNode=a;}
  Pi.prototype.render=function(a,b){var c=this._internalRoot,d=new Oi;b=void 0===b?null:b;null!==b&&d.then(b);Ki(a,c,null,d._onCommit);return d};Pi.prototype.unmount=function(a){var b=this._internalRoot,c=new Oi;a=void 0===a?null:a;null!==a&&c.then(a);Ki(null,b,null,c._onCommit);return c};Pi.prototype.legacy_renderSubtreeIntoContainer=function(a,b,c){var d=this._internalRoot,e=new Oi;c=void 0===c?null:c;null!==c&&e.then(c);Ki(b,d,a,e._onCommit);return e};
  Pi.prototype.createBatch=function(){var a=new Ni(this),b=a._expirationTime,c=this._internalRoot,d=c.firstBatch;if(null===d)c.firstBatch=a,a._next=null;else{for(c=null;null!==d&&d._expirationTime>=b;)c=d,d=d._next;a._next=d;null!==c&&(c._next=a);}return a};function Qi(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}Gb=Gi;Hb=Ii;Ib=function(){W$1||0===gi||(Yh(gi,!1),gi=0);};
  function Ri(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new Pi(a,!1,b)}
  function Si(a,b,c,d,e){var f=c._reactRootContainer;if(f){if("function"===typeof e){var g=e;e=function(){var a=Li(f._internalRoot);g.call(a);};}null!=a?f.legacy_renderSubtreeIntoContainer(a,b,e):f.render(b,e);}else{f=c._reactRootContainer=Ri(c,d);if("function"===typeof e){var h=e;e=function(){var a=Li(f._internalRoot);h.call(a);};}Hi(function(){null!=a?f.legacy_renderSubtreeIntoContainer(a,b,e):f.render(b,e);});}return Li(f._internalRoot)}
  function Ti(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Qi(b)?void 0:x$1("200");return Mi(a,b,null,c)}
  var Vi={createPortal:Ti,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;void 0===b&&("function"===typeof a.render?x$1("188"):x$1("268",Object.keys(a)));a=hd(b);a=null===a?null:a.stateNode;return a},hydrate:function(a,b,c){Qi(b)?void 0:x$1("200");return Si(null,a,b,!0,c)},render:function(a,b,c){Qi(b)?void 0:x$1("200");return Si(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){Qi(c)?void 0:x$1("200");null==a||void 0===a._reactInternalFiber?
  x$1("38"):void 0;return Si(a,b,c,!1,d)},unmountComponentAtNode:function(a){Qi(a)?void 0:x$1("40");return a._reactRootContainer?(Hi(function(){Si(null,null,a,!1,function(){a._reactRootContainer=null;});}),!0):!1},unstable_createPortal:function(){return Ti.apply(void 0,arguments)},unstable_batchedUpdates:Gi,unstable_interactiveUpdates:Ii,flushSync:function(a,b){W$1?x$1("187"):void 0;var c=X$1;X$1=!0;try{return ki(a,b)}finally{X$1=c,Yh(1073741823,!1);}},unstable_createRoot:Ui,unstable_flushControlled:function(a){var b=
  X$1;X$1=!0;try{ki(a);}finally{(X$1=b)||W$1||Yh(1073741823,!1);}},__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{Events:[Ia,Ja,Ka,Ba.injectEventPluginsByName,pa,Qa,function(a){ya(a,Pa);},Eb,Fb,Dd,Da]}};function Ui(a,b){Qi(a)?void 0:x$1("299","unstable_createRoot");return new Pi(a,!0,null!=b&&!0===b.hydrate)}
  (function(a){var b=a.findFiberByHostInstance;return Te(objectAssign({},a,{overrideProps:null,currentDispatcherRef:Tb.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=hd(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null}}))})({findFiberByHostInstance:Ha,bundleType:0,version:"16.8.6",rendererPackageName:"react-dom"});var Wi={default:Vi},Xi=Wi&&Vi||Wi;var reactDom_production_min=Xi.default||Xi;

  var reactDom = createCommonjsModule(function (module) {

  function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
    ) {
      return;
    }
    try {
      // Verify that the code above has been dead code eliminated (DCE'd).
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      // DevTools shouldn't crash React, no matter what.
      // We should still report in case we break this code.
      console.error(err);
    }
  }

  {
    // DCE check should happen before ReactDOM bundle executes so that
    // DevTools can report bad minification during injection.
    checkDCE();
    module.exports = reactDom_production_min;
  }
  });
  var reactDom_1 = reactDom.createPortal;
  var reactDom_2 = reactDom.findDOMNode;
  var reactDom_3 = reactDom.flushSync;
  var reactDom_4 = reactDom.hydrate;
  var reactDom_5 = reactDom.render;
  var reactDom_6 = reactDom.unmountComponentAtNode;
  var reactDom_7 = reactDom.unstable_batchedUpdates;
  var reactDom_8 = reactDom.unstable_createPortal;
  var reactDom_9 = reactDom.unstable_createRoot;
  var reactDom_10 = reactDom.unstable_flushControlled;
  var reactDom_11 = reactDom.unstable_interactiveUpdates;
  var reactDom_12 = reactDom.unstable_renderSubtreeIntoContainer;
  var reactDom_13 = reactDom.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  var index = /*#__PURE__*/Object.freeze({
    'default': reactDom,
    __moduleExports: reactDom,
    createPortal: reactDom_1,
    findDOMNode: reactDom_2,
    flushSync: reactDom_3,
    hydrate: reactDom_4,
    render: reactDom_5,
    unmountComponentAtNode: reactDom_6,
    unstable_batchedUpdates: reactDom_7,
    unstable_createPortal: reactDom_8,
    unstable_createRoot: reactDom_9,
    unstable_flushControlled: reactDom_10,
    unstable_interactiveUpdates: reactDom_11,
    unstable_renderSubtreeIntoContainer: reactDom_12,
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: reactDom_13
  });

  var uaParser = createCommonjsModule(function (module, exports) {
  /*!
   * UAParser.js v0.7.19
   * Lightweight JavaScript-based User-Agent string parser
   * https://github.com/faisalman/ua-parser-js
   *
   * Copyright © 2012-2016 Faisal Salman <fyzlman@gmail.com>
   * Dual licensed under GPLv2 or MIT
   */

  (function (window, undefined$1) {

      //////////////
      // Constants
      /////////////


      var LIBVERSION  = '0.7.19',
          EMPTY       = '',
          UNKNOWN     = '?',
          FUNC_TYPE   = 'function',
          UNDEF_TYPE  = 'undefined',
          OBJ_TYPE    = 'object',
          STR_TYPE    = 'string',
          MAJOR       = 'major', // deprecated
          MODEL       = 'model',
          NAME        = 'name',
          TYPE        = 'type',
          VENDOR      = 'vendor',
          VERSION     = 'version',
          ARCHITECTURE= 'architecture',
          CONSOLE     = 'console',
          MOBILE      = 'mobile',
          TABLET      = 'tablet',
          SMARTTV     = 'smarttv',
          WEARABLE    = 'wearable',
          EMBEDDED    = 'embedded';


      ///////////
      // Helper
      //////////


      var util = {
          extend : function (regexes, extensions) {
              var margedRegexes = {};
              for (var i in regexes) {
                  if (extensions[i] && extensions[i].length % 2 === 0) {
                      margedRegexes[i] = extensions[i].concat(regexes[i]);
                  } else {
                      margedRegexes[i] = regexes[i];
                  }
              }
              return margedRegexes;
          },
          has : function (str1, str2) {
            if (typeof str1 === "string") {
              return str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1;
            } else {
              return false;
            }
          },
          lowerize : function (str) {
              return str.toLowerCase();
          },
          major : function (version) {
              return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g,'').split(".")[0] : undefined$1;
          },
          trim : function (str) {
            return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
          }
      };


      ///////////////
      // Map helper
      //////////////


      var mapper = {

          rgx : function (ua, arrays) {

              //var result = {},
              var i = 0, j, k, p, q, matches, match;//, args = arguments;

              /*// construct object barebones
              for (p = 0; p < args[1].length; p++) {
                  q = args[1][p];
                  result[typeof q === OBJ_TYPE ? q[0] : q] = undefined;
              }*/

              // loop through all regexes maps
              while (i < arrays.length && !matches) {

                  var regex = arrays[i],       // even sequence (0,2,4,..)
                      props = arrays[i + 1];   // odd sequence (1,3,5,..)
                  j = k = 0;

                  // try matching uastring with regexes
                  while (j < regex.length && !matches) {

                      matches = regex[j++].exec(ua);

                      if (!!matches) {
                          for (p = 0; p < props.length; p++) {
                              match = matches[++k];
                              q = props[p];
                              // check if given property is actually array
                              if (typeof q === OBJ_TYPE && q.length > 0) {
                                  if (q.length == 2) {
                                      if (typeof q[1] == FUNC_TYPE) {
                                          // assign modified match
                                          this[q[0]] = q[1].call(this, match);
                                      } else {
                                          // assign given value, ignore regex match
                                          this[q[0]] = q[1];
                                      }
                                  } else if (q.length == 3) {
                                      // check whether function or regex
                                      if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                          // call function (usually string mapper)
                                          this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
                                      } else {
                                          // sanitize match using given regex
                                          this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
                                      }
                                  } else if (q.length == 4) {
                                          this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
                                  }
                              } else {
                                  this[q] = match ? match : undefined$1;
                              }
                          }
                      }
                  }
                  i += 2;
              }
              // console.log(this);
              //return this;
          },

          str : function (str, map) {

              for (var i in map) {
                  // check if array
                  if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                      for (var j = 0; j < map[i].length; j++) {
                          if (util.has(map[i][j], str)) {
                              return (i === UNKNOWN) ? undefined$1 : i;
                          }
                      }
                  } else if (util.has(map[i], str)) {
                      return (i === UNKNOWN) ? undefined$1 : i;
                  }
              }
              return str;
          }
      };


      ///////////////
      // String map
      //////////////


      var maps = {

          browser : {
              oldsafari : {
                  version : {
                      '1.0'   : '/8',
                      '1.2'   : '/1',
                      '1.3'   : '/3',
                      '2.0'   : '/412',
                      '2.0.2' : '/416',
                      '2.0.3' : '/417',
                      '2.0.4' : '/419',
                      '?'     : '/'
                  }
              }
          },

          device : {
              amazon : {
                  model : {
                      'Fire Phone' : ['SD', 'KF']
                  }
              },
              sprint : {
                  model : {
                      'Evo Shift 4G' : '7373KT'
                  },
                  vendor : {
                      'HTC'       : 'APA',
                      'Sprint'    : 'Sprint'
                  }
              }
          },

          os : {
              windows : {
                  version : {
                      'ME'        : '4.90',
                      'NT 3.11'   : 'NT3.51',
                      'NT 4.0'    : 'NT4.0',
                      '2000'      : 'NT 5.0',
                      'XP'        : ['NT 5.1', 'NT 5.2'],
                      'Vista'     : 'NT 6.0',
                      '7'         : 'NT 6.1',
                      '8'         : 'NT 6.2',
                      '8.1'       : 'NT 6.3',
                      '10'        : ['NT 6.4', 'NT 10.0'],
                      'RT'        : 'ARM'
                  }
              }
          }
      };


      //////////////
      // Regex map
      /////////////


      var regexes = {

          browser : [[

              // Presto based
              /(opera\smini)\/([\w\.-]+)/i,                                       // Opera Mini
              /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,                      // Opera Mobi/Tablet
              /(opera).+version\/([\w\.]+)/i,                                     // Opera > 9.80
              /(opera)[\/\s]+([\w\.]+)/i                                          // Opera < 9.80
              ], [NAME, VERSION], [

              /(opios)[\/\s]+([\w\.]+)/i                                          // Opera mini on iphone >= 8.0
              ], [[NAME, 'Opera Mini'], VERSION], [

              /\s(opr)\/([\w\.]+)/i                                               // Opera Webkit
              ], [[NAME, 'Opera'], VERSION], [

              // Mixed
              /(kindle)\/([\w\.]+)/i,                                             // Kindle
              /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,
                                                                                  // Lunascape/Maxthon/Netfront/Jasmine/Blazer

              // Trident based
              /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,
                                                                                  // Avant/IEMobile/SlimBrowser/Baidu
              /(?:ms|\()(ie)\s([\w\.]+)/i,                                        // Internet Explorer

              // Webkit/KHTML based
              /(rekonq)\/([\w\.]*)/i,                                             // Rekonq
              /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark)\/([\w\.-]+)/i
                                                                                  // Chromium/Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser
              ], [NAME, VERSION], [

              /(trident).+rv[:\s]([\w\.]+).+like\sgecko/i                         // IE11
              ], [[NAME, 'IE'], VERSION], [

              /(edge|edgios|edga)\/((\d+)?[\w\.]+)/i                              // Microsoft Edge
              ], [[NAME, 'Edge'], VERSION], [

              /(yabrowser)\/([\w\.]+)/i                                           // Yandex
              ], [[NAME, 'Yandex'], VERSION], [

              /(puffin)\/([\w\.]+)/i                                              // Puffin
              ], [[NAME, 'Puffin'], VERSION], [

              /(focus)\/([\w\.]+)/i                                               // Firefox Focus
              ], [[NAME, 'Firefox Focus'], VERSION], [

              /(opt)\/([\w\.]+)/i                                                 // Opera Touch
              ], [[NAME, 'Opera Touch'], VERSION], [

              /((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i         // UCBrowser
              ], [[NAME, 'UCBrowser'], VERSION], [

              /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
              ], [[NAME, /_/g, ' '], VERSION], [

              /(micromessenger)\/([\w\.]+)/i                                      // WeChat
              ], [[NAME, 'WeChat'], VERSION], [

              /(brave)\/([\w\.]+)/i                                              // Brave browser
              ], [[NAME, 'Brave'], VERSION], [

              /(qqbrowserlite)\/([\w\.]+)/i                                       // QQBrowserLite
              ], [NAME, VERSION], [

              /(QQ)\/([\d\.]+)/i                                                  // QQ, aka ShouQ
              ], [NAME, VERSION], [

              /m?(qqbrowser)[\/\s]?([\w\.]+)/i                                    // QQBrowser
              ], [NAME, VERSION], [

              /(BIDUBrowser)[\/\s]?([\w\.]+)/i                                    // Baidu Browser
              ], [NAME, VERSION], [

              /(2345Explorer)[\/\s]?([\w\.]+)/i                                   // 2345 Browser
              ], [NAME, VERSION], [

              /(MetaSr)[\/\s]?([\w\.]+)/i                                         // SouGouBrowser
              ], [NAME], [

              /(LBBROWSER)/i                                      // LieBao Browser
              ], [NAME], [

              /xiaomi\/miuibrowser\/([\w\.]+)/i                                   // MIUI Browser
              ], [VERSION, [NAME, 'MIUI Browser']], [

              /;fbav\/([\w\.]+);/i                                                // Facebook App for iOS & Android
              ], [VERSION, [NAME, 'Facebook']], [

              /safari\s(line)\/([\w\.]+)/i,                                       // Line App for iOS
              /android.+(line)\/([\w\.]+)\/iab/i                                  // Line App for Android
              ], [NAME, VERSION], [

              /headlesschrome(?:\/([\w\.]+)|\s)/i                                 // Chrome Headless
              ], [VERSION, [NAME, 'Chrome Headless']], [

              /\swv\).+(chrome)\/([\w\.]+)/i                                      // Chrome WebView
              ], [[NAME, /(.+)/, '$1 WebView'], VERSION], [

              /((?:oculus|samsung)browser)\/([\w\.]+)/i
              ], [[NAME, /(.+(?:g|us))(.+)/, '$1 $2'], VERSION], [                // Oculus / Samsung Browser

              /android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i        // Android Browser
              ], [VERSION, [NAME, 'Android Browser']], [

              /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i
                                                                                  // Chrome/OmniWeb/Arora/Tizen/Nokia
              ], [NAME, VERSION], [

              /(dolfin)\/([\w\.]+)/i                                              // Dolphin
              ], [[NAME, 'Dolphin'], VERSION], [

              /((?:android.+)crmo|crios)\/([\w\.]+)/i                             // Chrome for Android/iOS
              ], [[NAME, 'Chrome'], VERSION], [

              /(coast)\/([\w\.]+)/i                                               // Opera Coast
              ], [[NAME, 'Opera Coast'], VERSION], [

              /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
              ], [VERSION, [NAME, 'Firefox']], [

              /version\/([\w\.]+).+?mobile\/\w+\s(safari)/i                       // Mobile Safari
              ], [VERSION, [NAME, 'Mobile Safari']], [

              /version\/([\w\.]+).+?(mobile\s?safari|safari)/i                    // Safari & Safari Mobile
              ], [VERSION, NAME], [

              /webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i  // Google Search Appliance on iOS
              ], [[NAME, 'GSA'], VERSION], [

              /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i                     // Safari < 3.0
              ], [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]], [

              /(konqueror)\/([\w\.]+)/i,                                          // Konqueror
              /(webkit|khtml)\/([\w\.]+)/i
              ], [NAME, VERSION], [

              // Gecko based
              /(navigator|netscape)\/([\w\.-]+)/i                                 // Netscape
              ], [[NAME, 'Netscape'], VERSION], [
              /(swiftfox)/i,                                                      // Swiftfox
              /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
                                                                                  // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
              /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,

                                                                                  // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
              /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,                          // Mozilla

              // Other
              /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
                                                                                  // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir
              /(links)\s\(([\w\.]+)/i,                                            // Links
              /(gobrowser)\/?([\w\.]*)/i,                                         // GoBrowser
              /(ice\s?browser)\/v?([\w\._]+)/i,                                   // ICE Browser
              /(mosaic)[\/\s]([\w\.]+)/i                                          // Mosaic
              ], [NAME, VERSION]

              /* /////////////////////
              // Media players BEGIN
              ////////////////////////

              , [

              /(apple(?:coremedia|))\/((\d+)[\w\._]+)/i,                          // Generic Apple CoreMedia
              /(coremedia) v((\d+)[\w\._]+)/i
              ], [NAME, VERSION], [

              /(aqualung|lyssna|bsplayer)\/((\d+)?[\w\.-]+)/i                     // Aqualung/Lyssna/BSPlayer
              ], [NAME, VERSION], [

              /(ares|ossproxy)\s((\d+)[\w\.-]+)/i                                 // Ares/OSSProxy
              ], [NAME, VERSION], [

              /(audacious|audimusicstream|amarok|bass|core|dalvik|gnomemplayer|music on console|nsplayer|psp-internetradioplayer|videos)\/((\d+)[\w\.-]+)/i,
                                                                                  // Audacious/AudiMusicStream/Amarok/BASS/OpenCORE/Dalvik/GnomeMplayer/MoC
                                                                                  // NSPlayer/PSP-InternetRadioPlayer/Videos
              /(clementine|music player daemon)\s((\d+)[\w\.-]+)/i,               // Clementine/MPD
              /(lg player|nexplayer)\s((\d+)[\d\.]+)/i,
              /player\/(nexplayer|lg player)\s((\d+)[\w\.-]+)/i                   // NexPlayer/LG Player
              ], [NAME, VERSION], [
              /(nexplayer)\s((\d+)[\w\.-]+)/i                                     // Nexplayer
              ], [NAME, VERSION], [

              /(flrp)\/((\d+)[\w\.-]+)/i                                          // Flip Player
              ], [[NAME, 'Flip Player'], VERSION], [

              /(fstream|nativehost|queryseekspider|ia-archiver|facebookexternalhit)/i
                                                                                  // FStream/NativeHost/QuerySeekSpider/IA Archiver/facebookexternalhit
              ], [NAME], [

              /(gstreamer) souphttpsrc (?:\([^\)]+\)){0,1} libsoup\/((\d+)[\w\.-]+)/i
                                                                                  // Gstreamer
              ], [NAME, VERSION], [

              /(htc streaming player)\s[\w_]+\s\/\s((\d+)[\d\.]+)/i,              // HTC Streaming Player
              /(java|python-urllib|python-requests|wget|libcurl)\/((\d+)[\w\.-_]+)/i,
                                                                                  // Java/urllib/requests/wget/cURL
              /(lavf)((\d+)[\d\.]+)/i                                             // Lavf (FFMPEG)
              ], [NAME, VERSION], [

              /(htc_one_s)\/((\d+)[\d\.]+)/i                                      // HTC One S
              ], [[NAME, /_/g, ' '], VERSION], [

              /(mplayer)(?:\s|\/)(?:(?:sherpya-){0,1}svn)(?:-|\s)(r\d+(?:-\d+[\w\.-]+){0,1})/i
                                                                                  // MPlayer SVN
              ], [NAME, VERSION], [

              /(mplayer)(?:\s|\/|[unkow-]+)((\d+)[\w\.-]+)/i                      // MPlayer
              ], [NAME, VERSION], [

              /(mplayer)/i,                                                       // MPlayer (no other info)
              /(yourmuze)/i,                                                      // YourMuze
              /(media player classic|nero showtime)/i                             // Media Player Classic/Nero ShowTime
              ], [NAME], [

              /(nero (?:home|scout))\/((\d+)[\w\.-]+)/i                           // Nero Home/Nero Scout
              ], [NAME, VERSION], [

              /(nokia\d+)\/((\d+)[\w\.-]+)/i                                      // Nokia
              ], [NAME, VERSION], [

              /\s(songbird)\/((\d+)[\w\.-]+)/i                                    // Songbird/Philips-Songbird
              ], [NAME, VERSION], [

              /(winamp)3 version ((\d+)[\w\.-]+)/i,                               // Winamp
              /(winamp)\s((\d+)[\w\.-]+)/i,
              /(winamp)mpeg\/((\d+)[\w\.-]+)/i
              ], [NAME, VERSION], [

              /(ocms-bot|tapinradio|tunein radio|unknown|winamp|inlight radio)/i  // OCMS-bot/tap in radio/tunein/unknown/winamp (no other info)
                                                                                  // inlight radio
              ], [NAME], [

              /(quicktime|rma|radioapp|radioclientapplication|soundtap|totem|stagefright|streamium)\/((\d+)[\w\.-]+)/i
                                                                                  // QuickTime/RealMedia/RadioApp/RadioClientApplication/
                                                                                  // SoundTap/Totem/Stagefright/Streamium
              ], [NAME, VERSION], [

              /(smp)((\d+)[\d\.]+)/i                                              // SMP
              ], [NAME, VERSION], [

              /(vlc) media player - version ((\d+)[\w\.]+)/i,                     // VLC Videolan
              /(vlc)\/((\d+)[\w\.-]+)/i,
              /(xbmc|gvfs|xine|xmms|irapp)\/((\d+)[\w\.-]+)/i,                    // XBMC/gvfs/Xine/XMMS/irapp
              /(foobar2000)\/((\d+)[\d\.]+)/i,                                    // Foobar2000
              /(itunes)\/((\d+)[\d\.]+)/i                                         // iTunes
              ], [NAME, VERSION], [

              /(wmplayer)\/((\d+)[\w\.-]+)/i,                                     // Windows Media Player
              /(windows-media-player)\/((\d+)[\w\.-]+)/i
              ], [[NAME, /-/g, ' '], VERSION], [

              /windows\/((\d+)[\w\.-]+) upnp\/[\d\.]+ dlnadoc\/[\d\.]+ (home media server)/i
                                                                                  // Windows Media Server
              ], [VERSION, [NAME, 'Windows']], [

              /(com\.riseupradioalarm)\/((\d+)[\d\.]*)/i                          // RiseUP Radio Alarm
              ], [NAME, VERSION], [

              /(rad.io)\s((\d+)[\d\.]+)/i,                                        // Rad.io
              /(radio.(?:de|at|fr))\s((\d+)[\d\.]+)/i
              ], [[NAME, 'rad.io'], VERSION]

              //////////////////////
              // Media players END
              ////////////////////*/

          ],

          cpu : [[

              /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i                     // AMD64
              ], [[ARCHITECTURE, 'amd64']], [

              /(ia32(?=;))/i                                                      // IA32 (quicktime)
              ], [[ARCHITECTURE, util.lowerize]], [

              /((?:i[346]|x)86)[;\)]/i                                            // IA32
              ], [[ARCHITECTURE, 'ia32']], [

              // PocketPC mistakenly identified as PowerPC
              /windows\s(ce|mobile);\sppc;/i
              ], [[ARCHITECTURE, 'arm']], [

              /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i                           // PowerPC
              ], [[ARCHITECTURE, /ower/, '', util.lowerize]], [

              /(sun4\w)[;\)]/i                                                    // SPARC
              ], [[ARCHITECTURE, 'sparc']], [

              /((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+[;l]))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i
                                                                                  // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
              ], [[ARCHITECTURE, util.lowerize]]
          ],

          device : [[

              /\((ipad|playbook);[\w\s\);-]+(rim|apple)/i                         // iPad/PlayBook
              ], [MODEL, VENDOR, [TYPE, TABLET]], [

              /applecoremedia\/[\w\.]+ \((ipad)/                                  // iPad
              ], [MODEL, [VENDOR, 'Apple'], [TYPE, TABLET]], [

              /(apple\s{0,1}tv)/i                                                 // Apple TV
              ], [[MODEL, 'Apple TV'], [VENDOR, 'Apple']], [

              /(archos)\s(gamepad2?)/i,                                           // Archos
              /(hp).+(touchpad)/i,                                                // HP TouchPad
              /(hp).+(tablet)/i,                                                  // HP Tablet
              /(kindle)\/([\w\.]+)/i,                                             // Kindle
              /\s(nook)[\w\s]+build\/(\w+)/i,                                     // Nook
              /(dell)\s(strea[kpr\s\d]*[\dko])/i                                  // Dell Streak
              ], [VENDOR, MODEL, [TYPE, TABLET]], [

              /(kf[A-z]+)\sbuild\/.+silk\//i                                      // Kindle Fire HD
              ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [
              /(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i                         // Fire Phone
              ], [[MODEL, mapper.str, maps.device.amazon.model], [VENDOR, 'Amazon'], [TYPE, MOBILE]], [
              /android.+aft([bms])\sbuild/i                                       // Fire TV
              ], [MODEL, [VENDOR, 'Amazon'], [TYPE, SMARTTV]], [

              /\((ip[honed|\s\w*]+);.+(apple)/i                                   // iPod/iPhone
              ], [MODEL, VENDOR, [TYPE, MOBILE]], [
              /\((ip[honed|\s\w*]+);/i                                            // iPod/iPhone
              ], [MODEL, [VENDOR, 'Apple'], [TYPE, MOBILE]], [

              /(blackberry)[\s-]?(\w+)/i,                                         // BlackBerry
              /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,
                                                                                  // BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
              /(hp)\s([\w\s]+\w)/i,                                               // HP iPAQ
              /(asus)-?(\w+)/i                                                    // Asus
              ], [VENDOR, MODEL, [TYPE, MOBILE]], [
              /\(bb10;\s(\w+)/i                                                   // BlackBerry 10
              ], [MODEL, [VENDOR, 'BlackBerry'], [TYPE, MOBILE]], [
                                                                                  // Asus Tablets
              /android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i
              ], [MODEL, [VENDOR, 'Asus'], [TYPE, TABLET]], [

              /(sony)\s(tablet\s[ps])\sbuild\//i,                                  // Sony
              /(sony)?(?:sgp.+)\sbuild\//i
              ], [[VENDOR, 'Sony'], [MODEL, 'Xperia Tablet'], [TYPE, TABLET]], [
              /android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i
              ], [MODEL, [VENDOR, 'Sony'], [TYPE, MOBILE]], [

              /\s(ouya)\s/i,                                                      // Ouya
              /(nintendo)\s([wids3u]+)/i                                          // Nintendo
              ], [VENDOR, MODEL, [TYPE, CONSOLE]], [

              /android.+;\s(shield)\sbuild/i                                      // Nvidia
              ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [

              /(playstation\s[34portablevi]+)/i                                   // Playstation
              ], [MODEL, [VENDOR, 'Sony'], [TYPE, CONSOLE]], [

              /(sprint\s(\w+))/i                                                  // Sprint Phones
              ], [[VENDOR, mapper.str, maps.device.sprint.vendor], [MODEL, mapper.str, maps.device.sprint.model], [TYPE, MOBILE]], [

              /(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i                         // Lenovo tablets
              ], [VENDOR, MODEL, [TYPE, TABLET]], [

              /(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,                               // HTC
              /(zte)-(\w*)/i,                                                     // ZTE
              /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i
                                                                                  // Alcatel/GeeksPhone/Lenovo/Nexian/Panasonic/Sony
              ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

              /(nexus\s9)/i                                                       // HTC Nexus 9
              ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [

              /d\/huawei([\w\s-]+)[;\)]/i,
              /(nexus\s6p)/i                                                      // Huawei
              ], [MODEL, [VENDOR, 'Huawei'], [TYPE, MOBILE]], [

              /(microsoft);\s(lumia[\s\w]+)/i                                     // Microsoft Lumia
              ], [VENDOR, MODEL, [TYPE, MOBILE]], [

              /[\s\(;](xbox(?:\sone)?)[\s\);]/i                                   // Microsoft Xbox
              ], [MODEL, [VENDOR, 'Microsoft'], [TYPE, CONSOLE]], [
              /(kin\.[onetw]{3})/i                                                // Microsoft Kin
              ], [[MODEL, /\./g, ' '], [VENDOR, 'Microsoft'], [TYPE, MOBILE]], [

                                                                                  // Motorola
              /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i,
              /mot[\s-]?(\w*)/i,
              /(XT\d{3,4}) build\//i,
              /(nexus\s6)/i
              ], [MODEL, [VENDOR, 'Motorola'], [TYPE, MOBILE]], [
              /android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i
              ], [MODEL, [VENDOR, 'Motorola'], [TYPE, TABLET]], [

              /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i            // HbbTV devices
              ], [[VENDOR, util.trim], [MODEL, util.trim], [TYPE, SMARTTV]], [

              /hbbtv.+maple;(\d+)/i
              ], [[MODEL, /^/, 'SmartTV'], [VENDOR, 'Samsung'], [TYPE, SMARTTV]], [

              /\(dtv[\);].+(aquos)/i                                              // Sharp
              ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [

              /android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,
              /((SM-T\w+))/i
              ], [[VENDOR, 'Samsung'], MODEL, [TYPE, TABLET]], [                  // Samsung
              /smart-tv.+(samsung)/i
              ], [VENDOR, [TYPE, SMARTTV], MODEL], [
              /((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,
              /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i,
              /sec-((sgh\w+))/i
              ], [[VENDOR, 'Samsung'], MODEL, [TYPE, MOBILE]], [

              /sie-(\w*)/i                                                        // Siemens
              ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [

              /(maemo|nokia).*(n900|lumia\s\d+)/i,                                // Nokia
              /(nokia)[\s_-]?([\w-]*)/i
              ], [[VENDOR, 'Nokia'], MODEL, [TYPE, MOBILE]], [

              /android\s3\.[\s\w;-]{10}(a\d{3})/i                                 // Acer
              ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

              /android.+([vl]k\-?\d{3})\s+build/i                                 // LG Tablet
              ], [MODEL, [VENDOR, 'LG'], [TYPE, TABLET]], [
              /android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i                     // LG Tablet
              ], [[VENDOR, 'LG'], MODEL, [TYPE, TABLET]], [
              /(lg) netcast\.tv/i                                                 // LG SmartTV
              ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
              /(nexus\s[45])/i,                                                   // LG
              /lg[e;\s\/-]+(\w*)/i,
              /android.+lg(\-?[\d\w]+)\s+build/i
              ], [MODEL, [VENDOR, 'LG'], [TYPE, MOBILE]], [

              /android.+(ideatab[a-z0-9\-\s]+)/i                                  // Lenovo
              ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

              /linux;.+((jolla));/i                                               // Jolla
              ], [VENDOR, MODEL, [TYPE, MOBILE]], [

              /((pebble))app\/[\d\.]+\s/i                                         // Pebble
              ], [VENDOR, MODEL, [TYPE, WEARABLE]], [

              /android.+;\s(oppo)\s?([\w\s]+)\sbuild/i                            // OPPO
              ], [VENDOR, MODEL, [TYPE, MOBILE]], [

              /crkey/i                                                            // Google Chromecast
              ], [[MODEL, 'Chromecast'], [VENDOR, 'Google']], [

              /android.+;\s(glass)\s\d/i                                          // Google Glass
              ], [MODEL, [VENDOR, 'Google'], [TYPE, WEARABLE]], [

              /android.+;\s(pixel c)[\s)]/i                                       // Google Pixel C
              ], [MODEL, [VENDOR, 'Google'], [TYPE, TABLET]], [

              /android.+;\s(pixel( [23])?( xl)?)\s/i                              // Google Pixel
              ], [MODEL, [VENDOR, 'Google'], [TYPE, MOBILE]], [

              /android.+;\s(\w+)\s+build\/hm\1/i,                                 // Xiaomi Hongmi 'numeric' models
              /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,               // Xiaomi Hongmi
              /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i,    // Xiaomi Mi
              /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i       // Redmi Phones
              ], [[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, MOBILE]], [
              /android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i            // Mi Pad tablets
              ],[[MODEL, /_/g, ' '], [VENDOR, 'Xiaomi'], [TYPE, TABLET]], [
              /android.+;\s(m[1-5]\snote)\sbuild/i                                // Meizu Tablet
              ], [MODEL, [VENDOR, 'Meizu'], [TYPE, TABLET]], [
              /(mz)-([\w-]{2,})/i                                                 // Meizu Phone
              ], [[VENDOR, 'Meizu'], MODEL, [TYPE, MOBILE]], [

              /android.+a000(1)\s+build/i,                                        // OnePlus
              /android.+oneplus\s(a\d{4})\s+build/i
              ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

              /android.+[;\/]\s*(RCT[\d\w]+)\s+build/i                            // RCA Tablets
              ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [

              /android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i                      // Dell Venue Tablets
              ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [

              /android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i                         // Verizon Tablet
              ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [

              /android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i     // Barnes & Noble Tablet
              ], [[VENDOR, 'Barnes & Noble'], MODEL, [TYPE, TABLET]], [

              /android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i                           // Barnes & Noble Tablet
              ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [

              /android.+;\s(k88)\sbuild/i                                         // ZTE K Series Tablet
              ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [

              /android.+[;\/]\s*(gen\d{3})\s+build.*49h/i                         // Swiss GEN Mobile
              ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [

              /android.+[;\/]\s*(zur\d{3})\s+build/i                              // Swiss ZUR Tablet
              ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [

              /android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i                         // Zeki Tablets
              ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [

              /(android).+[;\/]\s+([YR]\d{2})\s+build/i,
              /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i        // Dragon Touch Tablet
              ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [

              /android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i                            // Insignia Tablets
              ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [

              /android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i                    // NextBook Tablets
              ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [

              /android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i
              ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [                    // Voice Xtreme Phones

              /android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i                     // LvTel Phones
              ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [

              /android.+;\s(PH-1)\s/i
              ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [                // Essential PH-1

              /android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i          // Envizen Tablets
              ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [

              /android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i          // Le Pan Tablets
              ], [VENDOR, MODEL, [TYPE, TABLET]], [

              /android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i                         // MachSpeed Tablets
              ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [

              /android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i                // Trinity Tablets
              ], [VENDOR, MODEL, [TYPE, TABLET]], [

              /android.+[;\/]\s*TU_(1491)\s+build/i                               // Rotor Tablets
              ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [

              /android.+(KS(.+))\s+build/i                                        // Amazon Kindle Tablets
              ], [MODEL, [VENDOR, 'Amazon'], [TYPE, TABLET]], [

              /android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i                      // Gigaset Tablets
              ], [VENDOR, MODEL, [TYPE, TABLET]], [

              /\s(tablet|tab)[;\/]/i,                                             // Unidentifiable Tablet
              /\s(mobile)(?:[;\/]|\ssafari)/i                                     // Unidentifiable Mobile
              ], [[TYPE, util.lowerize], VENDOR, MODEL], [

              /(android[\w\.\s\-]{0,9});.+build/i                                 // Generic Android Device
              ], [MODEL, [VENDOR, 'Generic']]


          /*//////////////////////////
              // TODO: move to string map
              ////////////////////////////

              /(C6603)/i                                                          // Sony Xperia Z C6603
              ], [[MODEL, 'Xperia Z C6603'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [
              /(C6903)/i                                                          // Sony Xperia Z 1
              ], [[MODEL, 'Xperia Z 1'], [VENDOR, 'Sony'], [TYPE, MOBILE]], [

              /(SM-G900[F|H])/i                                                   // Samsung Galaxy S5
              ], [[MODEL, 'Galaxy S5'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
              /(SM-G7102)/i                                                       // Samsung Galaxy Grand 2
              ], [[MODEL, 'Galaxy Grand 2'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
              /(SM-G530H)/i                                                       // Samsung Galaxy Grand Prime
              ], [[MODEL, 'Galaxy Grand Prime'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
              /(SM-G313HZ)/i                                                      // Samsung Galaxy V
              ], [[MODEL, 'Galaxy V'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
              /(SM-T805)/i                                                        // Samsung Galaxy Tab S 10.5
              ], [[MODEL, 'Galaxy Tab S 10.5'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [
              /(SM-G800F)/i                                                       // Samsung Galaxy S5 Mini
              ], [[MODEL, 'Galaxy S5 Mini'], [VENDOR, 'Samsung'], [TYPE, MOBILE]], [
              /(SM-T311)/i                                                        // Samsung Galaxy Tab 3 8.0
              ], [[MODEL, 'Galaxy Tab 3 8.0'], [VENDOR, 'Samsung'], [TYPE, TABLET]], [

              /(T3C)/i                                                            // Advan Vandroid T3C
              ], [MODEL, [VENDOR, 'Advan'], [TYPE, TABLET]], [
              /(ADVAN T1J\+)/i                                                    // Advan Vandroid T1J+
              ], [[MODEL, 'Vandroid T1J+'], [VENDOR, 'Advan'], [TYPE, TABLET]], [
              /(ADVAN S4A)/i                                                      // Advan Vandroid S4A
              ], [[MODEL, 'Vandroid S4A'], [VENDOR, 'Advan'], [TYPE, MOBILE]], [

              /(V972M)/i                                                          // ZTE V972M
              ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [

              /(i-mobile)\s(IQ\s[\d\.]+)/i                                        // i-mobile IQ
              ], [VENDOR, MODEL, [TYPE, MOBILE]], [
              /(IQ6.3)/i                                                          // i-mobile IQ IQ 6.3
              ], [[MODEL, 'IQ 6.3'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [
              /(i-mobile)\s(i-style\s[\d\.]+)/i                                   // i-mobile i-STYLE
              ], [VENDOR, MODEL, [TYPE, MOBILE]], [
              /(i-STYLE2.1)/i                                                     // i-mobile i-STYLE 2.1
              ], [[MODEL, 'i-STYLE 2.1'], [VENDOR, 'i-mobile'], [TYPE, MOBILE]], [

              /(mobiistar touch LAI 512)/i                                        // mobiistar touch LAI 512
              ], [[MODEL, 'Touch LAI 512'], [VENDOR, 'mobiistar'], [TYPE, MOBILE]], [

              /////////////
              // END TODO
              ///////////*/

          ],

          engine : [[

              /windows.+\sedge\/([\w\.]+)/i                                       // EdgeHTML
              ], [VERSION, [NAME, 'EdgeHTML']], [

              /(presto)\/([\w\.]+)/i,                                             // Presto
              /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,     // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m
              /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,                          // KHTML/Tasman/Links
              /(icab)[\/\s]([23]\.[\d\.]+)/i                                      // iCab
              ], [NAME, VERSION], [

              /rv\:([\w\.]{1,9}).+(gecko)/i                                       // Gecko
              ], [VERSION, NAME]
          ],

          os : [[

              // Windows based
              /microsoft\s(windows)\s(vista|xp)/i                                 // Windows (iTunes)
              ], [NAME, VERSION], [
              /(windows)\snt\s6\.2;\s(arm)/i,                                     // Windows RT
              /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,                   // Windows Phone
              /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i
              ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [
              /(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i
              ], [[NAME, 'Windows'], [VERSION, mapper.str, maps.os.windows.version]], [

              // Mobile/Embedded OS
              /\((bb)(10);/i                                                      // BlackBerry 10
              ], [[NAME, 'BlackBerry'], VERSION], [
              /(blackberry)\w*\/?([\w\.]*)/i,                                     // Blackberry
              /(tizen)[\/\s]([\w\.]+)/i,                                          // Tizen
              /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]*)/i,
                                                                                  // Android/WebOS/Palm/QNX/Bada/RIM/MeeGo/Contiki
              /linux;.+(sailfish);/i                                              // Sailfish OS
              ], [NAME, VERSION], [
              /(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i                  // Symbian
              ], [[NAME, 'Symbian'], VERSION], [
              /\((series40);/i                                                    // Series 40
              ], [NAME], [
              /mozilla.+\(mobile;.+gecko.+firefox/i                               // Firefox OS
              ], [[NAME, 'Firefox OS'], VERSION], [

              // Console
              /(nintendo|playstation)\s([wids34portablevu]+)/i,                   // Nintendo/Playstation

              // GNU/Linux based
              /(mint)[\/\s\(]?(\w*)/i,                                            // Mint
              /(mageia|vectorlinux)[;\s]/i,                                       // Mageia/VectorLinux
              /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i,
                                                                                  // Joli/Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware
                                                                                  // Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus
              /(hurd|linux)\s?([\w\.]*)/i,                                        // Hurd/Linux
              /(gnu)\s?([\w\.]*)/i                                                // GNU
              ], [NAME, VERSION], [

              /(cros)\s[\w]+\s([\w\.]+\w)/i                                       // Chromium OS
              ], [[NAME, 'Chromium OS'], VERSION],[

              // Solaris
              /(sunos)\s?([\w\.\d]*)/i                                            // Solaris
              ], [[NAME, 'Solaris'], VERSION], [

              // BSD based
              /\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i                    // FreeBSD/NetBSD/OpenBSD/PC-BSD/DragonFly
              ], [NAME, VERSION],[

              /(haiku)\s(\w+)/i                                                   // Haiku
              ], [NAME, VERSION],[

              /cfnetwork\/.+darwin/i,
              /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i             // iOS
              ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [

              /(mac\sos\sx)\s?([\w\s\.]*)/i,
              /(macintosh|mac(?=_powerpc)\s)/i                                    // Mac OS
              ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

              // Other
              /((?:open)?solaris)[\/\s-]?([\w\.]*)/i,                             // Solaris
              /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,                                // AIX
              /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,
                                                                                  // Plan9/Minix/BeOS/OS2/AmigaOS/MorphOS/RISCOS/OpenVMS/Fuchsia
              /(unix)\s?([\w\.]*)/i                                               // UNIX
              ], [NAME, VERSION]
          ]
      };


      /////////////////
      // Constructor
      ////////////////
      /*
      var Browser = function (name, version) {
          this[NAME] = name;
          this[VERSION] = version;
      };
      var CPU = function (arch) {
          this[ARCHITECTURE] = arch;
      };
      var Device = function (vendor, model, type) {
          this[VENDOR] = vendor;
          this[MODEL] = model;
          this[TYPE] = type;
      };
      var Engine = Browser;
      var OS = Browser;
      */
      var UAParser = function (uastring, extensions) {

          if (typeof uastring === 'object') {
              extensions = uastring;
              uastring = undefined$1;
          }

          if (!(this instanceof UAParser)) {
              return new UAParser(uastring, extensions).getResult();
          }

          var ua = uastring || ((window && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
          var rgxmap = extensions ? util.extend(regexes, extensions) : regexes;
          //var browser = new Browser();
          //var cpu = new CPU();
          //var device = new Device();
          //var engine = new Engine();
          //var os = new OS();

          this.getBrowser = function () {
              var browser = { name: undefined$1, version: undefined$1 };
              mapper.rgx.call(browser, ua, rgxmap.browser);
              browser.major = util.major(browser.version); // deprecated
              return browser;
          };
          this.getCPU = function () {
              var cpu = { architecture: undefined$1 };
              mapper.rgx.call(cpu, ua, rgxmap.cpu);
              return cpu;
          };
          this.getDevice = function () {
              var device = { vendor: undefined$1, model: undefined$1, type: undefined$1 };
              mapper.rgx.call(device, ua, rgxmap.device);
              return device;
          };
          this.getEngine = function () {
              var engine = { name: undefined$1, version: undefined$1 };
              mapper.rgx.call(engine, ua, rgxmap.engine);
              return engine;
          };
          this.getOS = function () {
              var os = { name: undefined$1, version: undefined$1 };
              mapper.rgx.call(os, ua, rgxmap.os);
              return os;
          };
          this.getResult = function () {
              return {
                  ua      : this.getUA(),
                  browser : this.getBrowser(),
                  engine  : this.getEngine(),
                  os      : this.getOS(),
                  device  : this.getDevice(),
                  cpu     : this.getCPU()
              };
          };
          this.getUA = function () {
              return ua;
          };
          this.setUA = function (uastring) {
              ua = uastring;
              //browser = new Browser();
              //cpu = new CPU();
              //device = new Device();
              //engine = new Engine();
              //os = new OS();
              return this;
          };
          return this;
      };

      UAParser.VERSION = LIBVERSION;
      UAParser.BROWSER = {
          NAME    : NAME,
          MAJOR   : MAJOR, // deprecated
          VERSION : VERSION
      };
      UAParser.CPU = {
          ARCHITECTURE : ARCHITECTURE
      };
      UAParser.DEVICE = {
          MODEL   : MODEL,
          VENDOR  : VENDOR,
          TYPE    : TYPE,
          CONSOLE : CONSOLE,
          MOBILE  : MOBILE,
          SMARTTV : SMARTTV,
          TABLET  : TABLET,
          WEARABLE: WEARABLE,
          EMBEDDED: EMBEDDED
      };
      UAParser.ENGINE = {
          NAME    : NAME,
          VERSION : VERSION
      };
      UAParser.OS = {
          NAME    : NAME,
          VERSION : VERSION
      };
      //UAParser.Utils = util;

      ///////////
      // Export
      //////////


      // check js environment
      {
          // nodejs env
          if (module.exports) {
              exports = module.exports = UAParser;
          }
          // TODO: test!!!!!!!!
          /*
          if (require && require.main === module && process) {
              // cli
              var jsonize = function (arr) {
                  var res = [];
                  for (var i in arr) {
                      res.push(new UAParser(arr[i]).getResult());
                  }
                  process.stdout.write(JSON.stringify(res, null, 2) + '\n');
              };
              if (process.stdin.isTTY) {
                  // via args
                  jsonize(process.argv.slice(2));
              } else {
                  // via pipe
                  var str = '';
                  process.stdin.on('readable', function() {
                      var read = process.stdin.read();
                      if (read !== null) {
                          str += read;
                      }
                  });
                  process.stdin.on('end', function () {
                      jsonize(str.replace(/\n$/, '').split('\n'));
                  });
              }
          }
          */
          exports.UAParser = UAParser;
      }

      // jQuery/Zepto specific (optional)
      // Note:
      //   In AMD env the global scope should be kept clean, but jQuery is an exception.
      //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
      //   and we should catch that.
      var $ = window && (window.jQuery || window.Zepto);
      if (typeof $ !== UNDEF_TYPE && !$.ua) {
          var parser = new UAParser();
          $.ua = parser.getResult();
          $.ua.get = function () {
              return parser.getUA();
          };
          $.ua.set = function (uastring) {
              parser.setUA(uastring);
              var result = parser.getResult();
              for (var prop in result) {
                  $.ua[prop] = result[prop];
              }
          };
      }

  })(typeof window === 'object' ? window : commonjsGlobal);
  });
  var uaParser_1 = uaParser.UAParser;

  var UNKNOWN = 'Unknown';

  var PLATFORM_MAP = {
    'Mac OS': 'Mac OS X'
  };

  /**
   * Convert from UAParser platform name to what we expect.
   */
  function convertPlatformName(name) {
    return PLATFORM_MAP[name] || name;
  }

  /**
   * Get the version number in parts. This is very naive. We actually get major
   * version as a part of UAParser already, which is generally good enough, but
   * let's get the minor just in case.
   */
  function getBrowserVersion(version) {
    if (!version) {
      return {
        major: '',
        minor: ''
      };
    }
    var parts = version.split('.');
    return {
      major: parts[0],
      minor: parts[1]
    };
  }

  /**
   * Get the UA data fom UAParser and then convert it to the format we're
   * expecting for our APIS.
   */
  var parser = new uaParser();
  var results = parser.getResult();

  // Do some conversion first.
  var browserVersionData = getBrowserVersion(results.browser.version);
  var uaData = {
    browserArchitecture: results.cpu.architecture || UNKNOWN,
    browserFullVersion: results.browser.version || UNKNOWN,
    browserMinorVersion: browserVersionData.minor || UNKNOWN,
    browserName: results.browser.name || UNKNOWN,
    browserVersion: results.browser.major || UNKNOWN,
    deviceName: results.device.model || UNKNOWN,
    engineName: results.engine.name || UNKNOWN,
    engineVersion: results.engine.version || UNKNOWN,
    platformArchitecture: results.cpu.architecture || UNKNOWN,
    platformName: convertPlatformName(results.os.name) || UNKNOWN,
    platformVersion: results.os.version || UNKNOWN,
    platformFullVersion: results.os.version || UNKNOWN
  };

  var UserAgentData = uaData;

  var componentRegex = /\./;
  var orRegex = /\|\|/;
  var rangeRegex = /\s+\-\s+/;
  var modifierRegex = /^(<=|<|=|>=|~>|~|>|)?\s*(.+)/;
  var numericRegex = /^(\d*)(.*)/;

  /**
   * Splits input `range` on "||" and returns true if any subrange matches
   * `version`.
   *
   * @param {string} range
   * @param {string} version
   * @returns {boolean}
   */
  function checkOrExpression(range, version) {
    var expressions = range.split(orRegex);

    if (expressions.length > 1) {
      return expressions.some(function (range) {
        return VersionRange.contains(range, version);
      });
    } else {
      range = expressions[0].trim();
      return checkRangeExpression(range, version);
    }
  }

  /**
   * Splits input `range` on " - " (the surrounding whitespace is required) and
   * returns true if version falls between the two operands.
   *
   * @param {string} range
   * @param {string} version
   * @returns {boolean}
   */
  function checkRangeExpression(range, version) {
    var expressions = range.split(rangeRegex);

    !(expressions.length > 0 && expressions.length <= 2) ? invariant_1(false) : void 0;

    if (expressions.length === 1) {
      return checkSimpleExpression(expressions[0], version);
    } else {
      var startVersion = expressions[0],
          endVersion = expressions[1];

      !(isSimpleVersion(startVersion) && isSimpleVersion(endVersion)) ? invariant_1(false) : void 0;

      return checkSimpleExpression('>=' + startVersion, version) && checkSimpleExpression('<=' + endVersion, version);
    }
  }

  /**
   * Checks if `range` matches `version`. `range` should be a "simple" range (ie.
   * not a compound range using the " - " or "||" operators).
   *
   * @param {string} range
   * @param {string} version
   * @returns {boolean}
   */
  function checkSimpleExpression(range, version) {
    range = range.trim();
    if (range === '') {
      return true;
    }

    var versionComponents = version.split(componentRegex);

    var _getModifierAndCompon = getModifierAndComponents(range),
        modifier = _getModifierAndCompon.modifier,
        rangeComponents = _getModifierAndCompon.rangeComponents;

    switch (modifier) {
      case '<':
        return checkLessThan(versionComponents, rangeComponents);
      case '<=':
        return checkLessThanOrEqual(versionComponents, rangeComponents);
      case '>=':
        return checkGreaterThanOrEqual(versionComponents, rangeComponents);
      case '>':
        return checkGreaterThan(versionComponents, rangeComponents);
      case '~':
      case '~>':
        return checkApproximateVersion(versionComponents, rangeComponents);
      default:
        return checkEqual(versionComponents, rangeComponents);
    }
  }

  /**
   * Checks whether `a` is less than `b`.
   *
   * @param {array<string>} a
   * @param {array<string>} b
   * @returns {boolean}
   */
  function checkLessThan(a, b) {
    return compareComponents(a, b) === -1;
  }

  /**
   * Checks whether `a` is less than or equal to `b`.
   *
   * @param {array<string>} a
   * @param {array<string>} b
   * @returns {boolean}
   */
  function checkLessThanOrEqual(a, b) {
    var result = compareComponents(a, b);
    return result === -1 || result === 0;
  }

  /**
   * Checks whether `a` is equal to `b`.
   *
   * @param {array<string>} a
   * @param {array<string>} b
   * @returns {boolean}
   */
  function checkEqual(a, b) {
    return compareComponents(a, b) === 0;
  }

  /**
   * Checks whether `a` is greater than or equal to `b`.
   *
   * @param {array<string>} a
   * @param {array<string>} b
   * @returns {boolean}
   */
  function checkGreaterThanOrEqual(a, b) {
    var result = compareComponents(a, b);
    return result === 1 || result === 0;
  }

  /**
   * Checks whether `a` is greater than `b`.
   *
   * @param {array<string>} a
   * @param {array<string>} b
   * @returns {boolean}
   */
  function checkGreaterThan(a, b) {
    return compareComponents(a, b) === 1;
  }

  /**
   * Checks whether `a` is "reasonably close" to `b` (as described in
   * https://www.npmjs.org/doc/misc/semver.html). For example, if `b` is "1.3.1"
   * then "reasonably close" is defined as ">= 1.3.1 and < 1.4".
   *
   * @param {array<string>} a
   * @param {array<string>} b
   * @returns {boolean}
   */
  function checkApproximateVersion(a, b) {
    var lowerBound = b.slice();
    var upperBound = b.slice();

    if (upperBound.length > 1) {
      upperBound.pop();
    }
    var lastIndex = upperBound.length - 1;
    var numeric = parseInt(upperBound[lastIndex], 10);
    if (isNumber(numeric)) {
      upperBound[lastIndex] = numeric + 1 + '';
    }

    return checkGreaterThanOrEqual(a, lowerBound) && checkLessThan(a, upperBound);
  }

  /**
   * Extracts the optional modifier (<, <=, =, >=, >, ~, ~>) and version
   * components from `range`.
   *
   * For example, given `range` ">= 1.2.3" returns an object with a `modifier` of
   * `">="` and `components` of `[1, 2, 3]`.
   *
   * @param {string} range
   * @returns {object}
   */
  function getModifierAndComponents(range) {
    var rangeComponents = range.split(componentRegex);
    var matches = rangeComponents[0].match(modifierRegex);
    !matches ? invariant_1(false) : void 0;

    return {
      modifier: matches[1],
      rangeComponents: [matches[2]].concat(rangeComponents.slice(1))
    };
  }

  /**
   * Determines if `number` is a number.
   *
   * @param {mixed} number
   * @returns {boolean}
   */
  function isNumber(number) {
    return !isNaN(number) && isFinite(number);
  }

  /**
   * Tests whether `range` is a "simple" version number without any modifiers
   * (">", "~" etc).
   *
   * @param {string} range
   * @returns {boolean}
   */
  function isSimpleVersion(range) {
    return !getModifierAndComponents(range).modifier;
  }

  /**
   * Zero-pads array `array` until it is at least `length` long.
   *
   * @param {array} array
   * @param {number} length
   */
  function zeroPad(array, length) {
    for (var i = array.length; i < length; i++) {
      array[i] = '0';
    }
  }

  /**
   * Normalizes `a` and `b` in preparation for comparison by doing the following:
   *
   * - zero-pads `a` and `b`
   * - marks any "x", "X" or "*" component in `b` as equivalent by zero-ing it out
   *   in both `a` and `b`
   * - marks any final "*" component in `b` as a greedy wildcard by zero-ing it
   *   and all of its successors in `a`
   *
   * @param {array<string>} a
   * @param {array<string>} b
   * @returns {array<array<string>>}
   */
  function normalizeVersions(a, b) {
    a = a.slice();
    b = b.slice();

    zeroPad(a, b.length);

    // mark "x" and "*" components as equal
    for (var i = 0; i < b.length; i++) {
      var matches = b[i].match(/^[x*]$/i);
      if (matches) {
        b[i] = a[i] = '0';

        // final "*" greedily zeros all remaining components
        if (matches[0] === '*' && i === b.length - 1) {
          for (var j = i; j < a.length; j++) {
            a[j] = '0';
          }
        }
      }
    }

    zeroPad(b, a.length);

    return [a, b];
  }

  /**
   * Returns the numerical -- not the lexicographical -- ordering of `a` and `b`.
   *
   * For example, `10-alpha` is greater than `2-beta`.
   *
   * @param {string} a
   * @param {string} b
   * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,
   * or greater than `b`, respectively
   */
  function compareNumeric(a, b) {
    var aPrefix = a.match(numericRegex)[1];
    var bPrefix = b.match(numericRegex)[1];
    var aNumeric = parseInt(aPrefix, 10);
    var bNumeric = parseInt(bPrefix, 10);

    if (isNumber(aNumeric) && isNumber(bNumeric) && aNumeric !== bNumeric) {
      return compare(aNumeric, bNumeric);
    } else {
      return compare(a, b);
    }
  }

  /**
   * Returns the ordering of `a` and `b`.
   *
   * @param {string|number} a
   * @param {string|number} b
   * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,
   * or greater than `b`, respectively
   */
  function compare(a, b) {
    !(typeof a === typeof b) ? invariant_1(false) : void 0;

    if (a > b) {
      return 1;
    } else if (a < b) {
      return -1;
    } else {
      return 0;
    }
  }

  /**
   * Compares arrays of version components.
   *
   * @param {array<string>} a
   * @param {array<string>} b
   * @returns {number} -1, 0 or 1 to indicate whether `a` is less than, equal to,
   * or greater than `b`, respectively
   */
  function compareComponents(a, b) {
    var _normalizeVersions = normalizeVersions(a, b),
        aNormalized = _normalizeVersions[0],
        bNormalized = _normalizeVersions[1];

    for (var i = 0; i < bNormalized.length; i++) {
      var result = compareNumeric(aNormalized[i], bNormalized[i]);
      if (result) {
        return result;
      }
    }

    return 0;
  }

  var VersionRange = {
    /**
     * Checks whether `version` satisfies the `range` specification.
     *
     * We support a subset of the expressions defined in
     * https://www.npmjs.org/doc/misc/semver.html:
     *
     *    version   Must match version exactly
     *    =version  Same as just version
     *    >version  Must be greater than version
     *    >=version Must be greater than or equal to version
     *    <version  Must be less than version
     *    <=version Must be less than or equal to version
     *    ~version  Must be at least version, but less than the next significant
     *              revision above version:
     *              "~1.2.3" is equivalent to ">= 1.2.3 and < 1.3"
     *    ~>version Equivalent to ~version
     *    1.2.x     Must match "1.2.x", where "x" is a wildcard that matches
     *              anything
     *    1.2.*     Similar to "1.2.x", but "*" in the trailing position is a
     *              "greedy" wildcard, so will match any number of additional
     *              components:
     *              "1.2.*" will match "1.2.1", "1.2.1.1", "1.2.1.1.1" etc
     *    *         Any version
     *    ""        (Empty string) Same as *
     *    v1 - v2   Equivalent to ">= v1 and <= v2"
     *    r1 || r2  Passes if either r1 or r2 are satisfied
     *
     * @param {string} range
     * @param {string} version
     * @returns {boolean}
     */
    contains: function contains(range, version) {
      return checkOrExpression(range.trim(), version.trim());
    }
  };

  var VersionRange_1 = VersionRange;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

  /**
   * Executes the provided `callback` once for each enumerable own property in the
   * object and constructs a new object from the results. The `callback` is
   * invoked with three arguments:
   *
   *  - the property value
   *  - the property name
   *  - the object being traversed
   *
   * Properties that are added after the call to `mapObject` will not be visited
   * by `callback`. If the values of existing properties are changed, the value
   * passed to `callback` will be the value at the time `mapObject` visits them.
   * Properties that are deleted before being visited are not visited.
   *
   * @grep function objectMap()
   * @grep function objMap()
   *
   * @param {?object} object
   * @param {function} callback
   * @param {*} context
   * @return {?object}
   */
  function mapObject(object, callback, context) {
    if (!object) {
      return null;
    }
    var result = {};
    for (var name in object) {
      if (hasOwnProperty$1.call(object, name)) {
        result[name] = callback.call(context, object[name], name, object);
      }
    }
    return result;
  }

  var mapObject_1 = mapObject;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @typechecks static-only
   */

  /**
   * Memoizes the return value of a function that accepts one string argument.
   */

  function memoizeStringOnly(callback) {
    var cache = {};
    return function (string) {
      if (!cache.hasOwnProperty(string)) {
        cache[string] = callback.call(this, string);
      }
      return cache[string];
    };
  }

  var memoizeStringOnly_1 = memoizeStringOnly;

  /**
   * Checks to see whether `name` and `version` satisfy `query`.
   *
   * @param {string} name Name of the browser, device, engine or platform
   * @param {?string} version Version of the browser, engine or platform
   * @param {string} query Query of form "Name [range expression]"
   * @param {?function} normalizer Optional pre-processor for range expression
   * @return {boolean}
   */
  function compare$1(name, version, query, normalizer) {
    // check for exact match with no version
    if (name === query) {
      return true;
    }

    // check for non-matching names
    if (!query.startsWith(name)) {
      return false;
    }

    // full comparison with version
    var range = query.slice(name.length);
    if (version) {
      range = normalizer ? normalizer(range) : range;
      return VersionRange_1.contains(range, version);
    }

    return false;
  }

  /**
   * Normalizes `version` by stripping any "NT" prefix, but only on the Windows
   * platform.
   *
   * Mimics the stripping performed by the `UserAgentWindowsPlatform` PHP class.
   *
   * @param {string} version
   * @return {string}
   */
  function normalizePlatformVersion(version) {
    if (UserAgentData.platformName === 'Windows') {
      return version.replace(/^\s*NT/, '');
    }

    return version;
  }

  /**
   * Provides client-side access to the authoritative PHP-generated User Agent
   * information supplied by the server.
   */
  var UserAgent = {
    /**
     * Check if the User Agent browser matches `query`.
     *
     * `query` should be a string like "Chrome" or "Chrome > 33".
     *
     * Valid browser names include:
     *
     * - ACCESS NetFront
     * - AOL
     * - Amazon Silk
     * - Android
     * - BlackBerry
     * - BlackBerry PlayBook
     * - Chrome
     * - Chrome for iOS
     * - Chrome frame
     * - Facebook PHP SDK
     * - Facebook for iOS
     * - Firefox
     * - IE
     * - IE Mobile
     * - Mobile Safari
     * - Motorola Internet Browser
     * - Nokia
     * - Openwave Mobile Browser
     * - Opera
     * - Opera Mini
     * - Opera Mobile
     * - Safari
     * - UIWebView
     * - Unknown
     * - webOS
     * - etc...
     *
     * An authoritative list can be found in the PHP `BrowserDetector` class and
     * related classes in the same file (see calls to `new UserAgentBrowser` here:
     * https://fburl.com/50728104).
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "Name [range expression]"
     * @return {boolean}
     */
    isBrowser: function isBrowser(query) {
      return compare$1(UserAgentData.browserName, UserAgentData.browserFullVersion, query);
    },


    /**
     * Check if the User Agent browser uses a 32 or 64 bit architecture.
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "32" or "64".
     * @return {boolean}
     */
    isBrowserArchitecture: function isBrowserArchitecture(query) {
      return compare$1(UserAgentData.browserArchitecture, null, query);
    },


    /**
     * Check if the User Agent device matches `query`.
     *
     * `query` should be a string like "iPhone" or "iPad".
     *
     * Valid device names include:
     *
     * - Kindle
     * - Kindle Fire
     * - Unknown
     * - iPad
     * - iPhone
     * - iPod
     * - etc...
     *
     * An authoritative list can be found in the PHP `DeviceDetector` class and
     * related classes in the same file (see calls to `new UserAgentDevice` here:
     * https://fburl.com/50728332).
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "Name"
     * @return {boolean}
     */
    isDevice: function isDevice(query) {
      return compare$1(UserAgentData.deviceName, null, query);
    },


    /**
     * Check if the User Agent rendering engine matches `query`.
     *
     * `query` should be a string like "WebKit" or "WebKit >= 537".
     *
     * Valid engine names include:
     *
     * - Gecko
     * - Presto
     * - Trident
     * - WebKit
     * - etc...
     *
     * An authoritative list can be found in the PHP `RenderingEngineDetector`
     * class related classes in the same file (see calls to `new
     * UserAgentRenderingEngine` here: https://fburl.com/50728617).
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "Name [range expression]"
     * @return {boolean}
     */
    isEngine: function isEngine(query) {
      return compare$1(UserAgentData.engineName, UserAgentData.engineVersion, query);
    },


    /**
     * Check if the User Agent platform matches `query`.
     *
     * `query` should be a string like "Windows" or "iOS 5 - 6".
     *
     * Valid platform names include:
     *
     * - Android
     * - BlackBerry OS
     * - Java ME
     * - Linux
     * - Mac OS X
     * - Mac OS X Calendar
     * - Mac OS X Internet Account
     * - Symbian
     * - SymbianOS
     * - Windows
     * - Windows Mobile
     * - Windows Phone
     * - iOS
     * - iOS Facebook Integration Account
     * - iOS Facebook Social Sharing UI
     * - webOS
     * - Chrome OS
     * - etc...
     *
     * An authoritative list can be found in the PHP `PlatformDetector` class and
     * related classes in the same file (see calls to `new UserAgentPlatform`
     * here: https://fburl.com/50729226).
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "Name [range expression]"
     * @return {boolean}
     */
    isPlatform: function isPlatform(query) {
      return compare$1(UserAgentData.platformName, UserAgentData.platformFullVersion, query, normalizePlatformVersion);
    },


    /**
     * Check if the User Agent platform is a 32 or 64 bit architecture.
     *
     * @note Function results are memoized
     *
     * @param {string} query Query of the form "32" or "64".
     * @return {boolean}
     */
    isPlatformArchitecture: function isPlatformArchitecture(query) {
      return compare$1(UserAgentData.platformArchitecture, null, query);
    }
  };

  var UserAgent_1 = mapObject_1(UserAgent, memoizeStringOnly_1);

  function _classCallCheck$a(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$7(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$7(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







  // In IE, spans with <br> tags render as two newlines. By rendering a span
  // with only a newline character, we can be sure to render a single line.
  var useNewlineChar = UserAgent_1.isBrowser('IE <= 11');

  /**
   * Check whether the node should be considered a newline.
   */
  function isNewline(node) {
    return useNewlineChar ? node.textContent === '\n' : node.tagName === 'BR';
  }

  /**
   * Placeholder elements for empty text content.
   *
   * What is this `data-text` attribute, anyway? It turns out that we need to
   * put an attribute on the lowest-level text node in order to preserve correct
   * spellcheck handling. If the <span> is naked, Chrome and Safari may do
   * bizarre things to do the DOM -- split text nodes, create extra spans, etc.
   * If the <span> has an attribute, this appears not to happen.
   * See http://jsfiddle.net/9khdavod/ for the failure case, and
   * http://jsfiddle.net/7pg143f7/ for the fixed case.
   */
  var NEWLINE_A = useNewlineChar ? react.createElement(
    'span',
    { key: 'A', 'data-text': 'true' },
    '\n'
  ) : react.createElement('br', { key: 'A', 'data-text': 'true' });

  var NEWLINE_B = useNewlineChar ? react.createElement(
    'span',
    { key: 'B', 'data-text': 'true' },
    '\n'
  ) : react.createElement('br', { key: 'B', 'data-text': 'true' });

  /**
   * The lowest-level component in a `DraftEditor`, the text node component
   * replaces the default React text node implementation. This allows us to
   * perform custom handling of newline behavior and avoid re-rendering text
   * nodes with DOM state that already matches the expectations of our immutable
   * editor state.
   */
  var DraftEditorTextNode = function (_React$Component) {
    _inherits$7(DraftEditorTextNode, _React$Component);

    function DraftEditorTextNode(props) {
      _classCallCheck$a(this, DraftEditorTextNode);

      // By flipping this flag, we also keep flipping keys which forces
      // React to remount this node every time it rerenders.
      var _this = _possibleConstructorReturn$7(this, _React$Component.call(this, props));

      _this._forceFlag = false;
      return _this;
    }

    DraftEditorTextNode.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var node = reactDom.findDOMNode(this);
      var shouldBeNewline = nextProps.children === '';
      !(node instanceof Element) ? invariant_1(false) : void 0;
      if (shouldBeNewline) {
        return !isNewline(node);
      }
      return node.textContent !== nextProps.children;
    };

    DraftEditorTextNode.prototype.componentDidMount = function componentDidMount() {
      this._forceFlag = !this._forceFlag;
    };

    DraftEditorTextNode.prototype.componentDidUpdate = function componentDidUpdate() {
      this._forceFlag = !this._forceFlag;
    };

    DraftEditorTextNode.prototype.render = function render() {
      if (this.props.children === '') {
        return this._forceFlag ? NEWLINE_A : NEWLINE_B;
      }
      return react.createElement(
        'span',
        { key: this._forceFlag ? 'A' : 'B', 'data-text': 'true' },
        this.props.children
      );
    };

    return DraftEditorTextNode;
  }(react.Component);

  var DraftEditorTextNode_react = DraftEditorTextNode;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule DraftJsDebugLogging
   */

  var DraftJsDebugLogging = {
    logSelectionStateFailure: function logSelectionStateFailure() {
      return null;
    }
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  /**
   * @param {*} object The object to check.
   * @return {boolean} Whether or not the object is a DOM node.
   */
  function isNode(object) {
    var doc = object ? object.ownerDocument || object : document;
    var defaultView = doc.defaultView || window;
    return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
  }

  var isNode_1 = isNode;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */



  /**
   * @param {*} object The object to check.
   * @return {boolean} Whether or not the object is a DOM text node.
   */
  function isTextNode(object) {
    return isNode_1(object) && object.nodeType == 3;
  }

  var isTextNode_1 = isTextNode;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */



  /*eslint-disable no-bitwise */

  /**
   * Checks if a given DOM node contains or is another DOM node.
   */
  function containsNode(outerNode, innerNode) {
    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode_1(outerNode)) {
      return false;
    } else if (isTextNode_1(innerNode)) {
      return containsNode(outerNode, innerNode.parentNode);
    } else if ('contains' in outerNode) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }

  var containsNode_1 = containsNode;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  /* eslint-disable fb-www/typeof-undefined */

  /**
   * Same as document.activeElement but wraps in a try-catch block. In IE it is
   * not safe to call document.activeElement if there is nothing focused.
   *
   * The activeElement will be null only if the document or document body is not
   * yet defined.
   *
   * @param {?DOMDocument} doc Defaults to current document.
   * @return {?DOMElement}
   */
  function getActiveElement(doc) /*?DOMElement*/{
    doc = doc || (typeof document !== 'undefined' ? document : undefined);
    if (typeof doc === 'undefined') {
      return null;
    }
    try {
      return doc.activeElement || doc.body;
    } catch (e) {
      return doc.body;
    }
  }

  var getActiveElement_1 = getActiveElement;

  function getAnonymizedDOM(node, getNodeLabels) {
    if (!node) {
      return '[empty]';
    }

    var anonymized = anonymizeTextWithin(node, getNodeLabels);
    if (anonymized.nodeType === Node.TEXT_NODE) {
      return anonymized.textContent;
    }

    !(anonymized instanceof Element) ? invariant_1(false) : void 0;
    return anonymized.outerHTML;
  }

  function anonymizeTextWithin(node, getNodeLabels) {
    var labels = getNodeLabels !== undefined ? getNodeLabels(node) : [];

    if (node.nodeType === Node.TEXT_NODE) {
      var length = node.textContent.length;
      return document.createTextNode('[text ' + length + (labels.length ? ' | ' + labels.join(', ') : '') + ']');
    }

    var clone = node.cloneNode();
    if (clone.nodeType === 1 && labels.length) {
      clone.setAttribute('data-labels', labels.join(', '));
    }
    var childNodes = node.childNodes;
    for (var ii = 0; ii < childNodes.length; ii++) {
      clone.appendChild(anonymizeTextWithin(childNodes[ii], getNodeLabels));
    }

    return clone;
  }

  function getAnonymizedEditorDOM(node, getNodeLabels) {
    // grabbing the DOM content of the Draft editor
    var currentNode = node;
    while (currentNode) {
      if (currentNode instanceof Element && currentNode.hasAttribute('contenteditable')) {
        // found the Draft editor container
        return getAnonymizedDOM(currentNode, getNodeLabels);
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return 'Could not find contentEditable parent of node';
  }

  function getNodeLength(node) {
    return node.nodeValue === null ? node.childNodes.length : node.nodeValue.length;
  }

  /**
   * In modern non-IE browsers, we can support both forward and backward
   * selections.
   *
   * Note: IE10+ supports the Selection object, but it does not support
   * the `extend` method, which means that even in modern IE, it's not possible
   * to programatically create a backward selection. Thus, for all IE
   * versions, we use the old IE API to create our selections.
   */
  function setDraftEditorSelection(selectionState, node, blockKey, nodeStart, nodeEnd) {
    // It's possible that the editor has been removed from the DOM but
    // our selection code doesn't know it yet. Forcing selection in
    // this case may lead to errors, so just bail now.
    if (!containsNode_1(document.documentElement, node)) {
      return;
    }

    var selection = commonjsGlobal.getSelection();
    var anchorKey = selectionState.getAnchorKey();
    var anchorOffset = selectionState.getAnchorOffset();
    var focusKey = selectionState.getFocusKey();
    var focusOffset = selectionState.getFocusOffset();
    var isBackward = selectionState.getIsBackward();

    // IE doesn't support backward selection. Swap key/offset pairs.
    if (!selection.extend && isBackward) {
      var tempKey = anchorKey;
      var tempOffset = anchorOffset;
      anchorKey = focusKey;
      anchorOffset = focusOffset;
      focusKey = tempKey;
      focusOffset = tempOffset;
      isBackward = false;
    }

    var hasAnchor = anchorKey === blockKey && nodeStart <= anchorOffset && nodeEnd >= anchorOffset;

    var hasFocus = focusKey === blockKey && nodeStart <= focusOffset && nodeEnd >= focusOffset;

    // If the selection is entirely bound within this node, set the selection
    // and be done.
    if (hasAnchor && hasFocus) {
      selection.removeAllRanges();
      addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
      addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
      return;
    }

    if (!isBackward) {
      // If the anchor is within this node, set the range start.
      if (hasAnchor) {
        selection.removeAllRanges();
        addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
      }

      // If the focus is within this node, we can assume that we have
      // already set the appropriate start range on the selection, and
      // can simply extend the selection.
      if (hasFocus) {
        addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
      }
    } else {
      // If this node has the focus, set the selection range to be a
      // collapsed range beginning here. Later, when we encounter the anchor,
      // we'll use this information to extend the selection.
      if (hasFocus) {
        selection.removeAllRanges();
        addPointToSelection(selection, node, focusOffset - nodeStart, selectionState);
      }

      // If this node has the anchor, we may assume that the correct
      // focus information is already stored on the selection object.
      // We keep track of it, reset the selection range, and extend it
      // back to the focus point.
      if (hasAnchor) {
        var storedFocusNode = selection.focusNode;
        var storedFocusOffset = selection.focusOffset;

        selection.removeAllRanges();
        addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
        addFocusToSelection(selection, storedFocusNode, storedFocusOffset, selectionState);
      }
    }
  }

  /**
   * Extend selection towards focus point.
   */
  function addFocusToSelection(selection, node, offset, selectionState) {
    var activeElement = getActiveElement_1();
    if (selection.extend && containsNode_1(activeElement, node)) {
      // If `extend` is called while another element has focus, an error is
      // thrown. We therefore disable `extend` if the active element is somewhere
      // other than the node we are selecting. This should only occur in Firefox,
      // since it is the only browser to support multiple selections.
      // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444.

      // logging to catch bug that is being reported in t16250795
      if (offset > getNodeLength(node)) {
        // the call to 'selection.extend' is about to throw
        DraftJsDebugLogging.logSelectionStateFailure({
          anonymizedDom: getAnonymizedEditorDOM(node),
          extraParams: JSON.stringify({ offset: offset }),
          selectionState: JSON.stringify(selectionState.toJS())
        });
      }

      // logging to catch bug that is being reported in t18110632
      var nodeWasFocus = node === selection.focusNode;
      try {
        selection.extend(node, offset);
      } catch (e) {
        DraftJsDebugLogging.logSelectionStateFailure({
          anonymizedDom: getAnonymizedEditorDOM(node, function (n) {
            var labels = [];
            if (n === activeElement) {
              labels.push('active element');
            }
            if (n === selection.anchorNode) {
              labels.push('selection anchor node');
            }
            if (n === selection.focusNode) {
              labels.push('selection focus node');
            }
            return labels;
          }),
          extraParams: JSON.stringify({
            activeElementName: activeElement ? activeElement.nodeName : null,
            nodeIsFocus: node === selection.focusNode,
            nodeWasFocus: nodeWasFocus,
            selectionRangeCount: selection.rangeCount,
            selectionAnchorNodeName: selection.anchorNode ? selection.anchorNode.nodeName : null,
            selectionAnchorOffset: selection.anchorOffset,
            selectionFocusNodeName: selection.focusNode ? selection.focusNode.nodeName : null,
            selectionFocusOffset: selection.focusOffset,
            message: e ? '' + e : null,
            offset: offset
          }, null, 2),
          selectionState: JSON.stringify(selectionState.toJS(), null, 2)
        });
        // allow the error to be thrown -
        // better than continuing in a broken state
        throw e;
      }
    } else {
      // IE doesn't support extend. This will mean no backward selection.
      // Extract the existing selection range and add focus to it.
      // Additionally, clone the selection range. IE11 throws an
      // InvalidStateError when attempting to access selection properties
      // after the range is detached.
      var range = selection.getRangeAt(0);
      range.setEnd(node, offset);
      selection.addRange(range.cloneRange());
    }
  }

  function addPointToSelection(selection, node, offset, selectionState) {
    var range = document.createRange();
    // logging to catch bug that is being reported in t16250795
    if (offset > getNodeLength(node)) {
      // in this case we know that the call to 'range.setStart' is about to throw
      DraftJsDebugLogging.logSelectionStateFailure({
        anonymizedDom: getAnonymizedEditorDOM(node),
        extraParams: JSON.stringify({ offset: offset }),
        selectionState: JSON.stringify(selectionState.toJS())
      });
    }
    range.setStart(node, offset);
    selection.addRange(range);
  }

  var setDraftEditorSelection_1 = setDraftEditorSelection;

  function _classCallCheck$b(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$8(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$8(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








  /**
   * All leaf nodes in the editor are spans with single text nodes. Leaf
   * elements are styled based on the merging of an optional custom style map
   * and a default style map.
   *
   * `DraftEditorLeaf` also provides a wrapper for calling into the imperative
   * DOM Selection API. In this way, top-level components can declaratively
   * maintain the selection state.
   */
  var DraftEditorLeaf = function (_React$Component) {
    _inherits$8(DraftEditorLeaf, _React$Component);

    function DraftEditorLeaf() {
      _classCallCheck$b(this, DraftEditorLeaf);

      return _possibleConstructorReturn$8(this, _React$Component.apply(this, arguments));
    }

    DraftEditorLeaf.prototype._setSelection = function _setSelection() {
      var selection = this.props.selection;

      // If selection state is irrelevant to the parent block, no-op.

      if (selection == null || !selection.getHasFocus()) {
        return;
      }

      var _props = this.props,
          block = _props.block,
          start = _props.start,
          text = _props.text;

      var blockKey = block.getKey();
      var end = start + text.length;
      if (!selection.hasEdgeWithin(blockKey, start, end)) {
        return;
      }

      // Determine the appropriate target node for selection. If the child
      // is not a text node, it is a <br /> spacer. In this case, use the
      // <span> itself as the selection target.
      var node = reactDom.findDOMNode(this);
      !node ? invariant_1(false) : void 0;
      var child = node.firstChild;
      !child ? invariant_1(false) : void 0;
      var targetNode = void 0;

      if (child.nodeType === Node.TEXT_NODE) {
        targetNode = child;
      } else if (child.tagName === 'BR') {
        targetNode = node;
      } else {
        targetNode = child.firstChild;
        !targetNode ? invariant_1(false) : void 0;
      }

      setDraftEditorSelection_1(selection, targetNode, blockKey, start, end);
    };
    /**
     * By making individual leaf instances aware of their context within
     * the text of the editor, we can set our selection range more
     * easily than we could in the non-React world.
     *
     * Note that this depends on our maintaining tight control over the
     * DOM structure of the DraftEditor component. If leaves had multiple
     * text nodes, this would be harder.
     */

    DraftEditorLeaf.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var leafNode = reactDom.findDOMNode(this.leaf);
      !leafNode ? invariant_1(false) : void 0;
      return leafNode.textContent !== nextProps.text || nextProps.styleSet !== this.props.styleSet || nextProps.forceSelection;
    };

    DraftEditorLeaf.prototype.componentDidUpdate = function componentDidUpdate() {
      this._setSelection();
    };

    DraftEditorLeaf.prototype.componentDidMount = function componentDidMount() {
      this._setSelection();
    };

    DraftEditorLeaf.prototype.render = function render() {
      var _this2 = this;

      var block = this.props.block;
      var text = this.props.text;

      // If the leaf is at the end of its block and ends in a soft newline, append
      // an extra line feed character. Browsers collapse trailing newline
      // characters, which leaves the cursor in the wrong place after a
      // shift+enter. The extra character repairs this.

      if (text.endsWith('\n') && this.props.isLast) {
        text += '\n';
      }

      var _props2 = this.props,
          customStyleMap = _props2.customStyleMap,
          customStyleFn = _props2.customStyleFn,
          offsetKey = _props2.offsetKey,
          styleSet = _props2.styleSet;

      var styleObj = styleSet.reduce(function (map, styleName) {
        var mergedStyles = {};
        var style = customStyleMap[styleName];

        if (style !== undefined && map.textDecoration !== style.textDecoration) {
          // .trim() is necessary for IE9/10/11 and Edge
          mergedStyles.textDecoration = [map.textDecoration, style.textDecoration].join(' ').trim();
        }

        return objectAssign(map, style, mergedStyles);
      }, {});

      if (customStyleFn) {
        var newStyles = customStyleFn(styleSet, block);
        styleObj = objectAssign(styleObj, newStyles);
      }

      return react.createElement(
        'span',
        {
          'data-offset-key': offsetKey,
          ref: function ref(_ref) {
            return _this2.leaf = _ref;
          },
          style: styleObj },
        react.createElement(
          DraftEditorTextNode_react,
          null,
          text
        )
      );
    };

    return DraftEditorLeaf;
  }(react.Component);

  var DraftEditorLeaf_react = DraftEditorLeaf;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule DraftOffsetKey
   * @format
   * 
   */

  var KEY_DELIMITER = '-';

  var DraftOffsetKey = {
    encode: function encode(blockKey, decoratorKey, leafKey) {
      return blockKey + KEY_DELIMITER + decoratorKey + KEY_DELIMITER + leafKey;
    },

    decode: function decode(offsetKey) {
      var _offsetKey$split = offsetKey.split(KEY_DELIMITER),
          blockKey = _offsetKey$split[0],
          decoratorKey = _offsetKey$split[1],
          leafKey = _offsetKey$split[2];

      return {
        blockKey: blockKey,
        decoratorKey: parseInt(decoratorKey, 10),
        leafKey: parseInt(leafKey, 10)
      };
    }
  };

  var DraftOffsetKey_1 = DraftOffsetKey;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  /**
   * @param {DOMElement} element
   * @param {DOMDocument} doc
   * @return {boolean}
   */
  function _isViewportScrollElement(element, doc) {
    return !!doc && (element === doc.documentElement || element === doc.body);
  }

  /**
   * Scroll Module. This class contains 4 simple static functions
   * to be used to access Element.scrollTop/scrollLeft properties.
   * To solve the inconsistencies between browsers when either
   * document.body or document.documentElement is supplied,
   * below logic will be used to alleviate the issue:
   *
   * 1. If 'element' is either 'document.body' or 'document.documentElement,
   *    get whichever element's 'scroll{Top,Left}' is larger.
   * 2. If 'element' is either 'document.body' or 'document.documentElement',
   *    set the 'scroll{Top,Left}' on both elements.
   */

  var Scroll = {
    /**
     * @param {DOMElement} element
     * @return {number}
     */
    getTop: function getTop(element) {
      var doc = element.ownerDocument;
      return _isViewportScrollElement(element, doc) ?
      // In practice, they will either both have the same value,
      // or one will be zero and the other will be the scroll position
      // of the viewport. So we can use `X || Y` instead of `Math.max(X, Y)`
      doc.body.scrollTop || doc.documentElement.scrollTop : element.scrollTop;
    },

    /**
     * @param {DOMElement} element
     * @param {number} newTop
     */
    setTop: function setTop(element, newTop) {
      var doc = element.ownerDocument;
      if (_isViewportScrollElement(element, doc)) {
        doc.body.scrollTop = doc.documentElement.scrollTop = newTop;
      } else {
        element.scrollTop = newTop;
      }
    },

    /**
     * @param {DOMElement} element
     * @return {number}
     */
    getLeft: function getLeft(element) {
      var doc = element.ownerDocument;
      return _isViewportScrollElement(element, doc) ? doc.body.scrollLeft || doc.documentElement.scrollLeft : element.scrollLeft;
    },

    /**
     * @param {DOMElement} element
     * @param {number} newLeft
     */
    setLeft: function setLeft(element, newLeft) {
      var doc = element.ownerDocument;
      if (_isViewportScrollElement(element, doc)) {
        doc.body.scrollLeft = doc.documentElement.scrollLeft = newLeft;
      } else {
        element.scrollLeft = newLeft;
      }
    }
  };

  var Scroll_1 = Scroll;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  var _hyphenPattern = /-(.)/g;

  /**
   * Camelcases a hyphenated string, for example:
   *
   *   > camelize('background-color')
   *   < "backgroundColor"
   *
   * @param {string} string
   * @return {string}
   */
  function camelize(string) {
    return string.replace(_hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  }

  var camelize_1 = camelize;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  var _uppercasePattern = /([A-Z])/g;

  /**
   * Hyphenates a camelcased string, for example:
   *
   *   > hyphenate('backgroundColor')
   *   < "background-color"
   *
   * For CSS style names, use `hyphenateStyleName` instead which works properly
   * with all vendor prefixes, including `ms`.
   *
   * @param {string} string
   * @return {string}
   */
  function hyphenate(string) {
    return string.replace(_uppercasePattern, '-$1').toLowerCase();
  }

  var hyphenate_1 = hyphenate;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */




  function asString(value) /*?string*/{
    return value == null ? value : String(value);
  }

  function getStyleProperty( /*DOMNode*/node, /*string*/name) /*?string*/{
    var computedStyle = void 0;

    // W3C Standard
    if (window.getComputedStyle) {
      // In certain cases such as within an iframe in FF3, this returns null.
      computedStyle = window.getComputedStyle(node, null);
      if (computedStyle) {
        return asString(computedStyle.getPropertyValue(hyphenate_1(name)));
      }
    }
    // Safari
    if (document.defaultView && document.defaultView.getComputedStyle) {
      computedStyle = document.defaultView.getComputedStyle(node, null);
      // A Safari bug causes this to return null for `display: none` elements.
      if (computedStyle) {
        return asString(computedStyle.getPropertyValue(hyphenate_1(name)));
      }
      if (name === 'display') {
        return 'none';
      }
    }
    // Internet Explorer
    if (node.currentStyle) {
      if (name === 'float') {
        return asString(node.currentStyle.cssFloat || node.currentStyle.styleFloat);
      }
      return asString(node.currentStyle[camelize_1(name)]);
    }
    return asString(node.style && node.style[camelize_1(name)]);
  }

  var getStyleProperty_1 = getStyleProperty;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */



  /**
   * @param {DOMNode} element [description]
   * @param {string} name Overflow style property name.
   * @return {boolean} True if the supplied ndoe is scrollable.
   */
  function _isNodeScrollable(element, name) {
    var overflow = Style.get(element, name);
    return overflow === 'auto' || overflow === 'scroll';
  }

  /**
   * Utilities for querying and mutating style properties.
   */
  var Style = {
    /**
     * Gets the style property for the supplied node. This will return either the
     * computed style, if available, or the declared style.
     *
     * @param {DOMNode} node
     * @param {string} name Style property name.
     * @return {?string} Style property value.
     */
    get: getStyleProperty_1,

    /**
     * Determines the nearest ancestor of a node that is scrollable.
     *
     * NOTE: This can be expensive if used repeatedly or on a node nested deeply.
     *
     * @param {?DOMNode} node Node from which to start searching.
     * @return {?DOMWindow|DOMElement} Scroll parent of the supplied node.
     */
    getScrollParent: function getScrollParent(node) {
      if (!node) {
        return null;
      }
      var ownerDocument = node.ownerDocument;
      while (node && node !== ownerDocument.body) {
        if (_isNodeScrollable(node, 'overflow') || _isNodeScrollable(node, 'overflowY') || _isNodeScrollable(node, 'overflowX')) {
          return node;
        }
        node = node.parentNode;
      }
      return ownerDocument.defaultView || ownerDocument.parentWindow;
    }

  };

  var Style_1 = Style;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */



  /**
   * Gets an element's bounding rect in pixels relative to the viewport.
   *
   * @param {DOMElement} elem
   * @return {object}
   */
  function getElementRect(elem) {
    var docElem = elem.ownerDocument.documentElement;

    // FF 2, Safari 3 and Opera 9.5- do not support getBoundingClientRect().
    // IE9- will throw if the element is not in the document.
    if (!('getBoundingClientRect' in elem) || !containsNode_1(docElem, elem)) {
      return {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
    }

    // Subtracts clientTop/Left because IE8- added a 2px border to the
    // <html> element (see http://fburl.com/1493213). IE 7 in
    // Quicksmode does not report clientLeft/clientTop so there
    // will be an unaccounted offset of 2px when in quirksmode
    var rect = elem.getBoundingClientRect();

    return {
      left: Math.round(rect.left) - docElem.clientLeft,
      right: Math.round(rect.right) - docElem.clientLeft,
      top: Math.round(rect.top) - docElem.clientTop,
      bottom: Math.round(rect.bottom) - docElem.clientTop
    };
  }

  var getElementRect_1 = getElementRect;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */



  /**
   * Gets an element's position in pixels relative to the viewport. The returned
   * object represents the position of the element's top left corner.
   *
   * @param {DOMElement} element
   * @return {object}
   */
  function getElementPosition(element) {
    var rect = getElementRect_1(element);
    return {
      x: rect.left,
      y: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  }

  var getElementPosition_1 = getElementPosition;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  var isWebkit = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('AppleWebKit') > -1;

  /**
   * Gets the element with the document scroll properties such as `scrollLeft` and
   * `scrollHeight`. This may differ across different browsers.
   *
   * NOTE: The return value can be null if the DOM is not yet ready.
   *
   * @param {?DOMDocument} doc Defaults to current document.
   * @return {?DOMElement}
   */
  function getDocumentScrollElement(doc) {
    doc = doc || document;
    if (doc.scrollingElement) {
      return doc.scrollingElement;
    }
    return !isWebkit && doc.compatMode === 'CSS1Compat' ? doc.documentElement : doc.body;
  }

  var getDocumentScrollElement_1 = getDocumentScrollElement;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */

  /**
   * Gets the scroll position of the supplied element or window.
   *
   * The return values are unbounded, unlike `getScrollPosition`. This means they
   * may be negative or exceed the element boundaries (which is possible using
   * inertial scrolling).
   *
   * @param {DOMWindow|DOMElement} scrollable
   * @return {object} Map with `x` and `y` keys.
   */

  function getUnboundedScrollPosition(scrollable) {
    if (scrollable.Window && scrollable instanceof scrollable.Window) {
      return {
        x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
        y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
      };
    }
    return {
      x: scrollable.scrollLeft,
      y: scrollable.scrollTop
    };
  }

  var getUnboundedScrollPosition_1 = getUnboundedScrollPosition;

  /**
   * Gets the scroll position of the supplied element or window.
   *
   * The return values are bounded. This means that if the scroll position is
   * negative or exceeds the element boundaries (which is possible using inertial
   * scrolling), you will get zero or the maximum scroll position, respectively.
   *
   * If you need the unbound scroll position, use `getUnboundedScrollPosition`.
   *
   * @param {DOMWindow|DOMElement} scrollable
   * @return {object} Map with `x` and `y` keys.
   */
  function getScrollPosition(scrollable) {
    var documentScrollElement = getDocumentScrollElement_1(scrollable.ownerDocument || scrollable.document);
    if (scrollable.Window && scrollable instanceof scrollable.Window) {
      scrollable = documentScrollElement;
    }
    var scrollPosition = getUnboundedScrollPosition_1(scrollable);

    var viewport = scrollable === documentScrollElement ? scrollable.ownerDocument.documentElement : scrollable;

    var xMax = scrollable.scrollWidth - viewport.clientWidth;
    var yMax = scrollable.scrollHeight - viewport.clientHeight;

    scrollPosition.x = Math.max(0, Math.min(scrollPosition.x, xMax));
    scrollPosition.y = Math.max(0, Math.min(scrollPosition.y, yMax));

    return scrollPosition;
  }

  var getScrollPosition_1 = getScrollPosition;

  function getViewportWidth() {
    var width = void 0;
    if (document.documentElement) {
      width = document.documentElement.clientWidth;
    }

    if (!width && document.body) {
      width = document.body.clientWidth;
    }

    return width || 0;
  } /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     *
     * 
     * @typechecks
     */

  function getViewportHeight() {
    var height = void 0;
    if (document.documentElement) {
      height = document.documentElement.clientHeight;
    }

    if (!height && document.body) {
      height = document.body.clientHeight;
    }

    return height || 0;
  }

  /**
   * Gets the viewport dimensions including any scrollbars.
   */
  function getViewportDimensions() {
    return {
      width: window.innerWidth || getViewportWidth(),
      height: window.innerHeight || getViewportHeight()
    };
  }

  /**
   * Gets the viewport dimensions excluding any scrollbars.
   */
  getViewportDimensions.withoutScrollbars = function () {
    return {
      width: getViewportWidth(),
      height: getViewportHeight()
    };
  };

  var getViewportDimensions_1 = getViewportDimensions;

  var _extends$2 = objectAssign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  function _classCallCheck$c(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$9(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$9(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

















  var SCROLL_BUFFER = 10;

  /**
   * Return whether a block overlaps with either edge of the `SelectionState`.
   */
  var isBlockOnSelectionEdge = function isBlockOnSelectionEdge(selection, key) {
    return selection.getAnchorKey() === key || selection.getFocusKey() === key;
  };

  /**
   * The default block renderer for a `DraftEditor` component.
   *
   * A `DraftEditorBlock` is able to render a given `ContentBlock` to its
   * appropriate decorator and inline style components.
   */

  var DraftEditorBlock = function (_React$Component) {
    _inherits$9(DraftEditorBlock, _React$Component);

    function DraftEditorBlock() {
      _classCallCheck$c(this, DraftEditorBlock);

      return _possibleConstructorReturn$9(this, _React$Component.apply(this, arguments));
    }

    DraftEditorBlock.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return this.props.block !== nextProps.block || this.props.tree !== nextProps.tree || this.props.direction !== nextProps.direction || isBlockOnSelectionEdge(nextProps.selection, nextProps.block.getKey()) && nextProps.forceSelection;
    };

    /**
     * When a block is mounted and overlaps the selection state, we need to make
     * sure that the cursor is visible to match native behavior. This may not
     * be the case if the user has pressed `RETURN` or pasted some content, since
     * programatically creating these new blocks and setting the DOM selection
     * will miss out on the browser natively scrolling to that position.
     *
     * To replicate native behavior, if the block overlaps the selection state
     * on mount, force the scroll position. Check the scroll state of the scroll
     * parent, and adjust it to align the entire block to the bottom of the
     * scroll parent.
     */


    DraftEditorBlock.prototype.componentDidMount = function componentDidMount() {
      var selection = this.props.selection;
      var endKey = selection.getEndKey();
      if (!selection.getHasFocus() || endKey !== this.props.block.getKey()) {
        return;
      }

      var blockNode = reactDom.findDOMNode(this);
      var scrollParent = Style_1.getScrollParent(blockNode);
      var scrollPosition = getScrollPosition_1(scrollParent);
      var scrollDelta = void 0;

      if (scrollParent === window) {
        var nodePosition = getElementPosition_1(blockNode);
        var nodeBottom = nodePosition.y + nodePosition.height;
        var viewportHeight = getViewportDimensions_1().height;
        scrollDelta = nodeBottom - viewportHeight;
        if (scrollDelta > 0) {
          window.scrollTo(scrollPosition.x, scrollPosition.y + scrollDelta + SCROLL_BUFFER);
        }
      } else {
        !(blockNode instanceof HTMLElement) ? invariant_1(false) : void 0;
        var blockBottom = blockNode.offsetHeight + blockNode.offsetTop;
        var scrollBottom = scrollParent.offsetHeight + scrollPosition.y;
        scrollDelta = blockBottom - scrollBottom;
        if (scrollDelta > 0) {
          Scroll_1.setTop(scrollParent, Scroll_1.getTop(scrollParent) + scrollDelta + SCROLL_BUFFER);
        }
      }
    };

    DraftEditorBlock.prototype._renderChildren = function _renderChildren() {
      var _this2 = this;

      var block = this.props.block;
      var blockKey = block.getKey();
      var text = block.getText();
      var lastLeafSet = this.props.tree.size - 1;
      var hasSelection = isBlockOnSelectionEdge(this.props.selection, blockKey);

      return this.props.tree.map(function (leafSet, ii) {
        var leavesForLeafSet = leafSet.get('leaves');
        var lastLeaf = leavesForLeafSet.size - 1;
        var leaves = leavesForLeafSet.map(function (leaf, jj) {
          var offsetKey = DraftOffsetKey_1.encode(blockKey, ii, jj);
          var start = leaf.get('start');
          var end = leaf.get('end');
          return react.createElement(DraftEditorLeaf_react, {
            key: offsetKey,
            offsetKey: offsetKey,
            block: block,
            start: start,
            selection: hasSelection ? _this2.props.selection : null,
            forceSelection: _this2.props.forceSelection,
            text: text.slice(start, end),
            styleSet: block.getInlineStyleAt(start),
            customStyleMap: _this2.props.customStyleMap,
            customStyleFn: _this2.props.customStyleFn,
            isLast: ii === lastLeafSet && jj === lastLeaf
          });
        }).toArray();

        var decoratorKey = leafSet.get('decoratorKey');
        if (decoratorKey == null) {
          return leaves;
        }

        if (!_this2.props.decorator) {
          return leaves;
        }

        var decorator = nullthrows_1(_this2.props.decorator);

        var DecoratorComponent = decorator.getComponentForKey(decoratorKey);
        if (!DecoratorComponent) {
          return leaves;
        }

        var decoratorProps = decorator.getPropsForKey(decoratorKey);
        var decoratorOffsetKey = DraftOffsetKey_1.encode(blockKey, ii, 0);
        var decoratedText = text.slice(leavesForLeafSet.first().get('start'), leavesForLeafSet.last().get('end'));

        // Resetting dir to the same value on a child node makes Chrome/Firefox
        // confused on cursor movement. See http://jsfiddle.net/d157kLck/3/
        var dir = UnicodeBidiDirection_1.getHTMLDirIfDifferent(UnicodeBidi_1.getDirection(decoratedText), _this2.props.direction);

        return react.createElement(
          DecoratorComponent,
          _extends$2({}, decoratorProps, {
            contentState: _this2.props.contentState,
            decoratedText: decoratedText,
            dir: dir,
            key: decoratorOffsetKey,
            entityKey: block.getEntityAt(leafSet.get('start')),
            offsetKey: decoratorOffsetKey }),
          leaves
        );
      }).toArray();
    };

    DraftEditorBlock.prototype.render = function render() {
      var _props = this.props,
          direction = _props.direction,
          offsetKey = _props.offsetKey;

      var className = cx_1({
        'public/DraftStyleDefault/block': true,
        'public/DraftStyleDefault/ltr': direction === 'LTR',
        'public/DraftStyleDefault/rtl': direction === 'RTL'
      });

      return react.createElement(
        'div',
        { 'data-offset-key': offsetKey, className: className },
        this._renderChildren()
      );
    };

    return DraftEditorBlock;
  }(react.Component);

  var DraftEditorBlock_react = DraftEditorBlock;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks static-only
   */

  /**
   * Combines multiple className strings into one.
   * http://jsperf.com/joinclasses-args-vs-array
   *
   * @param {...?string} className
   * @return {string}
   */

  function joinClasses(className /*, ... */) {
    if (!className) {
      className = '';
    }
    var nextClass = void 0;
    var argLength = arguments.length;
    if (argLength > 1) {
      for (var ii = 1; ii < argLength; ii++) {
        nextClass = arguments[ii];
        if (nextClass) {
          className = (className ? className + ' ' : '') + nextClass;
        }
      }
    }
    return className;
  }

  var joinClasses_1 = joinClasses;

  var _extends$3 = objectAssign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  function _classCallCheck$d(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$a(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$a(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }










  /**
   * Provide default styling for list items. This way, lists will be styled with
   * proper counters and indentation even if the caller does not specify
   * their own styling at all. If more than five levels of nesting are needed,
   * the necessary CSS classes can be provided via `blockStyleFn` configuration.
   */
  var getListItemClasses = function getListItemClasses(type, depth, shouldResetCount, direction) {
    return cx_1({
      'public/DraftStyleDefault/unorderedListItem': type === 'unordered-list-item',
      'public/DraftStyleDefault/orderedListItem': type === 'ordered-list-item',
      'public/DraftStyleDefault/reset': shouldResetCount,
      'public/DraftStyleDefault/depth0': depth === 0,
      'public/DraftStyleDefault/depth1': depth === 1,
      'public/DraftStyleDefault/depth2': depth === 2,
      'public/DraftStyleDefault/depth3': depth === 3,
      'public/DraftStyleDefault/depth4': depth === 4,
      'public/DraftStyleDefault/listLTR': direction === 'LTR',
      'public/DraftStyleDefault/listRTL': direction === 'RTL'
    });
  };

  /**
   * `DraftEditorContents` is the container component for all block components
   * rendered for a `DraftEditor`. It is optimized to aggressively avoid
   * re-rendering blocks whenever possible.
   *
   * This component is separate from `DraftEditor` because certain props
   * (for instance, ARIA props) must be allowed to update without affecting
   * the contents of the editor.
   */

  var DraftEditorContents = function (_React$Component) {
    _inherits$a(DraftEditorContents, _React$Component);

    function DraftEditorContents() {
      _classCallCheck$d(this, DraftEditorContents);

      return _possibleConstructorReturn$a(this, _React$Component.apply(this, arguments));
    }

    DraftEditorContents.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      var prevEditorState = this.props.editorState;
      var nextEditorState = nextProps.editorState;

      var prevDirectionMap = prevEditorState.getDirectionMap();
      var nextDirectionMap = nextEditorState.getDirectionMap();

      // Text direction has changed for one or more blocks. We must re-render.
      if (prevDirectionMap !== nextDirectionMap) {
        return true;
      }

      var didHaveFocus = prevEditorState.getSelection().getHasFocus();
      var nowHasFocus = nextEditorState.getSelection().getHasFocus();

      if (didHaveFocus !== nowHasFocus) {
        return true;
      }

      var nextNativeContent = nextEditorState.getNativelyRenderedContent();

      var wasComposing = prevEditorState.isInCompositionMode();
      var nowComposing = nextEditorState.isInCompositionMode();

      // If the state is unchanged or we're currently rendering a natively
      // rendered state, there's nothing new to be done.
      if (prevEditorState === nextEditorState || nextNativeContent !== null && nextEditorState.getCurrentContent() === nextNativeContent || wasComposing && nowComposing) {
        return false;
      }

      var prevContent = prevEditorState.getCurrentContent();
      var nextContent = nextEditorState.getCurrentContent();
      var prevDecorator = prevEditorState.getDecorator();
      var nextDecorator = nextEditorState.getDecorator();
      return wasComposing !== nowComposing || prevContent !== nextContent || prevDecorator !== nextDecorator || nextEditorState.mustForceSelection();
    };

    DraftEditorContents.prototype.render = function render() {
      var _props = this.props,
          blockRenderMap = _props.blockRenderMap,
          blockRendererFn = _props.blockRendererFn,
          blockStyleFn = _props.blockStyleFn,
          customStyleMap = _props.customStyleMap,
          customStyleFn = _props.customStyleFn,
          editorState = _props.editorState,
          editorKey = _props.editorKey,
          textDirectionality = _props.textDirectionality;


      var content = editorState.getCurrentContent();
      var selection = editorState.getSelection();
      var forceSelection = editorState.mustForceSelection();
      var decorator = editorState.getDecorator();
      var directionMap = nullthrows_1(editorState.getDirectionMap());

      var blocksAsArray = content.getBlocksAsArray();
      var processedBlocks = [];

      var currentDepth = null;
      var lastWrapperTemplate = null;

      for (var ii = 0; ii < blocksAsArray.length; ii++) {
        var _block = blocksAsArray[ii];
        var key = _block.getKey();
        var blockType = _block.getType();

        var customRenderer = blockRendererFn(_block);
        var CustomComponent = void 0,
            customProps = void 0,
            customEditable = void 0;
        if (customRenderer) {
          CustomComponent = customRenderer.component;
          customProps = customRenderer.props;
          customEditable = customRenderer.editable;
        }

        var direction = textDirectionality ? textDirectionality : directionMap.get(key);
        var offsetKey = DraftOffsetKey_1.encode(key, 0, 0);
        var componentProps = {
          contentState: content,
          block: _block,
          blockProps: customProps,
          blockStyleFn: blockStyleFn,
          customStyleMap: customStyleMap,
          customStyleFn: customStyleFn,
          decorator: decorator,
          direction: direction,
          forceSelection: forceSelection,
          key: key,
          offsetKey: offsetKey,
          selection: selection,
          tree: editorState.getBlockTree(key)
        };

        var configForType = blockRenderMap.get(blockType) || blockRenderMap.get('unstyled');
        var wrapperTemplate = configForType.wrapper;

        var Element = configForType.element || blockRenderMap.get('unstyled').element;

        var depth = _block.getDepth();
        var className = '';
        if (blockStyleFn) {
          className = blockStyleFn(_block);
        }

        // List items are special snowflakes, since we handle nesting and
        // counters manually.
        if (Element === 'li') {
          var shouldResetCount = lastWrapperTemplate !== wrapperTemplate || currentDepth === null || depth > currentDepth;
          className = joinClasses_1(className, getListItemClasses(blockType, depth, shouldResetCount, direction));
        }

        var Component = CustomComponent || DraftEditorBlock_react;
        var childProps = {
          className: className,
          'data-block': true,
          'data-editor': editorKey,
          'data-offset-key': offsetKey,
          key: key
        };
        if (customEditable !== undefined) {
          childProps = _extends$3({}, childProps, {
            contentEditable: customEditable,
            suppressContentEditableWarning: true
          });
        }

        var child = react.createElement(Element, childProps, react.createElement(Component, componentProps));

        processedBlocks.push({
          block: child,
          wrapperTemplate: wrapperTemplate,
          key: key,
          offsetKey: offsetKey
        });

        if (wrapperTemplate) {
          currentDepth = _block.getDepth();
        } else {
          currentDepth = null;
        }
        lastWrapperTemplate = wrapperTemplate;
      }

      // Group contiguous runs of blocks that have the same wrapperTemplate
      var outputBlocks = [];
      for (var _ii = 0; _ii < processedBlocks.length;) {
        var info = processedBlocks[_ii];
        if (info.wrapperTemplate) {
          var blocks = [];
          do {
            blocks.push(processedBlocks[_ii].block);
            _ii++;
          } while (_ii < processedBlocks.length && processedBlocks[_ii].wrapperTemplate === info.wrapperTemplate);
          var wrapperElement = react.cloneElement(info.wrapperTemplate, {
            key: info.key + '-wrap',
            'data-offset-key': info.offsetKey
          }, blocks);
          outputBlocks.push(wrapperElement);
        } else {
          outputBlocks.push(info.block);
          _ii++;
        }
      }

      return react.createElement(
        'div',
        { 'data-contents': 'true' },
        outputBlocks
      );
    };

    return DraftEditorContents;
  }(react.Component);

  var DraftEditorContentsCore_react = DraftEditorContents;

  var DraftEditorContents_react = DraftEditorContentsCore_react;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */
  var PhotosMimeType = {
    isImage: function isImage(mimeString) {
      return getParts(mimeString)[0] === 'image';
    },
    isJpeg: function isJpeg(mimeString) {
      var parts = getParts(mimeString);
      return PhotosMimeType.isImage(mimeString) && (
      // see http://fburl.com/10972194
      parts[1] === 'jpeg' || parts[1] === 'pjpeg');
    }
  };

  function getParts(mimeString) {
    return mimeString.split('/');
  }

  var PhotosMimeType_1 = PhotosMimeType;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */



  /**
   * Convert array-like objects to arrays.
   *
   * This API assumes the caller knows the contents of the data type. For less
   * well defined inputs use createArrayFromMixed.
   *
   * @param {object|function|filelist} obj
   * @return {array}
   */
  function toArray(obj) {
    var length = obj.length;

    // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
    // in old versions of Safari).
    !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? invariant_1(false) : void 0;

    !(typeof length === 'number') ? invariant_1(false) : void 0;

    !(length === 0 || length - 1 in obj) ? invariant_1(false) : void 0;

    !(typeof obj.callee !== 'function') ? invariant_1(false) : void 0;

    // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
    // without method will throw during the slice call and skip straight to the
    // fallback.
    if (obj.hasOwnProperty) {
      try {
        return Array.prototype.slice.call(obj);
      } catch (e) {
        // IE < 9 does not support Array#slice on collections objects
      }
    }

    // Fall back to copying key by key. This assumes all keys have a value,
    // so will not preserve sparsely populated inputs.
    var ret = Array(length);
    for (var ii = 0; ii < length; ii++) {
      ret[ii] = obj[ii];
    }
    return ret;
  }

  /**
   * Perform a heuristic test to determine if an object is "array-like".
   *
   *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
   *   Joshu replied: "Mu."
   *
   * This function determines if its argument has "array nature": it returns
   * true if the argument is an actual array, an `arguments' object, or an
   * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
   *
   * It will return false for other array-like objects like Filelist.
   *
   * @param {*} obj
   * @return {boolean}
   */
  function hasArrayNature(obj) {
    return (
      // not null/false
      !!obj && (
      // arrays are objects, NodeLists are functions in Safari
      typeof obj == 'object' || typeof obj == 'function') &&
      // quacks like an array
      'length' in obj &&
      // not window
      !('setInterval' in obj) &&
      // no DOM node should be considered an array-like
      // a 'select' element has 'length' and 'item' properties on IE8
      typeof obj.nodeType != 'number' && (
      // a real array
      Array.isArray(obj) ||
      // arguments
      'callee' in obj ||
      // HTMLCollection/NodeList
      'item' in obj)
    );
  }

  /**
   * Ensure that the argument is an array by wrapping it in an array if it is not.
   * Creates a copy of the argument if it is already an array.
   *
   * This is mostly useful idiomatically:
   *
   *   var createArrayFromMixed = require('createArrayFromMixed');
   *
   *   function takesOneOrMoreThings(things) {
   *     things = createArrayFromMixed(things);
   *     ...
   *   }
   *
   * This allows you to treat `things' as an array, but accept scalars in the API.
   *
   * If you need to convert an array-like object, like `arguments`, into an array
   * use toArray instead.
   *
   * @param {*} obj
   * @return {array}
   */
  function createArrayFromMixed(obj) {
    if (!hasArrayNature(obj)) {
      return [obj];
    } else if (Array.isArray(obj)) {
      return obj.slice();
    } else {
      return toArray(obj);
    }
  }

  var createArrayFromMixed_1 = createArrayFromMixed;

  function _classCallCheck$e(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   */






  var CR_LF_REGEX = new RegExp('\r\n', 'g');
  var LF_ONLY = '\n';

  var RICH_TEXT_TYPES = {
    'text/rtf': 1,
    'text/html': 1
  };

  /**
   * If DataTransferItem is a file then return the Blob of data.
   *
   * @param {object} item
   * @return {?blob}
   */
  function getFileFromDataTransfer(item) {
    if (item.kind == 'file') {
      return item.getAsFile();
    }
  }

  var DataTransfer = function () {
    /**
     * @param {object} data
     */
    function DataTransfer(data) {
      _classCallCheck$e(this, DataTransfer);

      this.data = data;

      // Types could be DOMStringList or array
      this.types = data.types ? createArrayFromMixed_1(data.types) : [];
    }

    /**
     * Is this likely to be a rich text data transfer?
     *
     * @return {boolean}
     */


    DataTransfer.prototype.isRichText = function isRichText() {
      // If HTML is available, treat this data as rich text. This way, we avoid
      // using a pasted image if it is packaged with HTML -- this may occur with
      // pastes from MS Word, for example.  However this is only rich text if
      // there's accompanying text.
      if (this.getHTML() && this.getText()) {
        return true;
      }

      // When an image is copied from a preview window, you end up with two
      // DataTransferItems one of which is a file's metadata as text.  Skip those.
      if (this.isImage()) {
        return false;
      }

      return this.types.some(function (type) {
        return RICH_TEXT_TYPES[type];
      });
    };

    /**
     * Get raw text.
     *
     * @return {?string}
     */


    DataTransfer.prototype.getText = function getText() {
      var text;
      if (this.data.getData) {
        if (!this.types.length) {
          text = this.data.getData('Text');
        } else if (this.types.indexOf('text/plain') != -1) {
          text = this.data.getData('text/plain');
        }
      }
      return text ? text.replace(CR_LF_REGEX, LF_ONLY) : null;
    };

    /**
     * Get HTML paste data
     *
     * @return {?string}
     */


    DataTransfer.prototype.getHTML = function getHTML() {
      if (this.data.getData) {
        if (!this.types.length) {
          return this.data.getData('Text');
        } else if (this.types.indexOf('text/html') != -1) {
          return this.data.getData('text/html');
        }
      }
    };

    /**
     * Is this a link data transfer?
     *
     * @return {boolean}
     */


    DataTransfer.prototype.isLink = function isLink() {
      return this.types.some(function (type) {
        return type.indexOf('Url') != -1 || type.indexOf('text/uri-list') != -1 || type.indexOf('text/x-moz-url');
      });
    };

    /**
     * Get a link url.
     *
     * @return {?string}
     */


    DataTransfer.prototype.getLink = function getLink() {
      if (this.data.getData) {
        if (this.types.indexOf('text/x-moz-url') != -1) {
          var url = this.data.getData('text/x-moz-url').split('\n');
          return url[0];
        }
        return this.types.indexOf('text/uri-list') != -1 ? this.data.getData('text/uri-list') : this.data.getData('url');
      }

      return null;
    };

    /**
     * Is this an image data transfer?
     *
     * @return {boolean}
     */


    DataTransfer.prototype.isImage = function isImage() {
      var isImage = this.types.some(function (type) {
        // Firefox will have a type of application/x-moz-file for images during
        // dragging
        return type.indexOf('application/x-moz-file') != -1;
      });

      if (isImage) {
        return true;
      }

      var items = this.getFiles();
      for (var i = 0; i < items.length; i++) {
        var type = items[i].type;
        if (!PhotosMimeType_1.isImage(type)) {
          return false;
        }
      }

      return true;
    };

    DataTransfer.prototype.getCount = function getCount() {
      if (this.data.hasOwnProperty('items')) {
        return this.data.items.length;
      } else if (this.data.hasOwnProperty('mozItemCount')) {
        return this.data.mozItemCount;
      } else if (this.data.files) {
        return this.data.files.length;
      }
      return null;
    };

    /**
     * Get files.
     *
     * @return {array}
     */


    DataTransfer.prototype.getFiles = function getFiles() {
      if (this.data.items) {
        // createArrayFromMixed doesn't properly handle DataTransferItemLists.
        return Array.prototype.slice.call(this.data.items).map(getFileFromDataTransfer).filter(emptyFunction_1.thatReturnsArgument);
      } else if (this.data.files) {
        return Array.prototype.slice.call(this.data.files);
      } else {
        return [];
      }
    };

    /**
     * Are there any files to fetch?
     *
     * @return {boolean}
     */


    DataTransfer.prototype.hasFiles = function hasFiles() {
      return this.getFiles().length > 0;
    };

    return DataTransfer;
  }();

  var DataTransfer_1 = DataTransfer;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule getSelectionOffsetKeyForNode
   * @format
   * 
   */

  /**
   * Get offset key from a node or it's child nodes. Return the first offset key
   * found on the DOM tree of given node.
   */

  function getSelectionOffsetKeyForNode(node) {
    if (node instanceof Element) {
      var offsetKey = node.getAttribute('data-offset-key');
      if (offsetKey) {
        return offsetKey;
      }
      for (var ii = 0; ii < node.childNodes.length; ii++) {
        var childOffsetKey = getSelectionOffsetKeyForNode(node.childNodes[ii]);
        if (childOffsetKey) {
          return childOffsetKey;
        }
      }
    }
    return null;
  }

  var getSelectionOffsetKeyForNode_1 = getSelectionOffsetKeyForNode;

  /**
   * Get the key from the node's nearest offset-aware ancestor.
   */
  function findAncestorOffsetKey(node) {
    var searchNode = node;
    while (searchNode && searchNode !== document.documentElement) {
      var key = getSelectionOffsetKeyForNode_1(searchNode);
      if (key != null) {
        return key;
      }
      searchNode = searchNode.parentNode;
    }
    return null;
  }

  var findAncestorOffsetKey_1 = findAncestorOffsetKey;

  var TEXT_CLIPPING_REGEX = /\.textClipping$/;

  var TEXT_TYPES = {
    'text/plain': true,
    'text/html': true,
    'text/rtf': true
  };

  // Somewhat arbitrary upper bound on text size. Let's not lock up the browser.
  var TEXT_SIZE_UPPER_BOUND = 5000;

  /**
   * Extract the text content from a file list.
   */
  function getTextContentFromFiles(files, callback) {
    var readCount = 0;
    var results = [];
    files.forEach(function ( /*blob*/file) {
      readFile(file, function ( /*string*/text) {
        readCount++;
        text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));
        if (readCount == files.length) {
          callback(results.join('\r'));
        }
      });
    });
  }

  /**
   * todo isaac: Do work to turn html/rtf into a content fragment.
   */
  function readFile(file, callback) {
    if (!commonjsGlobal.FileReader || file.type && !(file.type in TEXT_TYPES)) {
      callback('');
      return;
    }

    if (file.type === '') {
      var contents = '';
      // Special-case text clippings, which have an empty type but include
      // `.textClipping` in the file name. `readAsText` results in an empty
      // string for text clippings, so we force the file name to serve
      // as the text value for the file.
      if (TEXT_CLIPPING_REGEX.test(file.name)) {
        contents = file.name.replace(TEXT_CLIPPING_REGEX, '');
      }
      callback(contents);
      return;
    }

    var reader = new FileReader();
    reader.onload = function () {
      var result = reader.result;
      !(typeof result === 'string') ? invariant_1(false) : void 0;
      callback(result);
    };
    reader.onerror = function () {
      callback('');
    };
    reader.readAsText(file);
  }

  var getTextContentFromFiles_1 = getTextContentFromFiles;

  function getUpdatedSelectionState(editorState, anchorKey, anchorOffset, focusKey, focusOffset) {
    var selection = nullthrows_1(editorState.getSelection());

    var anchorPath = DraftOffsetKey_1.decode(anchorKey);
    var anchorBlockKey = anchorPath.blockKey;
    var anchorLeaf = editorState.getBlockTree(anchorBlockKey).getIn([anchorPath.decoratorKey, 'leaves', anchorPath.leafKey]);

    var focusPath = DraftOffsetKey_1.decode(focusKey);
    var focusBlockKey = focusPath.blockKey;
    var focusLeaf = editorState.getBlockTree(focusBlockKey).getIn([focusPath.decoratorKey, 'leaves', focusPath.leafKey]);

    var anchorLeafStart = anchorLeaf.get('start');
    var focusLeafStart = focusLeaf.get('start');

    var anchorBlockOffset = anchorLeaf ? anchorLeafStart + anchorOffset : null;
    var focusBlockOffset = focusLeaf ? focusLeafStart + focusOffset : null;

    var areEqual = selection.getAnchorKey() === anchorBlockKey && selection.getAnchorOffset() === anchorBlockOffset && selection.getFocusKey() === focusBlockKey && selection.getFocusOffset() === focusBlockOffset;

    if (areEqual) {
      return selection;
    }

    var isBackward = false;
    if (anchorBlockKey === focusBlockKey) {
      var anchorLeafEnd = anchorLeaf.get('end');
      var focusLeafEnd = focusLeaf.get('end');
      if (focusLeafStart === anchorLeafStart && focusLeafEnd === anchorLeafEnd) {
        isBackward = focusOffset < anchorOffset;
      } else {
        isBackward = focusLeafStart < anchorLeafStart;
      }
    } else {
      var startKey = editorState.getCurrentContent().getBlockMap().keySeq().skipUntil(function (v) {
        return v === anchorBlockKey || v === focusBlockKey;
      }).first();
      isBackward = startKey === focusBlockKey;
    }

    return selection.merge({
      anchorKey: anchorBlockKey,
      anchorOffset: anchorBlockOffset,
      focusKey: focusBlockKey,
      focusOffset: focusBlockOffset,
      isBackward: isBackward
    });
  }

  var getUpdatedSelectionState_1 = getUpdatedSelectionState;

  /**
   * Get a SelectionState for the supplied mouse event.
   */
  function getSelectionForEvent(event, editorState) {
    var node = null;
    var offset = null;

    if (typeof document.caretRangeFromPoint === 'function') {
      var dropRange = document.caretRangeFromPoint(event.x, event.y);
      node = dropRange.startContainer;
      offset = dropRange.startOffset;
    } else if (event.rangeParent) {
      node = event.rangeParent;
      offset = event.rangeOffset;
    } else {
      return null;
    }

    node = nullthrows_1(node);
    offset = nullthrows_1(offset);
    var offsetKey = nullthrows_1(findAncestorOffsetKey_1(node));

    return getUpdatedSelectionState_1(editorState, offsetKey, offset, offsetKey, offset);
  }

  var DraftEditorDragHandler = {
    /**
     * Drag originating from input terminated.
     */
    onDragEnd: function onDragEnd(editor) {
      editor.exitCurrentMode();
    },

    /**
     * Handle data being dropped.
     */
    onDrop: function onDrop(editor, e) {
      var data = new DataTransfer_1(e.nativeEvent.dataTransfer);

      var editorState = editor._latestEditorState;
      var dropSelection = getSelectionForEvent(e.nativeEvent, editorState);

      e.preventDefault();
      editor.exitCurrentMode();

      if (dropSelection == null) {
        return;
      }

      var files = data.getFiles();
      if (files.length > 0) {
        if (editor.props.handleDroppedFiles && isEventHandled_1(editor.props.handleDroppedFiles(dropSelection, files))) {
          return;
        }

        getTextContentFromFiles_1(files, function (fileText) {
          fileText && editor.update(insertTextAtSelection(editorState, dropSelection, fileText));
        });
        return;
      }

      var dragType = editor._internalDrag ? 'internal' : 'external';
      if (editor.props.handleDrop && isEventHandled_1(editor.props.handleDrop(dropSelection, data, dragType))) {
        return;
      }

      if (editor._internalDrag) {
        editor.update(moveText(editorState, dropSelection));
        return;
      }

      editor.update(insertTextAtSelection(editorState, dropSelection, data.getText()));
    }
  };

  function moveText(editorState, targetSelection) {
    var newContentState = DraftModifier_1.moveText(editorState.getCurrentContent(), editorState.getSelection(), targetSelection);
    return EditorState_1.push(editorState, newContentState, 'insert-fragment');
  }

  /**
   * Insert text at a specified selection.
   */
  function insertTextAtSelection(editorState, selection, text) {
    var newContentState = DraftModifier_1.insertText(editorState.getCurrentContent(), selection, text, editorState.getCurrentInlineStyle());
    return EditorState_1.push(editorState, newContentState, 'insert-fragment');
  }

  var DraftEditorDragHandler_1 = DraftEditorDragHandler;

  (function (global, undefined$1) {

      if (global.setImmediate) {
          return;
      }

      var nextHandle = 1; // Spec says greater than zero
      var tasksByHandle = {};
      var currentlyRunningATask = false;
      var doc = global.document;
      var registerImmediate;

      function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
          callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
      }

      function clearImmediate(handle) {
          delete tasksByHandle[handle];
      }

      function run(task) {
          var callback = task.callback;
          var args = task.args;
          switch (args.length) {
          case 0:
              callback();
              break;
          case 1:
              callback(args[0]);
              break;
          case 2:
              callback(args[0], args[1]);
              break;
          case 3:
              callback(args[0], args[1], args[2]);
              break;
          default:
              callback.apply(undefined$1, args);
              break;
          }
      }

      function runIfPresent(handle) {
          // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
          // So if we're currently running a task, we'll need to delay this invocation.
          if (currentlyRunningATask) {
              // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
              // "too much recursion" error.
              setTimeout(runIfPresent, 0, handle);
          } else {
              var task = tasksByHandle[handle];
              if (task) {
                  currentlyRunningATask = true;
                  try {
                      run(task);
                  } finally {
                      clearImmediate(handle);
                      currentlyRunningATask = false;
                  }
              }
          }
      }

      function installNextTickImplementation() {
          registerImmediate = function(handle) {
              process.nextTick(function () { runIfPresent(handle); });
          };
      }

      function canUsePostMessage() {
          // The test against `importScripts` prevents this implementation from being installed inside a web worker,
          // where `global.postMessage` means something completely different and can't be used for this purpose.
          if (global.postMessage && !global.importScripts) {
              var postMessageIsAsynchronous = true;
              var oldOnMessage = global.onmessage;
              global.onmessage = function() {
                  postMessageIsAsynchronous = false;
              };
              global.postMessage("", "*");
              global.onmessage = oldOnMessage;
              return postMessageIsAsynchronous;
          }
      }

      function installPostMessageImplementation() {
          // Installs an event handler on `global` for the `message` event: see
          // * https://developer.mozilla.org/en/DOM/window.postMessage
          // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

          var messagePrefix = "setImmediate$" + Math.random() + "$";
          var onGlobalMessage = function(event) {
              if (event.source === global &&
                  typeof event.data === "string" &&
                  event.data.indexOf(messagePrefix) === 0) {
                  runIfPresent(+event.data.slice(messagePrefix.length));
              }
          };

          if (global.addEventListener) {
              global.addEventListener("message", onGlobalMessage, false);
          } else {
              global.attachEvent("onmessage", onGlobalMessage);
          }

          registerImmediate = function(handle) {
              global.postMessage(messagePrefix + handle, "*");
          };
      }

      function installMessageChannelImplementation() {
          var channel = new MessageChannel();
          channel.port1.onmessage = function(event) {
              var handle = event.data;
              runIfPresent(handle);
          };

          registerImmediate = function(handle) {
              channel.port2.postMessage(handle);
          };
      }

      function installReadyStateChangeImplementation() {
          var html = doc.documentElement;
          registerImmediate = function(handle) {
              // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
              // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
              var script = doc.createElement("script");
              script.onreadystatechange = function () {
                  runIfPresent(handle);
                  script.onreadystatechange = null;
                  html.removeChild(script);
                  script = null;
              };
              html.appendChild(script);
          };
      }

      function installSetTimeoutImplementation() {
          registerImmediate = function(handle) {
              setTimeout(runIfPresent, 0, handle);
          };
      }

      // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
      attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

      // Don't get fooled by e.g. browserify environments.
      if ({}.toString.call(global.process) === "[object process]") {
          // For Node.js before 0.9
          installNextTickImplementation();

      } else if (canUsePostMessage()) {
          // For non-IE10 modern browsers
          installPostMessageImplementation();

      } else if (global.MessageChannel) {
          // For web workers, where supported
          installMessageChannelImplementation();

      } else if (doc && "onreadystatechange" in doc.createElement("script")) {
          // For IE 6–8
          installReadyStateChangeImplementation();

      } else {
          // For older browsers
          installSetTimeoutImplementation();
      }

      attachTo.setImmediate = setImmediate;
      attachTo.clearImmediate = clearImmediate;
  }(typeof self === "undefined" ? typeof commonjsGlobal === "undefined" ? commonjsGlobal : commonjsGlobal : self));

  // setimmediate adds setImmediate to the global. We want to make sure we export
  // the actual function.


  var setImmediate = commonjsGlobal.setImmediate;

  // When nothing is focused, Firefox regards two characters, `'` and `/`, as
  // commands that should open and focus the "quickfind" search bar. This should
  // *never* happen while a contenteditable is focused, but as of v28, it
  // sometimes does, even when the keypress event target is the contenteditable.
  // This breaks the input. Special case these characters to ensure that when
  // they are typed, we prevent default on the event to make sure not to
  // trigger quickfind.
  var FF_QUICKFIND_CHAR = "'";
  var FF_QUICKFIND_LINK_CHAR = '/';
  var isFirefox = UserAgent_1.isBrowser('Firefox');

  function mustPreventDefaultForCharacter(character) {
    return isFirefox && (character == FF_QUICKFIND_CHAR || character == FF_QUICKFIND_LINK_CHAR);
  }

  /**
   * Replace the current selection with the specified text string, with the
   * inline style and entity key applied to the newly inserted text.
   */
  function replaceText(editorState, text, inlineStyle, entityKey) {
    var contentState = DraftModifier_1.replaceText(editorState.getCurrentContent(), editorState.getSelection(), text, inlineStyle, entityKey);
    return EditorState_1.push(editorState, contentState, 'insert-characters');
  }

  /**
   * When `onBeforeInput` executes, the browser is attempting to insert a
   * character into the editor. Apply this character data to the document,
   * allowing native insertion if possible.
   *
   * Native insertion is encouraged in order to limit re-rendering and to
   * preserve spellcheck highlighting, which disappears or flashes if re-render
   * occurs on the relevant text nodes.
   */
  function editOnBeforeInput(editor, e) {
    if (editor._pendingStateFromBeforeInput !== undefined) {
      editor.update(editor._pendingStateFromBeforeInput);
      editor._pendingStateFromBeforeInput = undefined;
    }

    var editorState = editor._latestEditorState;

    var chars = e.data;

    // In some cases (ex: IE ideographic space insertion) no character data
    // is provided. There's nothing to do when this happens.
    if (!chars) {
      return;
    }

    // Allow the top-level component to handle the insertion manually. This is
    // useful when triggering interesting behaviors for a character insertion,
    // Simple examples: replacing a raw text ':)' with a smile emoji or image
    // decorator, or setting a block to be a list item after typing '- ' at the
    // start of the block.
    if (editor.props.handleBeforeInput && isEventHandled_1(editor.props.handleBeforeInput(chars, editorState))) {
      e.preventDefault();
      return;
    }

    // If selection is collapsed, conditionally allow native behavior. This
    // reduces re-renders and preserves spellcheck highlighting. If the selection
    // is not collapsed, we will re-render.
    var selection = editorState.getSelection();
    var selectionStart = selection.getStartOffset();
    var selectionEnd = selection.getEndOffset();
    var anchorKey = selection.getAnchorKey();

    if (!selection.isCollapsed()) {
      e.preventDefault();

      // If the currently selected text matches what the user is trying to
      // replace it with, let's just update the `SelectionState`. If not, update
      // the `ContentState` with the new text.
      var currentlySelectedChars = editorState.getCurrentContent().getPlainText().slice(selectionStart, selectionEnd);
      if (chars === currentlySelectedChars) {
        editor.update(EditorState_1.forceSelection(editorState, selection.merge({
          focusOffset: selectionEnd
        })));
      } else {
        editor.update(replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection_1(editorState.getCurrentContent(), editorState.getSelection())));
      }
      return;
    }

    var newEditorState = replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection_1(editorState.getCurrentContent(), editorState.getSelection()));

    // Bunch of different cases follow where we need to prevent native insertion.
    var mustPreventNative = false;
    if (!mustPreventNative) {
      // Browsers tend to insert text in weird places in the DOM when typing at
      // the start of a leaf, so we'll handle it ourselves.
      mustPreventNative = isSelectionAtLeafStart_1(editor._latestCommittedEditorState);
    }
    if (!mustPreventNative) {
      // Chrome will also split up a node into two pieces if it contains a Tab
      // char, for no explicable reason. Seemingly caused by this commit:
      // https://chromium.googlesource.com/chromium/src/+/013ac5eaf3%5E%21/
      var nativeSelection = commonjsGlobal.getSelection();
      // Selection is necessarily collapsed at this point due to earlier check.
      if (nativeSelection.anchorNode && nativeSelection.anchorNode.nodeType === Node.TEXT_NODE) {
        // See isTabHTMLSpanElement in chromium EditingUtilities.cpp.
        var parentNode = nativeSelection.anchorNode.parentNode;
        mustPreventNative = parentNode.nodeName === 'SPAN' && parentNode.firstChild.nodeType === Node.TEXT_NODE && parentNode.firstChild.nodeValue.indexOf('\t') !== -1;
      }
    }
    if (!mustPreventNative) {
      // Check the old and new "fingerprints" of the current block to determine
      // whether this insertion requires any addition or removal of text nodes,
      // in which case we would prevent the native character insertion.
      var originalFingerprint = BlockTree_1.getFingerprint(editorState.getBlockTree(anchorKey));
      var newFingerprint = BlockTree_1.getFingerprint(newEditorState.getBlockTree(anchorKey));
      mustPreventNative = originalFingerprint !== newFingerprint;
    }
    if (!mustPreventNative) {
      mustPreventNative = mustPreventDefaultForCharacter(chars);
    }
    if (!mustPreventNative) {
      mustPreventNative = nullthrows_1(newEditorState.getDirectionMap()).get(anchorKey) !== nullthrows_1(editorState.getDirectionMap()).get(anchorKey);
    }

    if (mustPreventNative) {
      e.preventDefault();
      editor.update(newEditorState);
      return;
    }

    // We made it all the way! Let the browser do its thing and insert the char.
    newEditorState = EditorState_1.set(newEditorState, {
      nativelyRenderedContent: newEditorState.getCurrentContent()
    });
    // The native event is allowed to occur. To allow user onChange handlers to
    // change the inserted text, we wait until the text is actually inserted
    // before we actually update our state. That way when we rerender, the text
    // we see in the DOM will already have been inserted properly.
    editor._pendingStateFromBeforeInput = newEditorState;
    setImmediate(function () {
      if (editor._pendingStateFromBeforeInput !== undefined) {
        editor.update(editor._pendingStateFromBeforeInput);
        editor._pendingStateFromBeforeInput = undefined;
      }
    });
  }

  var editOnBeforeInput_1 = editOnBeforeInput;

  function editOnBlur(editor, e) {
    // In a contentEditable element, when you select a range and then click
    // another active element, this does trigger a `blur` event but will not
    // remove the DOM selection from the contenteditable.
    // This is consistent across all browsers, but we prefer that the editor
    // behave like a textarea, where a `blur` event clears the DOM selection.
    // We therefore force the issue to be certain, checking whether the active
    // element is `body` to force it when blurring occurs within the window (as
    // opposed to clicking to another tab or window).
    if (getActiveElement_1() === document.body) {
      var _selection = commonjsGlobal.getSelection();
      var editorNode = editor.editor;
      if (_selection.rangeCount === 1 && containsNode_1(editorNode, _selection.anchorNode) && containsNode_1(editorNode, _selection.focusNode)) {
        _selection.removeAllRanges();
      }
    }

    var editorState = editor._latestEditorState;
    var currentSelection = editorState.getSelection();
    if (!currentSelection.getHasFocus()) {
      return;
    }

    var selection = currentSelection.set('hasFocus', false);
    editor.props.onBlur && editor.props.onBlur(e);
    editor.update(EditorState_1.acceptSelection(editorState, selection));
  }

  var editOnBlur_1 = editOnBlur;

  /**
   * The user has begun using an IME input system. Switching to `composite` mode
   * allows handling composition input and disables other edit behavior.
   */
  function editOnCompositionStart(editor, e) {
    editor.setMode('composite');
    editor.update(EditorState_1.set(editor._latestEditorState, { inCompositionMode: true }));
    // Allow composition handler to interpret the compositionstart event
    editor._onCompositionStart(e);
  }

  var editOnCompositionStart_1 = editOnCompositionStart;

  function getFragmentFromSelection(editorState) {
    var selectionState = editorState.getSelection();

    if (selectionState.isCollapsed()) {
      return null;
    }

    return getContentStateFragment_1(editorState.getCurrentContent(), selectionState);
  }

  var getFragmentFromSelection_1 = getFragmentFromSelection;

  /**
   * If we have a selection, create a ContentState fragment and store
   * it in our internal clipboard. Subsequent paste events will use this
   * fragment if no external clipboard data is supplied.
   */
  function editOnCopy(editor, e) {
    var editorState = editor._latestEditorState;
    var selection = editorState.getSelection();

    // No selection, so there's nothing to copy.
    if (selection.isCollapsed()) {
      e.preventDefault();
      return;
    }

    editor.setClipboard(getFragmentFromSelection_1(editor._latestEditorState));
  }

  var editOnCopy_1 = editOnCopy;

  /**
   * On `cut` events, native behavior is allowed to occur so that the system
   * clipboard is set properly. This means that we need to take steps to recover
   * the editor DOM state after the `cut` has occurred in order to maintain
   * control of the component.
   *
   * In addition, we can keep a copy of the removed fragment, including all
   * styles and entities, for use as an internal paste.
   */
  function editOnCut(editor, e) {
    var editorState = editor._latestEditorState;
    var selection = editorState.getSelection();
    var element = e.target;
    var scrollPosition = void 0;

    // No selection, so there's nothing to cut.
    if (selection.isCollapsed()) {
      e.preventDefault();
      return;
    }

    // Track the current scroll position so that it can be forced back in place
    // after the editor regains control of the DOM.
    if (element instanceof Node) {
      scrollPosition = getScrollPosition_1(Style_1.getScrollParent(element));
    }

    var fragment = getFragmentFromSelection_1(editorState);
    editor.setClipboard(fragment);

    // Set `cut` mode to disable all event handling temporarily.
    editor.setMode('cut');

    // Let native `cut` behavior occur, then recover control.
    setTimeout(function () {
      editor.restoreEditorDOM(scrollPosition);
      editor.exitCurrentMode();
      editor.update(removeFragment(editorState));
    }, 0);
  }

  function removeFragment(editorState) {
    var newContent = DraftModifier_1.removeRange(editorState.getCurrentContent(), editorState.getSelection(), 'forward');
    return EditorState_1.push(editorState, newContent, 'remove-range');
  }

  var editOnCut_1 = editOnCut;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule editOnDragOver
   * @format
   * 
   */

  /**
   * Drag behavior has begun from outside the editor element.
   */
  function editOnDragOver(editor, e) {
    editor._internalDrag = false;
    editor.setMode('drag');
    e.preventDefault();
  }

  var editOnDragOver_1 = editOnDragOver;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule editOnDragStart
   * @format
   * 
   */

  /**
   * A `dragstart` event has begun within the text editor component.
   */
  function editOnDragStart(editor) {
    editor._internalDrag = true;
    editor.setMode('drag');
  }

  var editOnDragStart_1 = editOnDragStart;

  function editOnFocus(editor, e) {
    var editorState = editor._latestEditorState;
    var currentSelection = editorState.getSelection();
    if (currentSelection.getHasFocus()) {
      return;
    }

    var selection = currentSelection.set('hasFocus', true);
    editor.props.onFocus && editor.props.onFocus(e);

    // When the tab containing this text editor is hidden and the user does a
    // find-in-page in a _different_ tab, Chrome on Mac likes to forget what the
    // selection was right after sending this focus event and (if you let it)
    // moves the cursor back to the beginning of the editor, so we force the
    // selection here instead of simply accepting it in order to preserve the
    // old cursor position. See https://crbug.com/540004.
    // But it looks like this is fixed in Chrome 60.0.3081.0.
    // Other browsers also don't have this bug, so we prefer to acceptSelection
    // when possible, to ensure that unfocusing and refocusing a Draft editor
    // doesn't preserve the selection, matching how textareas work.
    if (UserAgent_1.isBrowser('Chrome < 60.0.3081.0')) {
      editor.update(EditorState_1.forceSelection(editorState, selection));
    } else {
      editor.update(EditorState_1.acceptSelection(editorState, selection));
    }
  }

  var editOnFocus_1 = editOnFocus;

  var isGecko = UserAgent_1.isEngine('Gecko');

  var DOUBLE_NEWLINE = '\n\n';

  /**
   * This function is intended to handle spellcheck and autocorrect changes,
   * which occur in the DOM natively without any opportunity to observe or
   * interpret the changes before they occur.
   *
   * The `input` event fires in contentEditable elements reliably for non-IE
   * browsers, immediately after changes occur to the editor DOM. Since our other
   * handlers override or otherwise handle cover other varieties of text input,
   * the DOM state should match the model in all controlled input cases. Thus,
   * when an `input` change leads to a DOM/model mismatch, the change should be
   * due to a spellcheck change, and we can incorporate it into our model.
   */
  function editOnInput(editor) {
    if (editor._pendingStateFromBeforeInput !== undefined) {
      editor.update(editor._pendingStateFromBeforeInput);
      editor._pendingStateFromBeforeInput = undefined;
    }

    var domSelection = commonjsGlobal.getSelection();

    var anchorNode = domSelection.anchorNode,
        isCollapsed = domSelection.isCollapsed;

    var isNotTextNode = anchorNode.nodeType !== Node.TEXT_NODE;
    var isNotTextOrElementNode = anchorNode.nodeType !== Node.TEXT_NODE && anchorNode.nodeType !== Node.ELEMENT_NODE;

    {
      if (isNotTextOrElementNode) {
        // TODO: (t16149272) figure out context for this change
        return;
      }
    }

    if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {
      // When typing at the beginning of a visual line, Chrome splits the text
      // nodes into two. Why? No one knows. This commit is suspicious:
      // https://chromium.googlesource.com/chromium/src/+/a3b600981286b135632371477f902214c55a1724
      // To work around, we'll merge the sibling text nodes back into this one.
      var span = anchorNode.parentNode;
      anchorNode.nodeValue = span.textContent;
      for (var child = span.firstChild; child !== null; child = child.nextSibling) {
        if (child !== anchorNode) {
          span.removeChild(child);
        }
      }
    }

    var domText = anchorNode.textContent;
    var editorState = editor._latestEditorState;
    var offsetKey = nullthrows_1(findAncestorOffsetKey_1(anchorNode));

    var _DraftOffsetKey$decod = DraftOffsetKey_1.decode(offsetKey),
        blockKey = _DraftOffsetKey$decod.blockKey,
        decoratorKey = _DraftOffsetKey$decod.decoratorKey,
        leafKey = _DraftOffsetKey$decod.leafKey;

    var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, 'leaves', leafKey]),
        start = _editorState$getBlock.start,
        end = _editorState$getBlock.end;

    var content = editorState.getCurrentContent();
    var block = content.getBlockForKey(blockKey);
    var modelText = block.getText().slice(start, end);

    // Special-case soft newlines here. If the DOM text ends in a soft newline,
    // we will have manually inserted an extra soft newline in DraftEditorLeaf.
    // We want to remove this extra newline for the purpose of our comparison
    // of DOM and model text.
    if (domText.endsWith(DOUBLE_NEWLINE)) {
      domText = domText.slice(0, -1);
    }

    // No change -- the DOM is up to date. Nothing to do here.
    if (domText === modelText) {
      // This can be buggy for some Android keyboards because they don't fire
      // standard onkeydown/pressed events and only fired editOnInput
      // so domText is already changed by the browser and ends up being equal
      // to modelText unexpectedly
      return;
    }

    var selection = editorState.getSelection();

    // We'll replace the entire leaf with the text content of the target.
    var targetRange = selection.merge({
      anchorOffset: start,
      focusOffset: end,
      isBackward: false
    });

    var entityKey = block.getEntityAt(start);
    var entity = entityKey && content.getEntity(entityKey);
    var entityType = entity && entity.getMutability();
    var preserveEntity = entityType === 'MUTABLE';

    // Immutable or segmented entities cannot properly be handled by the
    // default browser undo, so we have to use a different change type to
    // force using our internal undo method instead of falling through to the
    // native browser undo.
    var changeType = preserveEntity ? 'spellcheck-change' : 'apply-entity';

    var newContent = DraftModifier_1.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);

    var anchorOffset, focusOffset, startOffset, endOffset;

    if (isGecko) {
      // Firefox selection does not change while the context menu is open, so
      // we preserve the anchor and focus values of the DOM selection.
      anchorOffset = domSelection.anchorOffset;
      focusOffset = domSelection.focusOffset;
      startOffset = start + Math.min(anchorOffset, focusOffset);
      endOffset = startOffset + Math.abs(anchorOffset - focusOffset);
      anchorOffset = startOffset;
      focusOffset = endOffset;
    } else {
      // Browsers other than Firefox may adjust DOM selection while the context
      // menu is open, and Safari autocorrect is prone to providing an inaccurate
      // DOM selection. Don't trust it. Instead, use our existing SelectionState
      // and adjust it based on the number of characters changed during the
      // mutation.
      var charDelta = domText.length - modelText.length;
      startOffset = selection.getStartOffset();
      endOffset = selection.getEndOffset();

      anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;
      focusOffset = endOffset + charDelta;
    }

    // Segmented entities are completely or partially removed when their
    // text content changes. For this case we do not want any text to be selected
    // after the change, so we are not merging the selection.
    var contentWithAdjustedDOMSelection = newContent.merge({
      selectionBefore: content.getSelectionAfter(),
      selectionAfter: selection.merge({ anchorOffset: anchorOffset, focusOffset: focusOffset })
    });

    editor.update(EditorState_1.push(editorState, contentWithAdjustedDOMSelection, changeType));
  }

  var editOnInput_1 = editOnInput;

  var isOSX = UserAgent_1.isPlatform('Mac OS X');

  var KeyBindingUtil = {
    /**
     * Check whether the ctrlKey modifier is *not* being used in conjunction with
     * the altKey modifier. If they are combined, the result is an `altGraph`
     * key modifier, which should not be handled by this set of key bindings.
     */
    isCtrlKeyCommand: function isCtrlKeyCommand(e) {
      return !!e.ctrlKey && !e.altKey;
    },

    isOptionKeyCommand: function isOptionKeyCommand(e) {
      return isOSX && e.altKey;
    },

    hasCommandModifier: function hasCommandModifier(e) {
      return isOSX ? !!e.metaKey && !e.altKey : KeyBindingUtil.isCtrlKeyCommand(e);
    }
  };

  var KeyBindingUtil_1 = KeyBindingUtil;

  var clipboard = null;

  /**
   * Some systems offer a "secondary" clipboard to allow quick internal cut
   * and paste behavior. For instance, Ctrl+K (cut) and Ctrl+Y (paste).
   */
  var SecondaryClipboard = {
    cut: function cut(editorState) {
      var content = editorState.getCurrentContent();
      var selection = editorState.getSelection();
      var targetRange = null;

      if (selection.isCollapsed()) {
        var anchorKey = selection.getAnchorKey();
        var blockEnd = content.getBlockForKey(anchorKey).getLength();

        if (blockEnd === selection.getAnchorOffset()) {
          return editorState;
        }

        targetRange = selection.set('focusOffset', blockEnd);
      } else {
        targetRange = selection;
      }

      targetRange = nullthrows_1(targetRange);
      clipboard = getContentStateFragment_1(content, targetRange);

      var afterRemoval = DraftModifier_1.removeRange(content, targetRange, 'forward');

      if (afterRemoval === content) {
        return editorState;
      }

      return EditorState_1.push(editorState, afterRemoval, 'remove-range');
    },

    paste: function paste(editorState) {
      if (!clipboard) {
        return editorState;
      }

      var newContent = DraftModifier_1.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), clipboard);

      return EditorState_1.push(editorState, newContent, 'insert-fragment');
    }
  };

  var SecondaryClipboard_1 = SecondaryClipboard;

  // These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a
  // surrogate code unit.
  var SURROGATE_HIGH_START = 0xD800;
  var SURROGATE_HIGH_END = 0xDBFF;
  var SURROGATE_LOW_START = 0xDC00;
  var SURROGATE_LOW_END = 0xDFFF;
  var SURROGATE_UNITS_REGEX = /[\uD800-\uDFFF]/;

  /**
   * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]
   * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range
   */
  function isCodeUnitInSurrogateRange(codeUnit) {
    return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;
  }

  /**
   * Returns whether the two characters starting at `index` form a surrogate pair.
   * For example, given the string s = "\uD83D\uDE0A", (s, 0) returns true and
   * (s, 1) returns false.
   *
   * @param {string} str
   * @param {number} index
   * @return {boolean}
   */
  function isSurrogatePair(str, index) {
    !(0 <= index && index < str.length) ? invariant_1(false) : void 0;
    if (index + 1 === str.length) {
      return false;
    }
    var first = str.charCodeAt(index);
    var second = str.charCodeAt(index + 1);
    return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;
  }

  /**
   * @param {string} str  Non-empty string
   * @return {boolean}    True if the input includes any surrogate code units
   */
  function hasSurrogateUnit(str) {
    return SURROGATE_UNITS_REGEX.test(str);
  }

  /**
   * Return the length of the original Unicode character at given position in the
   * String by looking into the UTF-16 code unit; that is equal to 1 for any
   * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and
   * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact
   * representing non-BMP characters ([U+10000..U+10FFFF]).
   *
   * Examples:
   * - '\u0020' => 1
   * - '\u3020' => 1
   * - '\uD835' => 2
   * - '\uD835\uDDEF' => 2
   * - '\uDDEF' => 2
   *
   * @param {string} str  Non-empty string
   * @param {number} pos  Position in the string to look for one code unit
   * @return {number}      Number 1 or 2
   */
  function getUTF16Length(str, pos) {
    return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));
  }

  /**
   * Fully Unicode-enabled replacement for String#length
   *
   * @param {string} str  Valid Unicode string
   * @return {number}     The number of Unicode characters in the string
   */
  function strlen(str) {
    // Call the native functions if there's no surrogate char
    if (!hasSurrogateUnit(str)) {
      return str.length;
    }

    var len = 0;
    for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
      len++;
    }
    return len;
  }

  /**
   * Fully Unicode-enabled replacement for String#substr()
   *
   * @param {string} str      Valid Unicode string
   * @param {number} start    Location in Unicode sequence to begin extracting
   * @param {?number} length  The number of Unicode characters to extract
   *                          (default: to the end of the string)
   * @return {string}         Extracted sub-string
   */
  function substr(str, start, length) {
    start = start || 0;
    length = length === undefined ? Infinity : length || 0;

    // Call the native functions if there's no surrogate char
    if (!hasSurrogateUnit(str)) {
      return str.substr(start, length);
    }

    // Obvious cases
    var size = str.length;
    if (size <= 0 || start > size || length <= 0) {
      return '';
    }

    // Find the actual starting position
    var posA = 0;
    if (start > 0) {
      for (; start > 0 && posA < size; start--) {
        posA += getUTF16Length(str, posA);
      }
      if (posA >= size) {
        return '';
      }
    } else if (start < 0) {
      for (posA = size; start < 0 && 0 < posA; start++) {
        posA -= getUTF16Length(str, posA - 1);
      }
      if (posA < 0) {
        posA = 0;
      }
    }

    // Find the actual ending position
    var posB = size;
    if (length < size) {
      for (posB = posA; length > 0 && posB < size; length--) {
        posB += getUTF16Length(str, posB);
      }
    }

    return str.substring(posA, posB);
  }

  /**
   * Fully Unicode-enabled replacement for String#substring()
   *
   * @param {string} str    Valid Unicode string
   * @param {number} start  Location in Unicode sequence to begin extracting
   * @param {?number} end   Location in Unicode sequence to end extracting
   *                        (default: end of the string)
   * @return {string}       Extracted sub-string
   */
  function substring(str, start, end) {
    start = start || 0;
    end = end === undefined ? Infinity : end || 0;

    if (start < 0) {
      start = 0;
    }
    if (end < 0) {
      end = 0;
    }

    var length = Math.abs(end - start);
    start = start < end ? start : end;
    return substr(str, start, length);
  }

  /**
   * Get a list of Unicode code-points from a String
   *
   * @param {string} str        Valid Unicode string
   * @return {array<number>}    A list of code-points in [0..0x10FFFF]
   */
  function getCodePoints(str) {
    var codePoints = [];
    for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
      codePoints.push(str.codePointAt(pos));
    }
    return codePoints;
  }

  var UnicodeUtils = {
    getCodePoints: getCodePoints,
    getUTF16Length: getUTF16Length,
    hasSurrogateUnit: hasSurrogateUnit,
    isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,
    isSurrogatePair: isSurrogatePair,
    strlen: strlen,
    substring: substring,
    substr: substr
  };

  var UnicodeUtils_1 = UnicodeUtils;

  var isChrome = UserAgent_1.isBrowser('Chrome');

  // In Chrome, the client rects will include the entire bounds of all nodes that
  // begin (have a start tag) within the selection, even if the selection does
  // not overlap the entire node. To resolve this, we split the range at each
  // start tag and join the client rects together.
  // https://code.google.com/p/chromium/issues/detail?id=324437
  /* eslint-disable consistent-return */
  function getRangeClientRectsChrome(range) {
    var tempRange = range.cloneRange();
    var clientRects = [];

    for (var ancestor = range.endContainer; ancestor != null; ancestor = ancestor.parentNode) {
      // If we've climbed up to the common ancestor, we can now use the
      // original start point and stop climbing the tree.
      var atCommonAncestor = ancestor === range.commonAncestorContainer;
      if (atCommonAncestor) {
        tempRange.setStart(range.startContainer, range.startOffset);
      } else {
        tempRange.setStart(tempRange.endContainer, 0);
      }
      var rects = Array.from(tempRange.getClientRects());
      clientRects.push(rects);
      if (atCommonAncestor) {
        var _ref;

        clientRects.reverse();
        return (_ref = []).concat.apply(_ref, clientRects);
      }
      tempRange.setEndBefore(ancestor);
    }

    invariant_1(false);
  }
  /* eslint-enable consistent-return */

  /**
   * Like range.getClientRects() but normalizes for browser bugs.
   */
  var getRangeClientRects = isChrome ? getRangeClientRectsChrome : function (range) {
    return Array.from(range.getClientRects());
  };

  var getRangeClientRects_1 = getRangeClientRects;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule expandRangeToStartOfLine
   * @format
   * 
   */






  /**
   * Return the computed line height, in pixels, for the provided element.
   */
  function getLineHeightPx(element) {
    var computed = getComputedStyle(element);
    var div = document.createElement('div');
    div.style.fontFamily = computed.fontFamily;
    div.style.fontSize = computed.fontSize;
    div.style.fontStyle = computed.fontStyle;
    div.style.fontWeight = computed.fontWeight;
    div.style.lineHeight = computed.lineHeight;
    div.style.position = 'absolute';
    div.textContent = 'M';

    var documentBody = document.body;
    !documentBody ? invariant_1(false) : void 0;

    // forced layout here
    documentBody.appendChild(div);
    var rect = div.getBoundingClientRect();
    documentBody.removeChild(div);

    return rect.height;
  }

  /**
   * Return whether every ClientRect in the provided list lies on the same line.
   *
   * We assume that the rects on the same line all contain the baseline, so the
   * lowest top line needs to be above the highest bottom line (i.e., if you were
   * to project the rects onto the y-axis, their intersection would be nonempty).
   *
   * In addition, we require that no two boxes are lineHeight (or more) apart at
   * either top or bottom, which helps protect against false positives for fonts
   * with extremely large glyph heights (e.g., with a font size of 17px, Zapfino
   * produces rects of height 58px!).
   */
  function areRectsOnOneLine(rects, lineHeight) {
    var minTop = Infinity;
    var minBottom = Infinity;
    var maxTop = -Infinity;
    var maxBottom = -Infinity;

    for (var ii = 0; ii < rects.length; ii++) {
      var rect = rects[ii];
      if (rect.width === 0 || rect.width === 1) {
        // When a range starts or ends a soft wrap, many browsers (Chrome, IE,
        // Safari) include an empty rect on the previous or next line. When the
        // text lies in a container whose position is not integral (e.g., from
        // margin: auto), Safari makes these empty rects have width 1 (instead of
        // 0). Having one-pixel-wide characters seems unlikely (and most browsers
        // report widths in subpixel precision anyway) so it's relatively safe to
        // skip over them.
        continue;
      }
      minTop = Math.min(minTop, rect.top);
      minBottom = Math.min(minBottom, rect.bottom);
      maxTop = Math.max(maxTop, rect.top);
      maxBottom = Math.max(maxBottom, rect.bottom);
    }

    return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;
  }

  /**
   * Return the length of a node, as used by Range offsets.
   */
  function getNodeLength$1(node) {
    // http://www.w3.org/TR/dom/#concept-node-length
    switch (node.nodeType) {
      case Node.DOCUMENT_TYPE_NODE:
        return 0;
      case Node.TEXT_NODE:
      case Node.PROCESSING_INSTRUCTION_NODE:
      case Node.COMMENT_NODE:
        return node.length;
      default:
        return node.childNodes.length;
    }
  }

  /**
   * Given a collapsed range, move the start position backwards as far as
   * possible while the range still spans only a single line.
   */
  function expandRangeToStartOfLine(range) {
    !range.collapsed ? invariant_1(false) : void 0;
    range = range.cloneRange();

    var containingElement = range.startContainer;
    if (containingElement.nodeType !== 1) {
      containingElement = containingElement.parentNode;
    }
    var lineHeight = getLineHeightPx(containingElement);

    // Imagine our text looks like:
    //   <div><span>once upon a time, there was a <em>boy
    //   who lived</em> </span><q><strong>under^ the
    //   stairs</strong> in a small closet.</q></div>
    // where the caret represents the cursor. First, we crawl up the tree until
    // the range spans multiple lines (setting the start point to before
    // "<strong>", then before "<div>"), then at each level we do a search to
    // find the latest point which is still on a previous line. We'll find that
    // the break point is inside the span, then inside the <em>, then in its text
    // node child, the actual break point before "who".

    var bestContainer = range.endContainer;
    var bestOffset = range.endOffset;
    range.setStart(range.startContainer, 0);

    while (areRectsOnOneLine(getRangeClientRects_1(range), lineHeight)) {
      bestContainer = range.startContainer;
      bestOffset = range.startOffset;
      !bestContainer.parentNode ? invariant_1(false) : void 0;
      range.setStartBefore(bestContainer);
      if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== 'inline') {
        // The start of the line is never in a different block-level container.
        break;
      }
    }

    // In the above example, range now spans from "<div>" to "under",
    // bestContainer is <div>, and bestOffset is 1 (index of <q> inside <div>)].
    // Picking out which child to recurse into here is a special case since we
    // don't want to check past <q> -- once we find that the final range starts
    // in <span>, we can look at all of its children (and all of their children)
    // to find the break point.

    // At all times, (bestContainer, bestOffset) is the latest single-line start
    // point that we know of.
    var currentContainer = bestContainer;
    var maxIndexToConsider = bestOffset - 1;

    do {
      var nodeValue = currentContainer.nodeValue;

      for (var ii = maxIndexToConsider; ii >= 0; ii--) {
        if (nodeValue != null && ii > 0 && UnicodeUtils_1.isSurrogatePair(nodeValue, ii - 1)) {
          // We're in the middle of a surrogate pair -- skip over so we never
          // return a range with an endpoint in the middle of a code point.
          continue;
        }

        range.setStart(currentContainer, ii);
        if (areRectsOnOneLine(getRangeClientRects_1(range), lineHeight)) {
          bestContainer = currentContainer;
          bestOffset = ii;
        } else {
          break;
        }
      }

      if (ii === -1 || currentContainer.childNodes.length === 0) {
        // If ii === -1, then (bestContainer, bestOffset), which is equal to
        // (currentContainer, 0), was a single-line start point but a start
        // point before currentContainer wasn't, so the line break seems to
        // have occurred immediately after currentContainer's start tag
        //
        // If currentContainer.childNodes.length === 0, we're already at a
        // terminal node (e.g., text node) and should return our current best.
        break;
      }

      currentContainer = currentContainer.childNodes[ii];
      maxIndexToConsider = getNodeLength$1(currentContainer);
    } while (true);

    range.setStart(bestContainer, bestOffset);
    return range;
  }

  var expandRangeToStartOfLine_1 = expandRangeToStartOfLine;

  /**
   * Convert the current selection range to an anchor/focus pair of offset keys
   * and values that can be interpreted by components.
   */
  function getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {
    var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;
    var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;

    // If the selection range lies only on text nodes, the task is simple.
    // Find the nearest offset-aware elements and use the
    // offset values supplied by the selection range.
    if (anchorIsTextNode && focusIsTextNode) {
      return {
        selectionState: getUpdatedSelectionState_1(editorState, nullthrows_1(findAncestorOffsetKey_1(anchorNode)), anchorOffset, nullthrows_1(findAncestorOffsetKey_1(focusNode)), focusOffset),
        needsRecovery: false
      };
    }

    var anchorPoint = null;
    var focusPoint = null;
    var needsRecovery = true;

    // An element is selected. Convert this selection range into leaf offset
    // keys and offset values for consumption at the component level. This
    // is common in Firefox, where select-all and triple click behavior leads
    // to entire elements being selected.
    //
    // Note that we use the `needsRecovery` parameter in the callback here. This
    // is because when certain elements are selected, the behavior for subsequent
    // cursor movement (e.g. via arrow keys) is uncertain and may not match
    // expectations at the component level. For example, if an entire <div> is
    // selected and the user presses the right arrow, Firefox keeps the selection
    // on the <div>. If we allow subsequent keypresses to insert characters
    // natively, they will be inserted into a browser-created text node to the
    // right of that <div>. This is obviously undesirable.
    //
    // With the `needsRecovery` flag, we inform the caller that it is responsible
    // for manually setting the selection state on the rendered document to
    // ensure proper selection state maintenance.

    if (anchorIsTextNode) {
      anchorPoint = {
        key: nullthrows_1(findAncestorOffsetKey_1(anchorNode)),
        offset: anchorOffset
      };
      focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);
    } else if (focusIsTextNode) {
      focusPoint = {
        key: nullthrows_1(findAncestorOffsetKey_1(focusNode)),
        offset: focusOffset
      };
      anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);
    } else {
      anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);
      focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);

      // If the selection is collapsed on an empty block, don't force recovery.
      // This way, on arrow key selection changes, the browser can move the
      // cursor from a non-zero offset on one block, through empty blocks,
      // to a matching non-zero offset on other text blocks.
      if (anchorNode === focusNode && anchorOffset === focusOffset) {
        needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';
      }
    }

    return {
      selectionState: getUpdatedSelectionState_1(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),
      needsRecovery: needsRecovery
    };
  }

  /**
   * Identify the first leaf descendant for the given node.
   */
  function getFirstLeaf(node) {
    while (node.firstChild && (
    // data-blocks has no offset
    node.firstChild instanceof Element && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode_1(node.firstChild))) {
      node = node.firstChild;
    }
    return node;
  }

  /**
   * Identify the last leaf descendant for the given node.
   */
  function getLastLeaf(node) {
    while (node.lastChild && (
    // data-blocks has no offset
    node.lastChild instanceof Element && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode_1(node.lastChild))) {
      node = node.lastChild;
    }
    return node;
  }

  function getPointForNonTextNode(editorRoot, startNode, childOffset) {
    var node = startNode;
    var offsetKey = findAncestorOffsetKey_1(node);

    !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? invariant_1(false) : void 0;

    // If the editorRoot is the selection, step downward into the content
    // wrapper.
    if (editorRoot === node) {
      node = node.firstChild;
      !(node instanceof Element && node.getAttribute('data-contents') === 'true') ? invariant_1(false) : void 0;
      if (childOffset > 0) {
        childOffset = node.childNodes.length;
      }
    }

    // If the child offset is zero and we have an offset key, we're done.
    // If there's no offset key because the entire editor is selected,
    // find the leftmost ("first") leaf in the tree and use that as the offset
    // key.
    if (childOffset === 0) {
      var key = null;
      if (offsetKey != null) {
        key = offsetKey;
      } else {
        var firstLeaf = getFirstLeaf(node);
        key = nullthrows_1(getSelectionOffsetKeyForNode_1(firstLeaf));
      }
      return { key: key, offset: 0 };
    }

    var nodeBeforeCursor = node.childNodes[childOffset - 1];
    var leafKey = null;
    var textLength = null;

    if (!getSelectionOffsetKeyForNode_1(nodeBeforeCursor)) {
      // Our target node may be a leaf or a text node, in which case we're
      // already where we want to be and can just use the child's length as
      // our offset.
      leafKey = nullthrows_1(offsetKey);
      textLength = getTextContentLength(nodeBeforeCursor);
    } else {
      // Otherwise, we'll look at the child to the left of the cursor and find
      // the last leaf node in its subtree.
      var lastLeaf = getLastLeaf(nodeBeforeCursor);
      leafKey = nullthrows_1(getSelectionOffsetKeyForNode_1(lastLeaf));
      textLength = getTextContentLength(lastLeaf);
    }

    return {
      key: leafKey,
      offset: textLength
    };
  }

  /**
   * Return the length of a node's textContent, regarding single newline
   * characters as zero-length. This allows us to avoid problems with identifying
   * the correct selection offset for empty blocks in IE, in which we
   * render newlines instead of break tags.
   */
  function getTextContentLength(node) {
    var textContent = node.textContent;
    return textContent === '\n' ? 0 : textContent.length;
  }

  var getDraftEditorSelectionWithNodes_1 = getDraftEditorSelectionWithNodes;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule moveSelectionBackward
   * @format
   * 
   */

  /**
   * Given a collapsed selection, move the focus `maxDistance` backward within
   * the selected block. If the selection will go beyond the start of the block,
   * move focus to the end of the previous block, but no further.
   *
   * This function is not Unicode-aware, so surrogate pairs will be treated
   * as having length 2.
   */
  function moveSelectionBackward(editorState, maxDistance) {
    var selection = editorState.getSelection();
    var content = editorState.getCurrentContent();
    var key = selection.getStartKey();
    var offset = selection.getStartOffset();

    var focusKey = key;
    var focusOffset = 0;

    if (maxDistance > offset) {
      var keyBefore = content.getKeyBefore(key);
      if (keyBefore == null) {
        focusKey = key;
      } else {
        focusKey = keyBefore;
        var blockBefore = content.getBlockForKey(keyBefore);
        focusOffset = blockBefore.getText().length;
      }
    } else {
      focusOffset = offset - maxDistance;
    }

    return selection.merge({
      focusKey: focusKey,
      focusOffset: focusOffset,
      isBackward: true
    });
  }

  var moveSelectionBackward_1 = moveSelectionBackward;

  /**
   * For a collapsed selection state, remove text based on the specified strategy.
   * If the selection state is not collapsed, remove the entire selected range.
   */
  function removeTextWithStrategy(editorState, strategy, direction) {
    var selection = editorState.getSelection();
    var content = editorState.getCurrentContent();
    var target = selection;
    if (selection.isCollapsed()) {
      if (direction === 'forward') {
        if (editorState.isSelectionAtEndOfContent()) {
          return content;
        }
      } else if (editorState.isSelectionAtStartOfContent()) {
        return content;
      }

      target = strategy(editorState);
      if (target === selection) {
        return content;
      }
    }
    return DraftModifier_1.removeRange(content, target, direction);
  }

  var removeTextWithStrategy_1 = removeTextWithStrategy;

  function keyCommandBackspaceToStartOfLine(editorState) {
    var afterRemoval = removeTextWithStrategy_1(editorState, function (strategyState) {
      var selection = strategyState.getSelection();
      if (selection.isCollapsed() && selection.getAnchorOffset() === 0) {
        return moveSelectionBackward_1(strategyState, 1);
      }

      var domSelection = commonjsGlobal.getSelection();
      var range = domSelection.getRangeAt(0);
      range = expandRangeToStartOfLine_1(range);

      return getDraftEditorSelectionWithNodes_1(strategyState, null, range.endContainer, range.endOffset, range.startContainer, range.startOffset).selectionState;
    }, 'backward');

    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }

    return EditorState_1.push(editorState, afterRemoval, 'remove-range');
  }

  var keyCommandBackspaceToStartOfLine_1 = keyCommandBackspaceToStartOfLine;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @typechecks
   * @stub
   * 
   */

  // \u00a1-\u00b1\u00b4-\u00b8\u00ba\u00bb\u00bf
  //             is latin supplement punctuation except fractions and superscript
  //             numbers
  // \u2010-\u2027\u2030-\u205e
  //             is punctuation from the general punctuation block:
  //             weird quotes, commas, bullets, dashes, etc.
  // \u30fb\u3001\u3002\u3008-\u3011\u3014-\u301f
  //             is CJK punctuation
  // \uff1a-\uff1f\uff01-\uff0f\uff3b-\uff40\uff5b-\uff65
  //             is some full-width/half-width punctuation
  // \u2E2E\u061f\u066a-\u066c\u061b\u060c\u060d\uFD3e\uFD3F
  //             is some Arabic punctuation marks
  // \u1801\u0964\u104a\u104b
  //             is misc. other language punctuation marks

  var PUNCTUATION = '[.,+*?$|#{}()\'\\^\\-\\[\\]\\\\\\/!@%"~=<>_:;' + '\u30FB\u3001\u3002\u3008-\u3011\u3014-\u301F\uFF1A-\uFF1F\uFF01-\uFF0F' + '\uFF3B-\uFF40\uFF5B-\uFF65\u2E2E\u061F\u066A-\u066C\u061B\u060C\u060D' + '\uFD3E\uFD3F\u1801\u0964\u104A\u104B\u2010-\u2027\u2030-\u205E' + '\xA1-\xB1\xB4-\xB8\xBA\xBB\xBF]';

  var TokenizeUtil = {
    getPunctuation: function getPunctuation() {
      return PUNCTUATION;
    }
  };

  var punctuation = TokenizeUtil.getPunctuation();

  // The apostrophe and curly single quotes behave in a curious way: when
  // surrounded on both sides by word characters, they behave as word chars; when
  // either neighbor is punctuation or an end of the string, they behave as
  // punctuation.
  var CHAMELEON_CHARS = '[\'\u2018\u2019]';

  // Remove the underscore, which should count as part of the removable word. The
  // "chameleon chars" also count as punctuation in this regex.
  var WHITESPACE_AND_PUNCTUATION = '\\s|(?![_])' + punctuation;

  var DELETE_STRING = '^' + '(?:' + WHITESPACE_AND_PUNCTUATION + ')*' + '(?:' + CHAMELEON_CHARS + '|(?!' + WHITESPACE_AND_PUNCTUATION + ').)*' + '(?:(?!' + WHITESPACE_AND_PUNCTUATION + ').)';
  var DELETE_REGEX = new RegExp(DELETE_STRING);

  var BACKSPACE_STRING = '(?:(?!' + WHITESPACE_AND_PUNCTUATION + ').)' + '(?:' + CHAMELEON_CHARS + '|(?!' + WHITESPACE_AND_PUNCTUATION + ').)*' + '(?:' + WHITESPACE_AND_PUNCTUATION + ')*' + '$';
  var BACKSPACE_REGEX = new RegExp(BACKSPACE_STRING);

  function getRemovableWord(text, isBackward) {
    var matches = isBackward ? BACKSPACE_REGEX.exec(text) : DELETE_REGEX.exec(text);
    return matches ? matches[0] : text;
  }

  var DraftRemovableWord = {
    getBackward: function getBackward(text) {
      return getRemovableWord(text, true);
    },

    getForward: function getForward(text) {
      return getRemovableWord(text, false);
    }
  };

  var DraftRemovableWord_1 = DraftRemovableWord;

  /**
   * Delete the word that is left of the cursor, as well as any spaces or
   * punctuation after the word.
   */
  function keyCommandBackspaceWord(editorState) {
    var afterRemoval = removeTextWithStrategy_1(editorState, function (strategyState) {
      var selection = strategyState.getSelection();
      var offset = selection.getStartOffset();
      // If there are no words before the cursor, remove the preceding newline.
      if (offset === 0) {
        return moveSelectionBackward_1(strategyState, 1);
      }
      var key = selection.getStartKey();
      var content = strategyState.getCurrentContent();
      var text = content.getBlockForKey(key).getText().slice(0, offset);
      var toRemove = DraftRemovableWord_1.getBackward(text);
      return moveSelectionBackward_1(strategyState, toRemove.length || 1);
    }, 'backward');

    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }

    return EditorState_1.push(editorState, afterRemoval, 'remove-range');
  }

  var keyCommandBackspaceWord_1 = keyCommandBackspaceWord;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule moveSelectionForward
   * @format
   * 
   */

  /**
   * Given a collapsed selection, move the focus `maxDistance` forward within
   * the selected block. If the selection will go beyond the end of the block,
   * move focus to the start of the next block, but no further.
   *
   * This function is not Unicode-aware, so surrogate pairs will be treated
   * as having length 2.
   */
  function moveSelectionForward(editorState, maxDistance) {
    var selection = editorState.getSelection();
    var key = selection.getStartKey();
    var offset = selection.getStartOffset();
    var content = editorState.getCurrentContent();

    var focusKey = key;
    var focusOffset;

    var block = content.getBlockForKey(key);

    if (maxDistance > block.getText().length - offset) {
      focusKey = content.getKeyAfter(key);
      focusOffset = 0;
    } else {
      focusOffset = offset + maxDistance;
    }

    return selection.merge({ focusKey: focusKey, focusOffset: focusOffset });
  }

  var moveSelectionForward_1 = moveSelectionForward;

  /**
   * Delete the word that is right of the cursor, as well as any spaces or
   * punctuation before the word.
   */
  function keyCommandDeleteWord(editorState) {
    var afterRemoval = removeTextWithStrategy_1(editorState, function (strategyState) {
      var selection = strategyState.getSelection();
      var offset = selection.getStartOffset();
      var key = selection.getStartKey();
      var content = strategyState.getCurrentContent();
      var text = content.getBlockForKey(key).getText().slice(offset);
      var toRemove = DraftRemovableWord_1.getForward(text);

      // If there are no words in front of the cursor, remove the newline.
      return moveSelectionForward_1(strategyState, toRemove.length || 1);
    }, 'forward');

    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }

    return EditorState_1.push(editorState, afterRemoval, 'remove-range');
  }

  var keyCommandDeleteWord_1 = keyCommandDeleteWord;

  function keyCommandInsertNewline(editorState) {
    var contentState = DraftModifier_1.splitBlock(editorState.getCurrentContent(), editorState.getSelection());
    return EditorState_1.push(editorState, contentState, 'split-block');
  }

  var keyCommandInsertNewline_1 = keyCommandInsertNewline;

  /**
   * See comment for `moveSelectionToStartOfBlock`.
   */
  function keyCommandMoveSelectionToEndOfBlock(editorState) {
    var selection = editorState.getSelection();
    var endKey = selection.getEndKey();
    var content = editorState.getCurrentContent();
    var textLength = content.getBlockForKey(endKey).getLength();
    return EditorState_1.set(editorState, {
      selection: selection.merge({
        anchorKey: endKey,
        anchorOffset: textLength,
        focusKey: endKey,
        focusOffset: textLength,
        isBackward: false
      }),
      forceSelection: true
    });
  }

  var keyCommandMoveSelectionToEndOfBlock_1 = keyCommandMoveSelectionToEndOfBlock;

  /**
   * Collapse selection at the start of the first selected block. This is used
   * for Firefox versions that attempt to navigate forward/backward instead of
   * moving the cursor. Other browsers are able to move the cursor natively.
   */
  function keyCommandMoveSelectionToStartOfBlock(editorState) {
    var selection = editorState.getSelection();
    var startKey = selection.getStartKey();
    return EditorState_1.set(editorState, {
      selection: selection.merge({
        anchorKey: startKey,
        anchorOffset: 0,
        focusKey: startKey,
        focusOffset: 0,
        isBackward: false
      }),
      forceSelection: true
    });
  }

  var keyCommandMoveSelectionToStartOfBlock_1 = keyCommandMoveSelectionToStartOfBlock;

  /**
   * Remove the selected range. If the cursor is collapsed, remove the preceding
   * character. This operation is Unicode-aware, so removing a single character
   * will remove a surrogate pair properly as well.
   */
  function keyCommandPlainBackspace(editorState) {
    var afterRemoval = removeTextWithStrategy_1(editorState, function (strategyState) {
      var selection = strategyState.getSelection();
      var content = strategyState.getCurrentContent();
      var key = selection.getAnchorKey();
      var offset = selection.getAnchorOffset();
      var charBehind = content.getBlockForKey(key).getText()[offset - 1];
      return moveSelectionBackward_1(strategyState, charBehind ? UnicodeUtils_1.getUTF16Length(charBehind, 0) : 1);
    }, 'backward');

    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }

    var selection = editorState.getSelection();
    return EditorState_1.push(editorState, afterRemoval.set('selectionBefore', selection), selection.isCollapsed() ? 'backspace-character' : 'remove-range');
  }

  var keyCommandPlainBackspace_1 = keyCommandPlainBackspace;

  /**
   * Remove the selected range. If the cursor is collapsed, remove the following
   * character. This operation is Unicode-aware, so removing a single character
   * will remove a surrogate pair properly as well.
   */
  function keyCommandPlainDelete(editorState) {
    var afterRemoval = removeTextWithStrategy_1(editorState, function (strategyState) {
      var selection = strategyState.getSelection();
      var content = strategyState.getCurrentContent();
      var key = selection.getAnchorKey();
      var offset = selection.getAnchorOffset();
      var charAhead = content.getBlockForKey(key).getText()[offset];
      return moveSelectionForward_1(strategyState, charAhead ? UnicodeUtils_1.getUTF16Length(charAhead, 0) : 1);
    }, 'forward');

    if (afterRemoval === editorState.getCurrentContent()) {
      return editorState;
    }

    var selection = editorState.getSelection();

    return EditorState_1.push(editorState, afterRemoval.set('selectionBefore', selection), selection.isCollapsed() ? 'delete-character' : 'remove-range');
  }

  var keyCommandPlainDelete_1 = keyCommandPlainDelete;

  /**
   * Transpose the characters on either side of a collapsed cursor, or
   * if the cursor is at the end of the block, transpose the last two
   * characters.
   */
  function keyCommandTransposeCharacters(editorState) {
    var selection = editorState.getSelection();
    if (!selection.isCollapsed()) {
      return editorState;
    }

    var offset = selection.getAnchorOffset();
    if (offset === 0) {
      return editorState;
    }

    var blockKey = selection.getAnchorKey();
    var content = editorState.getCurrentContent();
    var block = content.getBlockForKey(blockKey);
    var length = block.getLength();

    // Nothing to transpose if there aren't two characters.
    if (length <= 1) {
      return editorState;
    }

    var removalRange;
    var finalSelection;

    if (offset === length) {
      // The cursor is at the end of the block. Swap the last two characters.
      removalRange = selection.set('anchorOffset', offset - 1);
      finalSelection = selection;
    } else {
      removalRange = selection.set('focusOffset', offset + 1);
      finalSelection = removalRange.set('anchorOffset', offset + 1);
    }

    // Extract the character to move as a fragment. This preserves its
    // styling and entity, if any.
    var movedFragment = getContentStateFragment_1(content, removalRange);
    var afterRemoval = DraftModifier_1.removeRange(content, removalRange, 'backward');

    // After the removal, the insertion target is one character back.
    var selectionAfter = afterRemoval.getSelectionAfter();
    var targetOffset = selectionAfter.getAnchorOffset() - 1;
    var targetRange = selectionAfter.merge({
      anchorOffset: targetOffset,
      focusOffset: targetOffset
    });

    var afterInsert = DraftModifier_1.replaceWithFragment(afterRemoval, targetRange, movedFragment);

    var newEditorState = EditorState_1.push(editorState, afterInsert, 'insert-fragment');

    return EditorState_1.acceptSelection(newEditorState, finalSelection);
  }

  var keyCommandTransposeCharacters_1 = keyCommandTransposeCharacters;

  function keyCommandUndo(e, editorState, updateFn) {
    var undoneState = EditorState_1.undo(editorState);

    // If the last change to occur was a spellcheck change, allow the undo
    // event to fall through to the browser. This allows the browser to record
    // the unwanted change, which should soon lead it to learn not to suggest
    // the correction again.
    if (editorState.getLastChangeType() === 'spellcheck-change') {
      var nativelyRenderedContent = undoneState.getCurrentContent();
      updateFn(EditorState_1.set(undoneState, { nativelyRenderedContent: nativelyRenderedContent }));
      return;
    }

    // Otheriwse, manage the undo behavior manually.
    e.preventDefault();
    if (!editorState.getNativelyRenderedContent()) {
      updateFn(undoneState);
      return;
    }

    // Trigger a re-render with the current content state to ensure that the
    // component tree has up-to-date props for comparison.
    updateFn(EditorState_1.set(editorState, { nativelyRenderedContent: null }));

    // Wait to ensure that the re-render has occurred before performing
    // the undo action.
    setTimeout(function () {
      updateFn(undoneState);
    }, 0);
  }

  var keyCommandUndo_1 = keyCommandUndo;

  var isOptionKeyCommand = KeyBindingUtil_1.isOptionKeyCommand;

  var isChrome$1 = UserAgent_1.isBrowser('Chrome');

  /**
   * Map a `DraftEditorCommand` command value to a corresponding function.
   */
  function onKeyCommand(command, editorState) {
    switch (command) {
      case 'redo':
        return EditorState_1.redo(editorState);
      case 'delete':
        return keyCommandPlainDelete_1(editorState);
      case 'delete-word':
        return keyCommandDeleteWord_1(editorState);
      case 'backspace':
        return keyCommandPlainBackspace_1(editorState);
      case 'backspace-word':
        return keyCommandBackspaceWord_1(editorState);
      case 'backspace-to-start-of-line':
        return keyCommandBackspaceToStartOfLine_1(editorState);
      case 'split-block':
        return keyCommandInsertNewline_1(editorState);
      case 'transpose-characters':
        return keyCommandTransposeCharacters_1(editorState);
      case 'move-selection-to-start-of-block':
        return keyCommandMoveSelectionToStartOfBlock_1(editorState);
      case 'move-selection-to-end-of-block':
        return keyCommandMoveSelectionToEndOfBlock_1(editorState);
      case 'secondary-cut':
        return SecondaryClipboard_1.cut(editorState);
      case 'secondary-paste':
        return SecondaryClipboard_1.paste(editorState);
      default:
        return editorState;
    }
  }

  /**
   * Intercept keydown behavior to handle keys and commands manually, if desired.
   *
   * Keydown combinations may be mapped to `DraftCommand` values, which may
   * correspond to command functions that modify the editor or its contents.
   *
   * See `getDefaultKeyBinding` for defaults. Alternatively, the top-level
   * component may provide a custom mapping via the `keyBindingFn` prop.
   */
  function editOnKeyDown(editor, e) {
    var keyCode = e.which;
    var editorState = editor._latestEditorState;

    switch (keyCode) {
      case Keys.RETURN:
        e.preventDefault();
        // The top-level component may manually handle newline insertion. If
        // no special handling is performed, fall through to command handling.
        if (editor.props.handleReturn && isEventHandled_1(editor.props.handleReturn(e, editorState))) {
          return;
        }
        break;
      case Keys.ESC:
        e.preventDefault();
        editor.props.onEscape && editor.props.onEscape(e);
        return;
      case Keys.TAB:
        editor.props.onTab && editor.props.onTab(e);
        return;
      case Keys.UP:
        editor.props.onUpArrow && editor.props.onUpArrow(e);
        return;
      case Keys.RIGHT:
        editor.props.onRightArrow && editor.props.onRightArrow(e);
        return;
      case Keys.DOWN:
        editor.props.onDownArrow && editor.props.onDownArrow(e);
        return;
      case Keys.LEFT:
        editor.props.onLeftArrow && editor.props.onLeftArrow(e);
        return;
      case Keys.SPACE:
        // Handling for OSX where option + space scrolls.
        if (isChrome$1 && isOptionKeyCommand(e)) {
          e.preventDefault();
          // Insert a nbsp into the editor.
          var contentState = DraftModifier_1.replaceText(editorState.getCurrentContent(), editorState.getSelection(), '\xA0');
          editor.update(EditorState_1.push(editorState, contentState, 'insert-characters'));
          return;
        }
    }

    var command = editor.props.keyBindingFn(e);

    // If no command is specified, allow keydown event to continue.
    if (!command) {
      return;
    }

    if (command === 'undo') {
      // Since undo requires some special updating behavior to keep the editor
      // in sync, handle it separately.
      keyCommandUndo_1(e, editorState, editor.update);
      return;
    }

    // At this point, we know that we're handling a command of some kind, so
    // we don't want to insert a character following the keydown.
    e.preventDefault();

    // Allow components higher up the tree to handle the command first.
    if (editor.props.handleKeyCommand && isEventHandled_1(editor.props.handleKeyCommand(command, editorState))) {
      return;
    }

    var newState = onKeyCommand(command, editorState);
    if (newState !== editorState) {
      editor.update(newState);
    }
  }

  var editOnKeyDown_1 = editOnKeyDown;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function _classCallCheck$f(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var URI = function () {
    function URI(uri) {
      _classCallCheck$f(this, URI);

      this._uri = uri;
    }

    URI.prototype.toString = function toString() {
      return this._uri;
    };

    return URI;
  }();

  var URI_1 = URI;

  var isOldIE = UserAgent_1.isBrowser('IE <= 9');

  // Provides a dom node that will not execute scripts
  // https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation.createHTMLDocument
  // https://developer.mozilla.org/en-US/Add-ons/Code_snippets/HTML_to_DOM

  function getSafeBodyFromHTML(html) {
    var doc;
    var root = null;
    // Provides a safe context
    if (!isOldIE && document.implementation && document.implementation.createHTMLDocument) {
      doc = document.implementation.createHTMLDocument('foo');
      !doc.documentElement ? invariant_1(false) : void 0;
      doc.documentElement.innerHTML = html;
      root = doc.getElementsByTagName('body')[0];
    }
    return root;
  }

  var getSafeBodyFromHTML_1 = getSafeBodyFromHTML;

  var _extends$4 = objectAssign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _knownListItemDepthCl;

  function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









  var _require = immutable,
      Set$1 = _require.Set;









  var experimentalTreeDataSupport = DraftFeatureFlags_1.draft_tree_data_support;

  var List$a = immutable.List,
      OrderedSet$5 = immutable.OrderedSet;


  var NBSP = '&nbsp;';
  var SPACE = ' ';

  // Arbitrary max indent
  var MAX_DEPTH = 4;

  // used for replacing characters in HTML
  var REGEX_CR = new RegExp('\r', 'g');
  var REGEX_LF = new RegExp('\n', 'g');
  var REGEX_NBSP = new RegExp(NBSP, 'g');
  var REGEX_CARRIAGE = new RegExp('&#13;?', 'g');
  var REGEX_ZWS = new RegExp('&#8203;?', 'g');

  // https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight
  var boldValues = ['bold', 'bolder', '500', '600', '700', '800', '900'];
  var notBoldValues = ['light', 'lighter', '100', '200', '300', '400'];

  // Block tag flow is different because LIs do not have
  // a deterministic style ;_;
  var inlineTags = {
    b: 'BOLD',
    code: 'CODE',
    del: 'STRIKETHROUGH',
    em: 'ITALIC',
    i: 'ITALIC',
    s: 'STRIKETHROUGH',
    strike: 'STRIKETHROUGH',
    strong: 'BOLD',
    u: 'UNDERLINE'
  };

  var knownListItemDepthClasses = (_knownListItemDepthCl = {}, _defineProperty$1(_knownListItemDepthCl, cx_1('public/DraftStyleDefault/depth0'), 0), _defineProperty$1(_knownListItemDepthCl, cx_1('public/DraftStyleDefault/depth1'), 1), _defineProperty$1(_knownListItemDepthCl, cx_1('public/DraftStyleDefault/depth2'), 2), _defineProperty$1(_knownListItemDepthCl, cx_1('public/DraftStyleDefault/depth3'), 3), _defineProperty$1(_knownListItemDepthCl, cx_1('public/DraftStyleDefault/depth4'), 4), _knownListItemDepthCl);

  var anchorAttr = ['className', 'href', 'rel', 'target', 'title'];

  var imgAttr = ['alt', 'className', 'height', 'src', 'width'];

  var lastBlock = void 0;

  var EMPTY_CHUNK = {
    text: '',
    inlines: [],
    entities: [],
    blocks: []
  };

  var EMPTY_BLOCK = {
    children: List$a(),
    depth: 0,
    key: '',
    type: ''
  };

  var getListBlockType = function getListBlockType(tag, lastList) {
    if (tag === 'li') {
      return lastList === 'ol' ? 'ordered-list-item' : 'unordered-list-item';
    }
    return null;
  };

  var getBlockMapSupportedTags = function getBlockMapSupportedTags(blockRenderMap) {
    var unstyledElement = blockRenderMap.get('unstyled').element;
    var tags = Set$1([]);

    blockRenderMap.forEach(function (draftBlock) {
      if (draftBlock.aliasedElements) {
        draftBlock.aliasedElements.forEach(function (tag) {
          tags = tags.add(tag);
        });
      }

      tags = tags.add(draftBlock.element);
    });

    return tags.filter(function (tag) {
      return tag && tag !== unstyledElement;
    }).toArray().sort();
  };

  // custom element conversions
  var getMultiMatchedType = function getMultiMatchedType(tag, lastList, multiMatchExtractor) {
    for (var ii = 0; ii < multiMatchExtractor.length; ii++) {
      var matchType = multiMatchExtractor[ii](tag, lastList);
      if (matchType) {
        return matchType;
      }
    }
    return null;
  };

  var getBlockTypeForTag = function getBlockTypeForTag(tag, lastList, blockRenderMap) {
    var matchedTypes = blockRenderMap.filter(function (draftBlock) {
      return draftBlock.element === tag || draftBlock.wrapper === tag || draftBlock.aliasedElements && draftBlock.aliasedElements.some(function (alias) {
        return alias === tag;
      });
    }).keySeq().toSet().toArray().sort();

    // if we dont have any matched type, return unstyled
    // if we have one matched type return it
    // if we have multi matched types use the multi-match function to gather type
    switch (matchedTypes.length) {
      case 0:
        return 'unstyled';
      case 1:
        return matchedTypes[0];
      default:
        return getMultiMatchedType(tag, lastList, [getListBlockType]) || 'unstyled';
    }
  };

  var processInlineTag = function processInlineTag(tag, node, currentStyle) {
    var styleToCheck = inlineTags[tag];
    if (styleToCheck) {
      currentStyle = currentStyle.add(styleToCheck).toOrderedSet();
    } else if (node instanceof HTMLElement) {
      var htmlElement = node;
      currentStyle = currentStyle.withMutations(function (style) {
        var fontWeight = htmlElement.style.fontWeight;
        var fontStyle = htmlElement.style.fontStyle;
        var textDecoration = htmlElement.style.textDecoration;

        if (boldValues.indexOf(fontWeight) >= 0) {
          style.add('BOLD');
        } else if (notBoldValues.indexOf(fontWeight) >= 0) {
          style.remove('BOLD');
        }

        if (fontStyle === 'italic') {
          style.add('ITALIC');
        } else if (fontStyle === 'normal') {
          style.remove('ITALIC');
        }

        if (textDecoration === 'underline') {
          style.add('UNDERLINE');
        }
        if (textDecoration === 'line-through') {
          style.add('STRIKETHROUGH');
        }
        if (textDecoration === 'none') {
          style.remove('UNDERLINE');
          style.remove('STRIKETHROUGH');
        }
      }).toOrderedSet();
    }
    return currentStyle;
  };

  var joinChunks = function joinChunks(A, B, experimentalHasNestedBlocks) {
    // Sometimes two blocks will touch in the DOM and we need to strip the
    // extra delimiter to preserve niceness.
    var lastInA = A.text.slice(-1);
    var firstInB = B.text.slice(0, 1);

    if (lastInA === '\r' && firstInB === '\r' && !experimentalHasNestedBlocks) {
      A.text = A.text.slice(0, -1);
      A.inlines.pop();
      A.entities.pop();
      A.blocks.pop();
    }

    // Kill whitespace after blocks
    if (lastInA === '\r') {
      if (B.text === SPACE || B.text === '\n') {
        return A;
      } else if (firstInB === SPACE || firstInB === '\n') {
        B.text = B.text.slice(1);
        B.inlines.shift();
        B.entities.shift();
      }
    }

    return {
      text: A.text + B.text,
      inlines: A.inlines.concat(B.inlines),
      entities: A.entities.concat(B.entities),
      blocks: A.blocks.concat(B.blocks)
    };
  };

  /**
   * Check to see if we have anything like <p> <blockquote> <h1>... to create
   * block tags from. If we do, we can use those and ignore <div> tags. If we
   * don't, we can treat <div> tags as meaningful (unstyled) blocks.
   */
  var containsSemanticBlockMarkup = function containsSemanticBlockMarkup(html, blockTags) {
    return blockTags.some(function (tag) {
      return html.indexOf('<' + tag) !== -1;
    });
  };

  var hasValidLinkText = function hasValidLinkText(link) {
    !(link instanceof HTMLAnchorElement) ? invariant_1(false) : void 0;
    var protocol = link.protocol;
    return protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:';
  };

  var getWhitespaceChunk = function getWhitespaceChunk(inEntity) {
    var entities = new Array(1);
    if (inEntity) {
      entities[0] = inEntity;
    }
    return _extends$4({}, EMPTY_CHUNK, {
      text: SPACE,
      inlines: [OrderedSet$5()],
      entities: entities
    });
  };

  var getSoftNewlineChunk = function getSoftNewlineChunk() {
    return _extends$4({}, EMPTY_CHUNK, {
      text: '\n',
      inlines: [OrderedSet$5()],
      entities: new Array(1)
    });
  };

  var getChunkedBlock = function getChunkedBlock() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return _extends$4({}, EMPTY_BLOCK, props);
  };

  var getBlockDividerChunk = function getBlockDividerChunk(block, depth) {
    var parentKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    return {
      text: '\r',
      inlines: [OrderedSet$5()],
      entities: new Array(1),
      blocks: [getChunkedBlock({
        parent: parentKey,
        key: generateRandomKey_1(),
        type: block,
        depth: Math.max(0, Math.min(MAX_DEPTH, depth))
      })]
    };
  };

  /**
   *  If we're pasting from one DraftEditor to another we can check to see if
   *  existing list item depth classes are being used and preserve this style
   */
  var getListItemDepth = function getListItemDepth(node) {
    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    Object.keys(knownListItemDepthClasses).some(function (depthClass) {
      if (node.classList.contains(depthClass)) {
        depth = knownListItemDepthClasses[depthClass];
      }
    });
    return depth;
  };

  var genFragment = function genFragment(entityMap, node, inlineStyle, lastList, inBlock, blockTags, depth, blockRenderMap, inEntity, parentKey) {
    var lastLastBlock = lastBlock;
    var nodeName = node.nodeName.toLowerCase();
    var newEntityMap = entityMap;
    var nextBlockType = 'unstyled';
    var newBlock = false;
    var inBlockType = inBlock && getBlockTypeForTag(inBlock, lastList, blockRenderMap);
    var chunk = _extends$4({}, EMPTY_CHUNK);
    var newChunk = null;
    var blockKey = void 0;

    // Base Case
    if (nodeName === '#text') {
      var _text = node.textContent;
      var nodeTextContent = _text.trim();

      // We should not create blocks for leading spaces that are
      // existing around ol/ul and their children list items
      if (lastList && nodeTextContent === '' && node.parentElement) {
        var parentNodeName = node.parentElement.nodeName.toLowerCase();
        if (parentNodeName === 'ol' || parentNodeName === 'ul') {
          return { chunk: _extends$4({}, EMPTY_CHUNK), entityMap: entityMap };
        }
      }

      if (nodeTextContent === '' && inBlock !== 'pre') {
        return { chunk: getWhitespaceChunk(inEntity), entityMap: entityMap };
      }
      if (inBlock !== 'pre') {
        // Can't use empty string because MSWord
        _text = _text.replace(REGEX_LF, SPACE);
      }

      // save the last block so we can use it later
      lastBlock = nodeName;

      return {
        chunk: {
          text: _text,
          inlines: Array(_text.length).fill(inlineStyle),
          entities: Array(_text.length).fill(inEntity),
          blocks: []
        },
        entityMap: entityMap
      };
    }

    // save the last block so we can use it later
    lastBlock = nodeName;

    // BR tags
    if (nodeName === 'br') {
      if (lastLastBlock === 'br' && (!inBlock || inBlockType === 'unstyled')) {
        return {
          chunk: getBlockDividerChunk('unstyled', depth, parentKey),
          entityMap: entityMap
        };
      }
      return { chunk: getSoftNewlineChunk(), entityMap: entityMap };
    }

    // IMG tags
    if (nodeName === 'img' && node instanceof HTMLImageElement && node.attributes.getNamedItem('src') && node.attributes.getNamedItem('src').value) {
      var image = node;
      var entityConfig = {};

      imgAttr.forEach(function (attr) {
        var imageAttribute = image.getAttribute(attr);
        if (imageAttribute) {
          entityConfig[attr] = imageAttribute;
        }
      });
      // Forcing this node to have children because otherwise no entity will be
      // created for this node.
      // The child text node cannot just have a space or return as content -
      // we strip those out.
      // See https://github.com/facebook/draft-js/issues/231 for some context.
      node.textContent = '\uD83D\uDCF7';

      // TODO: update this when we remove DraftEntity entirely
      inEntity = DraftEntity_1.__create('IMAGE', 'MUTABLE', entityConfig || {});
    }

    // Inline tags
    inlineStyle = processInlineTag(nodeName, node, inlineStyle);

    // Handle lists
    if (nodeName === 'ul' || nodeName === 'ol') {
      if (lastList) {
        depth += 1;
      }
      lastList = nodeName;
    }

    if (nodeName === 'li' && node instanceof HTMLElement) {
      depth = getListItemDepth(node, depth);
    }

    var blockType = getBlockTypeForTag(nodeName, lastList, blockRenderMap);
    var inListBlock = lastList && inBlock === 'li' && nodeName === 'li';
    var inBlockOrHasNestedBlocks = (!inBlock || experimentalTreeDataSupport) && blockTags.indexOf(nodeName) !== -1;

    // Block Tags
    if (inListBlock || inBlockOrHasNestedBlocks) {
      chunk = getBlockDividerChunk(blockType, depth, parentKey);
      blockKey = chunk.blocks[0].key;
      inBlock = nodeName;
      newBlock = !experimentalTreeDataSupport;
    }

    // this is required so that we can handle 'ul' and 'ol'
    if (inListBlock) {
      nextBlockType = lastList === 'ul' ? 'unordered-list-item' : 'ordered-list-item';
    }

    // Recurse through children
    var child = node.firstChild;
    if (child != null) {
      nodeName = child.nodeName.toLowerCase();
    }

    var entityId = null;

    while (child) {
      if (child instanceof HTMLAnchorElement && child.href && hasValidLinkText(child)) {
        (function () {
          var anchor = child;
          var entityConfig = {};

          anchorAttr.forEach(function (attr) {
            var anchorAttribute = anchor.getAttribute(attr);
            if (anchorAttribute) {
              entityConfig[attr] = anchorAttribute;
            }
          });

          entityConfig.url = new URI_1(anchor.href).toString();
          // TODO: update this when we remove DraftEntity completely
          entityId = DraftEntity_1.__create('LINK', 'MUTABLE', entityConfig || {});
        })();
      } else {
        entityId = undefined;
      }

      var _genFragment = genFragment(newEntityMap, child, inlineStyle, lastList, inBlock, blockTags, depth, blockRenderMap, entityId || inEntity, null),
          generatedChunk = _genFragment.chunk,
          maybeUpdatedEntityMap = _genFragment.entityMap;

      newChunk = generatedChunk;
      newEntityMap = maybeUpdatedEntityMap;

      chunk = joinChunks(chunk, newChunk, experimentalTreeDataSupport);
      var sibling = child.nextSibling;

      // Put in a newline to break up blocks inside blocks
      if (!parentKey && sibling && blockTags.indexOf(nodeName) >= 0 && inBlock) {
        chunk = joinChunks(chunk, getSoftNewlineChunk());
      }
      if (sibling) {
        nodeName = sibling.nodeName.toLowerCase();
      }
      child = sibling;
    }

    if (newBlock) {
      chunk = joinChunks(chunk, getBlockDividerChunk(nextBlockType, depth, parentKey));
    }

    return { chunk: chunk, entityMap: newEntityMap };
  };

  var getChunkForHTML = function getChunkForHTML(html, DOMBuilder, blockRenderMap, entityMap) {
    html = html.trim().replace(REGEX_CR, '').replace(REGEX_NBSP, SPACE).replace(REGEX_CARRIAGE, '').replace(REGEX_ZWS, '');

    var supportedBlockTags = getBlockMapSupportedTags(blockRenderMap);

    var safeBody = DOMBuilder(html);
    if (!safeBody) {
      return null;
    }
    lastBlock = null;

    // Sometimes we aren't dealing with content that contains nice semantic
    // tags. In this case, use divs to separate everything out into paragraphs
    // and hope for the best.
    var workingBlocks = containsSemanticBlockMarkup(html, supportedBlockTags) ? supportedBlockTags : ['div'];

    // Start with -1 block depth to offset the fact that we are passing in a fake
    // UL block to start with.
    var fragment = genFragment(entityMap, safeBody, OrderedSet$5(), 'ul', null, workingBlocks, -1, blockRenderMap);

    var chunk = fragment.chunk;
    var newEntityMap = fragment.entityMap;

    // join with previous block to prevent weirdness on paste
    if (chunk.text.indexOf('\r') === 0) {
      chunk = {
        text: chunk.text.slice(1),
        inlines: chunk.inlines.slice(1),
        entities: chunk.entities.slice(1),
        blocks: chunk.blocks
      };
    }

    // Kill block delimiter at the end
    if (chunk.text.slice(-1) === '\r') {
      chunk.text = chunk.text.slice(0, -1);
      chunk.inlines = chunk.inlines.slice(0, -1);
      chunk.entities = chunk.entities.slice(0, -1);
      chunk.blocks.pop();
    }

    // If we saw no block tags, put an unstyled one in
    if (chunk.blocks.length === 0) {
      chunk.blocks.push(_extends$4({}, EMPTY_CHUNK, {
        type: 'unstyled',
        depth: 0
      }));
    }

    // Sometimes we start with text that isn't in a block, which is then
    // followed by blocks. Need to fix up the blocks to add in
    // an unstyled block for this content
    if (chunk.text.split('\r').length === chunk.blocks.length + 1) {
      chunk.blocks.unshift({ type: 'unstyled', depth: 0 });
    }

    return { chunk: chunk, entityMap: newEntityMap };
  };

  var convertChunkToContentBlocks = function convertChunkToContentBlocks(chunk) {
    if (!chunk || !chunk.text || !Array.isArray(chunk.blocks)) {
      return null;
    }

    var initialState = {
      cacheRef: {},
      contentBlocks: []
    };

    var start = 0;

    var rawBlocks = chunk.blocks,
        rawInlines = chunk.inlines,
        rawEntities = chunk.entities;


    var BlockNodeRecord = ContentBlock_1;

    return chunk.text.split('\r').reduce(function (acc, textBlock, index) {
      // Make absolutely certain that our text is acceptable.
      textBlock = sanitizeDraftText_1(textBlock);

      var block = rawBlocks[index];
      var end = start + textBlock.length;
      var inlines = rawInlines.slice(start, end);
      var entities = rawEntities.slice(start, end);
      var characterList = List$a(inlines.map(function (style, index) {
        var data = { style: style, entity: null };
        if (entities[index]) {
          data.entity = entities[index];
        }
        return CharacterMetadata_1.create(data);
      }));
      start = end + 1;

      var depth = block.depth,
          type = block.type,
          parent = block.parent;


      var key = block.key || generateRandomKey_1();
      var parentTextNodeKey = null; // will be used to store container text nodes

      // childrens add themselves to their parents since we are iterating in order
      if (parent) {
        var parentIndex = acc.cacheRef[parent];
        var parentRecord = acc.contentBlocks[parentIndex];

        // if parent has text we need to split it into a separate unstyled element
        if (parentRecord.getChildKeys().isEmpty() && parentRecord.getText()) {
          var parentCharacterList = parentRecord.getCharacterList();
          var parentText = parentRecord.getText();
          parentTextNodeKey = generateRandomKey_1();

          var textNode = new ContentBlockNode_1({
            key: parentTextNodeKey,
            text: parentText,
            characterList: parentCharacterList,
            parent: parent,
            nextSibling: key
          });

          acc.contentBlocks.push(textNode);

          parentRecord = parentRecord.withMutations(function (block) {
            block.set('characterList', List$a()).set('text', '').set('children', parentRecord.children.push(textNode.getKey()));
          });
        }

        acc.contentBlocks[parentIndex] = parentRecord.set('children', parentRecord.children.push(key));
      }

      var blockNode = new BlockNodeRecord({
        key: key,
        parent: parent,
        type: type,
        depth: depth,
        text: textBlock,
        characterList: characterList,
        prevSibling: parentTextNodeKey || (index === 0 || rawBlocks[index - 1].parent !== parent ? null : rawBlocks[index - 1].key),
        nextSibling: index === rawBlocks.length - 1 || rawBlocks[index + 1].parent !== parent ? null : rawBlocks[index + 1].key
      });

      // insert node
      acc.contentBlocks.push(blockNode);

      // cache ref for building links
      acc.cacheRef[blockNode.key] = index;

      return acc;
    }, initialState).contentBlocks;
  };

  var convertFromHTMLtoContentBlocks = function convertFromHTMLtoContentBlocks(html) {
    var DOMBuilder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getSafeBodyFromHTML_1;
    var blockRenderMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultDraftBlockRenderMap_1;

    // Be ABSOLUTELY SURE that the dom builder you pass here won't execute
    // arbitrary code in whatever environment you're running this in. For an
    // example of how we try to do this in-browser, see getSafeBodyFromHTML.

    // TODO: replace DraftEntity with an OrderedMap here
    var chunkData = getChunkForHTML(html, DOMBuilder, blockRenderMap, DraftEntity_1);

    if (chunkData == null) {
      return null;
    }

    var chunk = chunkData.chunk,
        entityMap = chunkData.entityMap;

    var contentBlocks = convertChunkToContentBlocks(chunk);

    return {
      contentBlocks: contentBlocks,
      entityMap: entityMap
    };
  };

  var convertFromHTMLToContentBlocks = convertFromHTMLtoContentBlocks;

  var List$b = immutable.List,
      Repeat$6 = immutable.Repeat;
  var ContentBlockRecord$2 = ContentBlock_1;

  var DraftPasteProcessor = {
    processHTML: function processHTML(html, blockRenderMap) {
      return convertFromHTMLToContentBlocks(html, getSafeBodyFromHTML_1, blockRenderMap);
    },
    processText: function processText(textBlocks, character, type) {
      return textBlocks.reduce(function (acc, textLine, index) {
        textLine = sanitizeDraftText_1(textLine);
        var key = generateRandomKey_1();

        var blockNodeConfig = {
          key: key,
          type: type,
          text: textLine,
          characterList: List$b(Repeat$6(character, textLine.length))
        };

        acc.push(new ContentBlockRecord$2(blockNodeConfig));

        return acc;
      }, []);
    }
  };

  var DraftPasteProcessor_1 = DraftPasteProcessor;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule adjustBlockDepthForContentState
   * @format
   * 
   */

  function adjustBlockDepthForContentState(contentState, selectionState, adjustment, maxDepth) {
    var startKey = selectionState.getStartKey();
    var endKey = selectionState.getEndKey();
    var blockMap = contentState.getBlockMap();
    var blocks = blockMap.toSeq().skipUntil(function (_, k) {
      return k === startKey;
    }).takeUntil(function (_, k) {
      return k === endKey;
    }).concat([[endKey, blockMap.get(endKey)]]).map(function (block) {
      var depth = block.getDepth() + adjustment;
      depth = Math.max(0, Math.min(depth, maxDepth));
      return block.set('depth', depth);
    });

    blockMap = blockMap.merge(blocks);

    return contentState.merge({
      blockMap: blockMap,
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  }

  var adjustBlockDepthForContentState_1 = adjustBlockDepthForContentState;

  var RichTextEditorUtil = {
    currentBlockContainsLink: function currentBlockContainsLink(editorState) {
      var selection = editorState.getSelection();
      var contentState = editorState.getCurrentContent();
      var entityMap = contentState.getEntityMap();
      return contentState.getBlockForKey(selection.getAnchorKey()).getCharacterList().slice(selection.getStartOffset(), selection.getEndOffset()).some(function (v) {
        var entity = v.getEntity();
        return !!entity && entityMap.__get(entity).getType() === 'LINK';
      });
    },

    getCurrentBlockType: function getCurrentBlockType(editorState) {
      var selection = editorState.getSelection();
      return editorState.getCurrentContent().getBlockForKey(selection.getStartKey()).getType();
    },

    getDataObjectForLinkURL: function getDataObjectForLinkURL(uri) {
      return { url: uri.toString() };
    },

    handleKeyCommand: function handleKeyCommand(editorState, command) {
      switch (command) {
        case 'bold':
          return RichTextEditorUtil.toggleInlineStyle(editorState, 'BOLD');
        case 'italic':
          return RichTextEditorUtil.toggleInlineStyle(editorState, 'ITALIC');
        case 'underline':
          return RichTextEditorUtil.toggleInlineStyle(editorState, 'UNDERLINE');
        case 'code':
          return RichTextEditorUtil.toggleCode(editorState);
        case 'backspace':
        case 'backspace-word':
        case 'backspace-to-start-of-line':
          return RichTextEditorUtil.onBackspace(editorState);
        case 'delete':
        case 'delete-word':
        case 'delete-to-end-of-block':
          return RichTextEditorUtil.onDelete(editorState);
        default:
          // they may have custom editor commands; ignore those
          return null;
      }
    },

    insertSoftNewline: function insertSoftNewline(editorState) {
      var contentState = DraftModifier_1.insertText(editorState.getCurrentContent(), editorState.getSelection(), '\n', editorState.getCurrentInlineStyle(), null);

      var newEditorState = EditorState_1.push(editorState, contentState, 'insert-characters');

      return EditorState_1.forceSelection(newEditorState, contentState.getSelectionAfter());
    },

    /**
     * For collapsed selections at the start of styled blocks, backspace should
     * just remove the existing style.
     */
    onBackspace: function onBackspace(editorState) {
      var selection = editorState.getSelection();
      if (!selection.isCollapsed() || selection.getAnchorOffset() || selection.getFocusOffset()) {
        return null;
      }

      // First, try to remove a preceding atomic block.
      var content = editorState.getCurrentContent();
      var startKey = selection.getStartKey();
      var blockBefore = content.getBlockBefore(startKey);

      if (blockBefore && blockBefore.getType() === 'atomic') {
        var blockMap = content.getBlockMap()['delete'](blockBefore.getKey());
        var withoutAtomicBlock = content.merge({
          blockMap: blockMap,
          selectionAfter: selection
        });
        if (withoutAtomicBlock !== content) {
          return EditorState_1.push(editorState, withoutAtomicBlock, 'remove-range');
        }
      }

      // If that doesn't succeed, try to remove the current block style.
      var withoutBlockStyle = RichTextEditorUtil.tryToRemoveBlockStyle(editorState);

      if (withoutBlockStyle) {
        return EditorState_1.push(editorState, withoutBlockStyle, 'change-block-type');
      }

      return null;
    },

    onDelete: function onDelete(editorState) {
      var selection = editorState.getSelection();
      if (!selection.isCollapsed()) {
        return null;
      }

      var content = editorState.getCurrentContent();
      var startKey = selection.getStartKey();
      var block = content.getBlockForKey(startKey);
      var length = block.getLength();

      // The cursor is somewhere within the text. Behave normally.
      if (selection.getStartOffset() < length) {
        return null;
      }

      var blockAfter = content.getBlockAfter(startKey);

      if (!blockAfter || blockAfter.getType() !== 'atomic') {
        return null;
      }

      var atomicBlockTarget = selection.merge({
        focusKey: blockAfter.getKey(),
        focusOffset: blockAfter.getLength()
      });

      var withoutAtomicBlock = DraftModifier_1.removeRange(content, atomicBlockTarget, 'forward');

      if (withoutAtomicBlock !== content) {
        return EditorState_1.push(editorState, withoutAtomicBlock, 'remove-range');
      }

      return null;
    },

    onTab: function onTab(event, editorState, maxDepth) {
      var selection = editorState.getSelection();
      var key = selection.getAnchorKey();
      if (key !== selection.getFocusKey()) {
        return editorState;
      }

      var content = editorState.getCurrentContent();
      var block = content.getBlockForKey(key);
      var type = block.getType();
      if (type !== 'unordered-list-item' && type !== 'ordered-list-item') {
        return editorState;
      }

      event.preventDefault();

      // Only allow indenting one level beyond the block above, and only if
      // the block above is a list item as well.
      var blockAbove = content.getBlockBefore(key);
      if (!blockAbove) {
        return editorState;
      }

      var typeAbove = blockAbove.getType();
      if (typeAbove !== 'unordered-list-item' && typeAbove !== 'ordered-list-item') {
        return editorState;
      }

      var depth = block.getDepth();
      if (!event.shiftKey && depth === maxDepth) {
        return editorState;
      }

      maxDepth = Math.min(blockAbove.getDepth() + 1, maxDepth);

      var withAdjustment = adjustBlockDepthForContentState_1(content, selection, event.shiftKey ? -1 : 1, maxDepth);

      return EditorState_1.push(editorState, withAdjustment, 'adjust-depth');
    },

    toggleBlockType: function toggleBlockType(editorState, blockType) {
      var selection = editorState.getSelection();
      var startKey = selection.getStartKey();
      var endKey = selection.getEndKey();
      var content = editorState.getCurrentContent();
      var target = selection;

      // Triple-click can lead to a selection that includes offset 0 of the
      // following block. The `SelectionState` for this case is accurate, but
      // we should avoid toggling block type for the trailing block because it
      // is a confusing interaction.
      if (startKey !== endKey && selection.getEndOffset() === 0) {
        var blockBefore = nullthrows_1(content.getBlockBefore(endKey));
        endKey = blockBefore.getKey();
        target = target.merge({
          anchorKey: startKey,
          anchorOffset: selection.getStartOffset(),
          focusKey: endKey,
          focusOffset: blockBefore.getLength(),
          isBackward: false
        });
      }

      var hasAtomicBlock = content.getBlockMap().skipWhile(function (_, k) {
        return k !== startKey;
      }).reverse().skipWhile(function (_, k) {
        return k !== endKey;
      }).some(function (v) {
        return v.getType() === 'atomic';
      });

      if (hasAtomicBlock) {
        return editorState;
      }

      var typeToSet = content.getBlockForKey(startKey).getType() === blockType ? 'unstyled' : blockType;

      return EditorState_1.push(editorState, DraftModifier_1.setBlockType(content, target, typeToSet), 'change-block-type');
    },

    toggleCode: function toggleCode(editorState) {
      var selection = editorState.getSelection();
      var anchorKey = selection.getAnchorKey();
      var focusKey = selection.getFocusKey();

      if (selection.isCollapsed() || anchorKey !== focusKey) {
        return RichTextEditorUtil.toggleBlockType(editorState, 'code-block');
      }

      return RichTextEditorUtil.toggleInlineStyle(editorState, 'CODE');
    },

    /**
     * Toggle the specified inline style for the selection. If the
     * user's selection is collapsed, apply or remove the style for the
     * internal state. If it is not collapsed, apply the change directly
     * to the document state.
     */
    toggleInlineStyle: function toggleInlineStyle(editorState, inlineStyle) {
      var selection = editorState.getSelection();
      var currentStyle = editorState.getCurrentInlineStyle();

      // If the selection is collapsed, toggle the specified style on or off and
      // set the result as the new inline style override. This will then be
      // used as the inline style for the next character to be inserted.
      if (selection.isCollapsed()) {
        return EditorState_1.setInlineStyleOverride(editorState, currentStyle.has(inlineStyle) ? currentStyle.remove(inlineStyle) : currentStyle.add(inlineStyle));
      }

      // If characters are selected, immediately apply or remove the
      // inline style on the document state itself.
      var content = editorState.getCurrentContent();
      var newContent;

      // If the style is already present for the selection range, remove it.
      // Otherwise, apply it.
      if (currentStyle.has(inlineStyle)) {
        newContent = DraftModifier_1.removeInlineStyle(content, selection, inlineStyle);
      } else {
        newContent = DraftModifier_1.applyInlineStyle(content, selection, inlineStyle);
      }

      return EditorState_1.push(editorState, newContent, 'change-inline-style');
    },

    toggleLink: function toggleLink(editorState, targetSelection, entityKey) {
      var withoutLink = DraftModifier_1.applyEntity(editorState.getCurrentContent(), targetSelection, entityKey);

      return EditorState_1.push(editorState, withoutLink, 'apply-entity');
    },

    /**
     * When a collapsed cursor is at the start of the first styled block, or
     * an empty styled block, changes block to 'unstyled'. Returns null if
     * block or selection does not meet that criteria.
     */
    tryToRemoveBlockStyle: function tryToRemoveBlockStyle(editorState) {
      var selection = editorState.getSelection();
      var offset = selection.getAnchorOffset();
      if (selection.isCollapsed() && offset === 0) {
        var key = selection.getAnchorKey();
        var content = editorState.getCurrentContent();
        var block = content.getBlockForKey(key);

        var firstBlock = content.getFirstBlock();
        if (block.getLength() > 0 && block !== firstBlock) {
          return null;
        }

        var type = block.getType();
        var blockBefore = content.getBlockBefore(key);
        if (type === 'code-block' && blockBefore && blockBefore.getType() === 'code-block' && blockBefore.getLength() !== 0) {
          return null;
        }

        if (type !== 'unstyled') {
          return DraftModifier_1.setBlockType(content, selection, 'unstyled');
        }
      }
      return null;
    }
  };

  var RichTextEditorUtil_1 = RichTextEditorUtil;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule splitTextIntoTextBlocks
   * @format
   * 
   */

  var NEWLINE_REGEX = /\r\n?|\n/g;

  function splitTextIntoTextBlocks(text) {
    return text.split(NEWLINE_REGEX);
  }

  var splitTextIntoTextBlocks_1 = splitTextIntoTextBlocks;

  /**
   * Paste content.
   */
  function editOnPaste(editor, e) {
    e.preventDefault();
    var data = new DataTransfer_1(e.clipboardData);

    // Get files, unless this is likely to be a string the user wants inline.
    if (!data.isRichText()) {
      var files = data.getFiles();
      var defaultFileText = data.getText();
      if (files.length > 0) {
        // Allow customized paste handling for images, etc. Otherwise, fall
        // through to insert text contents into the editor.
        if (editor.props.handlePastedFiles && isEventHandled_1(editor.props.handlePastedFiles(files))) {
          return;
        }

        getTextContentFromFiles_1(files, function ( /*string*/fileText) {
          fileText = fileText || defaultFileText;
          if (!fileText) {
            return;
          }

          var editorState = editor._latestEditorState;
          var blocks = splitTextIntoTextBlocks_1(fileText);
          var character = CharacterMetadata_1.create({
            style: editorState.getCurrentInlineStyle(),
            entity: getEntityKeyForSelection_1(editorState.getCurrentContent(), editorState.getSelection())
          });
          var currentBlockType = RichTextEditorUtil_1.getCurrentBlockType(editorState);

          var text = DraftPasteProcessor_1.processText(blocks, character, currentBlockType);
          var fragment = BlockMapBuilder_1.createFromArray(text);

          var withInsertedText = DraftModifier_1.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);

          editor.update(EditorState_1.push(editorState, withInsertedText, 'insert-fragment'));
        });

        return;
      }
    }

    var textBlocks = [];
    var text = data.getText();
    var html = data.getHTML();
    var editorState = editor._latestEditorState;

    if (editor.props.handlePastedText && isEventHandled_1(editor.props.handlePastedText(text, html, editorState))) {
      return;
    }

    if (text) {
      textBlocks = splitTextIntoTextBlocks_1(text);
    }

    if (!editor.props.stripPastedStyles) {
      // If the text from the paste event is rich content that matches what we
      // already have on the internal clipboard, assume that we should just use
      // the clipboard fragment for the paste. This will allow us to preserve
      // styling and entities, if any are present. Note that newlines are
      // stripped during comparison -- this is because copy/paste within the
      // editor in Firefox and IE will not include empty lines. The resulting
      // paste will preserve the newlines correctly.
      var internalClipboard = editor.getClipboard();
      if (data.isRichText() && internalClipboard) {
        if (
        // If the editorKey is present in the pasted HTML, it should be safe to
        // assume this is an internal paste.
        html.indexOf(editor.getEditorKey()) !== -1 ||
        // The copy may have been made within a single block, in which case the
        // editor key won't be part of the paste. In this case, just check
        // whether the pasted text matches the internal clipboard.
        textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {
          editor.update(insertFragment$1(editor._latestEditorState, internalClipboard));
          return;
        }
      } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {
        // Safari does not properly store text/html in some cases.
        // Use the internalClipboard if present and equal to what is on
        // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.
        editor.update(insertFragment$1(editor._latestEditorState, internalClipboard));
        return;
      }

      // If there is html paste data, try to parse that.
      if (html) {
        var htmlFragment = DraftPasteProcessor_1.processHTML(html, editor.props.blockRenderMap);
        if (htmlFragment) {
          var contentBlocks = htmlFragment.contentBlocks,
              entityMap = htmlFragment.entityMap;

          if (contentBlocks) {
            var htmlMap = BlockMapBuilder_1.createFromArray(contentBlocks);
            editor.update(insertFragment$1(editor._latestEditorState, htmlMap, entityMap));
            return;
          }
        }
      }

      // Otherwise, create a new fragment from our pasted text. Also
      // empty the internal clipboard, since it's no longer valid.
      editor.setClipboard(null);
    }

    if (textBlocks.length) {
      var character = CharacterMetadata_1.create({
        style: editorState.getCurrentInlineStyle(),
        entity: getEntityKeyForSelection_1(editorState.getCurrentContent(), editorState.getSelection())
      });

      var currentBlockType = RichTextEditorUtil_1.getCurrentBlockType(editorState);

      var textFragment = DraftPasteProcessor_1.processText(textBlocks, character, currentBlockType);

      var textMap = BlockMapBuilder_1.createFromArray(textFragment);
      editor.update(insertFragment$1(editor._latestEditorState, textMap));
    }
  }

  function insertFragment$1(editorState, fragment, entityMap) {
    var newContent = DraftModifier_1.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);
    // TODO: merge the entity map once we stop using DraftEntity
    // like this:
    // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);

    return EditorState_1.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');
  }

  function areTextBlocksAndClipboardEqual(textBlocks, blockMap) {
    return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {
      return block.getText() === textBlocks[ii];
    });
  }

  var editOnPaste_1 = editOnPaste;

  /**
   * Convert the current selection range to an anchor/focus pair of offset keys
   * and values that can be interpreted by components.
   */
  function getDraftEditorSelection(editorState, root) {
    var selection = commonjsGlobal.getSelection();

    // No active selection.
    if (selection.rangeCount === 0) {
      return {
        selectionState: editorState.getSelection().set('hasFocus', false),
        needsRecovery: false
      };
    }

    return getDraftEditorSelectionWithNodes_1(editorState, root, selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
  }

  var getDraftEditorSelection_1 = getDraftEditorSelection;

  function editOnSelect(editor) {
    if (editor._blockSelectEvents || editor._latestEditorState !== editor.props.editorState) {
      return;
    }

    var editorState = editor.props.editorState;
    var editorNode = reactDom.findDOMNode(editor.editorContainer);
    !editorNode ? invariant_1(false) : void 0;
    !(editorNode.firstChild instanceof HTMLElement) ? invariant_1(false) : void 0;
    var documentSelection = getDraftEditorSelection_1(editorState, editorNode.firstChild);
    var updatedSelectionState = documentSelection.selectionState;

    if (updatedSelectionState !== editorState.getSelection()) {
      if (documentSelection.needsRecovery) {
        editorState = EditorState_1.forceSelection(editorState, updatedSelectionState);
      } else {
        editorState = EditorState_1.acceptSelection(editorState, updatedSelectionState);
      }
      editor.update(editorState);
    }
  }

  var editOnSelect_1 = editOnSelect;

  var DraftEditorEditHandler = {
    onBeforeInput: editOnBeforeInput_1,
    onBlur: editOnBlur_1,
    onCompositionStart: editOnCompositionStart_1,
    onCopy: editOnCopy_1,
    onCut: editOnCut_1,
    onDragOver: editOnDragOver_1,
    onDragStart: editOnDragStart_1,
    onFocus: editOnFocus_1,
    onInput: editOnInput_1,
    onKeyDown: editOnKeyDown_1,
    onPaste: editOnPaste_1,
    onSelect: editOnSelect_1
  };

  var DraftEditorEditHandler_1 = DraftEditorEditHandler;

  function _classCallCheck$g(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$b(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$b(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





  /**
   * This component is responsible for rendering placeholder text for the
   * `DraftEditor` component.
   *
   * Override placeholder style via CSS.
   */
  var DraftEditorPlaceholder = function (_React$Component) {
    _inherits$b(DraftEditorPlaceholder, _React$Component);

    function DraftEditorPlaceholder() {
      _classCallCheck$g(this, DraftEditorPlaceholder);

      return _possibleConstructorReturn$b(this, _React$Component.apply(this, arguments));
    }

    DraftEditorPlaceholder.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
      return this.props.text !== nextProps.text || this.props.editorState.getSelection().getHasFocus() !== nextProps.editorState.getSelection().getHasFocus();
    };

    DraftEditorPlaceholder.prototype.render = function render() {
      var hasFocus = this.props.editorState.getSelection().getHasFocus();

      var className = cx_1({
        'public/DraftEditorPlaceholder/root': true,
        'public/DraftEditorPlaceholder/hasFocus': hasFocus
      });

      var contentStyle = {
        whiteSpace: 'pre-wrap'
      };

      return react.createElement(
        'div',
        { className: className },
        react.createElement(
          'div',
          {
            className: cx_1('public/DraftEditorPlaceholder/inner'),
            id: this.props.accessibilityID,
            style: contentStyle },
          this.props.text
        )
      );
    };

    return DraftEditorPlaceholder;
  }(react.Component);

  var DraftEditorPlaceholder_react = DraftEditorPlaceholder;

  var isOSX$1 = UserAgent_1.isPlatform('Mac OS X');
  var isWindows = UserAgent_1.isPlatform('Windows');

  // Firefox on OSX had a bug resulting in navigation instead of cursor movement.
  // This bug was fixed in Firefox 29. Feature detection is virtually impossible
  // so we just check the version number. See #342765.
  var shouldFixFirefoxMovement = isOSX$1 && UserAgent_1.isBrowser('Firefox < 29');

  var hasCommandModifier = KeyBindingUtil_1.hasCommandModifier,
      isCtrlKeyCommand = KeyBindingUtil_1.isCtrlKeyCommand;


  function shouldRemoveWord(e) {
    return isOSX$1 && e.altKey || isCtrlKeyCommand(e);
  }

  /**
   * Get the appropriate undo/redo command for a Z key command.
   */
  function getZCommand(e) {
    if (!hasCommandModifier(e)) {
      return null;
    }
    return e.shiftKey ? 'redo' : 'undo';
  }

  function getDeleteCommand(e) {
    // Allow default "cut" behavior for Windows on Shift + Delete.
    if (isWindows && e.shiftKey) {
      return null;
    }
    return shouldRemoveWord(e) ? 'delete-word' : 'delete';
  }

  function getBackspaceCommand(e) {
    if (hasCommandModifier(e) && isOSX$1) {
      return 'backspace-to-start-of-line';
    }
    return shouldRemoveWord(e) ? 'backspace-word' : 'backspace';
  }

  /**
   * Retrieve a bound key command for the given event.
   */
  function getDefaultKeyBinding(e) {
    switch (e.keyCode) {
      case 66:
        // B
        return hasCommandModifier(e) ? 'bold' : null;
      case 68:
        // D
        return isCtrlKeyCommand(e) ? 'delete' : null;
      case 72:
        // H
        return isCtrlKeyCommand(e) ? 'backspace' : null;
      case 73:
        // I
        return hasCommandModifier(e) ? 'italic' : null;
      case 74:
        // J
        return hasCommandModifier(e) ? 'code' : null;
      case 75:
        // K
        return !isWindows && isCtrlKeyCommand(e) ? 'secondary-cut' : null;
      case 77:
        // M
        return isCtrlKeyCommand(e) ? 'split-block' : null;
      case 79:
        // O
        return isCtrlKeyCommand(e) ? 'split-block' : null;
      case 84:
        // T
        return isOSX$1 && isCtrlKeyCommand(e) ? 'transpose-characters' : null;
      case 85:
        // U
        return hasCommandModifier(e) ? 'underline' : null;
      case 87:
        // W
        return isOSX$1 && isCtrlKeyCommand(e) ? 'backspace-word' : null;
      case 89:
        // Y
        if (isCtrlKeyCommand(e)) {
          return isWindows ? 'redo' : 'secondary-paste';
        }
        return null;
      case 90:
        // Z
        return getZCommand(e) || null;
      case Keys.RETURN:
        return 'split-block';
      case Keys.DELETE:
        return getDeleteCommand(e);
      case Keys.BACKSPACE:
        return getBackspaceCommand(e);
      // LEFT/RIGHT handlers serve as a workaround for a Firefox bug.
      case Keys.LEFT:
        return shouldFixFirefoxMovement && hasCommandModifier(e) ? 'move-selection-to-start-of-block' : null;
      case Keys.RIGHT:
        return shouldFixFirefoxMovement && hasCommandModifier(e) ? 'move-selection-to-end-of-block' : null;
      default:
        return null;
    }
  }

  var getDefaultKeyBinding_1 = getDefaultKeyBinding;

  var _extends$5 = objectAssign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  function _classCallCheck$h(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn$c(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits$c(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }























  var isIE = UserAgent_1.isBrowser('IE');

  // IE does not support the `input` event on contentEditable, so we can't
  // observe spellcheck behavior.
  var allowSpellCheck = !isIE;

  // Define a set of handler objects to correspond to each possible `mode`
  // of editor behavior.
  var handlerMap = {
    edit: DraftEditorEditHandler_1,
    composite: DraftEditorCompositionHandler_1,
    drag: DraftEditorDragHandler_1,
    cut: null,
    render: null
  };

  /**
   * `DraftEditor` is the root editor component. It composes a `contentEditable`
   * div, and provides a wide variety of useful function props for managing the
   * state of the editor. See `DraftEditorProps` for details.
   */
  var DraftEditor = function (_React$Component) {
    _inherits$c(DraftEditor, _React$Component);

    function DraftEditor(props) {
      _classCallCheck$h(this, DraftEditor);

      var _this = _possibleConstructorReturn$c(this, _React$Component.call(this, props));

      _this.focus = function (scrollPosition) {
        var editorState = _this.props.editorState;

        var alreadyHasFocus = editorState.getSelection().getHasFocus();
        var editorNode = reactDom.findDOMNode(_this.editor);

        if (!editorNode) {
          // once in a while people call 'focus' in a setTimeout, and the node has
          // been deleted, so it can be null in that case.
          return;
        }

        var scrollParent = Style_1.getScrollParent(editorNode);

        var _ref = scrollPosition || getScrollPosition_1(scrollParent),
            x = _ref.x,
            y = _ref.y;

        !(editorNode instanceof HTMLElement) ? invariant_1(false) : void 0;
        editorNode.focus();

        // Restore scroll position
        if (scrollParent === window) {
          window.scrollTo(x, y);
        } else {
          Scroll_1.setTop(scrollParent, y);
        }

        // On Chrome and Safari, calling focus on contenteditable focuses the
        // cursor at the first character. This is something you don't expect when
        // you're clicking on an input element but not directly on a character.
        // Put the cursor back where it was before the blur.
        if (!alreadyHasFocus) {
          _this.update(EditorState_1.forceSelection(editorState, editorState.getSelection()));
        }
      };

      _this.blur = function () {
        var editorNode = reactDom.findDOMNode(_this.editor);
        !(editorNode instanceof HTMLElement) ? invariant_1(false) : void 0;
        editorNode.blur();
      };

      _this.setMode = function (mode) {
        _this._handler = handlerMap[mode];
      };

      _this.exitCurrentMode = function () {
        _this.setMode('edit');
      };

      _this.restoreEditorDOM = function (scrollPosition) {
        _this.setState({ contentsKey: _this.state.contentsKey + 1 }, function () {
          _this.focus(scrollPosition);
        });
      };

      _this.setClipboard = function (clipboard) {
        _this._clipboard = clipboard;
      };

      _this.getClipboard = function () {
        return _this._clipboard;
      };

      _this.update = function (editorState) {
        _this._latestEditorState = editorState;
        _this.props.onChange(editorState);
      };

      _this.onDragEnter = function () {
        _this._dragCount++;
      };

      _this.onDragLeave = function () {
        _this._dragCount--;
        if (_this._dragCount === 0) {
          _this.exitCurrentMode();
        }
      };

      _this._blockSelectEvents = false;
      _this._clipboard = null;
      _this._handler = null;
      _this._dragCount = 0;
      _this._editorKey = props.editorKey || generateRandomKey_1();
      _this._placeholderAccessibilityID = 'placeholder-' + _this._editorKey;
      _this._latestEditorState = props.editorState;
      _this._latestCommittedEditorState = props.editorState;

      _this._onBeforeInput = _this._buildHandler('onBeforeInput');
      _this._onBlur = _this._buildHandler('onBlur');
      _this._onCharacterData = _this._buildHandler('onCharacterData');
      _this._onCompositionEnd = _this._buildHandler('onCompositionEnd');
      _this._onCompositionStart = _this._buildHandler('onCompositionStart');
      _this._onCopy = _this._buildHandler('onCopy');
      _this._onCut = _this._buildHandler('onCut');
      _this._onDragEnd = _this._buildHandler('onDragEnd');
      _this._onDragOver = _this._buildHandler('onDragOver');
      _this._onDragStart = _this._buildHandler('onDragStart');
      _this._onDrop = _this._buildHandler('onDrop');
      _this._onInput = _this._buildHandler('onInput');
      _this._onFocus = _this._buildHandler('onFocus');
      _this._onKeyDown = _this._buildHandler('onKeyDown');
      _this._onKeyPress = _this._buildHandler('onKeyPress');
      _this._onKeyUp = _this._buildHandler('onKeyUp');
      _this._onMouseDown = _this._buildHandler('onMouseDown');
      _this._onMouseUp = _this._buildHandler('onMouseUp');
      _this._onPaste = _this._buildHandler('onPaste');
      _this._onSelect = _this._buildHandler('onSelect');

      _this.getEditorKey = function () {
        return _this._editorKey;
      };

      // See `restoreEditorDOM()`.
      _this.state = { contentsKey: 0 };
      return _this;
    }

    /**
     * Build a method that will pass the event to the specified handler method.
     * This allows us to look up the correct handler function for the current
     * editor mode, if any has been specified.
     */


    /**
     * Define proxies that can route events to the current handler.
     */


    DraftEditor.prototype._buildHandler = function _buildHandler(eventName) {
      var _this2 = this;

      return function (e) {
        if (!_this2.props.readOnly) {
          var method = _this2._handler && _this2._handler[eventName];
          method && method(_this2, e);
        }
      };
    };

    DraftEditor.prototype._showPlaceholder = function _showPlaceholder() {
      return !!this.props.placeholder && !this.props.editorState.isInCompositionMode() && !this.props.editorState.getCurrentContent().hasText();
    };

    DraftEditor.prototype._renderPlaceholder = function _renderPlaceholder() {
      if (this._showPlaceholder()) {
        var placeHolderProps = {
          text: nullthrows_1(this.props.placeholder),
          editorState: this.props.editorState,
          textAlignment: this.props.textAlignment,
          accessibilityID: this._placeholderAccessibilityID
        };

        return react.createElement(DraftEditorPlaceholder_react, placeHolderProps);
      }
      return null;
    };

    DraftEditor.prototype.render = function render() {
      var _this3 = this;

      var _props = this.props,
          blockRenderMap = _props.blockRenderMap,
          blockRendererFn = _props.blockRendererFn,
          blockStyleFn = _props.blockStyleFn,
          customStyleFn = _props.customStyleFn,
          customStyleMap = _props.customStyleMap,
          editorState = _props.editorState,
          readOnly = _props.readOnly,
          textAlignment = _props.textAlignment,
          textDirectionality = _props.textDirectionality;


      var rootClass = cx_1({
        'DraftEditor/root': true,
        'DraftEditor/alignLeft': textAlignment === 'left',
        'DraftEditor/alignRight': textAlignment === 'right',
        'DraftEditor/alignCenter': textAlignment === 'center'
      });

      var contentStyle = {
        outline: 'none',
        // fix parent-draggable Safari bug. #1326
        userSelect: 'text',
        WebkitUserSelect: 'text',
        whiteSpace: 'pre-wrap',
        wordWrap: 'break-word'
      };

      // The aria-expanded and aria-haspopup properties should only be rendered
      // for a combobox.
      var ariaRole = this.props.role || 'textbox';
      var ariaExpanded = ariaRole === 'combobox' ? !!this.props.ariaExpanded : null;

      var editorContentsProps = {
        blockRenderMap: blockRenderMap,
        blockRendererFn: blockRendererFn,
        blockStyleFn: blockStyleFn,
        customStyleMap: _extends$5({}, DefaultDraftInlineStyle, customStyleMap),
        customStyleFn: customStyleFn,
        editorKey: this._editorKey,
        editorState: editorState,
        key: 'contents' + this.state.contentsKey,
        textDirectionality: textDirectionality
      };

      return react.createElement(
        'div',
        { className: rootClass },
        this._renderPlaceholder(),
        react.createElement(
          'div',
          {
            className: cx_1('DraftEditor/editorContainer'),
            ref: function ref(_ref3) {
              return _this3.editorContainer = _ref3;
            } },
          react.createElement(
            'div',
            {
              'aria-activedescendant': readOnly ? null : this.props.ariaActiveDescendantID,
              'aria-autocomplete': readOnly ? null : this.props.ariaAutoComplete,
              'aria-controls': readOnly ? null : this.props.ariaControls,
              'aria-describedby': this.props.ariaDescribedBy || this._placeholderAccessibilityID,
              'aria-expanded': readOnly ? null : ariaExpanded,
              'aria-label': this.props.ariaLabel,
              'aria-labelledby': this.props.ariaLabelledBy,
              'aria-multiline': this.props.ariaMultiline,
              autoCapitalize: this.props.autoCapitalize,
              autoComplete: this.props.autoComplete,
              autoCorrect: this.props.autoCorrect,
              className: cx_1({
                // Chrome's built-in translation feature mutates the DOM in ways
                // that Draft doesn't expect (ex: adding <font> tags inside
                // DraftEditorLeaf spans) and causes problems. We add notranslate
                // here which makes its autotranslation skip over this subtree.
                notranslate: !readOnly,
                'public/DraftEditor/content': true
              }),
              contentEditable: !readOnly,
              'data-testid': this.props.webDriverTestID,
              onBeforeInput: this._onBeforeInput,
              onBlur: this._onBlur,
              onCompositionEnd: this._onCompositionEnd,
              onCompositionStart: this._onCompositionStart,
              onCopy: this._onCopy,
              onCut: this._onCut,
              onDragEnd: this._onDragEnd,
              onDragEnter: this.onDragEnter,
              onDragLeave: this.onDragLeave,
              onDragOver: this._onDragOver,
              onDragStart: this._onDragStart,
              onDrop: this._onDrop,
              onFocus: this._onFocus,
              onInput: this._onInput,
              onKeyDown: this._onKeyDown,
              onKeyPress: this._onKeyPress,
              onKeyUp: this._onKeyUp,
              onMouseUp: this._onMouseUp,
              onPaste: this._onPaste,
              onSelect: this._onSelect,
              ref: function ref(_ref2) {
                return _this3.editor = _ref2;
              },
              role: readOnly ? null : ariaRole,
              spellCheck: allowSpellCheck && this.props.spellCheck,
              style: contentStyle,
              suppressContentEditableWarning: true,
              tabIndex: this.props.tabIndex },
            react.createElement(DraftEditorContents_react, editorContentsProps)
          )
        )
      );
    };

    DraftEditor.prototype.componentDidMount = function componentDidMount() {
      this.setMode('edit');

      /**
       * IE has a hardcoded "feature" that attempts to convert link text into
       * anchors in contentEditable DOM. This breaks the editor's expectations of
       * the DOM, and control is lost. Disable it to make IE behave.
       * See: http://blogs.msdn.com/b/ieinternals/archive/2010/09/15/
       * ie9-beta-minor-change-list.aspx
       */
      if (isIE) {
        document.execCommand('AutoUrlDetect', false, false);
      }
    };

    /**
     * Prevent selection events from affecting the current editor state. This
     * is mostly intended to defend against IE, which fires off `selectionchange`
     * events regardless of whether the selection is set via the browser or
     * programmatically. We only care about selection events that occur because
     * of browser interaction, not re-renders and forced selections.
     */


    DraftEditor.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {
      this._blockSelectEvents = true;
      this._latestEditorState = nextProps.editorState;
    };

    DraftEditor.prototype.componentDidUpdate = function componentDidUpdate() {
      this._blockSelectEvents = false;
      this._latestCommittedEditorState = this.props.editorState;
    };

    /**
     * Used via `this.focus()`.
     *
     * Force focus back onto the editor node.
     *
     * We attempt to preserve scroll position when focusing. You can also pass
     * a specified scroll position (for cases like `cut` behavior where it should
     * be restored to a known position).
     */


    /**
     * Used via `this.setMode(...)`.
     *
     * Set the behavior mode for the editor component. This switches the current
     * handler module to ensure that DOM events are managed appropriately for
     * the active mode.
     */


    /**
     * Used via `this.restoreEditorDOM()`.
     *
     * Force a complete re-render of the DraftEditorContents based on the current
     * EditorState. This is useful when we know we are going to lose control of
     * the DOM state (cut command, IME) and we want to make sure that
     * reconciliation occurs on a version of the DOM that is synchronized with
     * our EditorState.
     */


    /**
     * Used via `this.setClipboard(...)`.
     *
     * Set the clipboard state for a cut/copy event.
     */


    /**
     * Used via `this.getClipboard()`.
     *
     * Retrieve the clipboard state for a cut/copy event.
     */


    /**
     * Used via `this.update(...)`.
     *
     * Propagate a new `EditorState` object to higher-level components. This is
     * the method by which event handlers inform the `DraftEditor` component of
     * state changes. A component that composes a `DraftEditor` **must** provide
     * an `onChange` prop to receive state updates passed along from this
     * function.
     */


    /**
     * Used in conjunction with `onDragLeave()`, by counting the number of times
     * a dragged element enters and leaves the editor (or any of its children),
     * to determine when the dragged element absolutely leaves the editor.
     */


    /**
     * See `onDragEnter()`.
     */


    return DraftEditor;
  }(react.Component);

  DraftEditor.defaultProps = {
    blockRenderMap: DefaultDraftBlockRenderMap_1,
    blockRendererFn: emptyFunction_1.thatReturnsNull,
    blockStyleFn: emptyFunction_1.thatReturns(''),
    keyBindingFn: getDefaultKeyBinding_1,
    readOnly: false,
    spellCheck: false,
    stripPastedStyles: false
  };


  var DraftEditor_react = DraftEditor;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule DraftStringKey
   * @format
   * 
   */

  var DraftStringKey = {
    stringify: function stringify(key) {
      return '_' + String(key);
    },

    unstringify: function unstringify(key) {
      return key.slice(1);
    }
  };

  var DraftStringKey_1 = DraftStringKey;

  var strlen$1 = UnicodeUtils_1.strlen;

  /**
   * Convert to UTF-8 character counts for storage.
   */

  function encodeEntityRanges(block, storageMap) {
    var encoded = [];
    block.findEntityRanges(function (character) {
      return !!character.getEntity();
    }, function ( /*number*/start, /*number*/end) {
      var text = block.getText();
      var key = block.getEntityAt(start);
      encoded.push({
        offset: strlen$1(text.slice(0, start)),
        length: strlen$1(text.slice(start, end)),
        // Encode the key as a number for range storage.
        key: Number(storageMap[DraftStringKey_1.stringify(key)])
      });
    });
    return encoded;
  }

  var encodeEntityRanges_1 = encodeEntityRanges;

  var areEqual$1 = function areEqual(a, b) {
    return a === b;
  };
  var isTruthy = function isTruthy(a) {
    return !!a;
  };
  var EMPTY_ARRAY = [];

  /**
   * Helper function for getting encoded styles for each inline style. Convert
   * to UTF-8 character counts for storage.
   */
  function getEncodedInlinesForType(block, styleList, styleToEncode) {
    var ranges = [];

    // Obtain an array with ranges for only the specified style.
    var filteredInlines = styleList.map(function (style) {
      return style.has(styleToEncode);
    }).toList();

    findRangesImmutable_1(filteredInlines, areEqual$1,
    // We only want to keep ranges with nonzero style values.
    isTruthy, function (start, end) {
      var text = block.getText();
      ranges.push({
        offset: UnicodeUtils_1.strlen(text.slice(0, start)),
        length: UnicodeUtils_1.strlen(text.slice(start, end)),
        style: styleToEncode
      });
    });

    return ranges;
  }

  /*
   * Retrieve the encoded arrays of inline styles, with each individual style
   * treated separately.
   */
  function encodeInlineStyleRanges(block) {
    var styleList = block.getCharacterList().map(function (c) {
      return c.getStyle();
    }).toList();
    var ranges = styleList.flatten().toSet().map(function (style) {
      return getEncodedInlinesForType(block, styleList, style);
    });

    return Array.prototype.concat.apply(EMPTY_ARRAY, ranges.toJS());
  }

  var encodeInlineStyleRanges_1 = encodeInlineStyleRanges;

  var _extends$6 = objectAssign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };









  var createRawBlock = function createRawBlock(block, entityStorageMap) {
    return {
      key: block.getKey(),
      text: block.getText(),
      type: block.getType(),
      depth: block.getDepth(),
      inlineStyleRanges: encodeInlineStyleRanges_1(block),
      entityRanges: encodeEntityRanges_1(block, entityStorageMap),
      data: block.getData().toObject()
    };
  };

  var insertRawBlock = function insertRawBlock(block, entityMap, rawBlocks, blockCacheRef) {
    if (block instanceof ContentBlock_1) {
      rawBlocks.push(createRawBlock(block, entityMap));
      return;
    }

    !(block instanceof ContentBlockNode_1) ? invariant_1(false) : void 0;

    var parentKey = block.getParentKey();
    var rawBlock = blockCacheRef[block.getKey()] = _extends$6({}, createRawBlock(block, entityMap), {
      children: []
    });

    if (parentKey) {
      blockCacheRef[parentKey].children.push(rawBlock);
      return;
    }

    rawBlocks.push(rawBlock);
  };

  var encodeRawBlocks = function encodeRawBlocks(contentState, rawState) {
    var entityMap = rawState.entityMap;


    var rawBlocks = [];

    var blockCacheRef = {};
    var entityCacheRef = {};
    var entityStorageKey = 0;

    contentState.getBlockMap().forEach(function (block) {
      block.findEntityRanges(function (character) {
        return character.getEntity() !== null;
      }, function (start) {
        var entityKey = block.getEntityAt(start);
        // Stringify to maintain order of otherwise numeric keys.
        var stringifiedEntityKey = DraftStringKey_1.stringify(entityKey);
        // This makes this function resilient to two entities
        // erroneously having the same key
        if (entityCacheRef[stringifiedEntityKey]) {
          return;
        }
        entityCacheRef[stringifiedEntityKey] = entityKey;
        // we need the `any` casting here since this is a temporary state
        // where we will later on flip the entity map and populate it with
        // real entity, at this stage we just need to map back the entity
        // key used by the BlockNode
        entityMap[stringifiedEntityKey] = '' + entityStorageKey;
        entityStorageKey++;
      });

      insertRawBlock(block, entityMap, rawBlocks, blockCacheRef);
    });

    return {
      blocks: rawBlocks,
      entityMap: entityMap
    };
  };

  // Flip storage map so that our storage keys map to global
  // DraftEntity keys.
  var encodeRawEntityMap = function encodeRawEntityMap(contentState, rawState) {
    var blocks = rawState.blocks,
        entityMap = rawState.entityMap;


    var rawEntityMap = {};

    Object.keys(entityMap).forEach(function (key, index) {
      var entity = contentState.getEntity(DraftStringKey_1.unstringify(key));
      rawEntityMap[index] = {
        type: entity.getType(),
        mutability: entity.getMutability(),
        data: entity.getData()
      };
    });

    return {
      blocks: blocks,
      entityMap: rawEntityMap
    };
  };

  var convertFromDraftStateToRaw = function convertFromDraftStateToRaw(contentState) {
    var rawDraftContentState = {
      entityMap: {},
      blocks: []
    };

    // add blocks
    rawDraftContentState = encodeRawBlocks(contentState, rawDraftContentState);

    // add entities
    rawDraftContentState = encodeRawEntityMap(contentState, rawDraftContentState);

    return rawDraftContentState;
  };

  var convertFromDraftStateToRaw_1 = convertFromDraftStateToRaw;

  var _extends$7 = objectAssign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule DraftTreeAdapter
   * @format
   * 
   *
   * This is unstable and not part of the public API and should not be used by
   * production systems. This file may be update/removed without notice.
   */



  var traverseInDepthOrder = function traverseInDepthOrder(blocks, fn) {
    var stack = [].concat(blocks).reverse();
    while (stack.length) {
      var _block = stack.pop();

      fn(_block);

      var children = _block.children;

      !Array.isArray(children) ? invariant_1(false) : void 0;

      stack = stack.concat([].concat(children.reverse()));
    }
  };

  var isListBlock = function isListBlock(block) {
    if (!(block && block.type)) {
      return false;
    }
    var type = block.type;

    return type === 'unordered-list-item' || type === 'ordered-list-item';
  };

  var addDepthToChildren = function addDepthToChildren(block) {
    if (Array.isArray(block.children)) {
      block.children = block.children.map(function (child) {
        return child.type === block.type ? _extends$7({}, child, { depth: (block.depth || 0) + 1 }) : child;
      });
    }
  };

  /**
   * This adapter is intended to be be used as an adapter to draft tree data
   *
   * draft state <=====> draft tree state
   */
  var DraftTreeAdapter = {
    /**
     * Converts from a tree raw state back to  draft raw state
     */
    fromRawTreeStateToRawState: function fromRawTreeStateToRawState(draftTreeState) {
      var blocks = draftTreeState.blocks;

      var transformedBlocks = [];

      !Array.isArray(blocks) ? invariant_1(false) : void 0;

      if (!Array.isArray(blocks) || !blocks.length) {
        return draftTreeState;
      }

      traverseInDepthOrder(blocks, function (block) {
        var newBlock = _extends$7({}, block);

        if (isListBlock(block)) {
          newBlock.depth = newBlock.depth || 0;
          addDepthToChildren(block);
        }

        delete newBlock.children;

        transformedBlocks.push(newBlock);
      });

      draftTreeState.blocks = transformedBlocks;

      return _extends$7({}, draftTreeState, {
        blocks: transformedBlocks
      });
    },


    /**
     * Converts from draft raw state to tree draft state
     */
    fromRawStateToRawTreeState: function fromRawStateToRawTreeState(draftState) {
      var lastListDepthCacheRef = {};
      var transformedBlocks = [];

      draftState.blocks.forEach(function (block) {
        var isList = isListBlock(block);
        var depth = block.depth || 0;
        var treeBlock = _extends$7({}, block, {
          children: []
        });

        if (!isList) {
          // reset the cache path
          lastListDepthCacheRef = {};
          transformedBlocks.push(treeBlock);
          return;
        }

        // update our depth cache reference path
        lastListDepthCacheRef[depth] = treeBlock;

        // if we are greater than zero we must have seen a parent already
        if (depth > 0) {
          var parent = lastListDepthCacheRef[depth - 1];

          !parent ? invariant_1(false) : void 0;

          // push nested list blocks
          parent.children.push(treeBlock);
          return;
        }

        // push root list blocks
        transformedBlocks.push(treeBlock);
      });

      return _extends$7({}, draftState, {
        blocks: transformedBlocks
      });
    }
  };

  var DraftTreeAdapter_1 = DraftTreeAdapter;

  var List$c = immutable.List;


  function createCharacterList(inlineStyles, entities) {
    var characterArray = inlineStyles.map(function (style, ii) {
      var entity = entities[ii];
      return CharacterMetadata_1.create({ style: style, entity: entity });
    });
    return List$c(characterArray);
  }

  var createCharacterList_1 = createCharacterList;

  var substr$1 = UnicodeUtils_1.substr;

  /**
   * Convert to native JavaScript string lengths to determine ranges.
   */

  function decodeEntityRanges(text, ranges) {
    var entities = Array(text.length).fill(null);
    if (ranges) {
      ranges.forEach(function (range) {
        // Using Unicode-enabled substrings converted to JavaScript lengths,
        // fill the output array with entity keys.
        var start = substr$1(text, 0, range.offset).length;
        var end = start + substr$1(text, range.offset, range.length).length;
        for (var ii = start; ii < end; ii++) {
          entities[ii] = range.key;
        }
      });
    }
    return entities;
  }

  var decodeEntityRanges_1 = decodeEntityRanges;

  var OrderedSet$6 = immutable.OrderedSet;



  var substr$2 = UnicodeUtils_1.substr;


  var EMPTY_SET$3 = OrderedSet$6();

  /**
   * Convert to native JavaScript string lengths to determine ranges.
   */
  function decodeInlineStyleRanges(text, ranges) {
    var styles = Array(text.length).fill(EMPTY_SET$3);
    if (ranges) {
      ranges.forEach(function ( /*object*/range) {
        var cursor = substr$2(text, 0, range.offset).length;
        var end = cursor + substr$2(text, range.offset, range.length).length;
        while (cursor < end) {
          styles[cursor] = styles[cursor].add(range.style);
          cursor++;
        }
      });
    }
    return styles;
  }

  var decodeInlineStyleRanges_1 = decodeInlineStyleRanges;

  var _extends$8 = objectAssign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var List$d = immutable.List,
      Map$a = immutable.Map,
      OrderedMap$4 = immutable.OrderedMap;


  var decodeBlockNodeConfig = function decodeBlockNodeConfig(block, entityMap) {
    var key = block.key,
        type = block.type,
        data = block.data,
        text = block.text,
        depth = block.depth;


    var blockNodeConfig = {
      text: text,
      depth: depth || 0,
      type: type || 'unstyled',
      key: key || generateRandomKey_1(),
      data: Map$a(data),
      characterList: decodeCharacterList(block, entityMap)
    };

    return blockNodeConfig;
  };

  var decodeCharacterList = function decodeCharacterList(block, entityMap) {
    var text = block.text,
        rawEntityRanges = block.entityRanges,
        rawInlineStyleRanges = block.inlineStyleRanges;


    var entityRanges = rawEntityRanges || [];
    var inlineStyleRanges = rawInlineStyleRanges || [];

    // Translate entity range keys to the DraftEntity map.
    return createCharacterList_1(decodeInlineStyleRanges_1(text, inlineStyleRanges), decodeEntityRanges_1(text, entityRanges.filter(function (range) {
      return entityMap.hasOwnProperty(range.key);
    }).map(function (range) {
      return _extends$8({}, range, { key: entityMap[range.key] });
    })));
  };

  var addKeyIfMissing = function addKeyIfMissing(block) {
    return _extends$8({}, block, {
      key: block.key || generateRandomKey_1()
    });
  };

  /**
   * Node stack is responsible to ensure we traverse the tree only once
   * in depth order, while also providing parent refs to inner nodes to
   * construct their links.
   */
  var updateNodeStack = function updateNodeStack(stack, nodes, parentRef) {
    var nodesWithParentRef = nodes.map(function (block) {
      return _extends$8({}, block, {
        parentRef: parentRef
      });
    });

    // since we pop nodes from the stack we need to insert them in reverse
    return stack.concat(nodesWithParentRef.reverse());
  };

  /**
   * This will build a tree draft content state by creating the node
   * reference links into a single tree walk. Each node has a link
   * reference to "parent", "children", "nextSibling" and "prevSibling"
   * blockMap will be created using depth ordering.
   */
  var decodeContentBlockNodes = function decodeContentBlockNodes(blocks, entityMap) {
    return blocks
    // ensure children have valid keys to enable sibling links
    .map(addKeyIfMissing).reduce(function (blockMap, block, index) {
      !Array.isArray(block.children) ? invariant_1(false) : void 0;

      // ensure children have valid keys to enable sibling links
      var children = block.children.map(addKeyIfMissing);

      // root level nodes
      var contentBlockNode = new ContentBlockNode_1(_extends$8({}, decodeBlockNodeConfig(block, entityMap), {
        prevSibling: index === 0 ? null : blocks[index - 1].key,
        nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,
        children: List$d(children.map(function (child) {
          return child.key;
        }))
      }));

      // push root node to blockMap
      blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);

      // this stack is used to ensure we visit all nodes respecting depth ordering
      var stack = updateNodeStack([], children, contentBlockNode);

      // start computing children nodes
      while (stack.length > 0) {
        // we pop from the stack and start processing this node
        var node = stack.pop();

        // parentRef already points to a converted ContentBlockNode
        var parentRef = node.parentRef;
        var siblings = parentRef.getChildKeys();
        var _index = siblings.indexOf(node.key);
        var isValidBlock = Array.isArray(node.children);

        if (!isValidBlock) {
          !isValidBlock ? invariant_1(false) : void 0;
          break;
        }

        // ensure children have valid keys to enable sibling links
        var _children = node.children.map(addKeyIfMissing);

        var _contentBlockNode = new ContentBlockNode_1(_extends$8({}, decodeBlockNodeConfig(node, entityMap), {
          parent: parentRef.getKey(),
          children: List$d(_children.map(function (child) {
            return child.key;
          })),
          prevSibling: _index === 0 ? null : siblings.get(_index - 1),
          nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)
        }));

        // push node to blockMap
        blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);

        // this stack is used to ensure we visit all nodes respecting depth ordering
        stack = updateNodeStack(stack, _children, _contentBlockNode);
      }

      return blockMap;
    }, OrderedMap$4());
  };

  var decodeContentBlocks = function decodeContentBlocks(blocks, entityMap) {
    return OrderedMap$4(blocks.map(function (block) {
      var contentBlock = new ContentBlock_1(decodeBlockNodeConfig(block, entityMap));
      return [contentBlock.getKey(), contentBlock];
    }));
  };

  var decodeRawBlocks = function decodeRawBlocks(rawState, entityMap) {
    var isTreeRawBlock = Array.isArray(rawState.blocks[0].children);
    var rawBlocks = rawState.blocks;

    {
      return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter_1.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);
    }

    return decodeContentBlockNodes(rawBlocks, entityMap);
  };

  var decodeRawEntityMap = function decodeRawEntityMap(rawState) {
    var rawEntityMap = rawState.entityMap;

    var entityMap = {};

    // TODO: Update this once we completely remove DraftEntity
    Object.keys(rawEntityMap).forEach(function (rawEntityKey) {
      var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey],
          type = _rawEntityMap$rawEnti.type,
          mutability = _rawEntityMap$rawEnti.mutability,
          data = _rawEntityMap$rawEnti.data;

      // get the key reference to created entity

      entityMap[rawEntityKey] = DraftEntity_1.__create(type, mutability, data || {});
    });

    return entityMap;
  };

  var convertFromRawToDraftState = function convertFromRawToDraftState(rawState) {
    !Array.isArray(rawState.blocks) ? invariant_1(false) : void 0;

    // decode entities
    var entityMap = decodeRawEntityMap(rawState);

    // decode blockMap
    var blockMap = decodeRawBlocks(rawState, entityMap);

    // create initial selection
    var selectionState = blockMap.isEmpty() ? new SelectionState_1() : SelectionState_1.createEmpty(blockMap.first().getKey());

    return new ContentState_1({
      blockMap: blockMap,
      entityMap: entityMap,
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  };

  var convertFromRawToDraftState_1 = convertFromRawToDraftState;

  /**
   * Like range.getBoundingClientRect() but normalizes for browser bugs.
   */
  function getRangeBoundingClientRect(range) {
    // "Return a DOMRect object describing the smallest rectangle that includes
    // the first rectangle in list and all of the remaining rectangles of which
    // the height or width is not zero."
    // http://www.w3.org/TR/cssom-view/#dom-range-getboundingclientrect
    var rects = getRangeClientRects_1(range);
    var top = 0;
    var right = 0;
    var bottom = 0;
    var left = 0;

    if (rects.length) {
      // If the first rectangle has 0 width, we use the second, this is needed
      // because Chrome renders a 0 width rectangle when the selection contains
      // a line break.
      if (rects.length > 1 && rects[0].width === 0) {
        var _rects$ = rects[1];
        top = _rects$.top;
        right = _rects$.right;
        bottom = _rects$.bottom;
        left = _rects$.left;
      } else {
        var _rects$2 = rects[0];
        top = _rects$2.top;
        right = _rects$2.right;
        bottom = _rects$2.bottom;
        left = _rects$2.left;
      }

      for (var ii = 1; ii < rects.length; ii++) {
        var rect = rects[ii];
        if (rect.height !== 0 && rect.width !== 0) {
          top = Math.min(top, rect.top);
          right = Math.max(right, rect.right);
          bottom = Math.max(bottom, rect.bottom);
          left = Math.min(left, rect.left);
        }
      }
    }

    return {
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      width: right - left,
      height: bottom - top
    };
  }

  var getRangeBoundingClientRect_1 = getRangeBoundingClientRect;

  /**
   * Return the bounding ClientRect for the visible DOM selection, if any.
   * In cases where there are no selected ranges or the bounding rect is
   * temporarily invalid, return null.
   */
  function getVisibleSelectionRect(global) {
    var selection = global.getSelection();
    if (!selection.rangeCount) {
      return null;
    }

    var range = selection.getRangeAt(0);
    var boundingRect = getRangeBoundingClientRect_1(range);
    var top = boundingRect.top,
        right = boundingRect.right,
        bottom = boundingRect.bottom,
        left = boundingRect.left;

    // When a re-render leads to a node being removed, the DOM selection will
    // temporarily be placed on an ancestor node, which leads to an invalid
    // bounding rect. Discard this state.

    if (top === 0 && right === 0 && bottom === 0 && left === 0) {
      return null;
    }

    return boundingRect;
  }

  var getVisibleSelectionRect_1 = getVisibleSelectionRect;

  var DraftPublic = {
    Editor: DraftEditor_react,
    EditorBlock: DraftEditorBlock_react,
    EditorState: EditorState_1,

    CompositeDecorator: CompositeDraftDecorator_1,
    Entity: DraftEntity_1,
    EntityInstance: DraftEntityInstance_1,

    BlockMapBuilder: BlockMapBuilder_1,
    CharacterMetadata: CharacterMetadata_1,
    ContentBlock: ContentBlock_1,
    ContentState: ContentState_1,
    SelectionState: SelectionState_1,

    AtomicBlockUtils: AtomicBlockUtils_1,
    KeyBindingUtil: KeyBindingUtil_1,
    Modifier: DraftModifier_1,
    RichUtils: RichTextEditorUtil_1,

    DefaultDraftBlockRenderMap: DefaultDraftBlockRenderMap_1,
    DefaultDraftInlineStyle: DefaultDraftInlineStyle,

    convertFromHTML: convertFromHTMLToContentBlocks,
    convertFromRaw: convertFromRawToDraftState_1,
    convertToRaw: convertFromDraftStateToRaw_1,
    genKey: generateRandomKey_1,
    getDefaultKeyBinding: getDefaultKeyBinding_1,
    getVisibleSelectionRect: getVisibleSelectionRect_1
  };

  var Draft = DraftPublic;
  var Draft_1 = Draft.convertToRaw;
  var Draft_2 = Draft.convertFromRaw;
  var Draft_3 = Draft.CompositeDecorator;
  var Draft_4 = Draft.EditorState;
  var Draft_5 = Draft.RichUtils;
  var Draft_6 = Draft.Editor;
  var Draft_7 = Draft.Modifier;
  var Draft_8 = Draft.AtomicBlockUtils;
  var Draft_9 = Draft.ContentState;

  var Draft$1 = /*#__PURE__*/Object.freeze({
    'default': Draft,
    __moduleExports: Draft,
    convertToRaw: Draft_1,
    convertFromRaw: Draft_2,
    CompositeDecorator: Draft_3,
    EditorState: Draft_4,
    RichUtils: Draft_5,
    Editor: Draft_6,
    Modifier: Draft_7,
    AtomicBlockUtils: Draft_8,
    ContentState: Draft_9
  });

  var reactDraftWysiwyg = createCommonjsModule(function (module, exports) {
  !function(e,t){module.exports=t(react,Draft,immutable);}("undefined"!=typeof self?self:commonjsGlobal,function(e,t,n){return function(e){function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o});},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=13)}([function(t,n){t.exports=e;},function(e,t,n){e.exports=n(16)();},function(e,t,n){var o,r,i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};/*!
    Copyright (c) 2016 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  !function(){function a(){for(var e=[],t=0;t<arguments.length;t++){var n=arguments[t];if(n){var o=void 0===n?"undefined":i(n);if("string"===o||"number"===o)e.push(n);else if(Array.isArray(n))e.push(a.apply(null,n));else if("object"===o)for(var r in n)l.call(n,r)&&n[r]&&e.push(r);}}return e.join(" ")}var l={}.hasOwnProperty;void 0!==e&&e.exports?e.exports=a:"object"===i(n(10))&&n(10)?(o=[],void 0!==(r=function(){return a}.apply(t,o))&&(e.exports=r)):window.classNames=a;}();},function(e,n){e.exports=t;},function(e,t,n){!function(t,o){e.exports=o(n(3),n(9));}("undefined"!=typeof self&&self,function(e,t){return function(e){function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o});},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=3)}([function(t,n){t.exports=e;},function(e,t,n){function o(e){var t=e.getSelection(),n=e.getCurrentContent(),o=t.getStartKey(),r=t.getEndKey(),i=n.getBlockMap();return i.toSeq().skipUntil(function(e,t){return t===o}).takeUntil(function(e,t){return t===r}).concat([[r,i.get(r)]])}function r(e){return o(e).toList()}function i(e){if(e)return r(e).get(0)}function a(e){if(e){var t=i(e),n=e.getCurrentContent(),o=n.getBlockMap().toSeq().toList(),r=0;if(o.forEach(function(e,n){e.get("key")===t.get("key")&&(r=n-1);}),r>-1)return o.get(r)}}function l(e){return e?e.getCurrentContent().getBlockMap().toList():new h.List}function c(e){var t=r(e);if(!t.some(function(e){return e.type!==t.get(0).type}))return t.get(0).type}function s(e){var t=y.RichUtils.tryToRemoveBlockStyle(e);return t?y.EditorState.push(e,t,"change-block-type"):e}function u(e){var t="",n=e.getSelection(),o=n.getAnchorOffset(),i=n.getFocusOffset(),a=r(e);if(a.size>0){if(n.getIsBackward()){var l=o;o=i,i=l;}for(var c=0;c<a.size;c+=1){var s=0===c?o:0,u=c===a.size-1?i:a.get(c).getText().length;t+=a.get(c).getText().slice(s,u);}}return t}function d(e){var t=e.getCurrentContent(),n=e.getSelection(),o=y.Modifier.removeRange(t,n,"forward"),r=o.getSelectionAfter(),i=o.getBlockForKey(r.getStartKey());return o=y.Modifier.insertText(o,r,"\n",i.getInlineStyleAt(r.getStartOffset()),null),y.EditorState.push(e,o,"insert-fragment")}function p(e){var t=y.Modifier.splitBlock(e.getCurrentContent(),e.getSelection());return s(y.EditorState.push(e,t,"split-block"))}function f(e){var t=e.getCurrentContent().getBlockMap().toList(),n=e.getSelection().merge({anchorKey:t.first().get("key"),anchorOffset:0,focusKey:t.last().get("key"),focusOffset:t.last().getLength()}),o=y.Modifier.removeRange(e.getCurrentContent(),n,"forward");return y.EditorState.push(e,o,"remove-range")}function m(e,t){var n=y.Modifier.setBlockData(e.getCurrentContent(),e.getSelection(),t);return y.EditorState.push(e,n,"change-block-data")}function g(e){var t=new h.Map({}),n=r(e);if(n&&n.size>0)for(var o=0;o<n.size;o+=1){var i=function(e){var o=n.get(e).getData();if(!o||0===o.size)return t=t.clear(),"break";if(0===e)t=o;else if(t.forEach(function(e,n){o.get(n)&&o.get(n)===e||(t=t.delete(n));}),0===t.size)return t=t.clear(),"break"}(o);if("break"===i)break}return t}Object.defineProperty(t,"__esModule",{value:!0}),t.blockRenderMap=void 0,t.getSelectedBlocksMap=o,t.getSelectedBlocksList=r,t.getSelectedBlock=i,t.getBlockBeforeSelectedBlock=a,t.getAllBlocks=l,t.getSelectedBlocksType=c,t.removeSelectedBlocksStyle=s,t.getSelectionText=u,t.addLineBreakRemovingSelection=d,t.insertNewUnstyledBlock=p,t.clearEditorContent=f,t.setBlockData=m,t.getSelectedBlocksMetadata=g;var y=n(0),h=n(6),M=(0, h.Map)({code:{element:"pre"}});t.blockRenderMap=y.DefaultDraftBlockRenderMap.merge(M);},function(e,t,n){function o(e){if(e){var t=e.getType();return "unordered-list-item"===t||"ordered-list-item"===t}return !1}function r(e,t,n){var o=e.getSelection(),r=e.getCurrentContent(),i=r.getBlockMap(),a=(0, l.getSelectedBlocksMap)(e).map(function(e){var o=e.getDepth()+t;return o=Math.max(0,Math.min(o,n)),e.set("depth",o)});return i=i.merge(a),r.merge({blockMap:i,selectionBefore:o,selectionAfter:o})}function i(e,t,n){var o=e.getSelection(),i=void 0;i=o.getIsBackward()?o.getFocusKey():o.getAnchorKey();var l=e.getCurrentContent(),c=l.getBlockForKey(i),s=c.getType();if("unordered-list-item"!==s&&"ordered-list-item"!==s)return e;var u=l.getBlockBefore(i);if(!u)return e;if(u.getType()!==s)return e;var d=c.getDepth();if(1===t&&d===n)return e;var p=Math.min(u.getDepth()+1,n),f=r(e,t,p);return a.EditorState.push(e,f,"adjust-depth")}Object.defineProperty(t,"__esModule",{value:!0}),t.isListBlock=o,t.changeDepth=i;var a=n(0),l=n(1);},function(e,t,n){e.exports=n(4);},function(e,t,n){var o=n(5),r=n(1),i=n(7),a=function(e){return e&&e.__esModule?e:{default:e}}(i),l=n(2);e.exports={getSelectedBlocksMap:r.getSelectedBlocksMap,getSelectedBlocksList:r.getSelectedBlocksList,getSelectedBlock:r.getSelectedBlock,getBlockBeforeSelectedBlock:r.getBlockBeforeSelectedBlock,getAllBlocks:r.getAllBlocks,getSelectedBlocksType:r.getSelectedBlocksType,removeSelectedBlocksStyle:r.removeSelectedBlocksStyle,getSelectionText:r.getSelectionText,addLineBreakRemovingSelection:r.addLineBreakRemovingSelection,insertNewUnstyledBlock:r.insertNewUnstyledBlock,clearEditorContent:r.clearEditorContent,setBlockData:r.setBlockData,getSelectedBlocksMetadata:r.getSelectedBlocksMetadata,blockRenderMap:r.blockRenderMap,getEntityRange:o.getEntityRange,getCustomStyleMap:o.getCustomStyleMap,toggleCustomInlineStyle:o.toggleCustomInlineStyle,getSelectionEntity:o.getSelectionEntity,extractInlineStyle:o.extractInlineStyle,removeAllInlineStyles:o.removeAllInlineStyles,getSelectionInlineStyle:o.getSelectionInlineStyle,getSelectionCustomInlineStyle:o.getSelectionCustomInlineStyle,handleNewLine:a.default,isListBlock:l.isListBlock,changeDepth:l.changeDepth};},function(e,t,n){function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e){var t=e.getSelection();if(t.isCollapsed()){var n={},o=e.getCurrentInlineStyle().toList().toJS();if(o)return ["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT"].forEach(function(e){n[e]=o.indexOf(e)>=0;}),n}var r=t.getStartOffset(),i=t.getEndOffset(),a=(0, y.getSelectedBlocksList)(e);if(a.size>0){var l=function(){for(var e={BOLD:!0,ITALIC:!0,UNDERLINE:!0,STRIKETHROUGH:!0,CODE:!0,SUPERSCRIPT:!0,SUBSCRIPT:!0},t=0;t<a.size;t+=1){var n=0===t?r:0,o=t===a.size-1?i:a.get(t).getText().length;n===o&&0===n?(n=1,o=2):n===o&&(n-=1);for(var l=n;l<o;l+=1)!function(n){var o=a.get(t).getInlineStyleAt(n);["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT"].forEach(function(t){e[t]=e[t]&&o.get(t)===t;});}(l);}return {v:e}}();if("object"===(void 0===l?"undefined":m(l)))return l.v}return {}}function i(e){var t=void 0,n=e.getSelection(),o=n.getStartOffset(),r=n.getEndOffset();o===r&&0===o?r=1:o===r&&(o-=1);for(var i=(0, y.getSelectedBlock)(e),a=o;a<r;a+=1){var l=i.getEntityAt(a);if(!l){t=void 0;break}if(a===o)t=l;else if(t!==l){t=void 0;break}}return t}function a(e,t){var n=(0, y.getSelectedBlock)(e),o=void 0;return n.findEntityRanges(function(e){return e.get("entity")===t},function(e,t){o={start:e,end:t,text:n.get("text").slice(e,t)};}),o}function l(e,t,n){var o=e.getSelection(),r=Object.keys(h[t]).reduce(function(e,t){return g.Modifier.removeInlineStyle(e,o,t)},e.getCurrentContent()),i=g.EditorState.push(e,r,"changeinline-style"),a=e.getCurrentInlineStyle();if(o.isCollapsed()&&(i=a.reduce(function(e,t){return g.RichUtils.toggleInlineStyle(e,t)},i)),"SUPERSCRIPT"===t||"SUBSCRIPT"==t)a.has(n)||(i=g.RichUtils.toggleInlineStyle(i,n));else{var l="bgcolor"===t?"backgroundColor":t;a.has(l+"-"+n)||(i=g.RichUtils.toggleInlineStyle(i,t.toLowerCase()+"-"+n),M(t,l,n));}return i}function c(e){e&&e.getCurrentContent().getBlockMap().map(function(e){return e.get("characterList")}).toList().flatten().forEach(function(e){e&&0===e.indexOf("color-")?M("color","color",e.substr(6)):e&&0===e.indexOf("bgcolor-")?M("bgcolor","backgroundColor",e.substr(8)):e&&0===e.indexOf("fontsize-")?M("fontSize","fontSize",+e.substr(9)):e&&0===e.indexOf("fontfamily-")&&M("fontFamily","fontFamily",e.substr(11));});}function s(e,t,n){var o=e.getInlineStyleAt(n).toList(),r=o.filter(function(e){return e.startsWith(t.toLowerCase())});if(r&&r.size>0)return r.get(0)}function u(e,t){var n=e.getCurrentInlineStyle().toList(),o=n.filter(function(e){return e.startsWith(t.toLowerCase())});if(o&&o.size>0)return o.get(0)}function d(e,t){if(e&&t&&t.length>0){var n=function(){var n=e.getSelection(),o={};if(n.isCollapsed())return t.forEach(function(t){o[t]=u(e,t);}),{v:o};var r=n.getStartOffset(),i=n.getEndOffset(),a=(0, y.getSelectedBlocksList)(e);if(a.size>0){for(var l=0;l<a.size;l+=1)!function(e){var n=0===e?r:0,l=e===a.size-1?i:a.get(e).getText().length;n===l&&0===n?(n=1,l=2):n===l&&(n-=1);for(var c=n;c<l;c+=1)!function(r){r===n?t.forEach(function(t){o[t]=s(a.get(e),t,r);}):t.forEach(function(t){o[t]&&o[t]!==s(a.get(e),t,r)&&(o[t]=void 0);});}(c);}(l);return {v:o}}}();if("object"===(void 0===n?"undefined":m(n)))return n.v}return {}}function p(e){var t=e.getCurrentInlineStyle(),n=e.getCurrentContent();return t.forEach(function(t){n=g.Modifier.removeInlineStyle(n,e.getSelection(),t);}),g.EditorState.push(e,n,"change-inline-style")}Object.defineProperty(t,"__esModule",{value:!0}),t.getCustomStyleMap=void 0;var f=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},m="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};t.getSelectionInlineStyle=r,t.getSelectionEntity=i,t.getEntityRange=a,t.toggleCustomInlineStyle=l,t.extractInlineStyle=c,t.getSelectionCustomInlineStyle=d,t.removeAllInlineStyles=p;var g=n(0),y=n(1),h={color:{},bgcolor:{},fontSize:{},fontFamily:{},CODE:{fontFamily:"monospace",wordWrap:"break-word",background:"#f1f1f1",borderRadius:3,padding:"1px 3px"},SUPERSCRIPT:{fontSize:11,position:"relative",top:-8,display:"inline-flex"},SUBSCRIPT:{fontSize:11,position:"relative",bottom:-8,display:"inline-flex"}},M=function(e,t,n){h[e][e.toLowerCase()+"-"+n]=o({},""+t,n);};t.getCustomStyleMap=function(){return f({},h.color,h.bgcolor,h.fontSize,h.fontFamily,{CODE:h.CODE,SUPERSCRIPT:h.SUPERSCRIPT,SUBSCRIPT:h.SUBSCRIPT})};},function(e,n){e.exports=t;},function(e,t,n){function o(e){var t=e.getSelection();if(t.isCollapsed()){var n=e.getCurrentContent(),o=t.getStartKey(),r=n.getBlockForKey(o);if(!(0, c.isListBlock)(r)&&"unstyled"!==r.getType()&&r.getLength()===t.getStartOffset())return (0, l.insertNewUnstyledBlock)(e);if((0, c.isListBlock)(r)&&0===r.getLength()){var i=r.getDepth();if(0===i)return (0, l.removeSelectedBlocksStyle)(e);if(i>0)return (0, c.changeDepth)(e,-1,i)}}}function r(e){return 13===e.which&&(e.getModifierState("Shift")||e.getModifierState("Alt")||e.getModifierState("Control"))}function i(e,t){return r(t)?e.getSelection().isCollapsed()?a.RichUtils.insertSoftNewline(e):(0, l.addLineBreakRemovingSelection)(e):o(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=i;var a=n(0),l=n(1),c=n(2);}])});},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),u=o(s),d=n(1),p=o(d),f=n(2),m=o(f);n(29);var g=function(e){function t(){var e,n,o,r;i(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=a(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.onClick=function(){var e=o.props,t=e.disabled,n=e.onClick,r=e.value;t||n(r);},r=n,a(o,r)}return l(t,e),c(t,[{key:"render",value:function(){var e,t=this.props,n=t.children,o=t.className,i=t.activeClassName,a=t.active,l=t.disabled,c=t.title;return u.default.createElement("div",{className:(0, m.default)("rdw-option-wrapper",o,(e={},r(e,"rdw-option-active "+i,a),r(e,"rdw-option-disabled",l),e)),onClick:this.onClick,"aria-selected":a,title:c},n)}}]),t}(s.Component);g.propTypes={onClick:p.default.func.isRequired,children:p.default.any,value:p.default.string,className:p.default.string,activeClassName:p.default.string,active:p.default.bool,disabled:p.default.bool,title:p.default.string},g.defaultProps={activeClassName:""},t.default=g;},function(e,t,n){function o(e,t){if(e)for(var n in e)({}).hasOwnProperty.call(e,n)&&t(n,e[n]);}function r(e,t){var n=!1;if(e)for(var o in e)if({}.hasOwnProperty.call(e,o)&&t===o){n=!0;break}return n}function i(e){return !e||!e.trim()}function a(e){return "[object Object]"===Object.prototype.toString.call(e)}function l(e,t){var n=Object.keys(e).filter(function(e){return t.indexOf(e)<0}),o={};return n&&n.length>0&&n.forEach(function(t){o[t]=e[t];}),o}function c(e){e.stopPropagation();}Object.defineProperty(t,"__esModule",{value:!0}),t.forEach=o,t.hasProperty=r,t.isEmptyString=i,t.isMap=a,t.filter=l,t.stopPropagation=c;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}var r=n(30),i=o(r),a=n(32),l=o(a);e.exports={Dropdown:i.default,DropdownOption:l.default};},function(e,t,n){var o=n(6),r=function(e){return e[e.options[0]].icon},i=function e(t,n){if(t&&void 0===n)return t;var r={};return (0, o.forEach)(t,function(t,i){(0, o.isMap)(i)?r[t]=e(i,n[t]):r[t]=void 0!==n[t]?n[t]:i;}),r};e.exports={getFirstIcon:r,mergeRecursive:i};},function(e,t){e.exports=n;},function(e,t){(function(t){e.exports=t;}).call(t,{});},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var o=[];t.default={onKeyDown:function(e){o.forEach(function(t){t(e);});},registerCallBack:function(e){o.push(e);},deregisterCallBack:function(e){o=o.filter(function(t){return t!==e});}};},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var o=void 0;t.default={open:function(){o=!0;},close:function(){o=!1;},isOpen:function(){return o}};},function(e,t,n){e.exports=n(14);},function(e,t,n){var o=n(15),r=function(e){return e&&e.__esModule?e:{default:e}}(o);e.exports={Editor:r.default};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}return Array.from(e)}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),u=n(0),d=o(u),p=n(1),f=o(p),m=n(3),g=n(4),y=n(2),h=o(y),M=n(20),b=o(M),j=n(21),w=o(j),k=n(11),N=o(k),C=n(12),E=o(C),L=n(22),D=o(L),S=n(8),v=n(6),x=n(23),I=n(26),A=o(I),T=n(79),O=o(T),_=n(82),z=o(_),P=n(88),U=o(P),F=n(90),B=o(F),Y=n(94),R=o(Y),Q=n(120),H=o(Q);n(135),n(136);var Z=function(e){function t(e){i(this,t);var n=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));W.call(n);var o=(0, S.mergeRecursive)(R.default,e.toolbar);n.state={editorState:void 0,editorFocused:!1,toolbar:o};var r=e.wrapperId?e.wrapperId:Math.floor(1e4*Math.random());return n.wrapperId="rdw-wrapper-"+r,n.modalHandler=new b.default,n.focusHandler=new w.default,n.blockRendererFn=(0, B.default)({isReadOnly:n.isReadOnly,isImageAlignmentEnabled:n.isImageAlignmentEnabled,getEditorState:n.getEditorState,onChange:n.onChange},e.customBlockRenderFunc),n.editorProps=n.filterEditorProps(e),n.customStyleMap=n.getStyleMap(e),n}return l(t,e),s(t,[{key:"componentWillMount",value:function(){this.compositeDecorator=this.getCompositeDecorator();var e=this.createEditorState(this.compositeDecorator);(0, g.extractInlineStyle)(e),this.setState({editorState:e});}},{key:"componentDidMount",value:function(){this.modalHandler.init(this.wrapperId);}},{key:"componentWillReceiveProps",value:function(e){var t={};if(this.props.toolbar!==e.toolbar){var n=(0, S.mergeRecursive)(R.default,e.toolbar);t.toolbar=n;}if((0, v.hasProperty)(e,"editorState")&&this.props.editorState!==e.editorState)e.editorState?t.editorState=m.EditorState.set(e.editorState,{decorator:this.compositeDecorator}):t.editorState=m.EditorState.createEmpty(this.compositeDecorator);else if((0, v.hasProperty)(e,"contentState")&&this.props.contentState!==e.contentState)if(e.contentState){var o=this.changeEditorState(e.contentState);o&&(t.editorState=o);}else t.editorState=m.EditorState.createEmpty(this.compositeDecorator);e.editorState===this.props.editorState&&e.contentState===this.props.contentState||(0, g.extractInlineStyle)(t.editorState),this.setState(t),this.editorProps=this.filterEditorProps(e),this.customStyleMap=this.getStyleMap(e);}},{key:"render",value:function(){var e=this.state,t=e.editorState,n=e.editorFocused,o=e.toolbar,r=this.props,i=r.locale,a=r.localization,l=a.locale,s=a.translations,u=r.toolbarCustomButtons,p=r.toolbarOnFocus,f=r.toolbarClassName,y=r.toolbarHidden,M=r.editorClassName,b=r.wrapperClassName,j=r.toolbarStyle,w=r.editorStyle,k=r.wrapperStyle,C=r.uploadCallback,E=r.ariaLabel,L={modalHandler:this.modalHandler,editorState:t,onChange:this.onChange,translations:c({},H.default[i||l],s)},S=n||this.focusHandler.isInputFocused()||!p;return d.default.createElement("div",{id:this.wrapperId,className:(0, h.default)(b,"rdw-editor-wrapper"),style:k,onClick:this.modalHandler.onEditorClick,onBlur:this.onWrapperBlur,"aria-label":"rdw-wrapper"},!y&&d.default.createElement("div",{className:(0, h.default)("rdw-editor-toolbar",f),style:c({visibility:S?"visible":"hidden"},j),onMouseDown:this.preventDefault,"aria-label":"rdw-toolbar","aria-hidden":(!n&&p).toString(),onFocus:this.onToolbarFocus},o.options.map(function(e,t){var n=A.default[e],r=o[e];return "image"===e&&C&&(r.uploadCallback=C),d.default.createElement(n,c({key:t},L,{config:r}))}),u&&u.map(function(e,t){return d.default.cloneElement(e,c({key:t},L))})),d.default.createElement("div",{ref:this.setWrapperReference,className:(0, h.default)(M,"rdw-editor-main"),style:w,onClick:this.focusEditor,onFocus:this.onEditorFocus,onBlur:this.onEditorBlur,onKeyDown:N.default.onKeyDown,onMouseDown:this.onEditorMouseDown},d.default.createElement(m.Editor,c({ref:this.setEditorReference,onTab:this.onTab,onUpArrow:this.onUpDownArrow,onDownArrow:this.onUpDownArrow,editorState:t,onChange:this.onChange,blockStyleFn:D.default,customStyleMap:this.getStyleMap(this.props),handleReturn:this.handleReturn,handlePastedText:this.handlePastedText,blockRendererFn:this.blockRendererFn,handleKeyCommand:this.handleKeyCommand,ariaLabel:E||"rdw-editor",blockRenderMap:g.blockRenderMap},this.editorProps))))}}]),t}(u.Component);Z.propTypes={onChange:f.default.func,onEditorStateChange:f.default.func,onContentStateChange:f.default.func,initialContentState:f.default.object,defaultContentState:f.default.object,contentState:f.default.object,editorState:f.default.object,defaultEditorState:f.default.object,toolbarOnFocus:f.default.bool,spellCheck:f.default.bool,stripPastedStyles:f.default.bool,toolbar:f.default.object,toolbarCustomButtons:f.default.array,toolbarClassName:f.default.string,toolbarHidden:f.default.bool,locale:f.default.string,localization:f.default.object,editorClassName:f.default.string,wrapperClassName:f.default.string,toolbarStyle:f.default.object,editorStyle:f.default.object,wrapperStyle:f.default.object,uploadCallback:f.default.func,onFocus:f.default.func,onBlur:f.default.func,onTab:f.default.func,mention:f.default.object,hashtag:f.default.object,textAlignment:f.default.string,readOnly:f.default.bool,tabIndex:f.default.number,placeholder:f.default.string,ariaLabel:f.default.string,ariaOwneeID:f.default.string,ariaActiveDescendantID:f.default.string,ariaAutoComplete:f.default.string,ariaDescribedBy:f.default.string,ariaExpanded:f.default.string,ariaHasPopup:f.default.string,customBlockRenderFunc:f.default.func,wrapperId:f.default.number,customDecorators:f.default.array,editorRef:f.default.func},Z.defaultProps={toolbarOnFocus:!1,toolbarHidden:!1,stripPastedStyles:!1,localization:{locale:"en",translations:{}},customDecorators:[]};var W=function(){var e=this;this.onEditorBlur=function(){e.setState({editorFocused:!1});},this.onEditorFocus=function(t){var n=e.props.onFocus;e.setState({editorFocused:!0});var o=e.focusHandler.isEditorFocused();n&&o&&n(t);},this.onEditorMouseDown=function(){e.focusHandler.onEditorMouseDown();},this.onTab=function(t){var n=e.props.onTab;if(!n||!n(t)){var o=(0, g.changeDepth)(e.state.editorState,t.shiftKey?-1:1,4);o&&o!==e.state.editorState&&(e.onChange(o),t.preventDefault());}},this.onUpDownArrow=function(e){E.default.isOpen()&&e.preventDefault();},this.onToolbarFocus=function(t){var n=e.props.onFocus;n&&e.focusHandler.isToolbarFocused()&&n(t);},this.onWrapperBlur=function(t){var n=e.props.onBlur;n&&e.focusHandler.isEditorBlur(t)&&n(t,e.getEditorState());},this.onChange=function(t){var n=e.props,o=n.readOnly,r=n.onEditorStateChange;o||"atomic"===(0, g.getSelectedBlocksType)(t)&&t.getSelection().isCollapsed||(r&&r(t,e.props.wrapperId),(0, v.hasProperty)(e.props,"editorState")?e.afterChange(t):e.setState({editorState:t},e.afterChange(t)));},this.setWrapperReference=function(t){e.wrapper=t;},this.setEditorReference=function(t){e.props.editorRef&&e.props.editorRef(t),e.editor=t;},this.getCompositeDecorator=function(){var t=[].concat(r(e.props.customDecorators),[(0, O.default)({showOpenOptionOnHover:e.state.toolbar.link.showOpenOptionOnHover})]);return e.props.mention&&t.push.apply(t,r((0, z.default)(c({},e.props.mention,{onChange:e.onChange,getEditorState:e.getEditorState,getSuggestions:e.getSuggestions,getWrapperRef:e.getWrapperRef,modalHandler:e.modalHandler})))),e.props.hashtag&&t.push((0, U.default)(e.props.hashtag)),new m.CompositeDecorator(t)},this.getWrapperRef=function(){return e.wrapper},this.getEditorState=function(){return e.state.editorState},this.getSuggestions=function(){return e.props.mention&&e.props.mention.suggestions},this.afterChange=function(t){setTimeout(function(){var n=e.props,o=n.onChange,r=n.onContentStateChange;o&&o((0, m.convertToRaw)(t.getCurrentContent())),r&&r((0, m.convertToRaw)(t.getCurrentContent()));});},this.isReadOnly=function(){return e.props.readOnly},this.isImageAlignmentEnabled=function(){return e.state.toolbar.image.alignmentEnabled},this.createEditorState=function(t){var n=void 0;if((0, v.hasProperty)(e.props,"editorState"))e.props.editorState&&(n=m.EditorState.set(e.props.editorState,{decorator:t}));else if((0, v.hasProperty)(e.props,"defaultEditorState"))e.props.defaultEditorState&&(n=m.EditorState.set(e.props.defaultEditorState,{decorator:t}));else if((0, v.hasProperty)(e.props,"contentState")){if(e.props.contentState){var o=(0, m.convertFromRaw)(e.props.contentState);n=m.EditorState.createWithContent(o,t),n=m.EditorState.moveSelectionToEnd(n);}}else if((0, v.hasProperty)(e.props,"defaultContentState")||(0, v.hasProperty)(e.props,"initialContentState")){var r=e.props.defaultContentState||e.props.initialContentState;r&&(r=(0, m.convertFromRaw)(r),n=m.EditorState.createWithContent(r,t),n=m.EditorState.moveSelectionToEnd(n));}return n||(n=m.EditorState.createEmpty(t)),n},this.filterEditorProps=function(e){return (0, v.filter)(e,["onChange","onEditorStateChange","onContentStateChange","initialContentState","defaultContentState","contentState","editorState","defaultEditorState","locale","localization","toolbarOnFocus","toolbar","toolbarCustomButtons","toolbarClassName","editorClassName","toolbarHidden","wrapperClassName","toolbarStyle","editorStyle","wrapperStyle","uploadCallback","onFocus","onBlur","onTab","mention","hashtag","ariaLabel","customBlockRenderFunc","customDecorators","handlePastedText","customStyleMap"])},this.getStyleMap=function(e){return c({},(0, g.getCustomStyleMap)(),e.customStyleMap)},this.changeEditorState=function(t){var n=(0, m.convertFromRaw)(t),o=e.state.editorState;return o=m.EditorState.push(o,n,"insert-characters"),o=m.EditorState.moveSelectionToEnd(o)},this.focusEditor=function(){setTimeout(function(){e.editor.focus();});},this.handleKeyCommand=function(t){var n=e.state,o=n.editorState,r=n.toolbar.inline;if(r&&r.options.indexOf(t)>=0){var i=m.RichUtils.handleKeyCommand(o,t);if(i)return e.onChange(i),!0}return !1},this.handleReturn=function(t){if(E.default.isOpen())return !0;var n=(0, g.handleNewLine)(e.state.editorState,t);return !!n&&(e.onChange(n),!0)},this.handlePastedText=function(t,n){var o=e.state.editorState;return e.props.handlePastedText?e.props.handlePastedText(t,n,o,e.onChange):!e.props.stripPastedStyles&&(0, x.handlePastedText)(t,n,o,e.onChange)},this.preventDefault=function(t){"INPUT"===t.target.tagName||"LABEL"===t.target.tagName||"TEXTAREA"===t.target.tagName?e.focusHandler.onInputMouseDown():t.preventDefault();};};t.default=Z;},function(e,t,n){var o=n(17),r=n(18),i=n(19);e.exports=function(){function e(e,t,n,o,a,l){l!==i&&r(!1,"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");}function t(){return e}e.isRequired=e;var n={array:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t};return n.checkPropTypes=o,n.PropTypes=n,n};},function(e,t,n){function o(e){return function(){return e}}var r=function(){};r.thatReturns=o,r.thatReturnsFalse=o(!1),r.thatReturnsTrue=o(!0),r.thatReturnsNull=o(null),r.thatReturnsThis=function(){return this},r.thatReturnsArgument=function(e){return e},e.exports=r;},function(e,t,n){function o(e,t,n,o,i,a,l,c){if(!e){var s;if(void 0===t)s=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var u=[n,o,i,a,l,c],d=0;s=new Error(t.replace(/%s/g,function(){return u[d++]})),s.name="Invariant Violation";}throw s.framesToPop=1,s}}e.exports=o;},function(e,t,n){e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var r=function e(){var t=this;o(this,e),this.callBacks=[],this.suggestionCallback=void 0,this.editorFlag=!1,this.suggestionFlag=!1,this.closeAllModals=function(e){t.callBacks.forEach(function(t){t(e);});},this.init=function(e){var n=document.getElementById(e);n&&n.addEventListener("click",function(){t.editorFlag=!0;}),document&&(document.addEventListener("click",function(){t.editorFlag?t.editorFlag=!1:(t.closeAllModals(),t.suggestionCallback&&t.suggestionCallback());}),document.addEventListener("keydown",function(e){"Escape"===e.key&&t.closeAllModals();}));},this.onEditorClick=function(){t.closeModals(),!t.suggestionFlag&&t.suggestionCallback?t.suggestionCallback():t.suggestionFlag=!1;},this.closeModals=function(e){t.closeAllModals(e);},this.registerCallBack=function(e){t.callBacks.push(e);},this.deregisterCallBack=function(e){t.callBacks=t.callBacks.filter(function(t){return t!==e});},this.setSuggestionCallback=function(e){t.suggestionCallback=e;},this.removeSuggestionCallback=function(){t.suggestionCallback=void 0;},this.onSuggestionClick=function(){t.suggestionFlag=!0;};};t.default=r;},function(e,t,n){function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var r=function e(){var t=this;o(this,e),this.inputFocused=!1,this.editorMouseDown=!1,this.onEditorMouseDown=function(){t.editorFocused=!0;},this.onInputMouseDown=function(){t.inputFocused=!0;},this.isEditorBlur=function(e){return "INPUT"!==e.target.tagName&&"LABEL"!==e.target.tagName&&"TEXTAREA"!==e.target.tagName||t.editorFocused?!("INPUT"===e.target.tagName&&"LABEL"===e.target.tagName&&"TEXTAREA"===e.target.tagName||t.inputFocused)&&(t.editorFocused=!1,!0):(t.inputFocused=!1,!0)},this.isEditorFocused=function(){return !t.inputFocused||(t.inputFocused=!1,!1)},this.isToolbarFocused=function(){return !t.editorFocused||(t.editorFocused=!1,!1)},this.isInputFocused=function(){return t.inputFocused};};t.default=r;},function(e,t,n){function o(e){var t=e.getData()&&e.getData().get("text-align");return t?"rdw-"+t+"-aligned-block":""}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.handlePastedText=void 0;var o=n(4),r=n(3),i=n(24),a=function(e){return e&&e.__esModule?e:{default:e}}(i),l=n(9);t.handlePastedText=function(e,t,n,i){var c=(0, o.getSelectedBlock)(n);if(c&&"code"===c.type){var s=r.Modifier.replaceText(n.getCurrentContent(),n.getSelection(),e,n.getCurrentInlineStyle());return i(r.EditorState.push(n,s,"insert-characters")),!0}if(t){var u=(0, a.default)(t),d=n.getCurrentContent();return u.entityMap.forEach(function(e,t){d=d.mergeEntityData(t,e);}),d=r.Modifier.replaceWithFragment(d,n.getSelection(),new l.List(u.contentBlocks)),i(r.EditorState.push(n,d,"insert-characters")),!0}return !1};},function(e,t,n){(function(e){var o,r,i,a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};!function(l,c){"object"==a(t)&&"object"==a(e)?e.exports=c(n(9),n(3)):(r=[n(9),n(3)],o=c,void 0!==(i="function"==typeof o?o.apply(t,r):o)&&(e.exports=i));}("undefined"!=typeof self&&self,function(e,t){return function(e){function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:o});},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=2)}([function(t,n){t.exports=e;},function(e,n){e.exports=t;},function(e,t,n){e.exports=n(3);},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t,n,o,i,a){var c=e.nodeName.toLowerCase();if(a){var s=a(c,e);if(s){var u=l.Entity.__create(s.type,s.mutability,s.data||{});return {chunk:(0, d.getAtomicBlockChunk)(u)}}}if("#text"===c&&"\n"!==e.textContent)return (0, d.createTextChunk)(e,t,i);if("br"===c)return {chunk:(0, d.getSoftNewlineChunk)()};if("img"===c&&e instanceof HTMLImageElement){var p={};p.src=e.getAttribute?e.getAttribute("src")||e.src:e.src,p.alt=e.alt,p.height=e.style.height,p.width=e.style.width,e.style.float&&(p.alignment=e.style.float);var m=l.Entity.__create("IMAGE","MUTABLE",p);return {chunk:(0, d.getAtomicBlockChunk)(m)}}if("iframe"===c&&e instanceof HTMLIFrameElement){var y={};y.src=e.getAttribute?e.getAttribute("src")||e.src:e.src,y.height=e.height,y.width=e.width;var M=l.Entity.__create("EMBEDDED_LINK","MUTABLE",y);return {chunk:(0, d.getAtomicBlockChunk)(M)}}var j=(0, f.default)(c,o),w=void 0;j&&("ul"===c||"ol"===c?(o=c,n+=1):("unordered-list-item"!==j&&"ordered-list-item"!==j&&(o="",n=-1),k?(w=(0, d.getFirstBlockChunk)(j,(0, h.default)(e)),k=!1):w=(0, d.getBlockDividerChunk)(j,n,(0, h.default)(e)))),w||(w=(0, d.getEmptyChunk)()),t=(0, g.default)(c,e,t);for(var N=e.firstChild;N;){var C=(0, b.default)(N),E=r(N,t,n,o,C||i,a),L=E.chunk;w=(0, d.joinChunks)(w,L),N=N.nextSibling;}return {chunk:w}}function i(e,t){var n=e.trim().replace(w,j),o=(0, u.default)(n);return o?(k=!0,{chunk:r(o,new c.OrderedSet,-1,"",void 0,t).chunk}):null}function a(e,t){var n=i(e,t);if(n){var o=n.chunk,r=new c.OrderedMap({});o.entities&&o.entities.forEach(function(e){e&&(r=r.set(e,l.Entity.__get(e)));});var a=0;return {contentBlocks:o.text.split("\r").map(function(e,t){var n=a+e.length,r=o&&o.inlines.slice(a,n),i=o&&o.entities.slice(a,n),s=new c.List(r.map(function(e,t){var n={style:e,entity:null};return i[t]&&(n.entity=i[t]),l.CharacterMetadata.create(n)}));return a=n,new l.ContentBlock({key:(0, l.genKey)(),type:o&&o.blocks[t]&&o.blocks[t].type||"unstyled",depth:o&&o.blocks[t]&&o.blocks[t].depth,data:o&&o.blocks[t]&&o.blocks[t].data||new c.Map({}),text:e,characterList:s})}),entityMap:r}}return null}Object.defineProperty(t,"__esModule",{value:!0}),t.default=a;var l=n(1),c=n(0),s=n(4),u=o(s),d=n(5),p=n(6),f=o(p),m=n(7),g=o(m),y=n(8),h=o(y),M=n(9),b=o(M),j=" ",w=new RegExp("&nbsp;","g"),k=!0;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var o=function(e){var t,n=null;return document.implementation&&document.implementation.createHTMLDocument&&(t=document.implementation.createHTMLDocument("foo"),t.documentElement.innerHTML=e,n=t.getElementsByTagName("body")[0]),n};t.default=o;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.joinChunks=t.getAtomicBlockChunk=t.getBlockDividerChunk=t.getFirstBlockChunk=t.getEmptyChunk=t.getSoftNewlineChunk=t.createTextChunk=t.getWhitespaceChunk=void 0;var o=n(0),r=t.getWhitespaceChunk=function(e){return {text:" ",inlines:[new o.OrderedSet],entities:[e],blocks:[]}};t.createTextChunk=function(e,t,n){var o=e.textContent;return ""===o.trim()?{chunk:r(n)}:{chunk:{text:o,inlines:Array(o.length).fill(t),entities:Array(o.length).fill(n),blocks:[]}}},t.getSoftNewlineChunk=function(){return {text:"\n",inlines:[new o.OrderedSet],entities:new Array(1),blocks:[]}},t.getEmptyChunk=function(){return {text:"",inlines:[],entities:[],blocks:[]}},t.getFirstBlockChunk=function(e,t){return {text:"",inlines:[],entities:[],blocks:[{type:e,depth:0,data:t||new o.Map({})}]}},t.getBlockDividerChunk=function(e,t,n){return {text:"\r",inlines:[],entities:[],blocks:[{type:e,depth:Math.max(0,Math.min(4,t)),data:n||new o.Map({})}]}},t.getAtomicBlockChunk=function(e){return {text:"\r ",inlines:[new o.OrderedSet],entities:[e],blocks:[{type:"atomic",depth:0,data:new o.Map({})}]}},t.joinChunks=function(e,t){return {text:e.text+t.text,inlines:e.inlines.concat(t.inlines),entities:e.entities.concat(t.entities),blocks:e.blocks.concat(t.blocks)}};},function(e,t,n){function o(e,t){var n=i.filter(function(n){return n.element===e&&(!n.wrapper||n.wrapper===t)||n.wrapper===e||n.aliasedElements&&n.aliasedElements.indexOf(e)>-1}).keySeq().toSet().toArray();if(1===n.length)return n[0]}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var r=n(0),i=new r.Map({"header-one":{element:"h1"},"header-two":{element:"h2"},"header-three":{element:"h3"},"header-four":{element:"h4"},"header-five":{element:"h5"},"header-six":{element:"h6"},"unordered-list-item":{element:"li",wrapper:"ul"},"ordered-list-item":{element:"li",wrapper:"ol"},blockquote:{element:"blockquote"},code:{element:"pre"},atomic:{element:"figure"},unstyled:{element:"p",aliasedElements:["div"]}});},function(e,t,n){function o(e,t,n){var o=r[e],i=void 0;if(o)i=n.add(o).toOrderedSet();else if(t instanceof HTMLElement){i=n;var a=t;i=i.withMutations(function(e){var t=a.style.color,n=a.style.backgroundColor,o=a.style.fontSize,r=a.style.fontFamily.replace(/^"|"$/g,"");t&&e.add("color-"+t.replace(/ /g,"")),n&&e.add("bgcolor-"+n.replace(/ /g,"")),o&&e.add("fontsize-"+o.replace(/px$/g,"")),r&&e.add("fontfamily-"+r);}).toOrderedSet();}return i}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var r={code:"CODE",del:"STRIKETHROUGH",em:"ITALIC",strong:"BOLD",ins:"UNDERLINE",sub:"SUBSCRIPT",sup:"SUPERSCRIPT"};},function(e,t,n){function o(e){if(e.style.textAlign)return new r.Map({"text-align":e.style.textAlign})}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var r=n(0);},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var o=n(1),r=function(e){var t=void 0;if(e instanceof HTMLAnchorElement){var n={};e.dataset&&void 0!==e.dataset.mention?(n.url=e.href,n.text=e.innerHTML,n.value=e.dataset.value,t=o.Entity.__create("MENTION","IMMUTABLE",n)):(n.url=e.getAttribute?e.getAttribute("href")||e.href:e.href,n.title=e.innerHTML,n.targetOption=e.target,t=o.Entity.__create("LINK","MUTABLE",n));}return t};t.default=r;}])});}).call(t,n(25)(e));},function(e,t,n){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}var r=n(27),i=o(r),a=n(35),l=o(a),c=n(38),s=o(c),u=n(41),d=o(u),p=n(44),f=o(p),m=n(47),g=o(m),y=n(50),h=o(y),M=n(53),b=o(M),j=n(62),w=o(j),k=n(65),N=o(k),C=n(68),E=o(C),L=n(73),D=o(L),S=n(76),v=o(S);e.exports={inline:i.default,blockType:l.default,fontSize:s.default,fontFamily:d.default,list:f.default,textAlign:g.default,colorPicker:h.default,link:b.default,embedded:w.default,emoji:N.default,image:E.default,remove:D.default,history:v.default};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(4),f=n(3),m=n(6),g=n(28),y=o(g),h=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={currentStyles:{}},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.toggleInlineStyle=function(e){var t="monospace"===e?"CODE":e.toUpperCase(),n=o.props,r=n.editorState,i=n.onChange,a=f.RichUtils.toggleInlineStyle(r,t);if("subscript"===e||"superscript"===e){var l="subscript"===e?"SUPERSCRIPT":"SUBSCRIPT",c=f.Modifier.removeInlineStyle(a.getCurrentContent(),a.getSelection(),l);a=f.EditorState.push(a,c,"change-inline-style");}a&&i(a);},o.changeKeys=function(e){if(e){var t={};return (0, m.forEach)(e,function(e,n){t["CODE"===e?"monospace":e.toLowerCase()]=n;}),t}},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentStyles:this.changeKeys((0, p.getSelectionInlineStyle)(t))}),n.registerCallBack(this.expandCollapse);}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({currentStyles:this.changeKeys((0, p.getSelectionInlineStyle)(e.editorState))});}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,r=o.expanded,i=o.currentStyles,a=t.component||y.default;return s.default.createElement(a,{config:t,translations:n,currentState:i,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.toggleInlineStyle})}}]),t}(c.Component);h.propTypes={onChange:d.default.func.isRequired,editorState:d.default.object.isRequired,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=h;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p),m=n(8),g=n(5),y=o(g),h=n(7);n(34);var M=function(e){function t(){return r(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),l(t,[{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=e.currentState,o=e.onChange,r=e.translations;return s.default.createElement("div",{className:(0, f.default)("rdw-inline-wrapper",t.className),"aria-label":"rdw-inline-control"},t.options.map(function(e,i){return s.default.createElement(y.default,{key:i,value:e,onClick:o,className:(0, f.default)(t[e].className),active:!0===n[e]||"MONOSPACE"===e&&n.CODE,title:t[e].title||r["components.controls.inline."+e]},s.default.createElement("img",{alt:"",src:t[e].icon}))}))}},{key:"renderInDropDown",value:function(){var e=this.props,t=e.config,n=e.expanded,o=e.doExpand,r=e.onExpandEvent,i=e.doCollapse,a=e.currentState,l=e.onChange,c=e.translations,u=t.className,d=t.dropdownClassName,p=t.title;return s.default.createElement(h.Dropdown,{className:(0, f.default)("rdw-inline-dropdown",u),optionWrapperClassName:(0, f.default)(d),onChange:l,expanded:n,doExpand:o,doCollapse:i,onExpandEvent:r,"aria-label":"rdw-inline-control",title:p},s.default.createElement("img",{src:(0, m.getFirstIcon)(t),alt:""}),t.options.map(function(e,n){return s.default.createElement(h.DropdownOption,{key:n,value:e,className:(0, f.default)("rdw-inline-dropdownoption",t[e].className),active:!0===a[e]||"MONOSPACE"===e&&a.CODE,title:t[e].title||c["components.controls.inline."+e]},s.default.createElement("img",{src:t[e].icon,alt:""}))}))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(c.Component);M.propTypes={expanded:d.default.bool,doExpand:d.default.func,doCollapse:d.default.func,onExpandEvent:d.default.func,config:d.default.object,onChange:d.default.func,currentState:d.default.object,translations:d.default.object},t.default=M;},function(e,t){e.exports={"rdw-option-wrapper":"rdw-option-wrapper","rdw-option-active":"rdw-option-active","rdw-option-disabled":"rdw-option-disabled"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p);n(31);var m=n(6),g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={highlighted:-1},o.onChange=function(e){var t=o.props.onChange;t&&t(e),o.toggleExpansion();},o.setHighlighted=function(e){o.setState({highlighted:e});},o.toggleExpansion=function(){var e=o.props,t=e.doExpand,n=e.doCollapse;e.expanded?n():t();},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillReceiveProps",value:function(e){this.props.expanded&&!e.expanded&&this.setState({highlighted:-1});}},{key:"render",value:function(){var e=this,t=this.props,n=t.expanded,o=t.children,r=t.className,i=t.optionWrapperClassName,a=t.ariaLabel,l=t.onExpandEvent,c=t.title,u=this.state.highlighted,d=o.slice(1,o.length);return s.default.createElement("div",{className:(0, f.default)("rdw-dropdown-wrapper",r),"aria-expanded":n,"aria-label":a||"rdw-dropdown"},s.default.createElement("a",{className:"rdw-dropdown-selectedtext",onClick:l,title:c},o[0],s.default.createElement("div",{className:(0, f.default)({"rdw-dropdown-carettoclose":n,"rdw-dropdown-carettoopen":!n})})),n?s.default.createElement("ul",{className:(0, f.default)("rdw-dropdown-optionwrapper",i),onClick:m.stopPropagation},s.default.Children.map(d,function(t,n){return t&&s.default.cloneElement(t,{onSelect:e.onChange,highlighted:u===n,setHighlighted:e.setHighlighted,index:n})})):void 0)}}]),t}(c.Component);g.propTypes={children:d.default.any,onChange:d.default.func,className:d.default.string,expanded:d.default.bool,doExpand:d.default.func,doCollapse:d.default.func,onExpandEvent:d.default.func,optionWrapperClassName:d.default.string,ariaLabel:d.default.string,title:d.default.string},t.default=g;},function(e,t){e.exports={"rdw-dropdown-wrapper":"rdw-dropdown-wrapper","rdw-dropdown-carettoopen":"rdw-dropdown-carettoopen","rdw-dropdown-carettoclose":"rdw-dropdown-carettoclose","rdw-dropdown-selectedtext":"rdw-dropdown-selectedtext","rdw-dropdown-optionwrapper":"rdw-dropdown-optionwrapper"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),u=o(s),d=n(1),p=o(d),f=n(2),m=o(f);n(33);var g=function(e){function t(){var e,n,o,r;i(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=a(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.onClick=function(e){var t=o.props,n=t.onSelect,r=t.onClick,i=t.value;t.disabled||(n&&n(i),r&&(e.stopPropagation(),r(i)));},o.setHighlighted=function(){var e=o.props;(0, e.setHighlighted)(e.index);},o.resetHighlighted=function(){(0, o.props.setHighlighted)(-1);},r=n,a(o,r)}return l(t,e),c(t,[{key:"render",value:function(){var e,t=this.props,n=t.children,o=t.active,i=t.disabled,a=t.highlighted,l=t.className,c=t.activeClassName,s=t.disabledClassName,d=t.highlightedClassName,p=t.title;return u.default.createElement("li",{className:(0, m.default)("rdw-dropdownoption-default",l,(e={},r(e,"rdw-dropdownoption-active "+c,o),r(e,"rdw-dropdownoption-highlighted "+d,a),r(e,"rdw-dropdownoption-disabled "+s,i),e)),onMouseEnter:this.setHighlighted,onMouseLeave:this.resetHighlighted,onClick:this.onClick,title:p},n)}}]),t}(s.Component);g.propTypes={children:p.default.any,value:p.default.any,onClick:p.default.func,onSelect:p.default.func,setHighlighted:p.default.func,index:p.default.number,disabled:p.default.bool,active:p.default.bool,highlighted:p.default.bool,className:p.default.string,activeClassName:p.default.string,disabledClassName:p.default.string,highlightedClassName:p.default.string,title:p.default.string},g.defaultProps={activeClassName:"",disabledClassName:"",highlightedClassName:""},t.default=g;},function(e,t){e.exports={"rdw-dropdownoption-default":"rdw-dropdownoption-default","rdw-dropdownoption-highlighted":"rdw-dropdownoption-highlighted","rdw-dropdownoption-active":"rdw-dropdownoption-active","rdw-dropdownoption-disabled":"rdw-dropdownoption-disabled"};},function(e,t){e.exports={"rdw-inline-wrapper":"rdw-inline-wrapper","rdw-inline-dropdown":"rdw-inline-dropdown","rdw-inline-dropdownoption":"rdw-inline-dropdownoption"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(4),f=n(3),m=n(36),g=o(m),y=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,currentBlockType:"unstyled"},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.blocksTypes=[{label:"Normal",style:"unstyled"},{label:"H1",style:"header-one"},{label:"H2",style:"header-two"},{label:"H3",style:"header-three"},{label:"H4",style:"header-four"},{label:"H5",style:"header-five"},{label:"H6",style:"header-six"},{label:"Blockquote",style:"blockquote"},{label:"Code",style:"code"}],o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.toggleBlockType=function(e){var t=o.blocksTypes.find(function(t){return t.label===e}).style,n=o.props,r=n.editorState,i=n.onChange,a=f.RichUtils.toggleBlockType(r,t);a&&i(a);},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentBlockType:(0, p.getSelectedBlocksType)(t)}),n.registerCallBack(this.expandCollapse);}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({currentBlockType:(0, p.getSelectedBlocksType)(e.editorState)});}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,r=o.expanded,i=o.currentBlockType,a=t.component||g.default,l=this.blocksTypes.find(function(e){return e.style===i});return s.default.createElement(a,{config:t,translations:n,currentState:{blockType:l&&l.label},onChange:this.toggleBlockType,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);y.propTypes={onChange:d.default.func.isRequired,editorState:d.default.object,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=y;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p),m=n(5),g=o(m),y=n(7);n(37);var h=function(e){function t(e){r(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.getBlockTypes=function(e){return [{label:"Normal",displayName:e["components.controls.blocktype.normal"]},{label:"H1",displayName:e["components.controls.blocktype.h1"]},{label:"H2",displayName:e["components.controls.blocktype.h2"]},{label:"H3",displayName:e["components.controls.blocktype.h3"]},{label:"H4",displayName:e["components.controls.blocktype.h4"]},{label:"H5",displayName:e["components.controls.blocktype.h5"]},{label:"H6",displayName:e["components.controls.blocktype.h6"]},{label:"Blockquote",displayName:e["components.controls.blocktype.blockquote"]},{label:"Code",displayName:e["components.controls.blocktype.code"]}]},n.state={blockTypes:n.getBlockTypes(e.translations)},n}return a(t,e),l(t,[{key:"componentWillReceiveProps",value:function(e){this.props.translations!==e.translations&&this.setState({blockTypes:this.getBlockTypes(e.translations)});}},{key:"renderFlat",value:function(e){var t=this.props,n=t.config.className,o=t.onChange,r=t.currentState.blockType;return s.default.createElement("div",{className:(0, f.default)("rdw-inline-wrapper",n)},e.map(function(e,t){return s.default.createElement(g.default,{key:t,value:e.label,active:r===e.label,onClick:o},e.displayName)}))}},{key:"renderInDropdown",value:function(e){var t=this.props,n=t.config,o=n.className,r=n.dropdownClassName,i=n.title,a=t.currentState.blockType,l=t.expanded,c=t.doExpand,u=t.onExpandEvent,d=t.doCollapse,p=t.onChange,m=t.translations,g=this.state.blockTypes,h=g.filter(function(e){return e.label===a}),M=h&&h[0]&&h[0].displayName;return s.default.createElement("div",{className:"rdw-block-wrapper","aria-label":"rdw-block-control"},s.default.createElement(y.Dropdown,{className:(0, f.default)("rdw-block-dropdown",o),optionWrapperClassName:(0, f.default)(r),onChange:p,expanded:l,doExpand:c,doCollapse:d,onExpandEvent:u,title:i||m["components.controls.blocktype.blocktype"]},s.default.createElement("span",null,M||m["components.controls.blocktype.blocktype"]),e.map(function(e,t){return s.default.createElement(y.DropdownOption,{active:a===e.label,value:e.label,key:t},e.displayName)})))}},{key:"render",value:function(){var e=this.props.config,t=e.inDropdown,n=this.state.blockTypes,o=n.filter(function(t){var n=t.label;return e.options.indexOf(n)>-1});return t?this.renderInDropdown(o):this.renderFlat(o)}}]),t}(c.Component);h.propTypes={expanded:d.default.bool,onExpandEvent:d.default.func,doExpand:d.default.func,doCollapse:d.default.func,onChange:d.default.func,config:d.default.object,currentState:d.default.object,translations:d.default.object},t.default=h;},function(e,t){e.exports={"rdw-block-wrapper":"rdw-block-wrapper","rdw-block-dropdown":"rdw-block-dropdown"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(4),f=n(39),m=o(f),g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:void 0,currentFontSize:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.toggleFontSize=function(e){var t=o.props,n=t.editorState,r=t.onChange,i=(0, p.toggleCustomInlineStyle)(n,"fontSize",e);i&&r(i);},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentFontSize:(0, p.getSelectionCustomInlineStyle)(t,["FONTSIZE"]).FONTSIZE}),n.registerCallBack(this.expandCollapse);}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({currentFontSize:(0, p.getSelectionCustomInlineStyle)(e.editorState,["FONTSIZE"]).FONTSIZE});}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,r=o.expanded,i=o.currentFontSize,a=t.component||m.default,l=i&&Number(i.substring(9));return s.default.createElement(a,{config:t,translations:n,currentState:{fontSize:l},onChange:this.toggleFontSize,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);g.propTypes={onChange:d.default.func.isRequired,editorState:d.default.object,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=g;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p),m=n(7);n(40);var g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={defaultFontSize:void 0},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentDidMount",value:function(){var e=document.getElementsByClassName("DraftEditor-root");if(e&&e.length>0){var t=window.getComputedStyle(e[0]),n=t.getPropertyValue("font-size");n=n.substring(0,n.length-2),this.setState({defaultFontSize:n});}}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,r=t.dropdownClassName,i=t.options,a=t.title,l=e.onChange,c=e.expanded,u=e.doCollapse,d=e.onExpandEvent,p=e.doExpand,g=e.translations,y=this.props.currentState.fontSize,h=this.state.defaultFontSize;return h=Number(h),y=y||i&&i.indexOf(h)>=0&&h,s.default.createElement("div",{className:"rdw-fontsize-wrapper","aria-label":"rdw-font-size-control"},s.default.createElement(m.Dropdown,{className:(0, f.default)("rdw-fontsize-dropdown",o),optionWrapperClassName:(0, f.default)(r),onChange:l,expanded:c,doExpand:p,doCollapse:u,onExpandEvent:d,title:a||g["components.controls.fontsize.fontsize"]},y?s.default.createElement("span",null,y):s.default.createElement("img",{src:n,alt:""}),i.map(function(e,t){return s.default.createElement(m.DropdownOption,{className:"rdw-fontsize-option",active:y===e,value:e,key:t},e)})))}}]),t}(c.Component);g.propTypes={expanded:d.default.bool,onExpandEvent:d.default.func,doExpand:d.default.func,doCollapse:d.default.func,onChange:d.default.func,config:d.default.object,currentState:d.default.object,translations:d.default.object},t.default=g;},function(e,t){e.exports={"rdw-fontsize-wrapper":"rdw-fontsize-wrapper","rdw-fontsize-dropdown":"rdw-fontsize-dropdown","rdw-fontsize-option":"rdw-fontsize-option"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(4),f=n(42),m=o(f),g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:void 0,currentFontFamily:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.toggleFontFamily=function(e){var t=o.props,n=t.editorState,r=t.onChange,i=(0, p.toggleCustomInlineStyle)(n,"fontFamily",e);i&&r(i);},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentFontFamily:(0, p.getSelectionCustomInlineStyle)(t,["FONTFAMILY"]).FONTFAMILY}),n.registerCallBack(this.expandCollapse);}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({currentFontFamily:(0, p.getSelectionCustomInlineStyle)(e.editorState,["FONTFAMILY"]).FONTFAMILY});}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,r=o.expanded,i=o.currentFontFamily,a=t.component||m.default,l=i&&i.substring(11);return s.default.createElement(a,{translations:n,config:t,currentState:{fontFamily:l},onChange:this.toggleFontFamily,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);g.propTypes={onChange:d.default.func.isRequired,editorState:d.default.object,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=g;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p),m=n(7);n(43);var g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={defaultFontFamily:void 0},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentDidMount",value:function(){var e=document.getElementsByClassName("DraftEditor-root");if(e&&e.length>0){var t=window.getComputedStyle(e[0]),n=t.getPropertyValue("font-family");this.setState({defaultFontFamily:n});}}},{key:"render",value:function(){var e=this.state.defaultFontFamily,t=this.props,n=t.config,o=n.className,r=n.dropdownClassName,i=n.options,a=n.title,l=t.translations,c=t.onChange,u=t.expanded,d=t.doCollapse,p=t.onExpandEvent,g=t.doExpand,y=this.props.currentState.fontFamily;return y=y||i&&e&&i.some(function(t){return t.toLowerCase()===e.toLowerCase()})&&e,s.default.createElement("div",{className:"rdw-fontfamily-wrapper","aria-label":"rdw-font-family-control"},s.default.createElement(m.Dropdown,{className:(0, f.default)("rdw-fontfamily-dropdown",o),optionWrapperClassName:(0, f.default)("rdw-fontfamily-optionwrapper",r),onChange:c,expanded:u,doExpand:g,doCollapse:d,onExpandEvent:p,title:a||l["components.controls.fontfamily.fontfamily"]},s.default.createElement("span",{className:"rdw-fontfamily-placeholder"},y||l["components.controls.fontfamily.fontfamily"]),i.map(function(e,t){return s.default.createElement(m.DropdownOption,{active:y===e,value:e,key:t},e)})))}}]),t}(c.Component);g.propTypes={expanded:d.default.bool,onExpandEvent:d.default.func,doExpand:d.default.func,doCollapse:d.default.func,onChange:d.default.func,config:d.default.object,currentState:d.default.object,translations:d.default.object},t.default=g;},function(e,t){e.exports={"rdw-fontfamily-wrapper":"rdw-fontfamily-wrapper","rdw-fontfamily-dropdown":"rdw-fontfamily-dropdown","rdw-fontfamily-placeholder":"rdw-fontfamily-placeholder","rdw-fontfamily-optionwrapper":"rdw-fontfamily-optionwrapper"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(3),f=n(4),m=n(45),g=o(m),y=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,currentBlock:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.onChange=function(e){"unordered"===e?o.toggleBlockType("unordered-list-item"):"ordered"===e?o.toggleBlockType("ordered-list-item"):"indent"===e?o.adjustDepth(1):o.adjustDepth(-1);},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.toggleBlockType=function(e){var t=o.props,n=t.onChange,r=t.editorState,i=p.RichUtils.toggleBlockType(r,e);i&&n(i);},o.adjustDepth=function(e){var t=o.props,n=t.onChange,r=t.editorState,i=(0, f.changeDepth)(r,e,4);i&&n(i);},o.isIndentDisabled=function(){var e=o.props.editorState,t=o.state.currentBlock,n=(0, f.getBlockBeforeSelectedBlock)(e);return !n||!(0, f.isListBlock)(t)||n.get("type")!==t.get("type")||n.get("depth")<t.get("depth")},o.isOutdentDisabled=function(){var e=o.state.currentBlock;return !e||!(0, f.isListBlock)(e)||e.get("depth")<=0},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentBlock:(0, f.getSelectedBlock)(t)}),n.registerCallBack(this.expandCollapse);}},{key:"componentWillReceiveProps",value:function(e){if(e.editorState&&this.props.editorState!==e.editorState){(0, f.getSelectedBlock)(e.editorState);this.setState({currentBlock:(0, f.getSelectedBlock)(e.editorState)});}}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,r=o.expanded,i=o.currentBlock,a=t.component||g.default,l=void 0;"unordered-list-item"===i.get("type")?l="unordered":"ordered-list-item"===i.get("type")&&(l="ordered");var c=this.isIndentDisabled(),u=this.isOutdentDisabled();return s.default.createElement(a,{config:t,translations:n,currentState:{listType:l},expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.onChange,indentDisabled:c,outdentDisabled:u})}}]),t}(c.Component);y.propTypes={onChange:d.default.func.isRequired,editorState:d.default.object.isRequired,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=y;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p),m=n(8),g=n(7),y=n(5),h=o(y);n(46);var M=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.options=["unordered","ordered","indent","outdent"],o.toggleBlockType=function(e){(0, o.props.onChange)(e);},o.indent=function(){(0, o.props.onChange)("indent");},o.outdent=function(){(0, o.props.onChange)("outdent");},a=n,i(o,a)}return a(t,e),l(t,[{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=e.currentState.listType,o=e.translations,r=e.indentDisabled,i=e.outdentDisabled,a=t.options,l=t.unordered,c=t.ordered,u=t.indent,d=t.outdent,p=t.className;return s.default.createElement("div",{className:(0, f.default)("rdw-list-wrapper",p),"aria-label":"rdw-list-control"},a.indexOf("unordered")>=0&&s.default.createElement(h.default,{value:"unordered",onClick:this.toggleBlockType,className:(0, f.default)(l.className),active:"unordered"===n,title:l.title||o["components.controls.list.unordered"]},s.default.createElement("img",{src:l.icon,alt:""})),a.indexOf("ordered")>=0&&s.default.createElement(h.default,{value:"ordered",onClick:this.toggleBlockType,className:(0, f.default)(c.className),active:"ordered"===n,title:c.title||o["components.controls.list.ordered"]},s.default.createElement("img",{src:c.icon,alt:""})),a.indexOf("indent")>=0&&s.default.createElement(h.default,{onClick:this.indent,disabled:r,className:(0, f.default)(u.className),title:u.title||o["components.controls.list.indent"]},s.default.createElement("img",{src:u.icon,alt:""})),a.indexOf("outdent")>=0&&s.default.createElement(h.default,{onClick:this.outdent,disabled:i,className:(0, f.default)(d.className),title:d.title||o["components.controls.list.outdent"]},s.default.createElement("img",{src:d.icon,alt:""})))}},{key:"renderInDropDown",value:function(){var e=this,t=this.props,n=t.config,o=t.expanded,r=t.doCollapse,i=t.doExpand,a=t.onExpandEvent,l=t.onChange,c=t.currentState.listType,u=t.translations,d=n.options,p=n.className,y=n.dropdownClassName,h=n.title;return s.default.createElement(g.Dropdown,{className:(0, f.default)("rdw-list-dropdown",p),optionWrapperClassName:(0, f.default)(y),onChange:l,expanded:o,doExpand:i,doCollapse:r,onExpandEvent:a,"aria-label":"rdw-list-control",title:h||u["components.controls.list.list"]},s.default.createElement("img",{src:(0, m.getFirstIcon)(n),alt:""}),this.options.filter(function(e){return d.indexOf(e)>=0}).map(function(t,o){return s.default.createElement(g.DropdownOption,{key:o,value:t,disabled:e.props[t+"Disabled"],className:(0, f.default)("rdw-list-dropdownOption",n[t].className),active:c===t,title:n[t].title||u["components.controls.list."+t]},s.default.createElement("img",{src:n[t].icon,alt:""}))}))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(c.Component);M.propTypes={expanded:d.default.bool,doExpand:d.default.func,doCollapse:d.default.func,onExpandEvent:d.default.func,config:d.default.object,onChange:d.default.func,currentState:d.default.object,translations:d.default.object,indentDisabled:d.default.bool,outdentDisabled:d.default.bool},t.default=M;},function(e,t){e.exports={"rdw-list-wrapper":"rdw-list-wrapper","rdw-list-dropdown":"rdw-list-dropdown","rdw-list-dropdownOption":"rdw-list-dropdownOption"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(4),f=n(48),m=o(f),g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={currentTextAlignment:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.addBlockAlignmentData=function(e){var t=o.props,n=t.editorState,r=t.onChange;r(o.state.currentTextAlignment!==e?(0, p.setBlockData)(n,{"text-align":e}):(0, p.setBlockData)(n,{"text-align":void 0}));},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse);}},{key:"componentWillReceiveProps",value:function(e){e.editorState!==this.props.editorState&&this.setState({currentTextAlignment:(0, p.getSelectedBlocksMetadata)(e.editorState).get("text-align")});}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,r=o.expanded,i=o.currentTextAlignment,a=t.component||m.default;return s.default.createElement(a,{config:t,translations:n,expanded:r,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,currentState:{textAlignment:i},onChange:this.addBlockAlignmentData})}}]),t}(c.Component);g.propTypes={editorState:d.default.object.isRequired,onChange:d.default.func.isRequired,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=g;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p),m=n(5),g=o(m),y=n(7),h=n(8);n(49);var M=function(e){function t(){return r(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),l(t,[{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=t.options,o=t.left,r=t.center,i=t.right,a=t.justify,l=t.className,c=e.onChange,u=e.currentState.textAlignment,d=e.translations;return s.default.createElement("div",{className:(0, f.default)("rdw-text-align-wrapper",l),"aria-label":"rdw-textalign-control"},n.indexOf("left")>=0&&s.default.createElement(g.default,{value:"left",className:(0, f.default)(o.className),active:"left"===u,onClick:c,title:o.title||d["components.controls.textalign.left"]},s.default.createElement("img",{src:o.icon,alt:""})),n.indexOf("center")>=0&&s.default.createElement(g.default,{value:"center",className:(0, f.default)(r.className),active:"center"===u,onClick:c,title:r.title||d["components.controls.textalign.center"]},s.default.createElement("img",{src:r.icon,alt:""})),n.indexOf("right")>=0&&s.default.createElement(g.default,{value:"right",className:(0, f.default)(i.className),active:"right"===u,onClick:c,title:i.title||d["components.controls.textalign.right"]},s.default.createElement("img",{src:i.icon,alt:""})),n.indexOf("justify")>=0&&s.default.createElement(g.default,{value:"justify",className:(0, f.default)(a.className),active:"justify"===u,onClick:c,title:a.title||d["components.controls.textalign.justify"]},s.default.createElement("img",{src:a.icon,alt:""})))}},{key:"renderInDropDown",value:function(){var e=this.props,t=e.config,n=e.expanded,o=e.doExpand,r=e.onExpandEvent,i=e.doCollapse,a=e.currentState.textAlignment,l=e.onChange,c=e.translations,u=t.options,d=t.left,p=t.center,m=t.right,g=t.justify,M=t.className,b=t.dropdownClassName,j=t.title;return s.default.createElement(y.Dropdown,{className:(0, f.default)("rdw-text-align-dropdown",M),optionWrapperClassName:(0, f.default)(b),onChange:l,expanded:n,doExpand:o,doCollapse:i,onExpandEvent:r,"aria-label":"rdw-textalign-control",title:j||c["components.controls.textalign.textalign"]},s.default.createElement("img",{src:a&&t[a]&&t[a].icon||(0, h.getFirstIcon)(t),alt:""}),u.indexOf("left")>=0&&s.default.createElement(y.DropdownOption,{value:"left",active:"left"===a,className:(0, f.default)("rdw-text-align-dropdownOption",d.className),title:d.title||c["components.controls.textalign.left"]},s.default.createElement("img",{src:d.icon,alt:""})),u.indexOf("center")>=0&&s.default.createElement(y.DropdownOption,{value:"center",active:"center"===a,className:(0, f.default)("rdw-text-align-dropdownOption",p.className),title:p.title||c["components.controls.textalign.center"]},s.default.createElement("img",{src:p.icon,alt:""})),u.indexOf("right")>=0&&s.default.createElement(y.DropdownOption,{value:"right",active:"right"===a,className:(0, f.default)("rdw-text-align-dropdownOption",m.className),title:m.title||c["components.controls.textalign.right"]},s.default.createElement("img",{src:m.icon,alt:""})),u.indexOf("justify")>=0&&s.default.createElement(y.DropdownOption,{value:"justify",active:"justify"===a,className:(0, f.default)("rdw-text-align-dropdownOption",g.className),title:g.title||c["components.controls.textalign.justify"]},s.default.createElement("img",{src:g.icon,alt:""})))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(c.Component);M.propTypes={expanded:d.default.bool,doExpand:d.default.func,doCollapse:d.default.func,onExpandEvent:d.default.func,config:d.default.object,onChange:d.default.func,currentState:d.default.object,translations:d.default.object},t.default=M;},function(e,t){e.exports={"rdw-text-align-wrapper":"rdw-text-align-wrapper","rdw-text-align-dropdown":"rdw-text-align-dropdown","rdw-text-align-dropdownOption":"rdw-text-align-dropdownOption","rdw-right-aligned-block":"rdw-right-aligned-block","rdw-left-aligned-block":"rdw-left-aligned-block","rdw-center-aligned-block":"rdw-center-aligned-block","rdw-justify-aligned-block":"rdw-justify-aligned-block"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(4),f=n(51),m=o(f),g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,currentColor:void 0,currentBgColor:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.toggleColor=function(e,t){var n=o.props,r=n.editorState,i=n.onChange,a=(0, p.toggleCustomInlineStyle)(r,e,t);a&&i(a),o.doCollapse();},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentColor:(0, p.getSelectionCustomInlineStyle)(t,["COLOR"]).COLOR,currentBgColor:(0, p.getSelectionCustomInlineStyle)(t,["BGCOLOR"]).BGCOLOR}),n.registerCallBack(this.expandCollapse);}},{key:"componentWillReceiveProps",value:function(e){var t={};e.editorState&&this.props.editorState!==e.editorState&&(t.currentColor=(0, p.getSelectionCustomInlineStyle)(e.editorState,["COLOR"]).COLOR,t.currentBgColor=(0, p.getSelectionCustomInlineStyle)(e.editorState,["BGCOLOR"]).BGCOLOR),this.setState(t);}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,r=o.currentColor,i=o.currentBgColor,a=o.expanded,l=t.component||m.default,c=r&&r.substring(6),u=i&&i.substring(8);return s.default.createElement(l,{config:t,translations:n,onChange:this.toggleColor,expanded:a,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,currentState:{color:c,bgColor:u}})}}]),t}(c.Component);g.propTypes={onChange:d.default.func.isRequired,editorState:d.default.object.isRequired,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=g;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p),m=n(6),g=n(5),y=o(g);n(52);var h=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),u=0;u<l;u++)c[u]=arguments[u];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={currentStyle:"color"},o.onChange=function(e){(0, o.props.onChange)(o.state.currentStyle,e);},o.setCurrentStyleColor=function(){o.setState({currentStyle:"color"});},o.setCurrentStyleBgcolor=function(){o.setState({currentStyle:"bgcolor"});},o.renderModal=function(){var e=o.props,t=e.config,n=t.popupClassName,r=t.colors,i=e.currentState,a=i.color,l=i.bgColor,c=e.translations,u=o.state.currentStyle,d="color"===u?a:l;return s.default.createElement("div",{className:(0, f.default)("rdw-colorpicker-modal",n),onClick:m.stopPropagation},s.default.createElement("span",{className:"rdw-colorpicker-modal-header"},s.default.createElement("span",{className:(0, f.default)("rdw-colorpicker-modal-style-label",{"rdw-colorpicker-modal-style-label-active":"color"===u}),onClick:o.setCurrentStyleColor},c["components.controls.colorpicker.text"]),s.default.createElement("span",{className:(0, f.default)("rdw-colorpicker-modal-style-label",{"rdw-colorpicker-modal-style-label-active":"bgcolor"===u}),onClick:o.setCurrentStyleBgcolor},c["components.controls.colorpicker.background"])),s.default.createElement("span",{className:"rdw-colorpicker-modal-options"},r.map(function(e,t){return s.default.createElement(y.default,{value:e,key:t,className:"rdw-colorpicker-option",activeClassName:"rdw-colorpicker-option-active",active:d===e,onClick:o.onChange},s.default.createElement("span",{style:{backgroundColor:e},className:"rdw-colorpicker-cube"}))})))},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillReceiveProps",value:function(e){!this.props.expanded&&e.expanded&&this.setState({currentStyle:"color"});}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,r=t.title,i=e.expanded,a=e.onExpandEvent,l=e.translations;return s.default.createElement("div",{className:"rdw-colorpicker-wrapper","aria-haspopup":"true","aria-expanded":i,"aria-label":"rdw-color-picker",title:r||l["components.controls.colorpicker.colorpicker"]},s.default.createElement(y.default,{onClick:a,className:(0, f.default)(o)},s.default.createElement("img",{src:n,alt:""})),i?this.renderModal():void 0)}}]),t}(c.Component);h.propTypes={expanded:d.default.bool,onExpandEvent:d.default.func,onChange:d.default.func,config:d.default.object,currentState:d.default.object,translations:d.default.object},t.default=h;},function(e,t){e.exports={"rdw-colorpicker-wrapper":"rdw-colorpicker-wrapper","rdw-colorpicker-modal":"rdw-colorpicker-modal","rdw-colorpicker-modal-header":"rdw-colorpicker-modal-header","rdw-colorpicker-modal-style-label":"rdw-colorpicker-modal-style-label","rdw-colorpicker-modal-style-label-active":"rdw-colorpicker-modal-style-label-active","rdw-colorpicker-modal-options":"rdw-colorpicker-modal-options","rdw-colorpicker-cube":"rdw-colorpicker-cube","rdw-colorpicker-option":"rdw-colorpicker-option","rdw-colorpicker-option-active":"rdw-colorpicker-option-active"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);}return e},s=n(0),u=o(s),d=n(1),p=o(d),f=n(3),m=n(4),g=n(54),y=o(g),h=n(60),M=o(h),b=(0, y.default)(),j=function(e){var t=b.match(e.target);return c({},e,{target:t&&t[0]&&t[0].url||e.target})},w=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,link:void 0,selectionText:void 0},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.onChange=function(e,t,n,r){var i=o.props.config.linkCallback;if("link"===e){var a=i||j,l=a({title:t,target:n,targetOption:r});o.addLink(l.title,l.target,l.targetOption);}else o.removeLink();},o.getCurrentValues=function(){var e=o.props.editorState,t=o.state.currentEntity,n=e.getCurrentContent(),r={};if(t&&"LINK"===n.getEntity(t).get("type")){r.link={};var i=t&&(0, m.getEntityRange)(e,t);r.link.target=t&&n.getEntity(t).get("data").url,r.link.targetOption=t&&n.getEntity(t).get("data").targetOption,r.link.title=i&&i.text;}return r.selectionText=(0, m.getSelectionText)(e),r},o.doExpand=function(){o.setState({expanded:!0});},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.doCollapse=function(){o.setState({expanded:!1});},o.removeLink=function(){var e=o.props,t=e.editorState,n=e.onChange,r=o.state.currentEntity,i=t.getSelection();if(r){var a=(0, m.getEntityRange)(t,r);i=i.getIsBackward()?i.merge({anchorOffset:a.end,focusOffset:a.start}):i.merge({anchorOffset:a.start,focusOffset:a.end}),n(f.RichUtils.toggleLink(t,i,null));}},o.addLink=function(e,t,n){var r=o.props,i=r.editorState,a=r.onChange,l=o.state.currentEntity,c=i.getSelection();if(l){var s=(0, m.getEntityRange)(i,l);c=c.getIsBackward()?c.merge({anchorOffset:s.end,focusOffset:s.start}):c.merge({anchorOffset:s.start,focusOffset:s.end});}var u=i.getCurrentContent().createEntity("LINK","MUTABLE",{url:t,targetOption:n}).getLastCreatedEntityKey(),d=f.Modifier.replaceText(i.getCurrentContent(),c,""+e,i.getCurrentInlineStyle(),u),p=f.EditorState.push(i,d,"insert-characters");c=p.getSelection().merge({anchorOffset:c.get("anchorOffset")+e.length,focusOffset:c.get("anchorOffset")+e.length}),p=f.EditorState.acceptSelection(p,c),d=f.Modifier.insertText(p.getCurrentContent(),c," ",p.getCurrentInlineStyle(),void 0),a(f.EditorState.push(p,d,"insert-characters")),o.doCollapse();},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({currentEntity:(0, m.getSelectionEntity)(t)}),n.registerCallBack(this.expandCollapse);}},{key:"componentWillReceiveProps",value:function(e){var t={};e.editorState&&this.props.editorState!==e.editorState&&(t.currentEntity=(0, m.getSelectionEntity)(e.editorState)),this.setState(t);}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,r=this.getCurrentValues(),i=r.link,a=r.selectionText,l=t.component||M.default;return u.default.createElement(l,{config:t,translations:n,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,currentState:{link:i,selectionText:a},onChange:this.onChange})}}]),t}(s.Component);w.propTypes={editorState:p.default.object.isRequired,onChange:p.default.func.isRequired,modalHandler:p.default.object,config:p.default.object,translations:p.default.object},t.default=w;},function(e,t,n){function o(e){return Array.prototype.slice.call(arguments,1).forEach(function(t){t&&Object.keys(t).forEach(function(n){e[n]=t[n];});}),e}function r(e){return Object.prototype.toString.call(e)}function i(e){return "[object String]"===r(e)}function a(e){return "[object Object]"===r(e)}function l(e){return "[object RegExp]"===r(e)}function c(e){return "[object Function]"===r(e)}function s(e){return e.replace(/[.?*+^$[\]\\(){}|-]/g,"\\$&")}function u(e){return Object.keys(e||{}).reduce(function(e,t){return e||M.hasOwnProperty(t)},!1)}function d(e){e.__index__=-1,e.__text_cache__="";}function p(e){return function(t,n){var o=t.slice(n);return e.test(o)?o.match(e)[0].length:0}}function f(){return function(e,t){t.normalize(e);}}function m(e){function t(e){return e.replace("%TLDS%",r.src_tlds)}function o(e,t){throw new Error('(LinkifyIt) Invalid schema "'+e+'": '+t)}var r=e.re=n(55)(e.__opts__),u=e.__tlds__.slice();e.onCompile(),e.__tlds_replaced__||u.push(j),u.push(r.src_xn),r.src_tlds=u.join("|"),r.email_fuzzy=RegExp(t(r.tpl_email_fuzzy),"i"),r.link_fuzzy=RegExp(t(r.tpl_link_fuzzy),"i"),r.link_no_ip_fuzzy=RegExp(t(r.tpl_link_no_ip_fuzzy),"i"),r.host_fuzzy_test=RegExp(t(r.tpl_host_fuzzy_test),"i");var m=[];e.__compiled__={},Object.keys(e.__schemas__).forEach(function(t){var n=e.__schemas__[t];if(null!==n){var r={validate:null,link:null};return e.__compiled__[t]=r,a(n)?(l(n.validate)?r.validate=p(n.validate):c(n.validate)?r.validate=n.validate:o(t,n),void(c(n.normalize)?r.normalize=n.normalize:n.normalize?o(t,n):r.normalize=f())):i(n)?void m.push(t):void o(t,n)}}),m.forEach(function(t){e.__compiled__[e.__schemas__[t]]&&(e.__compiled__[t].validate=e.__compiled__[e.__schemas__[t]].validate,e.__compiled__[t].normalize=e.__compiled__[e.__schemas__[t]].normalize);}),e.__compiled__[""]={validate:null,normalize:f()};var g=Object.keys(e.__compiled__).filter(function(t){return t.length>0&&e.__compiled__[t]}).map(s).join("|");e.re.schema_test=RegExp("(^|(?!_)(?:[><｜]|"+r.src_ZPCc+"))("+g+")","i"),e.re.schema_search=RegExp("(^|(?!_)(?:[><｜]|"+r.src_ZPCc+"))("+g+")","ig"),e.re.pretest=RegExp("("+e.re.schema_test.source+")|("+e.re.host_fuzzy_test.source+")|@","i"),d(e);}function g(e,t){var n=e.__index__,o=e.__last_index__,r=e.__text_cache__.slice(n,o);this.schema=e.__schema__.toLowerCase(),this.index=n+t,this.lastIndex=o+t,this.raw=r,this.text=r,this.url=r;}function y(e,t){var n=new g(e,t);return e.__compiled__[n.schema].normalize(n,e),n}function h(e,t){if(!(this instanceof h))return new h(e,t);t||u(e)&&(t=e,e={}),this.__opts__=o({},M,t),this.__index__=-1,this.__last_index__=-1,this.__schema__="",this.__text_cache__="",this.__schemas__=o({},b,e),this.__compiled__={},this.__tlds__=w,this.__tlds_replaced__=!1,this.re={},m(this);}var M={fuzzyLink:!0,fuzzyEmail:!0,fuzzyIP:!1},b={"http:":{validate:function(e,t,n){var o=e.slice(t);return n.re.http||(n.re.http=new RegExp("^\\/\\/"+n.re.src_auth+n.re.src_host_port_strict+n.re.src_path,"i")),n.re.http.test(o)?o.match(n.re.http)[0].length:0}},"https:":"http:","ftp:":"http:","//":{validate:function(e,t,n){var o=e.slice(t);return n.re.no_http||(n.re.no_http=new RegExp("^"+n.re.src_auth+"(?:localhost|(?:(?:"+n.re.src_domain+")\\.)+"+n.re.src_domain_root+")"+n.re.src_port+n.re.src_host_terminator+n.re.src_path,"i")),n.re.no_http.test(o)?t>=3&&":"===e[t-3]?0:t>=3&&"/"===e[t-3]?0:o.match(n.re.no_http)[0].length:0}},"mailto:":{validate:function(e,t,n){var o=e.slice(t);return n.re.mailto||(n.re.mailto=new RegExp("^"+n.re.src_email_name+"@"+n.re.src_host_strict,"i")),n.re.mailto.test(o)?o.match(n.re.mailto)[0].length:0}}},j="a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",w="biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");h.prototype.add=function(e,t){return this.__schemas__[e]=t,m(this),this},h.prototype.set=function(e){return this.__opts__=o(this.__opts__,e),this},h.prototype.test=function(e){if(this.__text_cache__=e,this.__index__=-1,!e.length)return !1;var t,n,o,r,i,a,l,c;if(this.re.schema_test.test(e))for(l=this.re.schema_search,l.lastIndex=0;null!==(t=l.exec(e));)if(r=this.testSchemaAt(e,t[2],l.lastIndex)){this.__schema__=t[2],this.__index__=t.index+t[1].length,this.__last_index__=t.index+t[0].length+r;break}return this.__opts__.fuzzyLink&&this.__compiled__["http:"]&&(c=e.search(this.re.host_fuzzy_test))>=0&&(this.__index__<0||c<this.__index__)&&null!==(n=e.match(this.__opts__.fuzzyIP?this.re.link_fuzzy:this.re.link_no_ip_fuzzy))&&(i=n.index+n[1].length,(this.__index__<0||i<this.__index__)&&(this.__schema__="",this.__index__=i,this.__last_index__=n.index+n[0].length)),this.__opts__.fuzzyEmail&&this.__compiled__["mailto:"]&&e.indexOf("@")>=0&&null!==(o=e.match(this.re.email_fuzzy))&&(i=o.index+o[1].length,a=o.index+o[0].length,(this.__index__<0||i<this.__index__||i===this.__index__&&a>this.__last_index__)&&(this.__schema__="mailto:",this.__index__=i,this.__last_index__=a)),this.__index__>=0},h.prototype.pretest=function(e){return this.re.pretest.test(e)},h.prototype.testSchemaAt=function(e,t,n){return this.__compiled__[t.toLowerCase()]?this.__compiled__[t.toLowerCase()].validate(e,n,this):0},h.prototype.match=function(e){var t=0,n=[];this.__index__>=0&&this.__text_cache__===e&&(n.push(y(this,t)),t=this.__last_index__);for(var o=t?e.slice(t):e;this.test(o);)n.push(y(this,t)),o=o.slice(this.__last_index__),t+=this.__last_index__;return n.length?n:null},h.prototype.tlds=function(e,t){return e=Array.isArray(e)?e:[e],t?(this.__tlds__=this.__tlds__.concat(e).sort().filter(function(e,t,n){return e!==n[t-1]}).reverse(),m(this),this):(this.__tlds__=e.slice(),this.__tlds_replaced__=!0,m(this),this)},h.prototype.normalize=function(e){e.schema||(e.url="http://"+e.url),"mailto:"!==e.schema||/^mailto:/i.test(e.url)||(e.url="mailto:"+e.url);},h.prototype.onCompile=function(){},e.exports=h;},function(e,t,n){e.exports=function(e){var t={};t.src_Any=n(56).source,t.src_Cc=n(57).source,t.src_Z=n(58).source,t.src_P=n(59).source,t.src_ZPCc=[t.src_Z,t.src_P,t.src_Cc].join("|"),t.src_ZCc=[t.src_Z,t.src_Cc].join("|");return t.src_pseudo_letter="(?:(?![><｜]|"+t.src_ZPCc+")"+t.src_Any+")",t.src_ip4="(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)",t.src_auth="(?:(?:(?!"+t.src_ZCc+"|[@/\\[\\]()]).)+@)?",t.src_port="(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?",t.src_host_terminator="(?=$|[><｜]|"+t.src_ZPCc+")(?!-|_|:\\d|\\.-|\\.(?!$|"+t.src_ZPCc+"))",t.src_path="(?:[/?#](?:(?!"+t.src_ZCc+"|[><｜]|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!"+t.src_ZCc+"|\\]).)*\\]|\\((?:(?!"+t.src_ZCc+"|[)]).)*\\)|\\{(?:(?!"+t.src_ZCc+'|[}]).)*\\}|\\"(?:(?!'+t.src_ZCc+'|["]).)+\\"|\\\'(?:(?!'+t.src_ZCc+"|[']).)+\\'|\\'(?="+t.src_pseudo_letter+"|[-]).|\\.{2,3}[a-zA-Z0-9%/]|\\.(?!"+t.src_ZCc+"|[.]).|"+(e&&e["---"]?"\\-(?!--(?:[^-]|$))(?:-*)|":"\\-+|")+"\\,(?!"+t.src_ZCc+").|\\!(?!"+t.src_ZCc+"|[!]).|\\?(?!"+t.src_ZCc+"|[?]).)+|\\/)?",t.src_email_name='[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+',t.src_xn="xn--[a-z0-9\\-]{1,59}",t.src_domain_root="(?:"+t.src_xn+"|"+t.src_pseudo_letter+"{1,63})",t.src_domain="(?:"+t.src_xn+"|(?:"+t.src_pseudo_letter+")|(?:"+t.src_pseudo_letter+"(?:-(?!-)|"+t.src_pseudo_letter+"){0,61}"+t.src_pseudo_letter+"))",t.src_host="(?:(?:(?:(?:"+t.src_domain+")\\.)*"+t.src_domain+"))",t.tpl_host_fuzzy="(?:"+t.src_ip4+"|(?:(?:(?:"+t.src_domain+")\\.)+(?:%TLDS%)))",t.tpl_host_no_ip_fuzzy="(?:(?:(?:"+t.src_domain+")\\.)+(?:%TLDS%))",t.src_host_strict=t.src_host+t.src_host_terminator,t.tpl_host_fuzzy_strict=t.tpl_host_fuzzy+t.src_host_terminator,t.src_host_port_strict=t.src_host+t.src_port+t.src_host_terminator,t.tpl_host_port_fuzzy_strict=t.tpl_host_fuzzy+t.src_port+t.src_host_terminator,t.tpl_host_port_no_ip_fuzzy_strict=t.tpl_host_no_ip_fuzzy+t.src_port+t.src_host_terminator,t.tpl_host_fuzzy_test="localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:"+t.src_ZPCc+"|>|$))",t.tpl_email_fuzzy="(^|[><｜]|\\(|"+t.src_ZCc+")("+t.src_email_name+"@"+t.tpl_host_fuzzy_strict+")",t.tpl_link_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|"+t.src_ZPCc+"))((?![$+<=>^`|｜])"+t.tpl_host_port_fuzzy_strict+t.src_path+")",t.tpl_link_no_ip_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|"+t.src_ZPCc+"))((?![$+<=>^`|｜])"+t.tpl_host_port_no_ip_fuzzy_strict+t.src_path+")",t};},function(e,t,n){e.exports=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;},function(e,t,n){e.exports=/[\0-\x1F\x7F-\x9F]/;},function(e,t,n){e.exports=/[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;},function(e,t,n){e.exports=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),u=o(s),d=n(1),p=o(d),f=n(2),m=o(f),g=n(6),y=n(8),h=n(5),M=o(h),b=n(7);n(61);var j=function(e){function t(){var e,n,o,l;i(this,t);for(var c=arguments.length,s=Array(c),u=0;u<c;u++)s[u]=arguments[u];return n=o=a(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(s))),o.state={showModal:!1,linkTarget:"",linkTitle:"",linkTargetOption:o.props.config.defaultTargetOption},o.removeLink=function(){(0, o.props.onChange)("unlink");},o.addLink=function(){var e=o.props.onChange,t=o.state;e("link",t.linkTitle,t.linkTarget,t.linkTargetOption);},o.updateValue=function(e){o.setState(r({},""+e.target.name,e.target.value));},o.updateTargetOption=function(e){o.setState({linkTargetOption:e.target.checked?"_blank":"_self"});},o.hideModal=function(){o.setState({showModal:!1});},o.signalExpandShowModal=function(){var e=o.props,t=e.onExpandEvent,n=e.currentState,r=n.link,i=n.selectionText,a=o.state.linkTargetOption;t(),o.setState({showModal:!0,linkTarget:r&&r.target||"",linkTargetOption:r&&r.targetOption||a,linkTitle:r&&r.title||i});},o.forceExpandAndShowModal=function(){var e=o.props,t=e.doExpand,n=e.currentState,r=n.link,i=n.selectionText,a=o.state.linkTargetOption;t(),o.setState({showModal:!0,linkTarget:r&&r.target,linkTargetOption:r&&r.targetOption||a,linkTitle:r&&r.title||i});},l=n,a(o,l)}return l(t,e),c(t,[{key:"componentWillReceiveProps",value:function(e){this.props.expanded&&!e.expanded&&this.setState({showModal:!1,linkTarget:"",linkTitle:"",linkTargetOption:this.props.config.defaultTargetOption});}},{key:"renderAddLinkModal",value:function(){var e=this.props,t=e.config.popupClassName,n=e.doCollapse,o=e.translations,r=this.state,i=r.linkTitle,a=r.linkTarget,l=r.linkTargetOption;return u.default.createElement("div",{className:(0, m.default)("rdw-link-modal",t),onClick:g.stopPropagation},u.default.createElement("label",{className:"rdw-link-modal-label",htmlFor:"linkTitle"},o["components.controls.link.linkTitle"]),u.default.createElement("input",{id:"linkTitle",className:"rdw-link-modal-input",onChange:this.updateValue,onBlur:this.updateValue,name:"linkTitle",value:i}),u.default.createElement("label",{className:"rdw-link-modal-label",htmlFor:"linkTarget"},o["components.controls.link.linkTarget"]),u.default.createElement("input",{id:"linkTarget",className:"rdw-link-modal-input",onChange:this.updateValue,onBlur:this.updateValue,name:"linkTarget",value:a}),u.default.createElement("label",{className:"rdw-link-modal-target-option",htmlFor:"openLinkInNewWindow"},u.default.createElement("input",{id:"openLinkInNewWindow",type:"checkbox",defaultChecked:"_blank"===l,value:"_blank",onChange:this.updateTargetOption}),u.default.createElement("span",null,o["components.controls.link.linkTargetOption"])),u.default.createElement("span",{className:"rdw-link-modal-buttonsection"},u.default.createElement("button",{className:"rdw-link-modal-btn",onClick:this.addLink,disabled:!a||!i},o["generic.add"]),u.default.createElement("button",{className:"rdw-link-modal-btn",onClick:n},o["generic.cancel"])))}},{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=t.options,o=t.link,r=t.unlink,i=t.className,a=e.currentState,l=e.expanded,c=e.translations,s=this.state.showModal;return u.default.createElement("div",{className:(0, m.default)("rdw-link-wrapper",i),"aria-label":"rdw-link-control"},n.indexOf("link")>=0&&u.default.createElement(M.default,{value:"unordered-list-item",className:(0, m.default)(o.className),onClick:this.signalExpandShowModal,"aria-haspopup":"true","aria-expanded":s,title:o.title||c["components.controls.link.link"]},u.default.createElement("img",{src:o.icon,alt:""})),n.indexOf("unlink")>=0&&u.default.createElement(M.default,{disabled:!a.link,value:"ordered-list-item",className:(0, m.default)(r.className),onClick:this.removeLink,title:r.title||c["components.controls.link.unlink"]},u.default.createElement("img",{src:r.icon,alt:""})),l&&s?this.renderAddLinkModal():void 0)}},{key:"renderInDropDown",value:function(){var e=this.props,t=e.expanded,n=e.onExpandEvent,o=e.doCollapse,r=e.doExpand,i=e.onChange,a=e.config,l=e.currentState,c=e.translations,s=a.options,d=a.link,p=a.unlink,f=a.className,g=a.dropdownClassName,h=a.title,M=this.state.showModal;return u.default.createElement("div",{className:"rdw-link-wrapper","aria-haspopup":"true","aria-label":"rdw-link-control","aria-expanded":t,title:h},u.default.createElement(b.Dropdown,{className:(0, m.default)("rdw-link-dropdown",f),optionWrapperClassName:(0, m.default)(g),onChange:i,expanded:t&&!M,doExpand:r,doCollapse:o,onExpandEvent:n},u.default.createElement("img",{src:(0, y.getFirstIcon)(a),alt:""}),s.indexOf("link")>=0&&u.default.createElement(b.DropdownOption,{onClick:this.forceExpandAndShowModal,className:(0, m.default)("rdw-link-dropdownoption",d.className),title:d.title||c["components.controls.link.link"]},u.default.createElement("img",{src:d.icon,alt:""})),s.indexOf("unlink")>=0&&u.default.createElement(b.DropdownOption,{onClick:this.removeLink,disabled:!l.link,className:(0, m.default)("rdw-link-dropdownoption",p.className),title:p.title||c["components.controls.link.unlink"]},u.default.createElement("img",{src:p.icon,alt:""}))),t&&M?this.renderAddLinkModal():void 0)}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(s.Component);j.propTypes={expanded:p.default.bool,doExpand:p.default.func,doCollapse:p.default.func,onExpandEvent:p.default.func,config:p.default.object,onChange:p.default.func,currentState:p.default.object,translations:p.default.object},t.default=j;},function(e,t){e.exports={"rdw-link-wrapper":"rdw-link-wrapper","rdw-link-dropdown":"rdw-link-dropdown","rdw-link-dropdownOption":"rdw-link-dropdownOption","rdw-link-dropdownPlaceholder":"rdw-link-dropdownPlaceholder","rdw-link-modal":"rdw-link-modal","rdw-link-modal-label":"rdw-link-modal-label","rdw-link-modal-input":"rdw-link-modal-input","rdw-link-modal-buttonsection":"rdw-link-modal-buttonsection","rdw-link-modal-target-option":"rdw-link-modal-target-option","rdw-link-modal-btn":"rdw-link-modal-btn","rdw-link-dropdownoption":"rdw-link-dropdownoption","rdw-history-dropdown":"rdw-history-dropdown"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(3),f=n(63),m=o(f),g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.addEmbeddedLink=function(e,t,n){var r=o.props,i=r.editorState,a=r.onChange,l=r.config.embedCallback,c=l?l(e):e,s=i.getCurrentContent().createEntity("EMBEDDED_LINK","MUTABLE",{src:c,height:t,width:n}).getLastCreatedEntityKey();a(p.AtomicBlockUtils.insertAtomicBlock(i,s," ")),o.doCollapse();},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse);}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,r=t.component||m.default;return s.default.createElement(r,{config:t,translations:n,onChange:this.addEmbeddedLink,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);g.propTypes={editorState:d.default.object.isRequired,onChange:d.default.func.isRequired,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=g;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),u=o(s),d=n(1),p=o(d),f=n(2),m=o(f),g=n(6),y=n(5),h=o(y);n(64);var M=function(e){function t(){var e,n,o,l;i(this,t);for(var c=arguments.length,s=Array(c),u=0;u<c;u++)s[u]=arguments[u];return n=o=a(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(s))),o.state={embeddedLink:"",height:o.props.config.defaultSize.height,width:o.props.config.defaultSize.width},o.onChange=function(){var e=o.props.onChange,t=o.state;e(t.embeddedLink,t.height,t.width);},o.updateValue=function(e){o.setState(r({},""+e.target.name,e.target.value));},l=n,a(o,l)}return l(t,e),c(t,[{key:"componentWillReceiveProps",value:function(e){if(this.props.expanded&&!e.expanded){var t=this.props.config.defaultSize,n=t.height,o=t.width;this.setState({embeddedLink:"",height:n,width:o});}}},{key:"rendeEmbeddedLinkModal",value:function(){var e=this.state,t=e.embeddedLink,n=e.height,o=e.width,r=this.props,i=r.config.popupClassName,a=r.doCollapse,l=r.translations;return u.default.createElement("div",{className:(0, m.default)("rdw-embedded-modal",i),onClick:g.stopPropagation},u.default.createElement("div",{className:"rdw-embedded-modal-header"},u.default.createElement("span",{className:"rdw-embedded-modal-header-option"},l["components.controls.embedded.embeddedlink"],u.default.createElement("span",{className:"rdw-embedded-modal-header-label"}))),u.default.createElement("div",{className:"rdw-embedded-modal-link-section"},u.default.createElement("span",{className:"rdw-embedded-modal-link-input-wrapper"},u.default.createElement("input",{className:"rdw-embedded-modal-link-input",placeholder:l["components.controls.embedded.enterlink"],onChange:this.updateValue,onBlur:this.updateValue,value:t,name:"embeddedLink"}),u.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),u.default.createElement("div",{className:"rdw-embedded-modal-size"},u.default.createElement("span",null,u.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:n,name:"height",className:"rdw-embedded-modal-size-input",placeholder:"Height"}),u.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),u.default.createElement("span",null,u.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:o,name:"width",className:"rdw-embedded-modal-size-input",placeholder:"Width"}),u.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")))),u.default.createElement("span",{className:"rdw-embedded-modal-btn-section"},u.default.createElement("button",{type:"button",className:"rdw-embedded-modal-btn",onClick:this.onChange,disabled:!t||!n||!o},l["generic.add"]),u.default.createElement("button",{type:"button",className:"rdw-embedded-modal-btn",onClick:a},l["generic.cancel"])))}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,r=t.title,i=e.expanded,a=e.onExpandEvent,l=e.translations;return u.default.createElement("div",{className:"rdw-embedded-wrapper","aria-haspopup":"true","aria-expanded":i,"aria-label":"rdw-embedded-control"},u.default.createElement(h.default,{className:(0, m.default)(o),value:"unordered-list-item",onClick:a,title:r||l["components.controls.embedded.embedded"]},u.default.createElement("img",{src:n,alt:""})),i?this.rendeEmbeddedLinkModal():void 0)}}]),t}(s.Component);M.propTypes={expanded:p.default.bool,onExpandEvent:p.default.func,onChange:p.default.func,config:p.default.object,translations:p.default.object,doCollapse:p.default.func},t.default=M;},function(e,t){e.exports={"rdw-embedded-wrapper":"rdw-embedded-wrapper","rdw-embedded-modal":"rdw-embedded-modal","rdw-embedded-modal-header":"rdw-embedded-modal-header","rdw-embedded-modal-header-option":"rdw-embedded-modal-header-option","rdw-embedded-modal-header-label":"rdw-embedded-modal-header-label","rdw-embedded-modal-link-section":"rdw-embedded-modal-link-section","rdw-embedded-modal-link-input":"rdw-embedded-modal-link-input","rdw-embedded-modal-link-input-wrapper":"rdw-embedded-modal-link-input-wrapper","rdw-embedded-modal-btn-section":"rdw-embedded-modal-btn-section","rdw-embedded-modal-btn":"rdw-embedded-modal-btn","rdw-embedded-modal-size":"rdw-embedded-modal-size","rdw-embedded-modal-size-input":"rdw-embedded-modal-size-input"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(3),f=n(66),m=o(f),g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.addEmoji=function(e){var t=o.props,n=t.editorState,r=t.onChange,i=p.Modifier.replaceText(n.getCurrentContent(),n.getSelection(),e,n.getCurrentInlineStyle());r(p.EditorState.push(n,i,"insert-characters")),o.doCollapse();},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse);}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,r=t.component||m.default;return s.default.createElement(r,{config:t,translations:n,onChange:this.addEmoji,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onCollpase:this.closeModal})}}]),t}(c.Component);g.propTypes={editorState:d.default.object.isRequired,onChange:d.default.func.isRequired,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=g;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p),m=n(6),g=n(5),y=o(g);n(67);var h=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.onChange=function(e){(0, o.props.onChange)(e.target.innerHTML);},a=n,i(o,a)}return a(t,e),l(t,[{key:"renderEmojiModal",value:function(){var e=this,t=this.props.config,n=t.popupClassName,o=t.emojis;return s.default.createElement("div",{className:(0, f.default)("rdw-emoji-modal",n),onClick:m.stopPropagation},o.map(function(t,n){return s.default.createElement("span",{key:n,className:"rdw-emoji-icon",alt:"",onClick:e.onChange},t)}))}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,r=t.title,i=e.expanded,a=e.onExpandEvent,l=e.translations;return s.default.createElement("div",{className:"rdw-emoji-wrapper","aria-haspopup":"true","aria-label":"rdw-emoji-control","aria-expanded":i,title:r||l["components.controls.emoji.emoji"]},s.default.createElement(y.default,{className:(0, f.default)(o),value:"unordered-list-item",onClick:a},s.default.createElement("img",{src:n,alt:""})),i?this.renderEmojiModal():void 0)}}]),t}(c.Component);h.propTypes={expanded:d.default.bool,onExpandEvent:d.default.func,onChange:d.default.func,config:d.default.object,translations:d.default.object},t.default=h;},function(e,t){e.exports={"rdw-emoji-wrapper":"rdw-emoji-wrapper","rdw-emoji-modal":"rdw-emoji-modal","rdw-emoji-icon":"rdw-emoji-icon"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(3),f=n(69),m=o(f),g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.addImage=function(e,t,n,r){var i=o.props,a=i.editorState,l=i.onChange,c=i.config,s={src:e,height:t,width:n};c.alt.present&&(s.alt=r);var u=a.getCurrentContent().createEntity("IMAGE","MUTABLE",s).getLastCreatedEntityKey();l(p.AtomicBlockUtils.insertAtomicBlock(a,u," ")),o.doCollapse();},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse);}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,r=t.component||m.default;return s.default.createElement(r,{config:t,translations:n,onChange:this.addImage,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse})}}]),t}(c.Component);g.propTypes={editorState:d.default.object.isRequired,onChange:d.default.func.isRequired,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=g;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),u=o(s),d=n(1),p=o(d),f=n(2),m=o(f),g=n(5),y=o(g),h=n(70),M=o(h);n(72);var b=function(e){function t(){var e,n,o,l;i(this,t);for(var c=arguments.length,s=Array(c),u=0;u<c;u++)s[u]=arguments[u];return n=o=a(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(s))),o.state={imgSrc:"",dragEnter:!1,uploadHighlighted:o.props.config.uploadEnabled&&!!o.props.config.uploadCallback,showImageLoading:!1,height:o.props.config.defaultSize.height,width:o.props.config.defaultSize.width,alt:""},o.onDragEnter=function(e){o.stopPropagation(e),o.setState({dragEnter:!0});},o.onImageDrop=function(e){e.preventDefault(),e.stopPropagation(),o.setState({dragEnter:!1});var t=void 0,n=void 0;e.dataTransfer.items?(t=e.dataTransfer.items,n=!0):(t=e.dataTransfer.files,n=!1);for(var r=0;r<t.length;r+=1)if((!n||"file"===t[r].kind)&&t[r].type.match("^image/")){var i=n?t[r].getAsFile():t[r];o.uploadImage(i);}},o.showImageUploadOption=function(){o.setState({uploadHighlighted:!0});},o.addImageFromState=function(){var e=o.state,t=e.imgSrc,n=e.alt,r=o.state,i=r.height,a=r.width,l=o.props.onChange;isNaN(i)||(i+="px"),isNaN(a)||(a+="px"),l(t,i,a,n);},o.showImageURLOption=function(){o.setState({uploadHighlighted:!1});},o.toggleShowImageLoading=function(){var e=!o.state.showImageLoading;o.setState({showImageLoading:e});},o.updateValue=function(e){o.setState(r({},""+e.target.name,e.target.value));},o.selectImage=function(e){e.target.files&&e.target.files.length>0&&o.uploadImage(e.target.files[0]);},o.uploadImage=function(e){o.toggleShowImageLoading(),(0, o.props.config.uploadCallback)(e).then(function(e){var t=e.data;o.setState({showImageLoading:!1,dragEnter:!1,imgSrc:t.link||t.url}),o.fileUpload=!1;}).catch(function(){o.setState({showImageLoading:!1,dragEnter:!1});});},o.fileUploadClick=function(e){o.fileUpload=!0,e.stopPropagation();},o.stopPropagation=function(e){o.fileUpload?o.fileUpload=!1:(e.preventDefault(),e.stopPropagation());},l=n,a(o,l)}return l(t,e),c(t,[{key:"componentWillReceiveProps",value:function(e){this.props.expanded&&!e.expanded?this.setState({imgSrc:"",dragEnter:!1,uploadHighlighted:this.props.config.uploadEnabled&&!!this.props.config.uploadCallback,showImageLoading:!1,height:this.props.config.defaultSize.height,width:this.props.config.defaultSize.width,alt:""}):e.config.uploadCallback===this.props.config.uploadCallback&&e.config.uploadEnabled===this.props.config.uploadEnabled||this.setState({uploadHighlighted:e.config.uploadEnabled&&!!e.config.uploadCallback});}},{key:"renderAddImageModal",value:function(){var e=this.state,t=e.imgSrc,n=e.uploadHighlighted,o=e.showImageLoading,r=e.dragEnter,i=e.height,a=e.width,l=e.alt,c=this.props,s=c.config,d=s.popupClassName,p=s.uploadCallback,f=s.uploadEnabled,g=s.urlEnabled,y=s.previewImage,h=s.inputAccept,b=s.alt,j=c.doCollapse,w=c.translations;return u.default.createElement("div",{className:(0, m.default)("rdw-image-modal",d),onClick:this.stopPropagation},u.default.createElement("div",{className:"rdw-image-modal-header"},f&&p&&u.default.createElement("span",{onClick:this.showImageUploadOption,className:"rdw-image-modal-header-option"},w["components.controls.image.fileUpload"],u.default.createElement("span",{className:(0, m.default)("rdw-image-modal-header-label",{"rdw-image-modal-header-label-highlighted":n})})),g&&u.default.createElement("span",{onClick:this.showImageURLOption,className:"rdw-image-modal-header-option"},w["components.controls.image.byURL"],u.default.createElement("span",{className:(0, m.default)("rdw-image-modal-header-label",{"rdw-image-modal-header-label-highlighted":!n})}))),n?u.default.createElement("div",{onClick:this.fileUploadClick},u.default.createElement("div",{onDragEnter:this.onDragEnter,onDragOver:this.stopPropagation,onDrop:this.onImageDrop,className:(0, m.default)("rdw-image-modal-upload-option",{"rdw-image-modal-upload-option-highlighted":r})},u.default.createElement("label",{htmlFor:"file",className:"rdw-image-modal-upload-option-label"},y&&t?u.default.createElement("img",{src:t,alt:t,className:"rdw-image-modal-upload-option-image-preview"}):t||w["components.controls.image.dropFileText"])),u.default.createElement("input",{type:"file",id:"file",accept:h,onChange:this.selectImage,className:"rdw-image-modal-upload-option-input"})):u.default.createElement("div",{className:"rdw-image-modal-url-section"},u.default.createElement("input",{className:"rdw-image-modal-url-input",placeholder:w["components.controls.image.enterlink"],name:"imgSrc",onChange:this.updateValue,onBlur:this.updateValue,value:t}),u.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),b.present&&u.default.createElement("div",{className:"rdw-image-modal-size"},u.default.createElement("span",{className:"rdw-image-modal-alt-lbl"},"Alt Text"),u.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:l,name:"alt",className:"rdw-image-modal-alt-input",placeholder:"alt"}),u.default.createElement("span",{className:"rdw-image-mandatory-sign"},b.mandatory&&"*")),u.default.createElement("div",{className:"rdw-image-modal-size"},"↕ ",u.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:i,name:"height",className:"rdw-image-modal-size-input",placeholder:"Height"}),u.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")," ↔ ",u.default.createElement("input",{onChange:this.updateValue,onBlur:this.updateValue,value:a,name:"width",className:"rdw-image-modal-size-input",placeholder:"Width"}),u.default.createElement("span",{className:"rdw-image-mandatory-sign"},"*")),u.default.createElement("span",{className:"rdw-image-modal-btn-section"},u.default.createElement("button",{className:"rdw-image-modal-btn",onClick:this.addImageFromState,disabled:!t||!i||!a||b.mandatory&&!l},w["generic.add"]),u.default.createElement("button",{className:"rdw-image-modal-btn",onClick:j},w["generic.cancel"])),o?u.default.createElement("div",{className:"rdw-image-modal-spinner"},u.default.createElement(M.default,null)):void 0)}},{key:"render",value:function(){var e=this.props,t=e.config,n=t.icon,o=t.className,r=t.title,i=e.expanded,a=e.onExpandEvent,l=e.translations;return u.default.createElement("div",{className:"rdw-image-wrapper","aria-haspopup":"true","aria-expanded":i,"aria-label":"rdw-image-control"},u.default.createElement(y.default,{className:(0, m.default)(o),value:"unordered-list-item",onClick:a,title:r||l["components.controls.image.image"]},u.default.createElement("img",{src:n,alt:""})),i?this.renderAddImageModal():void 0)}}]),t}(s.Component);b.propTypes={expanded:p.default.bool,onExpandEvent:p.default.func,doCollapse:p.default.func,onChange:p.default.func,config:p.default.object,translations:p.default.object},t.default=b;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var o=n(0),r=function(e){return e&&e.__esModule?e:{default:e}}(o);n(71),t.default=function(){return r.default.createElement("div",{className:"rdw-spinner"},r.default.createElement("div",{className:"rdw-bounce1"}),r.default.createElement("div",{className:"rdw-bounce2"}),r.default.createElement("div",{className:"rdw-bounce3"}))};},function(e,t){e.exports={"rdw-spinner":"rdw-spinner","sk-bouncedelay":"sk-bouncedelay","rdw-bounce1":"rdw-bounce1","rdw-bounce2":"rdw-bounce2"};},function(e,t){e.exports={"rdw-image-wrapper":"rdw-image-wrapper","rdw-image-modal":"rdw-image-modal","rdw-image-modal-header":"rdw-image-modal-header","rdw-image-modal-header-option":"rdw-image-modal-header-option","rdw-image-modal-header-label":"rdw-image-modal-header-label","rdw-image-modal-header-label-highlighted":"rdw-image-modal-header-label-highlighted","rdw-image-modal-upload-option":"rdw-image-modal-upload-option","rdw-image-modal-upload-option-highlighted":"rdw-image-modal-upload-option-highlighted","rdw-image-modal-upload-option-label":"rdw-image-modal-upload-option-label","rdw-image-modal-upload-option-image-preview":"rdw-image-modal-upload-option-image-preview","rdw-image-modal-upload-option-input":"rdw-image-modal-upload-option-input","rdw-image-modal-url-section":"rdw-image-modal-url-section","rdw-image-modal-url-input":"rdw-image-modal-url-input","rdw-image-modal-btn-section":"rdw-image-modal-btn-section","rdw-image-modal-btn":"rdw-image-modal-btn","rdw-image-modal-spinner":"rdw-image-modal-spinner","rdw-image-modal-alt-input":"rdw-image-modal-alt-input","rdw-image-modal-alt-lbl":"rdw-image-modal-alt-lbl","rdw-image-modal-size":"rdw-image-modal-size","rdw-image-modal-size-input":"rdw-image-modal-size-input","rdw-image-mandatory-sign":"rdw-image-mandatory-sign"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(3),f=n(4),m=n(6),g=n(74),y=o(g),h=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},o.removeInlineStyles=function(){var e=o.props,t=e.editorState;(0, e.onChange)(o.removeAllInlineStyles(t));},o.removeAllInlineStyles=function(e){var t=e.getCurrentContent();["BOLD","ITALIC","UNDERLINE","STRIKETHROUGH","MONOSPACE","SUPERSCRIPT","SUBSCRIPT"].forEach(function(n){t=p.Modifier.removeInlineStyle(t,e.getSelection(),n);});var n=(0, f.getSelectionCustomInlineStyle)(e,["FONTSIZE","FONTFAMILY","COLOR","BGCOLOR"]);return (0, m.forEach)(n,function(n,o){o&&(t=p.Modifier.removeInlineStyle(t,e.getSelection(),o));}),p.EditorState.push(e,t,"change-inline-style")},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){this.props.modalHandler.registerCallBack(this.expandCollapse);}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state.expanded,r=t.component||y.default;return s.default.createElement(r,{config:t,translations:n,expanded:o,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.removeInlineStyles})}}]),t}(c.Component);h.propTypes={onChange:d.default.func.isRequired,editorState:d.default.object.isRequired,config:d.default.object,translations:d.default.object,modalHandler:d.default.object},t.default=h;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),i=o(r),a=n(1),l=o(a),c=n(2),s=o(c),u=n(5),d=o(u);n(75);var p=function(e){var t=e.config,n=e.onChange,o=e.translations,r=t.icon,a=t.className,l=t.title;return i.default.createElement("div",{className:"rdw-remove-wrapper","aria-label":"rdw-remove-control"},i.default.createElement(d.default,{className:(0, s.default)(a),onClick:n,title:l||o["components.controls.remove.remove"]},i.default.createElement("img",{src:r,alt:""})))};p.propTypes={onChange:l.default.func,config:l.default.object,translations:l.default.object},t.default=p;},function(e,t){e.exports={"rdw-remove-wrapper":"rdw-remove-wrapper"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(3),f=n(77),m=o(f),g=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={expanded:!1,undoDisabled:!1,redoDisabled:!1},o.onExpandEvent=function(){o.signalExpanded=!o.state.expanded;},o.onChange=function(e){var t=o.props,n=t.editorState,r=t.onChange,i=p.EditorState[e](n);i&&r(i);},o.doExpand=function(){o.setState({expanded:!0});},o.doCollapse=function(){o.setState({expanded:!1});},o.expandCollapse=function(){o.setState({expanded:o.signalExpanded}),o.signalExpanded=!1;},a=n,i(o,a)}return a(t,e),l(t,[{key:"componentWillMount",value:function(){var e=this.props,t=e.editorState,n=e.modalHandler;t&&this.setState({undoDisabled:0===t.getUndoStack().size,redoDisabled:0===t.getRedoStack().size}),n.registerCallBack(this.expandCollapse);}},{key:"componentWillReceiveProps",value:function(e){e.editorState&&this.props.editorState!==e.editorState&&this.setState({undoDisabled:0===e.editorState.getUndoStack().size,redoDisabled:0===e.editorState.getRedoStack().size});}},{key:"componentWillUnmount",value:function(){this.props.modalHandler.deregisterCallBack(this.expandCollapse);}},{key:"render",value:function(){var e=this.props,t=e.config,n=e.translations,o=this.state,r=o.undoDisabled,i=o.redoDisabled,a=o.expanded,l=t.component||m.default;return s.default.createElement(l,{config:t,translations:n,currentState:{undoDisabled:r,redoDisabled:i},expanded:a,onExpandEvent:this.onExpandEvent,doExpand:this.doExpand,doCollapse:this.doCollapse,onChange:this.onChange})}}]),t}(c.Component);g.propTypes={onChange:d.default.func.isRequired,editorState:d.default.object,modalHandler:d.default.object,config:d.default.object,translations:d.default.object},t.default=g;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(2),f=o(p),m=n(8),g=n(5),y=o(g),h=n(7);n(78);var M=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.onChange=function(e){(0, o.props.onChange)(e);},a=n,i(o,a)}return a(t,e),l(t,[{key:"renderInDropDown",value:function(){var e=this.props,t=e.config,n=e.expanded,o=e.doExpand,r=e.onExpandEvent,i=e.doCollapse,a=e.currentState,l=a.undoDisabled,c=a.redoDisabled,u=e.translations,d=t.options,p=t.undo,g=t.redo,y=t.className,M=t.dropdownClassName,b=t.title;return s.default.createElement(h.Dropdown,{className:(0, f.default)("rdw-history-dropdown",y),optionWrapperClassName:(0, f.default)(M),expanded:n,doExpand:o,doCollapse:i,onExpandEvent:r,"aria-label":"rdw-history-control",title:b||u["components.controls.history.history"]},s.default.createElement("img",{src:(0, m.getFirstIcon)(t),alt:""}),d.indexOf("undo")>=0&&s.default.createElement(h.DropdownOption,{value:"undo",onClick:this.onChange,disabled:l,className:(0, f.default)("rdw-history-dropdownoption",p.className),title:p.title||u["components.controls.history.undo"]},s.default.createElement("img",{src:p.icon,alt:""})),d.indexOf("redo")>=0&&s.default.createElement(h.DropdownOption,{value:"redo",onClick:this.onChange,disabled:c,className:(0, f.default)("rdw-history-dropdownoption",g.className),title:g.title||u["components.controls.history.redo"]},s.default.createElement("img",{src:g.icon,alt:""})))}},{key:"renderInFlatList",value:function(){var e=this.props,t=e.config,n=t.options,o=t.undo,r=t.redo,i=t.className,a=e.currentState,l=a.undoDisabled,c=a.redoDisabled,u=e.translations;return s.default.createElement("div",{className:(0, f.default)("rdw-history-wrapper",i),"aria-label":"rdw-history-control"},n.indexOf("undo")>=0&&s.default.createElement(y.default,{value:"undo",onClick:this.onChange,className:(0, f.default)(o.className),disabled:l,title:o.title||u["components.controls.history.undo"]},s.default.createElement("img",{src:o.icon,alt:""})),n.indexOf("redo")>=0&&s.default.createElement(y.default,{value:"redo",onClick:this.onChange,className:(0, f.default)(r.className),disabled:c,title:r.title||u["components.controls.history.redo"]},s.default.createElement("img",{src:r.icon,alt:""})))}},{key:"render",value:function(){return this.props.config.inDropdown?this.renderInDropDown():this.renderInFlatList()}}]),t}(c.Component);M.propTypes={expanded:d.default.bool,doExpand:d.default.func,doCollapse:d.default.func,onExpandEvent:d.default.func,config:d.default.object,onChange:d.default.func,currentState:d.default.object,translations:d.default.object},t.default=M;},function(e,t){e.exports={"rdw-history-wrapper":"rdw-history-wrapper","rdw-history-dropdownoption":"rdw-history-dropdownoption","rdw-history-dropdown":"rdw-history-dropdown"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}function l(e,t,n){e.findEntityRanges(function(e){var t=e.getEntity();return null!==t&&"LINK"===n.getEntity(t).getType()},t);}function c(e){var t,n,o=e.showOpenOptionOnHover;return n=t=function(e){function t(){var e,n,o,a;r(this,t);for(var l=arguments.length,c=Array(l),s=0;s<l;s++)c[s]=arguments[s];return n=o=i(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(c))),o.state={showPopOver:!1},o.openLink=function(){var e=o.props,t=e.entityKey,n=e.contentState,r=n.getEntity(t).getData(),i=r.url,a=window.open(i,"blank");a&&a.focus();},o.toggleShowPopOver=function(){var e=!o.state.showPopOver;o.setState({showPopOver:e});},a=n,i(o,a)}return a(t,e),s(t,[{key:"render",value:function(){var e=this.props,t=e.children,n=e.entityKey,r=e.contentState,i=r.getEntity(n).getData(),a=i.url,l=i.targetOption,c=this.state.showPopOver;return d.default.createElement("span",{className:"rdw-link-decorator-wrapper",onMouseEnter:this.toggleShowPopOver,onMouseLeave:this.toggleShowPopOver},d.default.createElement("a",{href:a,target:l},t),c&&o?d.default.createElement("img",{src:g.default,alt:"",onClick:this.openLink,className:"rdw-link-decorator-icon"}):void 0)}}]),t}(u.Component),t.propTypes={entityKey:f.default.string.isRequired,children:f.default.array,contentState:f.default.object},n}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),u=n(0),d=o(u),p=n(1),f=o(p),m=n(80),g=o(m);n(81),t.default=function(e){return {strategy:l,component:c(e)}};},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuMDcyIDBIOC45MTVhLjkyNS45MjUgMCAwIDAgMCAxLjg0OWgyLjkyNUw2Ljk2MSA2LjcyN2EuOTE4LjkxOCAwIDAgMC0uMjcuNjU0YzAgLjI0Ny4wOTUuNDguMjcuNjU0YS45MTguOTE4IDAgMCAwIC42NTQuMjcuOTE4LjkxOCAwIDAgMCAuNjUzLS4yN2w0Ljg4LTQuODh2Mi45MjZhLjkyNS45MjUgMCAwIDAgMS44NDggMFYuOTI0QS45MjUuOTI1IDAgMCAwIDE0LjA3MiAweiIvPjxwYXRoIGQ9Ik0xMC42MjMgMTMuNDExSDEuNTg1VjQuMzcyaDYuNzk4bDEuNTg0LTEuNTg0SC43OTJBLjc5Mi43OTIgMCAwIDAgMCAzLjU4djEwLjYyNGMwIC40MzcuMzU1Ljc5Mi43OTIuNzkyaDEwLjYyNGEuNzkyLjc5MiAwIDAgMCAuNzkyLS43OTJWNS4wMjlsLTEuNTg1IDEuNTg0djYuNzk4eiIvPjwvZz48L3N2Zz4=";},function(e,t){e.exports={"rdw-link-decorator-wrapper":"rdw-link-decorator-wrapper","rdw-link-decorator-icon":"rdw-link-decorator-icon"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}var r=n(83),i=o(r),a=n(85),l=o(a),c=function(e){return [new i.default(e.mentionClassName).getMentionDecorator(),new l.default(e).getSuggestionDecorator()]};e.exports=c;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=n(0),a=o(i),l=n(1),c=o(l),s=n(2),u=o(s);n(84);var d=function e(t){r(this,e),p.call(this),this.className=t;},p=function(){var e=this;this.getMentionComponent=function(){var t=e.className,n=function(e){var n=e.entityKey,o=e.children,r=e.contentState,i=r.getEntity(n).getData(),l=i.url,c=i.value;return a.default.createElement("a",{href:l||c,className:(0, u.default)("rdw-mention-link",t)},o)};return n.propTypes={entityKey:c.default.number,children:c.default.array,contentState:c.default.object},n},this.getMentionDecorator=function(){return {strategy:e.findMentionEntities,component:e.getMentionComponent()}};};d.prototype.findMentionEntities=function(e,t,n){e.findEntityRanges(function(e){var t=e.getEntity();return null!==t&&"MENTION"===n.getEntity(t).getType()},t);},e.exports=d;},function(e,t){e.exports={"rdw-mention-link":"rdw-mention-link"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}function a(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l(){var e,t,n=this.config;return t=e=function(e){function t(){var e,o,i,l;a(this,t);for(var c=arguments.length,s=Array(c),u=0;u<c;u++)s[u]=arguments[u];return o=i=r(this,(e=t.__proto__||Object.getPrototypeOf(t)).call.apply(e,[this].concat(s))),i.state={style:{left:15},activeOption:-1,showSuggestions:!0},i.onEditorKeyDown=function(e){var t=i.state.activeOption,n={};"ArrowDown"===e.key?(e.preventDefault(),t===i.filteredSuggestions.length-1?n.activeOption=0:n.activeOption=t+1):"ArrowUp"===e.key?n.activeOption=t<=0?i.filteredSuggestions.length-1:t-1:"Escape"===e.key?(n.showSuggestions=!1,j.default.close()):"Enter"===e.key&&i.addMention(),i.setState(n);},i.onOptionMouseEnter=function(e){var t=e.target.getAttribute("data-index");i.setState({activeOption:t});},i.onOptionMouseLeave=function(){i.setState({activeOption:-1});},i.setSuggestionReference=function(e){i.suggestion=e;},i.setDropdownReference=function(e){i.dropdown=e;},i.closeSuggestionDropdown=function(){i.setState({showSuggestions:!1});},i.filteredSuggestions=[],i.filterSuggestions=function(e){var t=e.children[0].props.text.substr(1),o=n.getSuggestions();i.filteredSuggestions=o&&o.filter(function(e){return !t||0===t.length||(n.caseSensitive?e.value.indexOf(t)>=0:e.value.toLowerCase().indexOf(t&&t.toLowerCase())>=0)});},i.addMention=function(){var e=i.state.activeOption,t=n.getEditorState(),o=n.onChange,r=n.separator,a=n.trigger,l=i.filteredSuggestions[e];l&&(0, y.default)(t,o,r,a,l);},l=o,r(i,l)}return i(t,e),c(t,[{key:"componentDidMount",value:function(){var e=n.getWrapperRef().getBoundingClientRect(),t=this.suggestion.getBoundingClientRect(),o=this.dropdown.getBoundingClientRect(),r=void 0,i=void 0,a=void 0;e.width<t.left-e.left+o.width?i=15:r=15,e.bottom<o.bottom&&(a=0),this.setState({style:{left:r,right:i,bottom:a}}),M.default.registerCallBack(this.onEditorKeyDown),j.default.open(),n.modalHandler.setSuggestionCallback(this.closeSuggestionDropdown),this.filterSuggestions(this.props);}},{key:"componentWillReceiveProps",value:function(e){this.props.children!==e.children&&(this.filterSuggestions(e),this.setState({showSuggestions:!0}));}},{key:"componentWillUnmount",value:function(){M.default.deregisterCallBack(this.onEditorKeyDown),j.default.close(),n.modalHandler.removeSuggestionCallback();}},{key:"render",value:function(){var e=this,t=this.props.children,o=this.state,r=o.activeOption,i=o.showSuggestions,a=n.dropdownClassName,l=n.optionClassName;return u.default.createElement("span",{className:"rdw-suggestion-wrapper",ref:this.setSuggestionReference,onClick:n.modalHandler.onSuggestionClick,"aria-haspopup":"true","aria-label":"rdw-suggestion-popup"},u.default.createElement("span",null,t),i&&u.default.createElement("span",{className:(0, m.default)("rdw-suggestion-dropdown",a),contentEditable:"false",suppressContentEditableWarning:!0,style:this.state.style,ref:this.setDropdownReference},this.filteredSuggestions.map(function(t,n){return u.default.createElement("span",{key:n,spellCheck:!1,onClick:e.addMention,"data-index":n,onMouseEnter:e.onOptionMouseEnter,onMouseLeave:e.onOptionMouseLeave,className:(0, m.default)("rdw-suggestion-option",l,{"rdw-suggestion-option-active":n===r})},t.text)})))}}]),t}(s.Component),e.propTypes={children:p.default.array},t}var c=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),s=n(0),u=o(s),d=n(1),p=o(d),f=n(2),m=o(f),g=n(86),y=o(g),h=n(11),M=o(h),b=n(12),j=o(b);n(87);var w=function e(t){a(this,e),k.call(this);var n=t.separator,o=t.trigger,r=t.getSuggestions,i=t.onChange,l=t.getEditorState,c=t.getWrapperRef,s=t.caseSensitive,u=t.dropdownClassName,d=t.optionClassName,p=t.modalHandler;this.config={separator:n,trigger:o,getSuggestions:r,onChange:i,getEditorState:l,getWrapperRef:c,caseSensitive:s,dropdownClassName:u,optionClassName:d,modalHandler:p};},k=function(){var e=this;this.findSuggestionEntities=function(t,n){if(e.config.getEditorState()){var o=e.config,r=o.separator,i=o.trigger,a=o.getSuggestions,l=o.getEditorState,c=l().getSelection();if(c.get("anchorKey")===t.get("key")&&c.get("anchorKey")===c.get("focusKey")){var s=t.getText();s=s.substr(0,c.get("focusOffset")===s.length-1?s.length:c.get("focusOffset")+1);var u=s.lastIndexOf(r+i),d=r+i;if((void 0===u||u<0)&&s[0]===i&&(u=0,d=i),u>=0){var p=s.substr(u+d.length,s.length);a().some(function(t){return !!t.value&&(e.config.caseSensitive?t.value.indexOf(p)>=0:t.value.toLowerCase().indexOf(p&&p.toLowerCase())>=0)})&&n(0===u?0:u+1,s.length);}}}},this.getSuggestionComponent=l.bind(this),this.getSuggestionDecorator=function(){return {strategy:e.findSuggestionEntities,component:e.getSuggestionComponent()}};};e.exports=w;},function(e,t,n){function o(e,t,n,o,a){var l=a.value,c=a.url,s=e.getCurrentContent().createEntity("MENTION","IMMUTABLE",{text:""+o+l,value:l,url:c}).getLastCreatedEntityKey(),u=(0, i.getSelectedBlock)(e),d=u.getText(),p=e.getSelection().focusOffset,f=(d.lastIndexOf(n+o,p)||0)+1,m=!1;d.length===f+1&&(p=d.length)," "===d[p]&&(m=!0);var g=e.getSelection().merge({anchorOffset:f,focusOffset:p}),y=r.EditorState.acceptSelection(e,g),h=r.Modifier.replaceText(y.getCurrentContent(),g,""+o+l,y.getCurrentInlineStyle(),s);y=r.EditorState.push(y,h,"insert-characters"),m||(g=y.getSelection().merge({anchorOffset:f+l.length+o.length,focusOffset:f+l.length+o.length}),y=r.EditorState.acceptSelection(y,g),h=r.Modifier.insertText(y.getCurrentContent(),g," ",y.getCurrentInlineStyle(),void 0)),t(r.EditorState.push(y,h,"insert-characters"));}Object.defineProperty(t,"__esModule",{value:!0}),t.default=o;var r=n(3),i=n(4);},function(e,t){e.exports={"rdw-suggestion-wrapper":"rdw-suggestion-wrapper","rdw-suggestion-dropdown":"rdw-suggestion-dropdown","rdw-suggestion-option":"rdw-suggestion-option","rdw-suggestion-option-active":"rdw-suggestion-option-active"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=n(0),a=o(i),l=n(1),c=o(l),s=n(2),u=o(s);n(89);var d=function e(t){var n=this;r(this,e),this.getHashtagComponent=function(){var e=n.className,t=function(t){var n=t.children,o=n[0].props.text;return a.default.createElement("a",{href:o,className:(0, u.default)("rdw-hashtag-link",e)},n)};return t.propTypes={children:c.default.object},t},this.findHashtagEntities=function(e,t){for(var o=e.getText(),r=0,i=0;o.length>0&&r>=0;)if(o[0]===n.hashCharacter?(r=0,i=0,o=o.substr(n.hashCharacter.length)):(r=o.indexOf(n.separator+n.hashCharacter))>=0&&(o=o.substr(r+(n.separator+n.hashCharacter).length),i+=r+n.separator.length),r>=0){var a=o.indexOf(n.separator)>=0?o.indexOf(n.separator):o.length,l=o.substr(0,a);l&&l.length>0&&(t(i,i+l.length+n.hashCharacter.length),i+=n.hashCharacter.length);}},this.getHashtagDecorator=function(){return {strategy:n.findHashtagEntities,component:n.getHashtagComponent()}},this.className=t.className,this.hashCharacter=t.hashCharacter||"#",this.separator=t.separator||" ";},p=function(e){return new d(e).getHashtagDecorator()};e.exports=p;},function(e,t){e.exports={"rdw-hashtag-link":"rdw-hashtag-link"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var r=n(91),i=o(r),a=n(92),l=o(a),c=function(e,t){return function(n){if("function"==typeof t){var o=t(n,e,e.getEditorState);if(o)return o}if("atomic"===n.getType()){var r=e.getEditorState().getCurrentContent(),a=r.getEntity(n.getEntityAt(0));if(a&&"IMAGE"===a.type)return {component:(0, l.default)(e),editable:!1};if(a&&"EMBEDDED_LINK"===a.type)return {component:i.default,editable:!1}}}};t.default=c;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),i=o(r),a=n(1),l=o(a),c=function(e){var t=e.block,n=e.contentState,o=n.getEntity(t.getEntityAt(0)),r=o.getData(),a=r.src,l=r.height,c=r.width;return i.default.createElement("iframe",{height:l,width:c,src:a,frameBorder:"0",allowFullScreen:!0,title:"Wysiwyg Embedded Content"})};c.propTypes={block:l.default.object,contentState:l.default.object},t.default=c;},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t);}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o);}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=n(0),s=o(c),u=n(1),d=o(u),p=n(3),f=n(2),m=o(f),g=n(5),y=o(g);n(93);var h=function(e){var t,n;return n=t=function(t){function n(){var t,o,a,l;r(this,n);for(var c=arguments.length,s=Array(c),u=0;u<c;u++)s[u]=arguments[u];return o=a=i(this,(t=n.__proto__||Object.getPrototypeOf(n)).call.apply(t,[this].concat(s))),a.state={hovered:!1},a.setEntityAlignmentLeft=function(){a.setEntityAlignment("left");},a.setEntityAlignmentRight=function(){a.setEntityAlignment("right");},a.setEntityAlignmentCenter=function(){a.setEntityAlignment("none");},a.setEntityAlignment=function(t){var n=a.props,o=n.block,r=n.contentState,i=o.getEntityAt(0);r.mergeEntityData(i,{alignment:t}),e.onChange(p.EditorState.push(e.getEditorState(),r,"change-block-data")),a.setState({dummy:!0});},a.toggleHovered=function(){var e=!a.state.hovered;a.setState({hovered:e});},l=o,i(a,l)}return a(n,t),l(n,[{key:"renderAlignmentOptions",value:function(e){return s.default.createElement("div",{className:(0, m.default)("rdw-image-alignment-options-popup",{"rdw-image-alignment-options-popup-right":"right"===e})},s.default.createElement(y.default,{onClick:this.setEntityAlignmentLeft,className:"rdw-image-alignment-option"},"L"),s.default.createElement(y.default,{onClick:this.setEntityAlignmentCenter,className:"rdw-image-alignment-option"},"C"),s.default.createElement(y.default,{onClick:this.setEntityAlignmentRight,className:"rdw-image-alignment-option"},"R"))}},{key:"render",value:function(){var t=this.props,n=t.block,o=t.contentState,r=this.state.hovered,i=e.isReadOnly,a=e.isImageAlignmentEnabled,l=o.getEntity(n.getEntityAt(0)),c=l.getData(),u=c.src,d=c.alignment,p=c.height,f=c.width,g=c.alt;return s.default.createElement("span",{onMouseEnter:this.toggleHovered,onMouseLeave:this.toggleHovered,className:(0, m.default)("rdw-image-alignment",{"rdw-image-left":"left"===d,"rdw-image-right":"right"===d,"rdw-image-center":!d||"none"===d})},s.default.createElement("span",{className:"rdw-image-imagewrapper"},s.default.createElement("img",{src:u,alt:g,style:{height:p,width:f}}),!i()&&r&&a()?this.renderAlignmentOptions(d):void 0))}}]),n}(c.Component),t.propTypes={block:d.default.object,contentState:d.default.object},n};t.default=h;},function(e,t){e.exports={"rdw-image-alignment-options-popup":"rdw-image-alignment-options-popup","rdw-alignment-option-left":"rdw-alignment-option-left","rdw-image-alignment-option":"rdw-image-alignment-option","rdw-image-alignment":"rdw-image-alignment","rdw-image-imagewrapper":"rdw-image-imagewrapper","rdw-image-center":"rdw-image-center","rdw-image-left":"rdw-image-left","rdw-image-right":"rdw-image-right","rdw-image-alignment-options-popup-right":"rdw-image-alignment-options-popup-right"};},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var r=n(95),i=o(r),a=n(96),l=o(a),c=n(97),s=o(c),u=n(98),d=o(u),p=n(99),f=o(p),m=n(100),g=o(m),y=n(101),h=o(y),M=n(102),b=o(M),j=n(103),w=o(j),k=n(104),N=o(k),C=n(105),E=o(C),L=n(106),D=o(L),S=n(107),v=o(S),x=n(108),I=o(x),A=n(109),T=o(A),O=n(110),_=o(O),z=n(111),P=o(z),U=n(112),F=o(U),B=n(113),Y=o(B),R=n(114),Q=o(R),H=n(115),Z=o(H),W=n(116),G=o(W),J=n(117),V=o(J),q=n(118),K=o(q),X=n(119),$=o(X);t.default={options:["inline","blockType","fontSize","fontFamily","list","textAlign","colorPicker","link","embedded","emoji","image","remove","history"],inline:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["bold","italic","underline","strikethrough","monospace","superscript","subscript"],bold:{icon:i.default,className:void 0,title:void 0},italic:{icon:l.default,className:void 0,title:void 0},underline:{icon:s.default,className:void 0,title:void 0},strikethrough:{icon:d.default,className:void 0,title:void 0},monospace:{icon:f.default,className:void 0,title:void 0},superscript:{icon:$.default,className:void 0,title:void 0},subscript:{icon:K.default,className:void 0,title:void 0}},blockType:{inDropdown:!0,options:["Normal","H1","H2","H3","H4","H5","H6","Blockquote","Code"],className:void 0,component:void 0,dropdownClassName:void 0,title:void 0},fontSize:{icon:g.default,options:[8,9,10,11,12,14,16,18,24,30,36,48,60,72,96],className:void 0,component:void 0,dropdownClassName:void 0,title:void 0},fontFamily:{options:["Arial","Georgia","Impact","Tahoma","Times New Roman","Verdana"],className:void 0,component:void 0,dropdownClassName:void 0,title:void 0},list:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["unordered","ordered","indent","outdent"],unordered:{icon:N.default,className:void 0,title:void 0},ordered:{icon:w.default,className:void 0,title:void 0},indent:{icon:h.default,className:void 0,title:void 0},outdent:{icon:b.default,className:void 0,title:void 0},title:void 0},textAlign:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["left","center","right","justify"],left:{icon:E.default,className:void 0,title:void 0},center:{icon:D.default,className:void 0,title:void 0},right:{icon:v.default,className:void 0,title:void 0},justify:{icon:I.default,className:void 0,title:void 0},title:void 0},colorPicker:{icon:T.default,className:void 0,component:void 0,popupClassName:void 0,colors:["rgb(97,189,109)","rgb(26,188,156)","rgb(84,172,210)","rgb(44,130,201)","rgb(147,101,184)","rgb(71,85,119)","rgb(204,204,204)","rgb(65,168,95)","rgb(0,168,133)","rgb(61,142,185)","rgb(41,105,176)","rgb(85,57,130)","rgb(40,50,78)","rgb(0,0,0)","rgb(247,218,100)","rgb(251,160,38)","rgb(235,107,86)","rgb(226,80,65)","rgb(163,143,132)","rgb(239,239,239)","rgb(255,255,255)","rgb(250,197,28)","rgb(243,121,52)","rgb(209,72,65)","rgb(184,49,47)","rgb(124,112,107)","rgb(209,213,216)"],title:void 0},link:{inDropdown:!1,className:void 0,component:void 0,popupClassName:void 0,dropdownClassName:void 0,showOpenOptionOnHover:!0,defaultTargetOption:"_self",options:["link","unlink"],link:{icon:P.default,className:void 0,title:void 0},unlink:{icon:F.default,className:void 0,title:void 0},linkCallback:void 0},emoji:{icon:Y.default,className:void 0,component:void 0,popupClassName:void 0,emojis:["😀","😁","😂","😃","😉","😋","😎","😍","😗","🤗","🤔","😣","😫","😴","😌","🤓","😛","😜","😠","😇","😷","😈","👻","😺","😸","😹","😻","😼","😽","🙀","🙈","🙉","🙊","👼","👮","🕵","💂","👳","🎅","👸","👰","👲","🙍","🙇","🚶","🏃","💃","⛷","🏂","🏌","🏄","🚣","🏊","⛹","🏋","🚴","👫","💪","👈","👉","👉","👆","🖕","👇","🖖","🤘","🖐","👌","👍","👎","✊","👊","👏","🙌","🙏","🐵","🐶","🐇","🐥","🐸","🐌","🐛","🐜","🐝","🍉","🍄","🍔","🍤","🍨","🍪","🎂","🍰","🍾","🍷","🍸","🍺","🌍","🚑","⏰","🌙","🌝","🌞","⭐","🌟","🌠","🌨","🌩","⛄","🔥","🎄","🎈","🎉","🎊","🎁","🎗","🏀","🏈","🎲","🔇","🔈","📣","🔔","🎵","🎷","💰","🖊","📅","✅","❎","💯"],title:void 0},embedded:{icon:Q.default,className:void 0,component:void 0,popupClassName:void 0,embedCallback:void 0,defaultSize:{height:"auto",width:"auto"},title:void 0},image:{icon:Z.default,className:void 0,component:void 0,popupClassName:void 0,urlEnabled:!0,uploadEnabled:!0,previewImage:!1,alignmentEnabled:!0,uploadCallback:void 0,inputAccept:"image/gif,image/jpeg,image/jpg,image/png,image/svg",alt:{present:!1,mandatory:!1},defaultSize:{height:"auto",width:"auto"},title:void 0},remove:{icon:_.default,className:void 0,component:void 0,title:void 0},history:{inDropdown:!1,className:void 0,component:void 0,dropdownClassName:void 0,options:["undo","redo"],undo:{icon:G.default,className:void 0,title:void 0},redo:{icon:V.default,className:void 0,title:void 0},title:void 0}};},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuMjM2IDBjMS42NTIgMCAyLjk0LjI5OCAzLjg2Ni44OTMuOTI1LjU5NSAxLjM4OCAxLjQ4NSAxLjM4OCAyLjY2OSAwIC42MDEtLjE3MyAxLjEzOS0uNTE2IDEuNjEtLjM0My40NzQtLjg0NC44My0xLjQ5OSAxLjA2OC44NDMuMTY3IDEuNDc0LjUyMyAxLjg5NSAxLjA3MS40MTkuNTUuNjMgMS4xODMuNjMgMS45MDMgMCAxLjI0NS0uNDQ0IDIuMTg3LTEuMzMgMi44MjUtLjg4Ni42NDEtMi4xNDQuOTYxLTMuNzY5Ljk2MUgwdi0yLjE2N2gxLjQ5NFYyLjE2N0gwVjBoNi4yMzZ6TTQuMzA4IDUuNDQ2aDIuMDI0Yy43NTIgMCAxLjMzLS4xNDMgMS43MzQtLjQzLjQwNS0uMjg1LjYwOC0uNzAxLjYwOC0xLjI1IDAtLjYtLjIwNC0xLjA0NC0uNjEyLTEuMzMtLjQwOC0uMjg2LTEuMDE2LS40MjctMS44MjYtLjQyN0g0LjMwOHYzLjQzN3ptMCAxLjgwNFYxMWgyLjU5M2MuNzQ3IDAgMS4zMTQtLjE1MiAxLjcwNy0uNDUyLjM5LS4zLjU4OC0uNzQ1LjU4OC0xLjMzNCAwLS42MzYtLjE2OC0xLjEyNC0uNS0xLjQ2LS4zMzYtLjMzNS0uODY0LS41MDQtMS41ODItLjUwNEg0LjMwOHoiIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTcgM1YyaDR2MUg5Ljc1M2wtMyAxMEg4djFINHYtMWgxLjI0N2wzLTEwSDd6Ii8+PC9zdmc+";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiI+PHBhdGggZD0iTTYuMDQ1IDJ2Ljk5Mkw0Ljc4NSAzdjUuMTcyYzAgLjg1OS4yNDMgMS41MTIuNzI3IDEuOTU3czEuMTI0LjY2OCAxLjkxOC42NjhjLjgzNiAwIDEuNTA5LS4yMjEgMi4wMTktLjY2NC41MTEtLjQ0Mi43NjYtMS4wOTYuNzY2LTEuOTYxVjNsLTEuMjYtLjAwOFYySDEzdi45OTJMMTEuNzM5IDN2NS4xNzJjMCAxLjIzNC0uMzk4IDIuMTgxLTEuMTk1IDIuODQtLjc5Ny42NTktMS44MzUuOTg4LTMuMTE0Ljk4OC0xLjI0MiAwLTIuMjQ4LS4zMjktMy4wMTctLjk4OC0uNzY5LS42NTktMS4xNTItMS42MDUtMS4xNTItMi44NFYzTDIgMi45OTJWMmg0LjA0NXpNMiAxM2gxMXYxSDJ6Ii8+PC9zdmc+";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNC4wNCA1Ljk1NGg2LjIxNWE3LjQxMiA3LjQxMiAwIDAgMC0uNzk1LS40MzggMTEuOTA3IDExLjkwNyAwIDAgMC0xLjQ0Ny0uNTU3Yy0xLjE4OC0uMzQ4LTEuOTY2LS43MTEtMi4zMzQtMS4wODgtLjM2OC0uMzc3LS41NTItLjc3LS41NTItMS4xODEgMC0uNDk1LjE4Ny0uOTA2LjU2LTEuMjMyLjM4LS4zMzEuODg3LS40OTcgMS41MjMtLjQ5Ny42OCAwIDEuMjY2LjI1NSAxLjc1Ny43NjcuMjk1LjMxNS41ODIuODkxLjg2MSAxLjczbC4xMTcuMDE2LjcwMy4wNS4xLS4wMjRjLjAyOC0uMTUyLjA0Mi0uMjc5LjA0Mi0uMzggMC0uMzM3LS4wMzktLjg1Mi0uMTE3LTEuNTQ0YTkuMzc0IDkuMzc0IDAgMCAwLS4xNzYtLjk5NUM5Ljg4LjM3OSA5LjM4NS4yNDQgOS4wMTcuMTc2IDguMzY1LjA3IDcuODk5LjAxNiA3LjYyLjAxNmMtMS40NSAwLTIuNTQ1LjM1Ny0zLjI4NyAxLjA3MS0uNzQ3LjcyLTEuMTIgMS41ODktMS4xMiAyLjYwNyAwIC41MTEuMTMzIDEuMDQuNCAxLjU4Ni4xMjkuMjUzLjI3LjQ3OC40MjcuNjc0ek04LjI4IDguMTE0Yy41NzUuMjM2Ljk1Ny40MzYgMS4xNDcuNTk5LjQ1MS40MS42NzcuODUyLjY3NyAxLjMyNCAwIC4zODMtLjEzLjc0NS0uMzkzIDEuMDg4LS4yNS4zMzgtLjU5LjU4LTEuMDIuNzI2YTMuNDE2IDMuNDE2IDAgMCAxLTEuMTYzLjIyOGMtLjQwNyAwLS43NzUtLjA2Mi0xLjEwNC0uMTg2YTIuNjk2IDIuNjk2IDAgMCAxLS44NzgtLjQ4IDMuMTMzIDMuMTMzIDAgMCAxLS42Ny0uNzk0IDEuNTI3IDEuNTI3IDAgMCAxLS4xMDQtLjIyNyA1Ny41MjMgNTcuNTIzIDAgMCAwLS4xODgtLjQ3MyAyMS4zNzEgMjEuMzcxIDAgMCAwLS4yNTEtLjU5OWwtLjg1My4wMTd2LjM3MWwtLjAxNy4zMTNhOS45MiA5LjkyIDAgMCAwIDAgLjU3M2MuMDExLjI3LjAxNy43MDkuMDE3IDEuMzE2di4xMWMwIC4wNzkuMDIyLjE0LjA2Ny4xODUuMDgzLjA2OC4yODQuMTQ3LjYwMi4yMzdsMS4xNy4zMzdjLjQ1Mi4xMy45OTYuMTk0IDEuNjMyLjE5NC42ODYgMCAxLjI1Mi0uMDU5IDEuNjk4LS4xNzdhNC42OTQgNC42OTQgMCAwIDAgMS4yOC0uNTU3Yy40MDEtLjI1OS43MDUtLjQ4Ni45MTEtLjY4My4yNjgtLjI3Ni40NjYtLjU2OC41OTQtLjg3OGE0Ljc0IDQuNzQgMCAwIDAgLjM0My0xLjc4OGMwLS4yOTgtLjAyLS41NTctLjA1OC0uNzc2SDguMjgxek0xNC45MTQgNi41N2EuMjYuMjYgMCAwIDAtLjE5My0uMDc2SC4yNjhhLjI2LjI2IDAgMCAwLS4xOTMuMDc2LjI2NC4yNjQgMCAwIDAtLjA3NS4xOTR2LjU0YzAgLjA3OS4wMjUuMTQzLjA3NS4xOTRhLjI2LjI2IDAgMCAwIC4xOTMuMDc2SDE0LjcyYS4yNi4yNiAwIDAgMCAuMTkzLS4wNzYuMjY0LjI2NCAwIDAgMCAuMDc1LS4xOTR2LS41NGEuMjY0LjI2NCAwIDAgMC0uMDc1LS4xOTR6Ii8+PC9nPjwvc3ZnPg==";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzQ0NCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMS4wMjEgMi45MDZjLjE4NiAxLjIxOS4zNzIgMS41LjM3MiAyLjcxOUMxLjM5MyA2LjM3NSAwIDcuMDMxIDAgNy4wMzF2LjkzOHMxLjM5My42NTYgMS4zOTMgMS40MDZjMCAxLjIxOS0uMTg2IDEuNS0uMzcyIDIuNzE5Qy43NDMgMTQuMDYzIDEuNzY0IDE1IDIuNjkzIDE1aDEuOTV2LTEuODc1cy0xLjY3Mi4xODgtMS42NzItLjkzOGMwLS44NDMuMTg2LS44NDMuMzcyLTIuNzE4LjA5My0uODQ0LS40NjQtMS41LTEuMDIyLTEuOTY5LjU1OC0uNDY5IDEuMTE1LTEuMDMxIDEuMDIyLTEuODc1QzMuMDY0IDMuNzUgMi45NyAzLjc1IDIuOTcgMi45MDZjMC0xLjEyNSAxLjY3Mi0xLjAzMSAxLjY3Mi0xLjAzMVYwaC0xLjk1QzEuNjcgMCAuNzQzLjkzOCAxLjAyIDIuOTA2ek0xMS45NzkgMi45MDZjLS4xODYgMS4yMTktLjM3MiAxLjUtLjM3MiAyLjcxOSAwIC43NSAxLjM5MyAxLjQwNiAxLjM5MyAxLjQwNnYuOTM4cy0xLjM5My42NTYtMS4zOTMgMS40MDZjMCAxLjIxOS4xODYgMS41LjM3MiAyLjcxOS4yNzggMS45NjktLjc0MyAyLjkwNi0xLjY3MiAyLjkwNmgtMS45NXYtMS44NzVzMS42NzIuMTg4IDEuNjcyLS45MzhjMC0uODQzLS4xODYtLjg0My0uMzcyLTIuNzE4LS4wOTMtLjg0NC40NjQtMS41IDEuMDIyLTEuOTY5LS41NTgtLjQ2OS0xLjExNS0xLjAzMS0xLjAyMi0xLjg3NS4xODYtMS44NzUuMzcyLTEuODc1LjM3Mi0yLjcxOSAwLTEuMTI1LTEuNjcyLTEuMDMxLTEuNjcyLTEuMDMxVjBoMS45NWMxLjAyMiAwIDEuOTUuOTM4IDEuNjcyIDIuOTA2eiIvPjwvZz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTEuOTIxIDMuMTE5YS40MjcuNDI3IDAgMCAwIC4zMzUuMTY0aC45N2EuNDI2LjQyNiAwIDAgMCAuMzA0LS4xMy40NDEuNDQxIDAgMCAwIC4xMjUtLjMxbC4wMDItMi40MWEuNDM0LjQzNCAwIDAgMC0uNDMtLjQzMkguNDNBLjQzNC40MzQgMCAwIDAgMCAuNDR2Mi40MDZjMCAuMjQyLjE5Mi40MzguNDMuNDM4aC45N2MuMTMgMCAuMjU0LS4wNi4zMzUtLjE2NWwuNzMtLjkzSDUuNTR2MTEuMzZjMCAuMjQxLjE5Mi40MzcuNDMuNDM3aDEuNzE3Yy4yMzcgMCAuNDMtLjE5Ni40My0uNDM3VjIuMTg4aDMuMDdsLjczNC45MzF6TTEzLjg5OCAxMS4yNjNhLjQyNS40MjUgMCAwIDAtLjQ4Mi0uMTQ2bC0uNTQ3LjE5NFY5LjYxN2EuNDQyLjQ0MiAwIDAgMC0uMTI2LS4zMS40MjYuNDI2IDAgMCAwLS4zMDQtLjEyN2gtLjQyOWEuNDM0LjQzNCAwIDAgMC0uNDMuNDM3djEuNjk0bC0uNTQ3LS4xOTRhLjQyNS40MjUgMCAwIDAtLjQ4MS4xNDYuNDQ0LjQ0NCAwIDAgMC0uMDE2LjUxMmwxLjMzMiAyLjAxN2EuNDI3LjQyNyAwIDAgMCAuNzEzIDBsMS4zMzMtMi4wMTdhLjQ0NC40NDQgMCAwIDAtLjAxNi0uNTEyeiIvPjwvZz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNS43MTYgMy4yMTFIMTd2MS4xOTdINS43MTZ6TTAgLjAyaDE3djEuMTk3SDB6TTAgMTIuNzgzaDE3djEuMTk3SDB6TTUuNzE2IDkuNTkzSDE3djEuMTk3SDUuNzE2ek01LjcxNiA2LjQwMkgxN3YxLjE5N0g1LjcxNnpNLjE4NyA5LjQ5MUwyLjUyIDcgLjE4NyA0LjUwOXoiLz48L2c+PC9zdmc+";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNS4zOTYgMy4xOTNoMTAuNTczVjQuMzlINS4zOTZ6TS4wMzkuMDAzaDE1LjkzVjEuMkguMDM5ek0uMDM5IDEyLjc2NmgxNS45M3YxLjE5N0guMDM5ek01LjM5NiA5LjU3NWgxMC41NzN2MS4xOTdINS4zOTZ6TTUuMzk2IDYuMzg0aDEwLjU3M3YxLjE5N0g1LjM5NnpNMi4xODcgNC40OTFMMCA2Ljk4M2wyLjE4NyAyLjQ5MXoiLz48L2c+PC9zdmc+";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNNC4yMDIgMS40NjZoOC4xNWMuMzM4IDAgLjYxMi0uMzIyLjYxMi0uNzIgMC0uMzk3LS4yNzQtLjcyLS42MTItLjcyaC04LjE1Yy0uMzM4IDAtLjYxMS4zMjMtLjYxMS43MiAwIC4zOTguMjczLjcyLjYxLjcyek0xMi4zNTIgNS43ODNoLTguMTVjLS4zMzggMC0uNjExLjMyMi0uNjExLjcyIDAgLjM5Ny4yNzMuNzIuNjEuNzJoOC4xNTFjLjMzOCAwIC42MTItLjMyMy42MTItLjcyIDAtLjM5OC0uMjc0LS43Mi0uNjEyLS43MnpNMTIuMzUyIDExLjU0aC04LjE1Yy0uMzM4IDAtLjYxMS4zMjItLjYxMS43MiAwIC4zOTYuMjczLjcxOS42MS43MTloOC4xNTFjLjMzOCAwIC42MTItLjMyMy42MTItLjcyIDAtLjM5Ny0uMjc0LS43Mi0uNjEyLS43MnpNLjc2NyAxLjI0OXYxLjgwMmMwIC4xOTUuMTM2LjM0My4zMTUuMzQzLjE3NiAwIC4zMTUtLjE1LjMxNS0uMzQzVi4zNTZjMC0uMTktLjEzMy0uMzM5LS4zMDItLjMzOS0uMTQ4IDAtLjIyMy4xMTgtLjI0Ny4xNTZhLjIyOC4yMjggMCAwIDAtLjAwMy4wMDVMLjU3OS42MjFhLjQ3NC40NzQgMCAwIDAtLjA5OC4yNzNjMCAuMTk0LjEyOC4zNTEuMjg2LjM1NXpNLjM1MiA4LjE5SDEuNTVjLjE1NyAwIC4yODUtLjE2Mi4yODUtLjM2MiAwLS4xOTgtLjEyOC0uMzU5LS4yODUtLjM1OUguNjh2LS4wMDZjMC0uMTA3LjIxLS4yODEuMzc4LS40MjIuMzM2LS4yNzguNzUzLS42MjUuNzUzLTEuMjI2IDAtLjU3LS4zNzYtMS0uODc0LTEtLjQ3NyAwLS44MzYuMzg1LS44MzYuODk3IDAgLjI5Ny4xNjQuNDAyLjMwNS40MDIuMiAwIC4zMjEtLjE3Ni4zMjEtLjM0NiAwLS4xMDYuMDIzLS4yMjguMjA0LS4yMjguMjQzIDAgLjI1LjI1NC4yNS4yODMgMCAuMjI4LS4yNTIuNDQyLS40OTUuNjQ5LS4zMDEuMjU1LS42NDIuNTQ0LS42NDIuOTkydi4zODRjMCAuMjA1LjE1OS4zNDMuMzA4LjM0M3pNMS43NyAxMC41NDNjMC0uNTkyLS4yOTYtLjkzMS0uODE0LS45MzEtLjY4IDAtLjg1OS41Ny0uODU5Ljg3MiAwIC4zNTEuMjIyLjM5LjMxOC4zOS4xODUgMCAuMzEtLjE0OC4zMS0uMzY2IDAtLjA4NC4wMjYtLjE4MS4yMjQtLjE4MS4xNDIgMCAuMi4wMjQuMi4yNjcgMCAuMjM3LS4wNDMuMjYzLS4yMTMuMjYzLS4xNjQgMC0uMjg4LjE1Mi0uMjg4LjM1NCAwIC4yLjEyNS4zNS4yOTEuMzUuMjI1IDAgLjI3LjEwOC4yNy4yODN2LjA3NWMwIC4yOTQtLjA5Ny4zNS0uMjc3LjM1LS4yNDggMC0uMjY3LS4xNS0uMjY3LS4xOTcgMC0uMTc0LS4wOTgtLjM1LS4zMTctLjM1LS4xOTIgMC0uMzA3LjE0MS0uMzA3LjM3OCAwIC40My4zMTMuODg4Ljg5NS44ODguNTY0IDAgLjkwMS0uNC45MDEtMS4wN3YtLjA3NGMwLS4yNzQtLjA3NC0uNTAyLS4yMTQtLjY2Ni4wOTYtLjE2My4xNDgtLjM4LjE0OC0uNjM1eiIvPjwvZz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMS43MiAzLjQyN2MuOTUxIDAgMS43MjItLjc2OCAxLjcyMi0xLjcwOFMyLjY3LjAxIDEuNzIuMDFDLjc3LjAwOCAwIC43NzUgMCAxLjcxNWMwIC45NC43NzQgMS43MTEgMS43MiAxLjcxMXptMC0yLjYyNWMuNTEgMCAuOTIyLjQxMi45MjIuOTE0YS45Mi45MiAwIDAgMS0xLjg0MiAwIC45Mi45MiAwIDAgMSAuOTItLjkxNHpNMS43MiA4LjcwM2MuOTUxIDAgMS43MjItLjc2OCAxLjcyMi0xLjcwOFMyLjY3IDUuMjg3IDEuNzIgNS4yODdDLjc3IDUuMjg3IDAgNi4wNTIgMCA2Ljk5NXMuNzc0IDEuNzA4IDEuNzIgMS43MDh6bTAtMi42MjJjLjUxIDAgLjkyMi40MTIuOTIyLjkxNGEuOTIuOTIgMCAwIDEtMS44NDIgMGMwLS41MDUuNDE1LS45MTQuOTItLjkxNHpNMS43MiAxMy45ODJjLjk1MSAwIDEuNzIyLS43NjggMS43MjItMS43MDggMC0uOTQzLS43NzQtMS43MDgtMS43MjEtMS43MDgtLjk0NyAwLTEuNzIxLjc2OC0xLjcyMSAxLjcwOHMuNzc0IDEuNzA4IDEuNzIgMS43MDh6bTAtMi42MjVjLjUxIDAgLjkyMi40MTIuOTIyLjkxNGEuOTIuOTIgMCAxIDEtMS44NDIgMCAuOTIuOTIgMCAwIDEgLjkyLS45MTR6TTUuNzQ0IDIuMTE1aDkuODQ1YS40LjQgMCAwIDAgLjQwMS0uMzk5LjQuNCAwIDAgMC0uNDAxLS4zOTlINS43NDRhLjQuNCAwIDAgMC0uNDAyLjM5OS40LjQgMCAwIDAgLjQwMi4zOTl6TTUuNzQ0IDcuMzk0aDkuODQ1YS40LjQgMCAwIDAgLjQwMS0uMzk5LjQuNCAwIDAgMC0uNDAxLS4zOThINS43NDRhLjQuNCAwIDAgMC0uNDAyLjM5OC40LjQgMCAwIDAgLjQwMi4zOTl6TTUuNzQ0IDEyLjY3aDkuODQ1YS40LjQgMCAwIDAgLjQwMS0uMzk5LjQuNCAwIDAgMC0uNDAxLS4zOTlINS43NDRhLjQuNCAwIDAgMC0uNDAyLjQuNC40IDAgMCAwIC40MDIuMzk4eiIvPjwvZz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNOC40OTMgMTQuODg3SC4zMjZhLjMyNi4zMjYgMCAwIDEgMC0uNjUyaDguMTY3YS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjE4IDEwLjE2MkguMzI2YS4zMjYuMzI2IDAgMCAxIDAtLjY1M2gxNC4yOTJhLjMyNi4zMjYgMCAwIDEgMCAuNjUzek04LjQ5MyA1LjQzNUguMzI2YS4zMjYuMzI2IDAgMCAxIDAtLjY1Mmg4LjE2N2EuMzI2LjMyNiAwIDAgMSAwIC42NTJ6TTE0LjYxOC43MDlILjMyNmEuMzI2LjMyNiAwIDAgMSAwLS42NTJoMTQuMjkyYS4zMjYuMzI2IDAgMCAxIDAgLjY1MnoiLz48L2c+PC9zdmc+";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTEuNTU2IDE0Ljg4N0gzLjM4OGEuMzI2LjMyNiAwIDAgMSAwLS42NTJoOC4xNjdhLjMyNi4zMjYgMCAwIDEgMCAuNjUyek0xNC42MTggMTAuMTYySC4zMjZhLjMyNi4zMjYgMCAwIDEgMC0uNjUzaDE0LjI5MmEuMzI2LjMyNiAwIDAgMSAwIC42NTN6TTExLjU1NiA1LjQzNUgzLjM4OGEuMzI2LjMyNiAwIDAgMSAwLS42NTJoOC4xNjdhLjMyNi4zMjYgMCAwIDEgMCAuNjUyek0xNC42MTguNzA5SC4zMjZhLjMyNi4zMjYgMCAwIDEgMC0uNjUyaDE0LjI5MmEuMzI2LjMyNiAwIDAgMSAwIC42NTJ6Ii8+PC9nPjwvc3ZnPg==";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNjE4IDE0Ljg4N0g2LjQ1YS4zMjYuMzI2IDAgMCAxIDAtLjY1Mmg4LjE2N2EuMzI2LjMyNiAwIDAgMSAwIC42NTJ6TTE0LjYxOCAxMC4xNjJILjMyNmEuMzI2LjMyNiAwIDAgMSAwLS42NTNoMTQuMjkyYS4zMjYuMzI2IDAgMCAxIDAgLjY1M3pNMTQuNjE4IDUuNDM1SDYuNDVhLjMyNi4zMjYgMCAwIDEgMC0uNjUyaDguMTY3YS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjE4LjcwOUguMzI2YS4zMjYuMzI2IDAgMCAxIDAtLjY1MmgxNC4yOTJhLjMyNi4zMjYgMCAwIDEgMCAuNjUyeiIvPjwvZz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNjIgMTQuODg4SC4zMjVhLjMyNi4zMjYgMCAwIDEgMC0uNjUySDE0LjYyYS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjIgMTAuMTYySC4zMjVhLjMyNi4zMjYgMCAwIDEgMC0uNjUySDE0LjYyYS4zMjYuMzI2IDAgMCAxIDAgLjY1MnpNMTQuNjIgNS40MzZILjMyNWEuMzI2LjMyNiAwIDAgMSAwLS42NTJIMTQuNjJhLjMyNi4zMjYgMCAwIDEgMCAuNjUyek0xNC42Mi43MUguMzI1YS4zMjYuMzI2IDAgMCAxIDAtLjY1M0gxNC42MmEuMzI2LjMyNiAwIDAgMSAwIC42NTN6Ii8+PC9nPjwvc3ZnPg==";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNDA2LjU4NWExLjk5OCAxLjk5OCAwIDAgMC0yLjgyNSAwbC0uNTQuNTRhLjc0MS43NDEgMCAxIDAtMS4wNDggMS4wNDhsLjE3NS4xNzUtNS44MjYgNS44MjUtMi4wMjIgMi4wMjNhLjkxLjkxIDAgMCAwLS4yNjYuNjAybC0uMDA1LjEwOHYuMDAybC0uMDgxIDEuODI5YS4zMDIuMzAyIDAgMCAwIC4zMDIuMzE2aC4wMTNsLjk3LS4wNDQuNTkyLS4wMjYuMjY4LS4wMTJjLjI5Ny0uMDEzLjU3OS0uMTM3Ljc5LS4zNDdsNy43Ny03Ljc3LjE0Ni4xNDRhLjc0Ljc0IDAgMCAwIDEuMDQ4IDBjLjI5LS4yOS4yOS0uNzU5IDAtMS4wNDhsLjU0LS41NGMuNzgtLjc4Ljc4LTIuMDQ0IDAtMi44MjV6TTguNzk1IDcuMzMzbC0yLjczLjUxNSA0LjQ1Mi00LjQ1MiAxLjEwOCAxLjEwNy0yLjgzIDIuODN6TTIuMDggMTMuNjczYy0xLjE0OCAwLTIuMDguMjk1LTIuMDguNjYgMCAuMzYzLjkzMi42NTggMi4wOC42NTggMS4xNSAwIDIuMDgtLjI5NCAyLjA4LS42NTkgMC0uMzY0LS45My0uNjU5LTIuMDgtLjY1OXoiLz48L2c+PC9zdmc+";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNSIgaGVpZ2h0PSIxNSIgdmlld0JveD0iMCAwIDE2IDE2Ij48cGF0aCBkPSJNOC4xIDE0bDYuNC03LjJjLjYtLjcuNi0xLjgtLjEtMi41bC0yLjctMi43Yy0uMy0uNC0uOC0uNi0xLjMtLjZIOC42Yy0uNSAwLTEgLjItMS40LjZMLjUgOS4yYy0uNi43LS42IDEuOS4xIDIuNWwyLjcgMi43Yy4zLjQuOC42IDEuMy42SDE2di0xSDguMXptLTEuMy0uMXMwLS4xIDAgMGwtMi43LTIuN2MtLjQtLjQtLjQtLjkgMC0xLjNMNy41IDZoLTFsLTMgMy4zYy0uNi43LS42IDEuNy4xIDIuNEw1LjkgMTRINC42Yy0uMiAwLS40LS4xLS42LS4yTDEuMiAxMWMtLjMtLjMtLjMtLjggMC0xLjFMNC43IDZoMS44TDEwIDJoMUw3LjUgNmwzLjEgMy43LTMuNSA0Yy0uMS4xLS4yLjEtLjMuMnoiLz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEzLjk2Ny45NUEzLjIyNiAzLjIyNiAwIDAgMCAxMS42Ny4wMDJjLS44NyAwLTEuNjg2LjMzNy0yLjI5Ny45NDhMNy4xMDUgMy4yMThBMy4yNDcgMy4yNDcgMCAwIDAgNi4yNCA2LjI0YTMuMjI1IDMuMjI1IDAgMCAwLTMuMDIyLjg2NUwuOTUgOS4zNzNhMy4yNTMgMy4yNTMgMCAwIDAgMCA0LjU5NCAzLjIyNiAzLjIyNiAwIDAgMCAyLjI5Ny45NDhjLjg3IDAgMS42ODYtLjMzNiAyLjI5OC0uOTQ4TDcuODEyIDExLjdhMy4yNDcgMy4yNDcgMCAwIDAgLjg2NS0zLjAyMyAzLjIyNSAzLjIyNSAwIDAgMCAzLjAyMi0uODY1bDIuMjY4LTIuMjY3YTMuMjUyIDMuMjUyIDAgMCAwIDAtNC41OTV6TTcuMTA1IDEwLjk5M0w0LjgzNyAxMy4yNmEyLjIzMyAyLjIzMyAwIDAgMS0xLjU5LjY1NSAyLjIzMyAyLjIzMyAwIDAgMS0xLjU5LS42NTUgMi4yNTIgMi4yNTIgMCAwIDEgMC0zLjE4bDIuMjY4LTIuMjY4YTIuMjMyIDIuMjMyIDAgMCAxIDEuNTktLjY1NWMuNDMgMCAuODQxLjEyIDEuMTk1LjM0M0w0Ljc3MiA5LjQzOGEuNS41IDAgMSAwIC43MDcuNzA3bDEuOTM5LTEuOTM4Yy41NDUuODY4LjQ0MiAyLjAzLS4zMTMgMi43ODV6bTYuMTU1LTYuMTU1bC0yLjI2OCAyLjI2N2EyLjIzMyAyLjIzMyAwIDAgMS0xLjU5LjY1NWMtLjQzMSAwLS44NDEtLjEyLTEuMTk1LS4zNDNsMS45MzgtMS45MzhhLjUuNSAwIDEgMC0uNzA3LS43MDdMNy40OTkgNi43MWEyLjI1MiAyLjI1MiAwIDAgMSAuMzEzLTIuNzg1bDIuMjY3LTIuMjY4YTIuMjMzIDIuMjMzIDAgMCAxIDEuNTktLjY1NSAyLjIzMyAyLjIzMyAwIDAgMSAyLjI0NiAyLjI0NWMwIC42MDMtLjIzMiAxLjE2OC0uNjU1IDEuNTl6IiBmaWxsPSIjMDAwIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTMuOTU2IDEuMDM3YTMuNTUgMy41NSAwIDAgMC01LjAxNCAwTDYuNDM2IDMuNTQ0YS41NDUuNTQ1IDAgMSAwIC43Ny43N2wyLjUwOC0yLjUwNmEyLjQzOCAyLjQzOCAwIDAgMSAxLjczNS0uNzE1Yy42NTggMCAxLjI3NS4yNTQgMS43MzYuNzE1LjQ2LjQ2MS43MTUgMS4wNzguNzE1IDEuNzM2IDAgLjY1OC0uMjU0IDEuMjc0LS43MTUgMS43MzVMOS45MDcgOC41NThhMi40NTggMi40NTggMCAwIDEtMy40NzIgMCAuNTQ1LjU0NSAwIDEgMC0uNzcxLjc3MSAzLjUzNCAzLjUzNCAwIDAgMCAyLjUwNyAxLjAzN2MuOTA4IDAgMS44MTYtLjM0NiAyLjUwNy0xLjAzN2wzLjI3OC0zLjI3OGEzLjUyIDMuNTIgMCAwIDAgMS4wMzUtMi41MDdjMC0uOTUtLjM2Ny0xLjg0LTEuMDM1LTIuNTA3eiIvPjxwYXRoIGQ9Ik03LjQgMTEuMDY1bC0yLjEyMiAyLjEyYTIuNDM3IDIuNDM3IDAgMCAxLTEuNzM1LjcxNiAyLjQzNyAyLjQzNyAwIDAgMS0xLjczNi0uNzE1IDIuNDU3IDIuNDU3IDAgMCAxIDAtMy40NzFsMy4wODYtMy4wODZhMi40MzggMi40MzggMCAwIDEgMS43MzUtLjcxNWMuNjU4IDAgMS4yNzUuMjU0IDEuNzM2LjcxNWEuNTQ1LjU0NSAwIDEgMCAuNzcxLS43NzEgMy41NSAzLjU1IDAgMCAwLTUuMDE0IDBMMS4wMzYgOC45NDRBMy41MiAzLjUyIDAgMCAwIDAgMTEuNDVjMCAuOTUuMzY3IDEuODQgMS4wMzUgMi41MDdhMy41MiAzLjUyIDAgMCAwIDIuNTA2IDEuMDM1Yy45NSAwIDEuODQtLjM2OCAyLjUwNy0xLjAzNWwyLjEyMi0yLjEyMWEuNTQ1LjU0NSAwIDAgMC0uNzcxLS43NzF6TTkuMjc0IDEyLjAwMmEuNTQ2LjU0NiAwIDAgMC0uNTQ2LjU0NXYxLjYzN2EuNTQ2LjU0NiAwIDAgMCAxLjA5MSAwdi0xLjYzN2EuNTQ1LjU0NSAwIDAgMC0uNTQ1LS41NDV6TTExLjIzIDExLjYxNmEuNTQ1LjU0NSAwIDEgMC0uNzcyLjc3MmwxLjE1NyAxLjE1NmEuNTQzLjU0MyAwIDAgMCAuNzcxIDAgLjU0NS41NDUgMCAwIDAgMC0uNzdsLTEuMTU2LTEuMTU4ek0xMi41MzcgOS44MkgxMC45YS41NDYuNTQ2IDAgMCAwIDAgMS4wOTFoMS42MzdhLjU0Ni41NDYgMCAwIDAgMC0xLjA5ek00LjkxIDMuNTQ3YS41NDYuNTQ2IDAgMCAwIC41NDUtLjU0NVYxLjM2NmEuNTQ2LjU0NiAwIDAgMC0xLjA5IDB2MS42MzZjMCAuMzAxLjI0NC41NDUuNTQ1LjU0NXpNMi44ODggMy45MzNhLjU0My41NDMgMCAwIDAgLjc3MSAwIC41NDUuNTQ1IDAgMCAwIDAtLjc3MUwyLjUwMiAyLjAwNWEuNTQ1LjU0NSAwIDEgMC0uNzcxLjc3bDEuMTU3IDEuMTU4ek0xLjYyOCA1LjczaDEuNjM2YS41NDYuNTQ2IDAgMCAwIDAtMS4wOTJIMS42MjhhLjU0Ni41NDYgMCAwIDAgMCAxLjA5MXoiLz48L2c+PC9zdmc+";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIHZpZXdCb3g9IjE1LjcyOSAyMi4wODIgMTcgMTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTI5LjcwOCAyNS4xMDRjLTMuMDIxLTMuMDIyLTcuOTM3LTMuMDIyLTEwLjk1OCAwLTMuMDIxIDMuMDItMy4wMiA3LjkzNiAwIDEwLjk1OCAzLjAyMSAzLjAyIDcuOTM3IDMuMDIgMTAuOTU4LS4wMDEgMy4wMi0zLjAyMSAzLjAyLTcuOTM2IDAtMTAuOTU3em0tLjg0NSAxMC4xMTJhNi41NiA2LjU2IDAgMCAxLTkuMjY4IDAgNi41NiA2LjU2IDAgMCAxIDAtOS4yNjcgNi41NiA2LjU2IDAgMCAxIDkuMjY4IDAgNi41NiA2LjU2IDAgMCAxIDAgOS4yNjd6bS03LjUyNC02LjczYS45MDYuOTA2IDAgMSAxIDEuODExIDAgLjkwNi45MDYgMCAwIDEtMS44MTEgMHptNC4xMDYgMGEuOTA2LjkwNiAwIDEgMSAxLjgxMiAwIC45MDYuOTA2IDAgMCAxLTEuODEyIDB6bTIuMTQxIDMuNzA4Yy0uNTYxIDEuMjk4LTEuODc1IDIuMTM3LTMuMzQ4IDIuMTM3LTEuNTA1IDAtMi44MjctLjg0My0zLjM2OS0yLjE0N2EuNDM4LjQzOCAwIDAgMSAuODEtLjMzNmMuNDA1Ljk3NiAxLjQxIDEuNjA3IDIuNTU5IDEuNjA3IDEuMTIzIDAgMi4xMjEtLjYzMSAyLjU0NC0xLjYwOGEuNDM4LjQzOCAwIDAgMSAuODA0LjM0N3oiLz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuNzA4IDYuNjE1YS40MzYuNDM2IDAgMCAwLS41NDMuMjkxbC0xLjgzIDYuMDQ1YS40MzYuNDM2IDAgMCAwIC44MzMuMjUyTDcgNy4xNmEuNDM2LjQzNiAwIDAgMC0uMjktLjU0NHpNOC45MzEgNi42MTVhLjQzNi40MzYgMCAwIDAtLjU0My4yOTFsLTEuODMgNi4wNDVhLjQzNi40MzYgMCAwIDAgLjgzNC4yNTJsMS44My02LjA0NGEuNDM2LjQzNiAwIDAgMC0uMjktLjU0NHoiLz48cGF0aCBkPSJNMTYuNTY0IDBILjQzNkEuNDM2LjQzNiAwIDAgMCAwIC40MzZ2MTYuMTI4YzAgLjI0LjE5NS40MzYuNDM2LjQzNmgxNi4xMjhjLjI0IDAgLjQzNi0uMTk1LjQzNi0uNDM2Vi40MzZBLjQzNi40MzYgMCAwIDAgMTYuNTY0IDB6TTMuNDg3Ljg3MmgxMC4wMjZ2MS43NDNIMy40ODdWLjg3MnptLTIuNjE1IDBoMS43NDN2MS43NDNILjg3MlYuODcyem0xNS4yNTYgMTUuMjU2SC44NzJWMy40ODhoMTUuMjU2djEyLjY0em0wLTEzLjUxM2gtMS43NDNWLjg3MmgxLjc0M3YxLjc0M3oiLz48Y2lyY2xlIGN4PSI5My44NjciIGN5PSIyNDUuMDY0IiByPSIxMy4xMjgiIHRyYW5zZm9ybT0ibWF0cml4KC4wMzMyIDAgMCAuMDMzMiAwIDApIi8+PGNpcmNsZSBjeD0iOTMuODY3IiBjeT0iMzYwLjU5MiIgcj0iMTMuMTI4IiB0cmFuc2Zvcm09Im1hdHJpeCguMDMzMiAwIDAgLjAzMzIgMCAwKSIvPjxwYXRoIGQ9Ik0xNC4yNTQgMTIuNjQxSDEwLjJhLjQzNi40MzYgMCAwIDAgMCAuODcyaDQuMDU0YS40MzYuNDM2IDAgMCAwIDAtLjg3MnoiLz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIj48cGF0aCBkPSJNMTQuNzQxIDBILjI2Qy4xMTYgMCAwIC4xMzYgMCAuMzA0djEzLjM5MmMwIC4xNjguMTE2LjMwNC4yNTkuMzA0SDE0Ljc0Yy4xNDMgMCAuMjU5LS4xMzYuMjU5LS4zMDRWLjMwNEMxNSAuMTM2IDE0Ljg4NCAwIDE0Ljc0MSAwem0tLjI1OCAxMy4zOTFILjUxN1YuNjFoMTMuOTY2VjEzLjM5eiIvPjxwYXRoIGQ9Ik00LjEzOCA2LjczOGMuNzk0IDAgMS40NC0uNzYgMS40NC0xLjY5NXMtLjY0Ni0xLjY5NS0xLjQ0LTEuNjk1Yy0uNzk0IDAtMS40NC43Ni0xLjQ0IDEuNjk1IDAgLjkzNC42NDYgMS42OTUgMS40NCAxLjY5NXptMC0yLjc4MWMuNTA5IDAgLjkyMy40ODcuOTIzIDEuMDg2IDAgLjU5OC0uNDE0IDEuMDg2LS45MjMgMS4wODYtLjUwOSAwLS45MjMtLjQ4Ny0uOTIzLTEuMDg2IDAtLjU5OS40MTQtMS4wODYuOTIzLTEuMDg2ek0xLjgxIDEyLjE3NGMuMDYgMCAuMTIyLS4wMjUuMTcxLS4wNzZMNi4yIDcuNzI4bDIuNjY0IDMuMTM0YS4yMzIuMjMyIDAgMCAwIC4zNjYgMCAuMzQzLjM0MyAwIDAgMCAwLS40M0w3Ljk4NyA4Ljk2OWwyLjM3NC0zLjA2IDIuOTEyIDMuMTQyYy4xMDYuMTEzLjI3LjEwNS4zNjYtLjAyYS4zNDMuMzQzIDAgMCAwLS4wMTYtLjQzbC0zLjEwNC0zLjM0N2EuMjQ0LjI0NCAwIDAgMC0uMTg2LS4wOC4yNDUuMjQ1IDAgMCAwLS4xOC4xTDcuNjIyIDguNTM3IDYuMzk0IDcuMDk0YS4yMzIuMjMyIDAgMCAwLS4zNTQtLjAxM2wtNC40IDQuNTZhLjM0My4zNDMgMCAwIDAtLjAyNC40My4yNDMuMjQzIDAgMCAwIC4xOTQuMTAzeiIvPjwvZz48L3N2Zz4=";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcgMTQuODc1YzIuNjcyIDAgNC44NDYtMi4xNDUgNC44NDYtNC43ODEgMC0yLjYzNy0yLjE3NC00Ljc4MS00Ljg0Ni00Ljc4MVY4LjVMMS42MTUgNC4yNSA3IDB2My4xODhjMy44NiAwIDcgMy4wOTggNyA2LjkwNlMxMC44NiAxNyA3IDE3cy03LTMuMDk4LTctNi45MDZoMi4xNTRjMCAyLjYzNiAyLjE3NCA0Ljc4MSA0Ljg0NiA0Ljc4MXoiIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuNTA0IDEzLjk3N2E0LjQ5NyA0LjQ5NyAwIDAgMS00LjQ5Mi00LjQ5MiA0LjQ5NyA0LjQ5NyAwIDAgMSA0LjQ5Mi00LjQ5M3YyLjk5NWw0Ljk5LTMuOTkzTDYuNTA0IDB2Mi45OTVhNi40OTYgNi40OTYgMCAwIDAtNi40ODggNi40OWMwIDMuNTc4IDIuOTEgNi40OSA2LjQ4OCA2LjQ5YTYuNDk2IDYuNDk2IDAgMCAwIDYuNDg3LTYuNDloLTEuOTk2YTQuNDk3IDQuNDk3IDAgMCAxLTQuNDkxIDQuNDkyeiIgZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTExLjg2NiAxMS42NDZIOS4wNkw1Ljg2NyA3Ljk0MmwtMy4xMjEgMy43MDRIMGw0LjUyNC01LjA2NEwuMjE4IDEuODA0aDIuNzdsMyAzLjQ2NCAzLjAyMy0zLjQ2NGgyLjY1TDcuMzA2IDYuNTgybDQuNTYgNS4wNjR6bTEuNzI1IDIuMDU4bDEuODI3LTEuMzY4Yy42NC0uNDM1IDEuMDYyLS44NCAxLjI2NC0xLjIxMi4yMDItLjM3Mi4zMDItLjc3My4zMDItMS4yMDIgMC0uNy0uMjM3LTEuMjY2LS43MS0xLjY5Ni0uNDc0LS40MzEtMS4wOTctLjY0Ni0xLjg2OS0uNjQ2LS43NDQgMC0xLjM0LjIxOC0xLjc4NS42NTMtLjQ0Ni40MzYtLjY3IDEuMDkyLS42NyAxLjk3aDEuNDM2YzAtLjUyNC4wOTQtLjg4Ni4yODEtMS4wODcuMTg4LS4yLjQ0NS0uMzAxLjc3Mi0uMzAxcy41ODYuMTAyLjc3Ny4zMDZjLjE5LjIwNC4yODYuNDU4LjI4Ni43NiAwIC4zMDMtLjA4OC41NzctLjI2Ni44MjItLjE3Ny4yNDUtLjY3LjY1OC0xLjQ3OCAxLjI0LS42OTIuNS0xLjYyOC45NzEtMS45MSAxLjQxM0wxMS44NjQgMTVIMTd2LTEuMjk2aC0zLjQxeiIvPjwvc3ZnPg==";},function(e,t){e.exports="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTcuMzA1IDEwLjE2NUwxMS44NjUgMTVIOS4wNTdsLTMuMTkyLTMuNTM2TDIuNzQ2IDE1SDBsNC41MjMtNC44MzVMLjIxOCA1LjYwM2gyLjc3TDUuOTg2IDguOTEgOS4wMSA1LjYwM2gyLjY0OWwtNC4zNTQgNC41NjJ6bTYuMjM0LTMuMjY5bDEuODc5LTEuMzA2Yy42NC0uNDE2IDEuMDYyLS44MDEgMS4yNjQtMS4xNTcuMjAxLS4zNTYuMzAyLS43MzguMzAyLTEuMTQ4IDAtLjY2OS0uMjM3LTEuMjEtLjcxLTEuNjItLjQ3NC0uNDExLTEuMDk3LS42MTctMS44NjgtLjYxNy0uNzQ0IDAtMS4zNC4yMDgtMS43ODUuNjI0LS40NDcuNDE2LS42NyAxLjA0My0uNjcgMS44ODFoMS40MzZjMC0uNS4wOTQtLjg0Ni4yODEtMS4wMzguMTg4LS4xOTEuNDQ1LS4yODcuNzcyLS4yODdzLjU4NS4wOTcuNzc3LjI5MmMuMTkuMTk1LjI4Ni40MzcuMjg2LjcyNiAwIC4yOS0uMDg5LjU1LS4yNjYuNzg1cy0uNjcuNjI4LTEuNDc5IDEuMTg0Yy0uNjkxLjQ3Ny0xLjYyNy45MjctMS45MDggMS4zNWwuMDE0IDEuNTY5SDE3VjYuODk2aC0zLjQ2MXoiLz48L3N2Zz4=";},function(e,t,n){function o(e){return e&&e.__esModule?e:{default:e}}var r=n(121),i=o(r),a=n(122),l=o(a),c=n(123),s=o(c),u=n(124),d=o(u),p=n(125),f=o(p),m=n(126),g=o(m),y=n(127),h=o(y),M=n(128),b=o(M),j=n(129),w=o(j),k=n(130),N=o(k),C=n(131),E=o(C),L=n(132),D=o(L),S=n(133),v=o(S),x=n(134),I=o(x);e.exports={en:i.default,fr:l.default,zh:s.default,ru:d.default,pt:f.default,ko:g.default,it:h.default,nl:b.default,de:w.default,da:N.default,zh_tw:E.default,pl:D.default,es:v.default,ja:I.default};},function(e,t,n){e.exports={"generic.add":"Add","generic.cancel":"Cancel","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Blockquote","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Block Type","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Color Picker","components.controls.colorpicker.text":"Text","components.controls.colorpicker.background":"Highlight","components.controls.embedded.embedded":"Embedded","components.controls.embedded.embeddedlink":"Embedded Link","components.controls.embedded.enterlink":"Enter link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Font","components.controls.fontsize.fontsize":"Font Size","components.controls.history.history":"History","components.controls.history.undo":"Undo","components.controls.history.redo":"Redo","components.controls.image.image":"Image","components.controls.image.fileUpload":"File Upload","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop the file or click to upload","components.controls.inline.bold":"Bold","components.controls.inline.italic":"Italic","components.controls.inline.underline":"Underline","components.controls.inline.strikethrough":"Strikethrough","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Superscript","components.controls.inline.subscript":"Subscript","components.controls.link.linkTitle":"Link Title","components.controls.link.linkTarget":"Link Target","components.controls.link.linkTargetOption":"Open link in new window","components.controls.link.link":"Link","components.controls.link.unlink":"Unlink","components.controls.list.list":"List","components.controls.list.unordered":"Unordered","components.controls.list.ordered":"Ordered","components.controls.list.indent":"Indent","components.controls.list.outdent":"Outdent","components.controls.remove.remove":"Remove","components.controls.textalign.textalign":"Text Align","components.controls.textalign.left":"Left","components.controls.textalign.center":"Center","components.controls.textalign.right":"Right","components.controls.textalign.justify":"Justify"};},function(e,t,n){e.exports={"generic.add":"Ok","generic.cancel":"Annuler","components.controls.blocktype.h1":"Titre 1","components.controls.blocktype.h2":"Titre 2","components.controls.blocktype.h3":"Titre 3","components.controls.blocktype.h4":"Titre 4","components.controls.blocktype.h5":"Titre 5","components.controls.blocktype.h6":"Titre 6","components.controls.blocktype.blockquote":"Citation","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Type bloc","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Palette de couleur","components.controls.colorpicker.text":"Texte","components.controls.colorpicker.background":"Fond","components.controls.embedded.embedded":"Embedded","components.controls.embedded.embeddedlink":"Lien iFrame","components.controls.embedded.enterlink":"Entrer le lien","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Police","components.controls.fontsize.fontsize":"Taille de police","components.controls.history.history":"Historique","components.controls.history.undo":"Précédent","components.controls.history.redo":"Suivant","components.controls.image.image":"Image","components.controls.image.fileUpload":"Téléchargement","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Glisser une image ou cliquer pour télécharger","components.controls.inline.bold":"Gras","components.controls.inline.italic":"Italique","components.controls.inline.underline":"Souligner","components.controls.inline.strikethrough":"Barrer","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Exposant","components.controls.inline.subscript":"Indice","components.controls.link.linkTitle":"Titre du lien","components.controls.link.linkTarget":"Cible du lien","components.controls.link.linkTargetOption":"Ouvrir le lien dans une nouvelle fenêtre","components.controls.link.link":"Lier","components.controls.link.unlink":"Délier","components.controls.list.list":"Liste","components.controls.list.unordered":"Désordonnée","components.controls.list.ordered":"Ordonnée","components.controls.list.indent":"Augmenter le retrait","components.controls.list.outdent":"Diminuer le retrait","components.controls.remove.remove":"Supprimer","components.controls.textalign.textalign":"Alignement du texte","components.controls.textalign.left":"Gauche","components.controls.textalign.center":"Centre","components.controls.textalign.right":"Droite","components.controls.textalign.justify":"Justifier"};},function(e,t,n){e.exports={"generic.add":"添加","generic.cancel":"取消","components.controls.blocktype.h1":"标题1","components.controls.blocktype.h2":"标题2","components.controls.blocktype.h3":"标题3","components.controls.blocktype.h4":"标题4","components.controls.blocktype.h5":"标题5","components.controls.blocktype.h6":"标题6","components.controls.blocktype.blockquote":"引用","components.controls.blocktype.code":"源码","components.controls.blocktype.blocktype":"样式","components.controls.blocktype.normal":"正文","components.controls.colorpicker.colorpicker":"选色器","components.controls.colorpicker.text":"文字","components.controls.colorpicker.background":"背景","components.controls.embedded.embedded":"内嵌","components.controls.embedded.embeddedlink":"内嵌网页","components.controls.embedded.enterlink":"输入网页地址","components.controls.emoji.emoji":"表情符号","components.controls.fontfamily.fontfamily":"字体","components.controls.fontsize.fontsize":"字号","components.controls.history.history":"历史","components.controls.history.undo":"撤销","components.controls.history.redo":"恢复","components.controls.image.image":"图片","components.controls.image.fileUpload":"来自文件","components.controls.image.byURL":"在线图片","components.controls.image.dropFileText":"点击或者拖拽文件上传","components.controls.inline.bold":"粗体","components.controls.inline.italic":"斜体","components.controls.inline.underline":"下划线","components.controls.inline.strikethrough":"删除线","components.controls.inline.monospace":"等宽字体","components.controls.inline.superscript":"上标","components.controls.inline.subscript":"下标","components.controls.link.linkTitle":"超链接","components.controls.link.linkTarget":"输入链接地址","components.controls.link.linkTargetOption":"在新窗口中打开链接","components.controls.link.link":"链接","components.controls.link.unlink":"删除链接","components.controls.list.list":"列表","components.controls.list.unordered":"项目符号","components.controls.list.ordered":"编号","components.controls.list.indent":"增加缩进量","components.controls.list.outdent":"减少缩进量","components.controls.remove.remove":"清除格式","components.controls.textalign.textalign":"文本对齐","components.controls.textalign.left":"文本左对齐","components.controls.textalign.center":"居中","components.controls.textalign.right":"文本右对齐","components.controls.textalign.justify":"两端对齐"};},function(e,t,n){e.exports={"generic.add":"Добавить","generic.cancel":"Отменить","components.controls.blocktype.h1":"Заголовок 1","components.controls.blocktype.h2":"Заголовок 2","components.controls.blocktype.h3":"Заголовок 3","components.controls.blocktype.h4":"Заголовок 4","components.controls.blocktype.h5":"Заголовок 5","components.controls.blocktype.h6":"Заголовок 6","components.controls.blocktype.blockquote":"Цитата","components.controls.blocktype.code":"Код","components.controls.blocktype.blocktype":"Форматирование","components.controls.blocktype.normal":"Обычный","components.controls.colorpicker.colorpicker":"Выбор цвета","components.controls.colorpicker.text":"Текст","components.controls.colorpicker.background":"Фон","components.controls.embedded.embedded":"Встраивание","components.controls.embedded.embeddedlink":"Ссылка в iFrame","components.controls.embedded.enterlink":"Вставьте ссылку","components.controls.emoji.emoji":"Эмодзи","components.controls.fontfamily.fontfamily":"Шрифт","components.controls.fontsize.fontsize":"Размер шрифта","components.controls.history.history":"История","components.controls.history.undo":"Отменить","components.controls.history.redo":"Вернуть","components.controls.image.image":"Изображение","components.controls.image.fileUpload":"Файлы","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Переместите в эту область файлы или кликните для загрузки","components.controls.inline.bold":"Жирный","components.controls.inline.italic":"Курсив","components.controls.inline.underline":"Подчеркивание","components.controls.inline.strikethrough":"Зачеркивание","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Верхний индекс","components.controls.inline.subscript":"Нижний индекс","components.controls.link.linkTitle":"Текст","components.controls.link.linkTarget":"Адрес ссылки","components.controls.link.linkTargetOption":"Открывать в новом окне","components.controls.link.link":"Ссылка","components.controls.link.unlink":"Убрать ссылку","components.controls.list.list":"Список","components.controls.list.unordered":"Неупорядоченный","components.controls.list.ordered":"Упорядоченный","components.controls.list.indent":"Отступ","components.controls.list.outdent":"Выступ","components.controls.remove.remove":"Удалить","components.controls.textalign.textalign":"Выравнивание текста","components.controls.textalign.left":"Слева","components.controls.textalign.center":"По центру","components.controls.textalign.right":"Справа","components.controls.textalign.justify":"Выравнить"};},function(e,t,n){e.exports={"generic.add":"Ok","generic.cancel":"Cancelar","components.controls.blocktype.h1":"Título 1","components.controls.blocktype.h2":"Título 2","components.controls.blocktype.h3":"Título 3","components.controls.blocktype.h4":"Título 4","components.controls.blocktype.h5":"Título 5","components.controls.blocktype.h6":"Título 6","components.controls.blocktype.blockquote":"Citação","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Estilo","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Paleta de cores","components.controls.colorpicker.text":"Texto","components.controls.colorpicker.background":"Fundo","components.controls.embedded.embedded":"Embarcado","components.controls.embedded.embeddedlink":"Link embarcado","components.controls.embedded.enterlink":"Coloque o link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Fonte","components.controls.fontsize.fontsize":"Tamanho da Fonte","components.controls.history.history":"Histórico","components.controls.history.undo":"Desfazer","components.controls.history.redo":"Refazer","components.controls.image.image":"Imagem","components.controls.image.fileUpload":"Carregar arquivo","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Arraste uma imagem aqui ou clique para carregar","components.controls.inline.bold":"Negrito","components.controls.inline.italic":"Itálico","components.controls.inline.underline":"Sublinhado","components.controls.inline.strikethrough":"Strikethrough","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Sobrescrito","components.controls.inline.subscript":"Subscrito","components.controls.link.linkTitle":"Título do link","components.controls.link.linkTarget":"Alvo do link","components.controls.link.linkTargetOption":"Abrir link em outra janela","components.controls.link.link":"Adicionar Link","components.controls.link.unlink":"Remover link","components.controls.list.list":"Lista","components.controls.list.unordered":"Sem ordenção","components.controls.list.ordered":"Ordenada","components.controls.list.indent":"Aumentar recuo","components.controls.list.outdent":"Diminuir recuo","components.controls.remove.remove":"Remover","components.controls.textalign.textalign":"Alinhamento do texto","components.controls.textalign.left":"À Esquerda","components.controls.textalign.center":"Centralizado","components.controls.textalign.right":"À Direita","components.controls.textalign.justify":"Justificado"};},function(e,t,n){e.exports={"generic.add":"입력","generic.cancel":"취소","components.controls.blocktype.h1":"제목1","components.controls.blocktype.h2":"제목2","components.controls.blocktype.h3":"제목3","components.controls.blocktype.h4":"제목4","components.controls.blocktype.h5":"제목5","components.controls.blocktype.h6":"제목6","components.controls.blocktype.blockquote":"인용","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"블록","components.controls.blocktype.normal":"표준","components.controls.colorpicker.colorpicker":"색상 선택","components.controls.colorpicker.text":"글꼴색","components.controls.colorpicker.background":"배경색","components.controls.embedded.embedded":"임베드","components.controls.embedded.embeddedlink":"임베드 링크","components.controls.embedded.enterlink":"주소를 입력하세요","components.controls.emoji.emoji":"이모지","components.controls.fontfamily.fontfamily":"글꼴","components.controls.fontsize.fontsize":"글꼴 크기","components.controls.history.history":"히스토리","components.controls.history.undo":"실행 취소","components.controls.history.redo":"다시 실행","components.controls.image.image":"이미지","components.controls.image.fileUpload":"파일 업로드","components.controls.image.byURL":"주소","components.controls.image.dropFileText":"클릭하거나 파일을 드롭하여 업로드하세요","components.controls.inline.bold":"굵게","components.controls.inline.italic":"기울임꼴","components.controls.inline.underline":"밑줄","components.controls.inline.strikethrough":"취소선","components.controls.inline.monospace":"고정 너비","components.controls.inline.superscript":"위 첨자","components.controls.inline.subscript":"아래 첨자","components.controls.link.linkTitle":"링크 제목","components.controls.link.linkTarget":"링크 타겟","components.controls.link.linkTargetOption":"새창으로 열기","components.controls.link.link":"링크","components.controls.link.unlink":"링크 제거","components.controls.list.list":"리스트","components.controls.list.unordered":"일반 리스트","components.controls.list.ordered":"순서 리스트","components.controls.list.indent":"들여쓰기","components.controls.list.outdent":"내어쓰기","components.controls.remove.remove":"삭제","components.controls.textalign.textalign":"텍스트 정렬","components.controls.textalign.left":"왼쪽","components.controls.textalign.center":"중앙","components.controls.textalign.right":"오른쪽","components.controls.textalign.justify":"양쪽"};},function(e,t,n){e.exports={"generic.add":"Aggiungi","generic.cancel":"Annulla","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Citazione","components.controls.blocktype.code":"Codice","components.controls.blocktype.blocktype":"Stili","components.controls.blocktype.normal":"Normale","components.controls.colorpicker.colorpicker":"Colore testo","components.controls.colorpicker.text":"Testo","components.controls.colorpicker.background":"Evidenziazione","components.controls.embedded.embedded":"Incorpora","components.controls.embedded.embeddedlink":"Incorpora link","components.controls.embedded.enterlink":"Inserisci link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Carattere","components.controls.fontsize.fontsize":"Dimensione carattere","components.controls.history.history":"Modifiche","components.controls.history.undo":"Annulla","components.controls.history.redo":"Ripristina","components.controls.image.image":"Immagine","components.controls.image.fileUpload":"Carica immagine","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Trascina il file o clicca per caricare","components.controls.inline.bold":"Grassetto","components.controls.inline.italic":"Corsivo","components.controls.inline.underline":"Sottolineato","components.controls.inline.strikethrough":"Barrato","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Apice","components.controls.inline.subscript":"Pedice","components.controls.link.linkTitle":"Testo","components.controls.link.linkTarget":"Link","components.controls.link.linkTargetOption":"Apri link in una nuova finestra","components.controls.link.link":"Inserisci link","components.controls.link.unlink":"Rimuovi link","components.controls.list.list":"Lista","components.controls.list.unordered":"Elenco puntato","components.controls.list.ordered":"Elenco numerato","components.controls.list.indent":"Indent","components.controls.list.outdent":"Outdent","components.controls.remove.remove":"Rimuovi formattazione","components.controls.textalign.textalign":"Allineamento del testo","components.controls.textalign.left":"Allinea a sinistra","components.controls.textalign.center":"Allinea al centro","components.controls.textalign.right":"Allinea a destra","components.controls.textalign.justify":"Giustifica"};},function(e,t,n){e.exports={"generic.add":"Toevoegen","generic.cancel":"Annuleren","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Blockquote","components.controls.blocktype.code":"Code","components.controls.blocktype.blocktype":"Blocktype","components.controls.blocktype.normal":"Normaal","components.controls.colorpicker.colorpicker":"Kleurkiezer","components.controls.colorpicker.text":"Tekst","components.controls.colorpicker.background":"Achtergrond","components.controls.embedded.embedded":"Ingevoegd","components.controls.embedded.embeddedlink":"Ingevoegde link","components.controls.embedded.enterlink":"Voeg link toe","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Lettertype","components.controls.fontsize.fontsize":"Lettergrootte","components.controls.history.history":"Geschiedenis","components.controls.history.undo":"Ongedaan maken","components.controls.history.redo":"Opnieuw","components.controls.image.image":"Afbeelding","components.controls.image.fileUpload":"Bestand uploaden","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop het bestand hier of klik om te uploaden","components.controls.inline.bold":"Dikgedrukt","components.controls.inline.italic":"Schuingedrukt","components.controls.inline.underline":"Onderstrepen","components.controls.inline.strikethrough":"Doorstrepen","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Superscript","components.controls.inline.subscript":"Subscript","components.controls.link.linkTitle":"Linktitel","components.controls.link.linkTarget":"Link bestemming","components.controls.link.linkTargetOption":"Open link in een nieuw venster","components.controls.link.link":"Link","components.controls.link.unlink":"Unlink","components.controls.list.list":"Lijst","components.controls.list.unordered":"Ongeordend","components.controls.list.ordered":"Geordend","components.controls.list.indent":"Inspringen","components.controls.list.outdent":"Inspringen verkleinen","components.controls.remove.remove":"Verwijderen","components.controls.textalign.textalign":"Tekst uitlijnen","components.controls.textalign.left":"Links","components.controls.textalign.center":"Gecentreerd","components.controls.textalign.right":"Rechts","components.controls.textalign.justify":"Uitgelijnd"};},function(e,t,n){e.exports={"generic.add":"Hinzufügen","generic.cancel":"Abbrechen","components.controls.blocktype.h1":"Überschrift 1","components.controls.blocktype.h2":"Überschrift 2","components.controls.blocktype.h3":"Überschrift 3","components.controls.blocktype.h4":"Überschrift 4","components.controls.blocktype.h5":"Überschrift 5","components.controls.blocktype.h6":"Überschrift 6","components.controls.blocktype.blockquote":"Zitat","components.controls.blocktype.code":"Quellcode","components.controls.blocktype.blocktype":"Blocktyp","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Farbauswahl","components.controls.colorpicker.text":"Text","components.controls.colorpicker.background":"Hintergrund","components.controls.embedded.embedded":"Eingebettet","components.controls.embedded.embeddedlink":"Eingebetteter Link","components.controls.embedded.enterlink":"Link eingeben","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Schriftart","components.controls.fontsize.fontsize":"Schriftgröße","components.controls.history.history":"Historie","components.controls.history.undo":"Zurücknehmen","components.controls.history.redo":"Wiederholen","components.controls.image.image":"Bild","components.controls.image.fileUpload":"Datei-Upload","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Dateien ziehen und ablegen, oder klicken zum Hochladen","components.controls.inline.bold":"Fett","components.controls.inline.italic":"Kursiv","components.controls.inline.underline":"Unterstreichen","components.controls.inline.strikethrough":"Durchstreichen","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Hochgestellt","components.controls.inline.subscript":"Tiefgestellt","components.controls.link.linkTitle":"Link-Titel","components.controls.link.linkTarget":"Link-Ziel","components.controls.link.linkTargetOption":"Link in neuem Fenster öffnen","components.controls.link.link":"Link","components.controls.link.unlink":"Aufheben","components.controls.list.list":"Liste","components.controls.list.unordered":"Aufzählung","components.controls.list.ordered":"Nummerierte Liste","components.controls.list.indent":"Einzug vergrößern","components.controls.list.outdent":"Einzug reduzieren","components.controls.remove.remove":"Entfernen","components.controls.textalign.textalign":"Textausrichtung","components.controls.textalign.left":"Linksbündig","components.controls.textalign.center":"Zentrieren","components.controls.textalign.right":"Rechtsbündig","components.controls.textalign.justify":"Blocksatz"};},function(e,t,n){e.exports={"generic.add":"Tilføj","generic.cancel":"Annuller","components.controls.blocktype.h1":"Overskrift 1","components.controls.blocktype.h2":"Overskrift 2","components.controls.blocktype.h3":"Overskrift 3","components.controls.blocktype.h4":"Overskrift 4","components.controls.blocktype.h5":"Overskrift 5","components.controls.blocktype.h6":"Overskrift 6","components.controls.blocktype.blockquote":"Blokcitat","components.controls.blocktype.code":"Kode","components.controls.blocktype.blocktype":"Blok Type","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Farver","components.controls.colorpicker.text":"Tekst","components.controls.colorpicker.background":"Baggrund","components.controls.embedded.embedded":"Indlejre","components.controls.embedded.embeddedlink":"Indlejre Link","components.controls.embedded.enterlink":"Indtast link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Fonttype","components.controls.fontsize.fontsize":"Fontstørrelser","components.controls.history.history":"Historie","components.controls.history.undo":"Fortryd","components.controls.history.redo":"Gendan","components.controls.image.image":"Billede","components.controls.image.fileUpload":"Filoverførsel","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Drop filen eller klik for at uploade","components.controls.inline.bold":"Fed","components.controls.inline.italic":"Kursiv","components.controls.inline.underline":"Understrege","components.controls.inline.strikethrough":"Gennemstreget","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Hævet","components.controls.inline.subscript":"Sænket","components.controls.link.linkTitle":"Link Titel","components.controls.link.linkTarget":"Link Mål","components.controls.link.linkTargetOption":"Åbn link i nyt vindue","components.controls.link.link":"Link","components.controls.link.unlink":"Fjern link","components.controls.list.list":"Liste","components.controls.list.unordered":"Uordnet","components.controls.list.ordered":"Ordnet","components.controls.list.indent":"Indrykning","components.controls.list.outdent":"Udrykning","components.controls.remove.remove":"Fjern","components.controls.textalign.textalign":"Tekstjustering","components.controls.textalign.left":"Venstre","components.controls.textalign.center":"Center","components.controls.textalign.right":"Højre","components.controls.textalign.justify":"Margener"};},function(e,t,n){e.exports={"generic.add":"新增","generic.cancel":"取消","components.controls.blocktype.h1":"標題1","components.controls.blocktype.h2":"標題2","components.controls.blocktype.h3":"標題3","components.controls.blocktype.h4":"標題4","components.controls.blocktype.h5":"標題5","components.controls.blocktype.h6":"標題6","components.controls.blocktype.blockquote":"引用","components.controls.blocktype.code":"程式碼","components.controls.blocktype.blocktype":"樣式","components.controls.blocktype.normal":"正文","components.controls.colorpicker.colorpicker":"選色器","components.controls.colorpicker.text":"文字","components.controls.colorpicker.background":"背景","components.controls.embedded.embedded":"內嵌","components.controls.embedded.embeddedlink":"內嵌網頁","components.controls.embedded.enterlink":"輸入網頁地址","components.controls.emoji.emoji":"表情符號","components.controls.fontfamily.fontfamily":"字體","components.controls.fontsize.fontsize":"字體大小","components.controls.history.history":"歷史紀錄","components.controls.history.undo":"復原","components.controls.history.redo":"重做","components.controls.image.image":"圖片","components.controls.image.fileUpload":"檔案上傳","components.controls.image.byURL":"網址","components.controls.image.dropFileText":"點擊或拖曳檔案上傳","components.controls.inline.bold":"粗體","components.controls.inline.italic":"斜體","components.controls.inline.underline":"底線","components.controls.inline.strikethrough":"刪除線","components.controls.inline.monospace":"等寬字體","components.controls.inline.superscript":"上標","components.controls.inline.subscript":"下標","components.controls.link.linkTitle":"超連結","components.controls.link.linkTarget":"輸入連結位址","components.controls.link.linkTargetOption":"在新視窗打開連結","components.controls.link.link":"連結","components.controls.link.unlink":"刪除連結","components.controls.list.list":"列表","components.controls.list.unordered":"項目符號","components.controls.list.ordered":"編號","components.controls.list.indent":"增加縮排","components.controls.list.outdent":"減少縮排","components.controls.remove.remove":"清除格式","components.controls.textalign.textalign":"文字對齊","components.controls.textalign.left":"文字向左對齊","components.controls.textalign.center":"文字置中","components.controls.textalign.right":"文字向右對齊","components.controls.textalign.justify":"兩端對齊"};},function(e,t,n){e.exports={"generic.add":"Dodaj","generic.cancel":"Anuluj","components.controls.blocktype.h1":"Nagłówek 1","components.controls.blocktype.h2":"Nagłówek 2","components.controls.blocktype.h3":"Nagłówek 3","components.controls.blocktype.h4":"Nagłówek 4","components.controls.blocktype.h5":"Nagłówek 5","components.controls.blocktype.h6":"Nagłówek 6","components.controls.blocktype.blockquote":"Cytat","components.controls.blocktype.code":"Kod","components.controls.blocktype.blocktype":"Format","components.controls.blocktype.normal":"Normalny","components.controls.colorpicker.colorpicker":"Kolor","components.controls.colorpicker.text":"Tekst","components.controls.colorpicker.background":"Tło","components.controls.embedded.embedded":"Osadź","components.controls.embedded.embeddedlink":"Osadź odnośnik","components.controls.embedded.enterlink":"Wprowadź odnośnik","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Krój czcionki","components.controls.fontsize.fontsize":"Rozmiar czcionki","components.controls.history.history":"Historia","components.controls.history.undo":"Cofnij","components.controls.history.redo":"Ponów","components.controls.image.image":"Obrazek","components.controls.image.fileUpload":"Prześlij plik","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Upuść plik lub kliknij, aby przesłać","components.controls.inline.bold":"Pogrubienie","components.controls.inline.italic":"Kursywa","components.controls.inline.underline":"Podkreślenie","components.controls.inline.strikethrough":"Przekreślenie","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Indeks górny","components.controls.inline.subscript":"Indeks dolny","components.controls.link.linkTitle":"Tytuł odnośnika","components.controls.link.linkTarget":"Adres odnośnika","components.controls.link.linkTargetOption":"Otwórz odnośnik w nowej karcie","components.controls.link.link":"Wstaw odnośnik","components.controls.link.unlink":"Usuń odnośnik","components.controls.list.list":"Lista","components.controls.list.unordered":"Lista nieuporządkowana","components.controls.list.ordered":"Lista uporządkowana","components.controls.list.indent":"Zwiększ wcięcie","components.controls.list.outdent":"Zmniejsz wcięcie","components.controls.remove.remove":"Usuń","components.controls.textalign.textalign":"Wyrównaj tekst","components.controls.textalign.left":"Do lewej","components.controls.textalign.center":"Do środka","components.controls.textalign.right":"Do prawej","components.controls.textalign.justify":"Wyjustuj"};},function(e,t,n){e.exports={"generic.add":"Añadir","generic.cancel":"Cancelar","components.controls.blocktype.h1":"H1","components.controls.blocktype.h2":"H2","components.controls.blocktype.h3":"H3","components.controls.blocktype.h4":"H4","components.controls.blocktype.h5":"H5","components.controls.blocktype.h6":"H6","components.controls.blocktype.blockquote":"Blockquote","components.controls.blocktype.code":"Código","components.controls.blocktype.blocktype":"Tipo de bloque","components.controls.blocktype.normal":"Normal","components.controls.colorpicker.colorpicker":"Seleccionar color","components.controls.colorpicker.text":"Texto","components.controls.colorpicker.background":"Subrayado","components.controls.embedded.embedded":"Adjuntar","components.controls.embedded.embeddedlink":"Adjuntar Link","components.controls.embedded.enterlink":"Introducir link","components.controls.emoji.emoji":"Emoji","components.controls.fontfamily.fontfamily":"Fuente","components.controls.fontsize.fontsize":"Tamaño de fuente","components.controls.history.history":"Histórico","components.controls.history.undo":"Deshacer","components.controls.history.redo":"Rehacer","components.controls.image.image":"Imagen","components.controls.image.fileUpload":"Subir archivo","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"Arrastra el archivo o haz click para subirlo","components.controls.inline.bold":"Negrita","components.controls.inline.italic":"Cursiva","components.controls.inline.underline":"Subrayado","components.controls.inline.strikethrough":"Tachado","components.controls.inline.monospace":"Monospace","components.controls.inline.superscript":"Sobreíndice","components.controls.inline.subscript":"Subíndice","components.controls.link.linkTitle":"Título del enlace","components.controls.link.linkTarget":"Objetivo del enlace","components.controls.link.linkTargetOption":"Abrir en nueva ventana","components.controls.link.link":"Enlazar","components.controls.link.unlink":"Desenlazar","components.controls.list.list":"Lista","components.controls.list.unordered":"Desordenada","components.controls.list.ordered":"Ordenada","components.controls.list.indent":"Indentada","components.controls.list.outdent":"Dentada","components.controls.remove.remove":"Eliminar","components.controls.textalign.textalign":"Alineación del texto","components.controls.textalign.left":"Izquierda","components.controls.textalign.center":"Centrado","components.controls.textalign.right":"Derecha","components.controls.textalign.justify":"Justificado"};},function(e,t,n){e.exports={"generic.add":"追加","generic.cancel":"キャンセル","components.controls.blocktype.h1":"見出し1","components.controls.blocktype.h2":"見出し2","components.controls.blocktype.h3":"見出し3","components.controls.blocktype.h4":"見出し4","components.controls.blocktype.h5":"見出し5","components.controls.blocktype.h6":"見出し6","components.controls.blocktype.blockquote":"引用","components.controls.blocktype.code":"コード","components.controls.blocktype.blocktype":"スタイル","components.controls.blocktype.normal":"標準テキスト","components.controls.colorpicker.colorpicker":"テキストの色","components.controls.colorpicker.text":"テキスト","components.controls.colorpicker.background":"ハイライト","components.controls.embedded.embedded":"埋め込み","components.controls.embedded.embeddedlink":"埋め込みリンク","components.controls.embedded.enterlink":"リンクを入力してください","components.controls.emoji.emoji":"絵文字","components.controls.fontfamily.fontfamily":"フォント","components.controls.fontsize.fontsize":"フォントサイズ","components.controls.history.history":"履歴","components.controls.history.undo":"元に戻す","components.controls.history.redo":"やり直し","components.controls.image.image":"画像","components.controls.image.fileUpload":"ファイルをアップロード","components.controls.image.byURL":"URL","components.controls.image.dropFileText":"ここに画像をドラッグするか、クリックしてください","components.controls.inline.bold":"太字","components.controls.inline.italic":"斜体","components.controls.inline.underline":"下線","components.controls.inline.strikethrough":"取り消し線","components.controls.inline.monospace":"等幅フォント","components.controls.inline.superscript":"上付き文字","components.controls.inline.subscript":"下付き文字","components.controls.link.linkTitle":"リンクタイトル","components.controls.link.linkTarget":"リンク対象","components.controls.link.linkTargetOption":"新しいウィンドウで開く","components.controls.link.link":"リンク","components.controls.link.unlink":"リンクを解除","components.controls.list.list":"リスト","components.controls.list.unordered":"箇条書き","components.controls.list.ordered":"番号付き","components.controls.list.indent":"インデント増","components.controls.list.outdent":"インデント減","components.controls.remove.remove":"書式をクリア","components.controls.textalign.textalign":"整列","components.controls.textalign.left":"左揃え","components.controls.textalign.center":"中央揃え","components.controls.textalign.right":"右揃え","components.controls.textalign.justify":"両端揃え"};},function(e,t){e.exports={"rdw-editor-main":"rdw-editor-main","rdw-editor-toolbar":"rdw-editor-toolbar","public-DraftStyleDefault-block":"public-DraftStyleDefault-block","rdw-editor-wrapper":"rdw-editor-wrapper"};},function(e,t){e.exports={"DraftEditor-editorContainer":"DraftEditor-editorContainer","DraftEditor-root":"DraftEditor-root","public-DraftEditor-content":"public-DraftEditor-content","public-DraftEditor-block":"public-DraftEditor-block","DraftEditor-alignLeft":"DraftEditor-alignLeft","public-DraftStyleDefault-block":"public-DraftStyleDefault-block","public-DraftEditorPlaceholder-root":"public-DraftEditorPlaceholder-root","DraftEditor-alignCenter":"DraftEditor-alignCenter","DraftEditor-alignRight":"DraftEditor-alignRight","public-DraftEditorPlaceholder-hasFocus":"public-DraftEditorPlaceholder-hasFocus","DraftEditorPlaceholder-hidden":"DraftEditorPlaceholder-hidden","public-DraftStyleDefault-ltr":"public-DraftStyleDefault-ltr","public-DraftStyleDefault-rtl":"public-DraftStyleDefault-rtl","public-DraftStyleDefault-listLTR":"public-DraftStyleDefault-listLTR","public-DraftStyleDefault-listRTL":"public-DraftStyleDefault-listRTL","public-DraftStyleDefault-ol":"public-DraftStyleDefault-ol","public-DraftStyleDefault-ul":"public-DraftStyleDefault-ul","public-DraftStyleDefault-depth0":"public-DraftStyleDefault-depth0","public-DraftStyleDefault-depth1":"public-DraftStyleDefault-depth1","public-DraftStyleDefault-depth2":"public-DraftStyleDefault-depth2","public-DraftStyleDefault-depth3":"public-DraftStyleDefault-depth3","public-DraftStyleDefault-depth4":"public-DraftStyleDefault-depth4","public-DraftStyleDefault-unorderedListItem":"public-DraftStyleDefault-unorderedListItem","public-DraftStyleDefault-orderedListItem":"public-DraftStyleDefault-orderedListItem","public-DraftStyleDefault-reset":"public-DraftStyleDefault-reset"};}])});
  });

  var reactDraftWysiwyg$1 = unwrapExports(reactDraftWysiwyg);
  var reactDraftWysiwyg_1 = reactDraftWysiwyg.Editor;
  var reactDraftWysiwyg_2 = reactDraftWysiwyg.reactDraftWysiwyg;

  var reactDraftWysiwyg$2 = /*#__PURE__*/Object.freeze({
    'default': reactDraftWysiwyg$1,
    __moduleExports: reactDraftWysiwyg,
    Editor: reactDraftWysiwyg_1,
    reactDraftWysiwyg: reactDraftWysiwyg_2
  });

  var draftjsToHtml = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
  	module.exports = factory();
  }(commonjsGlobal, (function () {
  /**
  * Utility function to execute callback for eack key->value pair.
  */
  function forEach(obj, callback) {
    if (obj) {
      for (var key in obj) {
        // eslint-disable-line no-restricted-syntax
        if ({}.hasOwnProperty.call(obj, key)) {
          callback(key, obj[key]);
        }
      }
    }
  }

  /**
  * The function returns true if the string passed to it has no content.
  */
  function isEmptyString(str) {
    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {
      return true;
    }
    return false;
  }

  /**
  * Mapping block-type to corresponding html tag.
  */
  var blockTypesMapping = {
    unstyled: 'p',
    'header-one': 'h1',
    'header-two': 'h2',
    'header-three': 'h3',
    'header-four': 'h4',
    'header-five': 'h5',
    'header-six': 'h6',
    'unordered-list-item': 'ul',
    'ordered-list-item': 'ol',
    blockquote: 'blockquote',
    code: 'pre'
  };

  /**
  * Function will return HTML tag for a block.
  */
  function getBlockTag(type) {
    return type && blockTypesMapping[type];
  }

  /**
  * Function will return style string for a block.
  */
  function getBlockStyle(data) {
    var styles = '';
    forEach(data, function (key, value) {
      if (value) {
        styles += key + ':' + value + ';';
      }
    });
    return styles;
  }

  /**
  * The function returns an array of hashtag-sections in blocks.
  * These will be areas in block which have hashtags applicable to them.
  */
  function getHashtagRanges(blockText, hashtagConfig) {
    var sections = [];
    if (hashtagConfig) {
      var counter = 0;
      var startIndex = 0;
      var text = blockText;
      var trigger = hashtagConfig.trigger || '#';
      var separator = hashtagConfig.separator || ' ';
      for (; text.length > 0 && startIndex >= 0;) {
        if (text[0] === trigger) {
          startIndex = 0;
          counter = 0;
          text = text.substr(trigger.length);
        } else {
          startIndex = text.indexOf(separator + trigger);
          if (startIndex >= 0) {
            text = text.substr(startIndex + (separator + trigger).length);
            counter += startIndex + separator.length;
          }
        }
        if (startIndex >= 0) {
          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;
          var hashtag = text.substr(0, endIndex);
          if (hashtag && hashtag.length > 0) {
            sections.push({
              offset: counter,
              length: hashtag.length + trigger.length,
              type: 'HASHTAG'
            });
          }
          counter += trigger.length;
        }
      }
    }
    return sections;
  }

  /**
  * The function returns an array of entity-sections in blocks.
  * These will be areas in block which have same entity or no entity applicable to them.
  */
  function getSections(block, hashtagConfig) {
    var sections = [];
    var lastOffset = 0;
    var sectionRanges = block.entityRanges.map(function (range) {
      var offset = range.offset,
          length = range.length,
          key = range.key;

      return {
        offset: offset,
        length: length,
        key: key,
        type: 'ENTITY'
      };
    });
    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));
    sectionRanges = sectionRanges.sort(function (s1, s2) {
      return s1.offset - s2.offset;
    });
    sectionRanges.forEach(function (r) {
      if (r.offset > lastOffset) {
        sections.push({
          start: lastOffset,
          end: r.offset
        });
      }
      sections.push({
        start: r.offset,
        end: r.offset + r.length,
        entityKey: r.key,
        type: r.type
      });
      lastOffset = r.offset + r.length;
    });
    if (lastOffset < block.text.length) {
      sections.push({
        start: lastOffset,
        end: block.text.length
      });
    }
    return sections;
  }

  /**
  * Function to check if the block is an atomic entity block.
  */
  function isAtomicEntityBlock(block) {
    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {
      return true;
    }
    return false;
  }

  /**
  * The function will return array of inline styles applicable to the block.
  */
  function getStyleArrayForBlock(block) {
    var text = block.text,
        inlineStyleRanges = block.inlineStyleRanges;

    var inlineStyles = {
      BOLD: new Array(text.length),
      ITALIC: new Array(text.length),
      UNDERLINE: new Array(text.length),
      STRIKETHROUGH: new Array(text.length),
      CODE: new Array(text.length),
      SUPERSCRIPT: new Array(text.length),
      SUBSCRIPT: new Array(text.length),
      COLOR: new Array(text.length),
      BGCOLOR: new Array(text.length),
      FONTSIZE: new Array(text.length),
      FONTFAMILY: new Array(text.length),
      length: text.length
    };
    if (inlineStyleRanges && inlineStyleRanges.length > 0) {
      inlineStyleRanges.forEach(function (range) {
        var offset = range.offset;

        var length = offset + range.length;
        for (var i = offset; i < length; i += 1) {
          if (range.style.indexOf('color-') === 0) {
            inlineStyles.COLOR[i] = range.style.substring(6);
          } else if (range.style.indexOf('bgcolor-') === 0) {
            inlineStyles.BGCOLOR[i] = range.style.substring(8);
          } else if (range.style.indexOf('fontsize-') === 0) {
            inlineStyles.FONTSIZE[i] = range.style.substring(9);
          } else if (range.style.indexOf('fontfamily-') === 0) {
            inlineStyles.FONTFAMILY[i] = range.style.substring(11);
          } else if (inlineStyles[range.style]) {
            inlineStyles[range.style][i] = true;
          }
        }
      });
    }
    return inlineStyles;
  }

  /**
  * The function will return inline style applicable at some offset within a block.
  */
  function getStylesAtOffset(inlineStyles, offset) {
    var styles = {};
    if (inlineStyles.COLOR[offset]) {
      styles.COLOR = inlineStyles.COLOR[offset];
    }
    if (inlineStyles.BGCOLOR[offset]) {
      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];
    }
    if (inlineStyles.FONTSIZE[offset]) {
      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];
    }
    if (inlineStyles.FONTFAMILY[offset]) {
      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];
    }
    if (inlineStyles.UNDERLINE[offset]) {
      styles.UNDERLINE = true;
    }
    if (inlineStyles.ITALIC[offset]) {
      styles.ITALIC = true;
    }
    if (inlineStyles.BOLD[offset]) {
      styles.BOLD = true;
    }
    if (inlineStyles.STRIKETHROUGH[offset]) {
      styles.STRIKETHROUGH = true;
    }
    if (inlineStyles.CODE[offset]) {
      styles.CODE = true;
    }
    if (inlineStyles.SUBSCRIPT[offset]) {
      styles.SUBSCRIPT = true;
    }
    if (inlineStyles.SUPERSCRIPT[offset]) {
      styles.SUPERSCRIPT = true;
    }
    return styles;
  }

  /**
  * Function returns true for a set of styles if the value of these styles at an offset
  * are same as that on the previous offset.
  */
  function sameStyleAsPrevious(inlineStyles, styles, index) {
    var sameStyled = true;
    if (index > 0 && index < inlineStyles.length) {
      styles.forEach(function (style) {
        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];
      });
    } else {
      sameStyled = false;
    }
    return sameStyled;
  }

  /**
  * Function returns html for text depending on inline style tags applicable to it.
  */
  function addInlineStyleMarkup(style, content) {
    if (style === 'BOLD') {
      return '<strong>' + content + '</strong>';
    } else if (style === 'ITALIC') {
      return '<em>' + content + '</em>';
    } else if (style === 'UNDERLINE') {
      return '<ins>' + content + '</ins>';
    } else if (style === 'STRIKETHROUGH') {
      return '<del>' + content + '</del>';
    } else if (style === 'CODE') {
      return '<code>' + content + '</code>';
    } else if (style === 'SUPERSCRIPT') {
      return '<sup>' + content + '</sup>';
    } else if (style === 'SUBSCRIPT') {
      return '<sub>' + content + '</sub>';
    }
    return content;
  }

  /**
  * The function returns text for given section of block after doing required character replacements.
  */
  function getSectionText(text) {
    if (text && text.length > 0) {
      var chars = text.map(function (ch) {
        switch (ch) {
          case '\n':
            return '<br>';
          case '&':
            return '&amp;';
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
          default:
            return ch;
        }
      });
      return chars.join('');
    }
    return '';
  }

  /**
  * Function returns html for text depending on inline style tags applicable to it.
  */
  function addStylePropertyMarkup(styles, text) {
    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {
      var styleString = 'style="';
      if (styles.COLOR) {
        styleString += 'color: ' + styles.COLOR + ';';
      }
      if (styles.BGCOLOR) {
        styleString += 'background-color: ' + styles.BGCOLOR + ';';
      }
      if (styles.FONTSIZE) {
        styleString += 'font-size: ' + styles.FONTSIZE + (/^\d+$/.test(styles.FONTSIZE) ? 'px' : '') + ';';
      }
      if (styles.FONTFAMILY) {
        styleString += 'font-family: ' + styles.FONTFAMILY + ';';
      }
      styleString += '"';
      return '<span ' + styleString + '>' + text + '</span>';
    }
    return text;
  }

  /**
  * Function will return markup for Entity.
  */
  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {
    var entity = entityMap[entityKey];
    if (typeof customEntityTransform === 'function') {
      var html = customEntityTransform(entity, text);
      if (html) {
        return html;
      }
    }
    if (entity.type === 'MENTION') {
      return '<a href="' + entity.data.url + '" class="wysiwyg-mention" data-mention data-value="' + entity.data.value + '">' + text + '</a>';
    }
    if (entity.type === 'LINK') {
      var targetOption = entity.data.targetOption || '_self';
      return '<a href="' + entity.data.url + '" target="' + targetOption + '">' + text + '</a>';
    }
    if (entity.type === 'IMAGE') {
      return '<img src="' + entity.data.src + '" alt="' + entity.data.alt + '" style="float:' + (entity.data.alignment || 'none') + ';height: ' + entity.data.height + ';width: ' + entity.data.width + '"/>';
    }
    if (entity.type === 'EMBEDDED_LINK') {
      return '<iframe width="' + entity.data.width + '" height="' + entity.data.height + '" src="' + entity.data.src + '" frameBorder="0"></iframe>';
    }
    return text;
  }

  /**
  * For a given section in a block the function will return a further list of sections,
  * with similar inline styles applicable to them.
  */
  function getInlineStyleSections(block, styles, start, end) {
    var styleSections = [];
    var text = block.text;

    if (text.length > 0) {
      var inlineStyles = getStyleArrayForBlock(block);
      var section = void 0;
      for (var i = start; i < end; i += 1) {
        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {
          section.text.push(text[i]);
          section.end = i + 1;
        } else {
          section = {
            styles: getStylesAtOffset(inlineStyles, i),
            text: [text[i]],
            start: i,
            end: i + 1
          };
          styleSections.push(section);
        }
      }
    }
    return styleSections;
  }

  /**
  * Replace leading blank spaces by &nbsp;
  */
  function trimLeadingZeros(sectionText) {
    if (sectionText) {
      var replacedText = sectionText;
      for (var i = 0; i < replacedText.length; i += 1) {
        if (sectionText[i] === ' ') {
          replacedText = replacedText.replace(' ', '&nbsp;');
        } else {
          break;
        }
      }
      return replacedText;
    }
    return sectionText;
  }

  /**
  * Replace trailing blank spaces by &nbsp;
  */
  function trimTrailingZeros(sectionText) {
    if (sectionText) {
      var replacedText = sectionText;
      for (var i = replacedText.length - 1; i >= 0; i -= 1) {
        if (replacedText[i] === ' ') {
          replacedText = replacedText.substring(0, i) + '&nbsp;' + replacedText.substring(i + 1);
        } else {
          break;
        }
      }
      return replacedText;
    }
    return sectionText;
  }

  /**
  * The method returns markup for section to which inline styles
  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.
  */
  function getStyleTagSectionMarkup(styleSection) {
    var styles = styleSection.styles,
        text = styleSection.text;

    var content = getSectionText(text);
    forEach(styles, function (style, value) {
      content = addInlineStyleMarkup(style, content, value);
    });
    return content;
  }

  /**
  * The method returns markup for section to which inline styles
  like color, background-color, font-size are applicable.
  */
  function getInlineStyleSectionMarkup(block, styleSection) {
    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);
    var styleSectionText = '';
    styleTagSections.forEach(function (stylePropertySection) {
      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);
    });
    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);
    return styleSectionText;
  }

  /*
  * The method returns markup for an entity section.
  * An entity section is a continuous section in a block
  * to which same entity or no entity is applicable.
  */
  function getSectionMarkup(block, entityMap, section, customEntityTransform) {
    var entityInlineMarkup = [];
    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);
    inlineStyleSections.forEach(function (styleSection) {
      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));
    });
    var sectionText = entityInlineMarkup.join('');
    if (section.type === 'ENTITY') {
      if (section.entityKey !== undefined && section.entityKey !== null) {
        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len
      }
    } else if (section.type === 'HASHTAG') {
      sectionText = '<a href="' + sectionText + '" class="wysiwyg-hashtag">' + sectionText + '</a>';
    }
    return sectionText;
  }

  /**
  * Function will return the markup for block preserving the inline styles and
  * special characters like newlines or blank spaces.
  */
  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {
    var blockMarkup = [];
    var sections = getSections(block, hashtagConfig);
    sections.forEach(function (section, index) {
      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);
      if (index === 0) {
        sectionText = trimLeadingZeros(sectionText);
      }
      if (index === sections.length - 1) {
        sectionText = trimTrailingZeros(sectionText);
      }
      blockMarkup.push(sectionText);
    });
    return blockMarkup.join('');
  }

  /**
  * Function will return html for the block.
  */
  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {
    var blockHtml = [];
    if (isAtomicEntityBlock(block)) {
      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));
    } else {
      var blockTag = getBlockTag(block.type);
      if (blockTag) {
        blockHtml.push('<' + blockTag);
        var blockStyle = getBlockStyle(block.data);
        if (blockStyle) {
          blockHtml.push(' style="' + blockStyle + '"');
        }
        if (directional) {
          blockHtml.push(' dir = "auto"');
        }
        blockHtml.push('>');
        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));
        blockHtml.push('</' + blockTag + '>');
      }
    }
    blockHtml.push('\n');
    return blockHtml.join('');
  }

  /**
  * Function to check if a block is of type list.
  */
  function isList(blockType) {
    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';
  }

  /**
  * Function will return html markup for a list block.
  */
  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {
    var listHtml = [];
    var nestedListBlock = [];
    var previousBlock = void 0;
    listBlocks.forEach(function (block) {
      var nestedBlock = false;
      if (!previousBlock) {
        listHtml.push('<' + getBlockTag(block.type) + '>\n');
      } else if (previousBlock.type !== block.type) {
        listHtml.push('</' + getBlockTag(previousBlock.type) + '>\n');
        listHtml.push('<' + getBlockTag(block.type) + '>\n');
      } else if (previousBlock.depth === block.depth) {
        if (nestedListBlock && nestedListBlock.length > 0) {
          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));
          nestedListBlock = [];
        }
      } else {
        nestedBlock = true;
        nestedListBlock.push(block);
      }
      if (!nestedBlock) {
        listHtml.push('<li');
        var blockStyle = getBlockStyle(block.data);
        if (blockStyle) {
          listHtml.push(' style="' + blockStyle + '"');
        }
        if (directional) {
          listHtml.push(' dir = "auto"');
        }
        listHtml.push('>');
        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));
        listHtml.push('</li>\n');
        previousBlock = block;
      }
    });
    if (nestedListBlock && nestedListBlock.length > 0) {
      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));
    }
    listHtml.push('</' + getBlockTag(previousBlock.type) + '>\n');
    return listHtml.join('');
  }

  /**
  * The function will generate html markup for given draftjs editorContent.
  */
  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {
    var html = [];
    if (editorContent) {
      var blocks = editorContent.blocks,
          entityMap = editorContent.entityMap;

      if (blocks && blocks.length > 0) {
        var listBlocks = [];
        blocks.forEach(function (block) {
          if (isList(block.type)) {
            listBlocks.push(block);
          } else {
            if (listBlocks.length > 0) {
              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len
              html.push(listHtml);
              listBlocks = [];
            }
            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);
            html.push(blockHtml);
          }
        });
        if (listBlocks.length > 0) {
          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len
          html.push(listHtml);
          listBlocks = [];
        }
      }
    }
    return html.join('');
  }

  return draftToHtml;

  })));
  });

  var htmlToDraftjs = createCommonjsModule(function (module, exports) {
  !function(e,t){module.exports=t(immutable,Draft);}("undefined"!=typeof self?self:commonjsGlobal,function(e,t){return function(e){function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r});},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=2)}([function(t,n){t.exports=e;},function(e,n){e.exports=t;},function(e,t,n){e.exports=n(3);},function(e,t,n){function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t,n,r,o,u){var a=e.nodeName.toLowerCase();if(u){var c=u(a,e);if(c){var s=l.Entity.__create(c.type,c.mutability,c.data||{});return {chunk:(0, d.getAtomicBlockChunk)(s)}}}if("#text"===a&&"\n"!==e.textContent)return (0, d.createTextChunk)(e,t,o);if("br"===a)return {chunk:(0, d.getSoftNewlineChunk)()};if("img"===a&&e instanceof HTMLImageElement){var f={};f.src=e.getAttribute?e.getAttribute("src")||e.src:e.src,f.alt=e.alt,f.height=e.style.height,f.width=e.style.width,e.style.float&&(f.alignment=e.style.float);var m=l.Entity.__create("IMAGE","MUTABLE",f);return {chunk:(0, d.getAtomicBlockChunk)(m)}}if("iframe"===a&&e instanceof HTMLIFrameElement){var k={};k.src=e.getAttribute?e.getAttribute("src")||e.src:e.src,k.height=e.height,k.width=e.width;var y=l.Entity.__create("EMBEDDED_LINK","MUTABLE",k);return {chunk:(0, d.getAtomicBlockChunk)(y)}}var b=(0, h.default)(a,r),x=void 0;b&&("ul"===a||"ol"===a?(r=a,n+=1):("unordered-list-item"!==b&&"ordered-list-item"!==b&&(r="",n=-1),M?(x=(0, d.getFirstBlockChunk)(b,(0, g.default)(e)),M=!1):x=(0, d.getBlockDividerChunk)(b,n,(0, g.default)(e)))),x||(x=(0, d.getEmptyChunk)()),t=(0, p.default)(a,e,t);for(var C=e.firstChild;C;){var E=(0, v.default)(C),w=i(C,t,n,r,E||o,u),_=w.chunk;x=(0, d.joinChunks)(x,_);C=C.nextSibling;}return {chunk:x}}function o(e,t){var n=e.trim().replace(x,b),r=(0, s.default)(n);return r?(M=!0,{chunk:i(r,new a.OrderedSet,-1,"",void 0,t).chunk}):null}function u(e,t){var n=o(e,t);if(n){var r=n.chunk,i=new a.OrderedMap({});r.entities&&r.entities.forEach(function(e){e&&(i=i.set(e,l.Entity.__get(e)));});var u=0;return {contentBlocks:r.text.split("\r").map(function(e,t){var n=u+e.length,i=r&&r.inlines.slice(u,n),o=r&&r.entities.slice(u,n),c=new a.List(i.map(function(e,t){var n={style:e,entity:null};return o[t]&&(n.entity=o[t]),l.CharacterMetadata.create(n)}));return u=n,new l.ContentBlock({key:(0, l.genKey)(),type:r&&r.blocks[t]&&r.blocks[t].type||"unstyled",depth:r&&r.blocks[t]&&r.blocks[t].depth,data:r&&r.blocks[t]&&r.blocks[t].data||new a.Map({}),text:e,characterList:c})}),entityMap:i}}return null}Object.defineProperty(t,"__esModule",{value:!0}),t.default=u;var l=n(1),a=n(0),c=n(4),s=r(c),d=n(5),f=n(6),h=r(f),m=n(7),p=r(m),k=n(8),g=r(k),y=n(9),v=r(y),b=" ",x=new RegExp("&nbsp;","g"),M=!0;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(e){var t,n=null;return document.implementation&&document.implementation.createHTMLDocument&&(t=document.implementation.createHTMLDocument("foo"),t.documentElement.innerHTML=e,n=t.getElementsByTagName("body")[0]),n};t.default=r;},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.joinChunks=t.getAtomicBlockChunk=t.getBlockDividerChunk=t.getFirstBlockChunk=t.getEmptyChunk=t.getSoftNewlineChunk=t.createTextChunk=t.getWhitespaceChunk=void 0;var r=n(0),i=t.getWhitespaceChunk=function(e){return {text:" ",inlines:[new r.OrderedSet],entities:[e],blocks:[]}};t.createTextChunk=function(e,t,n){var r=e.textContent;return ""===r.trim()?{chunk:i(n)}:{chunk:{text:r,inlines:Array(r.length).fill(t),entities:Array(r.length).fill(n),blocks:[]}}},t.getSoftNewlineChunk=function(){return {text:"\n",inlines:[new r.OrderedSet],entities:new Array(1),blocks:[]}},t.getEmptyChunk=function(){return {text:"",inlines:[],entities:[],blocks:[]}},t.getFirstBlockChunk=function(e,t){return {text:"",inlines:[],entities:[],blocks:[{type:e,depth:0,data:t||new r.Map({})}]}},t.getBlockDividerChunk=function(e,t,n){return {text:"\r",inlines:[],entities:[],blocks:[{type:e,depth:Math.max(0,Math.min(4,t)),data:n||new r.Map({})}]}},t.getAtomicBlockChunk=function(e){return {text:"\r ",inlines:[new r.OrderedSet],entities:[e],blocks:[{type:"atomic",depth:0,data:new r.Map({})}]}},t.joinChunks=function(e,t){return {text:e.text+t.text,inlines:e.inlines.concat(t.inlines),entities:e.entities.concat(t.entities),blocks:e.blocks.concat(t.blocks)}};},function(e,t,n){function r(e,t){var n=o.filter(function(n){return n.element===e&&(!n.wrapper||n.wrapper===t)||n.wrapper===e||n.aliasedElements&&n.aliasedElements.indexOf(e)>-1}).keySeq().toSet().toArray();if(1===n.length)return n[0]}Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;var i=n(0),o=new i.Map({"header-one":{element:"h1"},"header-two":{element:"h2"},"header-three":{element:"h3"},"header-four":{element:"h4"},"header-five":{element:"h5"},"header-six":{element:"h6"},"unordered-list-item":{element:"li",wrapper:"ul"},"ordered-list-item":{element:"li",wrapper:"ol"},blockquote:{element:"blockquote"},code:{element:"pre"},atomic:{element:"figure"},unstyled:{element:"p",aliasedElements:["div"]}});},function(e,t,n){function r(e,t,n){var r=i[e],o=void 0;if(r)o=n.add(r).toOrderedSet();else if(t instanceof HTMLElement){o=n;var u=t;o=o.withMutations(function(e){var t=u.style.color,n=u.style.backgroundColor,r=u.style.fontSize,i=u.style.fontFamily.replace(/^"|"$/g,"");t&&e.add("color-"+t.replace(/ /g,"")),n&&e.add("bgcolor-"+n.replace(/ /g,"")),r&&e.add("fontsize-"+r.replace(/px$/g,"")),i&&e.add("fontfamily-"+i);}).toOrderedSet();}return o}Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;var i={code:"CODE",del:"STRIKETHROUGH",em:"ITALIC",strong:"BOLD",ins:"UNDERLINE",sub:"SUBSCRIPT",sup:"SUPERSCRIPT"};},function(e,t,n){function r(e){if(e.style.textAlign)return new i.Map({"text-align":e.style.textAlign})}Object.defineProperty(t,"__esModule",{value:!0}),t.default=r;var i=n(0);},function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0});var r=n(1),i=function(e){var t=void 0;if(e instanceof HTMLAnchorElement){var n={};e.dataset&&void 0!==e.dataset.mention?(n.url=e.href,n.text=e.innerHTML,n.value=e.dataset.value,t=r.Entity.__create("MENTION","IMMUTABLE",n)):(n.url=e.getAttribute?e.getAttribute("href")||e.href:e.href,n.title=e.innerHTML,n.targetOption=e.target,t=r.Entity.__create("LINK","MUTABLE",n));}return t};t.default=i;}])});
  });

  var htmlToDraft = unwrapExports(htmlToDraftjs);
  var htmlToDraftjs_1 = htmlToDraftjs.htmlToDraftjs;

  var XHTMLEditor =
  /*#__PURE__*/
  function (_Component) {
    _inherits(XHTMLEditor, _Component);

    function XHTMLEditor(props) {
      var _this;

      _classCallCheck(this, XHTMLEditor);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(XHTMLEditor).call(this, props));

      _defineProperty(_assertThisInitialized(_this), "onEditorStateChange", function (editorState) {
        _this.setState({
          editorState: editorState
        }, function () {
          var val = draftjsToHtml(Draft_1(editorState.getCurrentContent()));

          if (typeof val === "string") {
            _this.props.onHtmlChange && _this.props.onHtmlChange(val);
          }
        });
      });

      var html = _this.props.value || "";
      var contentBlock = htmlToDraft(html);

      if (contentBlock) {
        var contentState = Draft_9.createFromBlockArray(contentBlock.contentBlocks);
        var editorState = Draft_4.createWithContent(contentState);
        _this.state = {
          editorState: editorState
        };
      }

      return _this;
    }

    _createClass(XHTMLEditor, [{
      key: "render",
      value: function render() {
        var editorState = this.state.editorState;
        return react.createElement(reactDraftWysiwyg_1, Object.assign({
          editorState: editorState,
          wrapperClassName: "demo-wrapper",
          editorClassName: "demo-editor",
          onEditorStateChange: this.onEditorStateChange
        }, this.props));
      }
    }]);

    return XHTMLEditor;
  }(react_2);

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  function symbolObservablePonyfill(root) {
  	var result;
  	var Symbol = root.Symbol;

  	if (typeof Symbol === 'function') {
  		if (Symbol.observable) {
  			result = Symbol.observable;
  		} else {
  			result = Symbol('observable');
  			Symbol.observable = result;
  		}
  	} else {
  		result = '@@observable';
  	}

  	return result;
  }

  /* global window */

  var root;

  if (typeof self !== 'undefined') {
    root = self;
  } else if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof global !== 'undefined') {
    root = global;
  } else if (typeof module !== 'undefined') {
    root = module;
  } else {
    root = Function('return this')();
  }

  var result = symbolObservablePonyfill(root);

  /**
   * These are private action types reserved by Redux.
   * For any unknown actions, you must return the current state.
   * If the current state is undefined, you must return the initial state.
   * Do not reference these action types directly in your code.
   */
  var randomString = function randomString() {
    return Math.random().toString(36).substring(7).split('').join('.');
  };

  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };

  /**
   * @param {any} obj The object to inspect.
   * @returns {boolean} True if the argument appears to be a plain object.
   */
  function isPlainObject(obj) {
    if (typeof obj !== 'object' || obj === null) return false;
    var proto = obj;

    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(obj) === proto;
  }

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */

  function createStore(reducer, preloadedState, enhancer) {
    var _ref2;

    if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
      throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function');
    }

    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
      enhancer = preloadedState;
      preloadedState = undefined;
    }

    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error('Expected the enhancer to be a function.');
      }

      return enhancer(createStore)(reducer, preloadedState);
    }

    if (typeof reducer !== 'function') {
      throw new Error('Expected the reducer to be a function.');
    }

    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;

    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    /**
     * Reads the state tree managed by the store.
     *
     * @returns {any} The current state tree of your application.
     */


    function getState() {
      if (isDispatching) {
        throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
      }

      return currentState;
    }
    /**
     * Adds a change listener. It will be called any time an action is dispatched,
     * and some part of the state tree may potentially have changed. You may then
     * call `getState()` to read the current state tree inside the callback.
     *
     * You may call `dispatch()` from a change listener, with the following
     * caveats:
     *
     * 1. The subscriptions are snapshotted just before every `dispatch()` call.
     * If you subscribe or unsubscribe while the listeners are being invoked, this
     * will not have any effect on the `dispatch()` that is currently in progress.
     * However, the next `dispatch()` call, whether nested or not, will use a more
     * recent snapshot of the subscription list.
     *
     * 2. The listener should not expect to see all state changes, as the state
     * might have been updated multiple times during a nested `dispatch()` before
     * the listener is called. It is, however, guaranteed that all subscribers
     * registered before the `dispatch()` started will be called with the latest
     * state by the time it exits.
     *
     * @param {Function} listener A callback to be invoked on every dispatch.
     * @returns {Function} A function to remove this change listener.
     */


    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error('Expected the listener to be a function.');
      }

      if (isDispatching) {
        throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
      }

      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }

        if (isDispatching) {
          throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
        }

        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
      };
    }
    /**
     * Dispatches an action. It is the only way to trigger a state change.
     *
     * The `reducer` function, used to create the store, will be called with the
     * current state tree and the given `action`. Its return value will
     * be considered the **next** state of the tree, and the change listeners
     * will be notified.
     *
     * The base implementation only supports plain object actions. If you want to
     * dispatch a Promise, an Observable, a thunk, or something else, you need to
     * wrap your store creating function into the corresponding middleware. For
     * example, see the documentation for the `redux-thunk` package. Even the
     * middleware will eventually dispatch plain object actions using this method.
     *
     * @param {Object} action A plain object representing “what changed”. It is
     * a good idea to keep actions serializable so you can record and replay user
     * sessions, or use the time travelling `redux-devtools`. An action must have
     * a `type` property which may not be `undefined`. It is a good idea to use
     * string constants for action types.
     *
     * @returns {Object} For convenience, the same action object you dispatched.
     *
     * Note that, if you use a custom middleware, it may wrap `dispatch()` to
     * return something else (for example, a Promise you can await).
     */


    function dispatch(action) {
      if (!isPlainObject(action)) {
        throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
      }

      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
      }

      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }

      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }

      var listeners = currentListeners = nextListeners;

      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }

      return action;
    }
    /**
     * Replaces the reducer currently used by the store to calculate the state.
     *
     * You might need this if your app implements code splitting and you want to
     * load some of the reducers dynamically. You might also need this if you
     * implement a hot reloading mechanism for Redux.
     *
     * @param {Function} nextReducer The reducer for the store to use instead.
     * @returns {void}
     */


    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error('Expected the nextReducer to be a function.');
      }

      currentReducer = nextReducer;
      dispatch({
        type: ActionTypes.REPLACE
      });
    }
    /**
     * Interoperability point for observable/reactive libraries.
     * @returns {observable} A minimal observable of state changes.
     * For more information, see the observable proposal:
     * https://github.com/tc39/proposal-observable
     */


    function observable() {
      var _ref;

      var outerSubscribe = subscribe;
      return _ref = {
        /**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe: function subscribe(observer) {
          if (typeof observer !== 'object' || observer === null) {
            throw new TypeError('Expected the observer to be an object.');
          }

          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }

          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe: unsubscribe
          };
        }
      }, _ref[result] = function () {
        return this;
      }, _ref;
    } // When a store is created, an "INIT" action is dispatched so that every
    // reducer returns their initial state. This effectively populates
    // the initial state tree.


    dispatch({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    }, _ref2[result] = observable, _ref2;
  }

  function getUndefinedStateErrorMessage(key, action) {
    var actionType = action && action.type;
    var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
    return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
  }

  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach(function (key) {
      var reducer = reducers[key];
      var initialState = reducer(undefined, {
        type: ActionTypes.INIT
      });

      if (typeof initialState === 'undefined') {
        throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
      }

      if (typeof reducer(undefined, {
        type: ActionTypes.PROBE_UNKNOWN_ACTION()
      }) === 'undefined') {
        throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
      }
    });
  }
  /**
   * Turns an object whose values are different reducer functions, into a single
   * reducer function. It will call every child reducer, and gather their results
   * into a single state object, whose keys correspond to the keys of the passed
   * reducer functions.
   *
   * @param {Object} reducers An object whose values correspond to different
   * reducer functions that need to be combined into one. One handy way to obtain
   * it is to use ES6 `import * as reducers` syntax. The reducers may never return
   * undefined for any action. Instead, they should return their initial state
   * if the state passed to them was undefined, and the current state for any
   * unrecognized action.
   *
   * @returns {Function} A reducer function that invokes every reducer inside the
   * passed object, and builds a state object with the same shape.
   */


  function combineReducers(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};

    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];

      if (typeof reducers[key] === 'function') {
        finalReducers[key] = reducers[key];
      }
    }

    var finalReducerKeys = Object.keys(finalReducers);

    var shapeAssertionError;

    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }

    return function combination(state, action) {
      if (state === void 0) {
        state = {};
      }

      if (shapeAssertionError) {
        throw shapeAssertionError;
      }

      var hasChanged = false;
      var nextState = {};

      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer(previousStateForKey, action);

        if (typeof nextStateForKey === 'undefined') {
          var errorMessage = getUndefinedStateErrorMessage(_key, action);
          throw new Error(errorMessage);
        }

        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }

      return hasChanged ? nextState : state;
    };
  }

  function bindActionCreator(actionCreator, dispatch) {
    return function () {
      return dispatch(actionCreator.apply(this, arguments));
    };
  }
  /**
   * Turns an object whose values are action creators, into an object with the
   * same keys, but with every function wrapped into a `dispatch` call so they
   * may be invoked directly. This is just a convenience method, as you can call
   * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
   *
   * For convenience, you can also pass a single function as the first argument,
   * and get a function in return.
   *
   * @param {Function|Object} actionCreators An object whose values are action
   * creator functions. One handy way to obtain it is to use ES6 `import * as`
   * syntax. You may also pass a single function.
   *
   * @param {Function} dispatch The `dispatch` function available on your Redux
   * store.
   *
   * @returns {Function|Object} The object mimicking the original object, but with
   * every action creator wrapped into the `dispatch` call. If you passed a
   * function as `actionCreators`, the return value will also be a single
   * function.
   */


  function bindActionCreators(actionCreators, dispatch) {
    if (typeof actionCreators === 'function') {
      return bindActionCreator(actionCreators, dispatch);
    }

    if (typeof actionCreators !== 'object' || actionCreators === null) {
      throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
    }

    var keys = Object.keys(actionCreators);
    var boundActionCreators = {};

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var actionCreator = actionCreators[key];

      if (typeof actionCreator === 'function') {
        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
      }
    }

    return boundActionCreators;
  }

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty$2(target, key, source[key]);
      });
    }

    return target;
  }

  /**
   * Composes single-argument functions from right to left. The rightmost
   * function can take multiple arguments as it provides the signature for
   * the resulting composite function.
   *
   * @param {...Function} funcs The functions to compose.
   * @returns {Function} A function obtained by composing the argument functions
   * from right to left. For example, compose(f, g, h) is identical to doing
   * (...args) => f(g(h(...args))).
   */
  function compose() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    if (funcs.length === 0) {
      return function (arg) {
        return arg;
      };
    }

    if (funcs.length === 1) {
      return funcs[0];
    }

    return funcs.reduce(function (a, b) {
      return function () {
        return a(b.apply(void 0, arguments));
      };
    });
  }

  /**
   * Creates a store enhancer that applies middleware to the dispatch method
   * of the Redux store. This is handy for a variety of tasks, such as expressing
   * asynchronous actions in a concise manner, or logging every action payload.
   *
   * See `redux-thunk` package as an example of the Redux middleware.
   *
   * Because middleware is potentially asynchronous, this should be the first
   * store enhancer in the composition chain.
   *
   * Note that each middleware will be given the `dispatch` and `getState` functions
   * as named arguments.
   *
   * @param {...Function} middlewares The middleware chain to be applied.
   * @returns {Function} A store enhancer applying the middleware.
   */

  function applyMiddleware() {
    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }

    return function (createStore) {
      return function () {
        var store = createStore.apply(void 0, arguments);

        var _dispatch = function dispatch() {
          throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");
        };

        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch() {
            return _dispatch.apply(void 0, arguments);
          }
        };
        var chain = middlewares.map(function (middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = compose.apply(void 0, chain)(store.dispatch);
        return _objectSpread({}, store, {
          dispatch: _dispatch
        });
      };
    };
  }

  var redux = /*#__PURE__*/Object.freeze({
    createStore: createStore,
    combineReducers: combineReducers,
    bindActionCreators: bindActionCreators,
    applyMiddleware: applyMiddleware,
    compose: compose,
    __DO_NOT_USE__ActionTypes: ActionTypes
  });

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  var ReactPropTypesSecret_1 = ReactPropTypesSecret;

  function emptyFunction$1() {}
  function emptyFunctionWithReset() {}
  emptyFunctionWithReset.resetWarningCache = emptyFunction$1;

  var factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret_1) {
        // It is still safe when called from React.
        return;
      }
      var err = new Error(
        'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
        'Use PropTypes.checkPropTypes() to call them. ' +
        'Read more at http://fb.me/use-check-prop-types'
      );
      err.name = 'Invariant Violation';
      throw err;
    }  shim.isRequired = shim;
    function getShim() {
      return shim;
    }  // Important!
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,

      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,

      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction$1
    };

    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
  };

  var propTypes = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    // By explicitly using `prop-types` you are opting into new production behavior.
    // http://fb.me/prop-types-in-prod
    module.exports = factoryWithThrowingShims();
  }
  });
  var propTypes_1 = propTypes.any;
  var propTypes_2 = propTypes.array;
  var propTypes_3 = propTypes.arrayOf;
  var propTypes_4 = propTypes.bool;
  var propTypes_5 = propTypes.checkPropTypes;
  var propTypes_6 = propTypes.element;
  var propTypes_7 = propTypes.exact;
  var propTypes_8 = propTypes.func;
  var propTypes_9 = propTypes.instanceOf;
  var propTypes_10 = propTypes.node;
  var propTypes_11 = propTypes.number;
  var propTypes_12 = propTypes.object;
  var propTypes_13 = propTypes.objectOf;
  var propTypes_14 = propTypes.oneOf;
  var propTypes_15 = propTypes.oneOfType;
  var propTypes_16 = propTypes.shape;
  var propTypes_17 = propTypes.string;
  var propTypes_18 = propTypes.symbol;

  var ReactReduxContext = react.createContext(null);

  // Default to a dummy "batch" implementation that just runs the callback
  function defaultNoopBatch(callback) {
    callback();
  }

  var batch = defaultNoopBatch; // Allow injecting another batching function later

  var setBatch = function setBatch(newBatch) {
    return batch = newBatch;
  }; // Supply a getter just to skip dealing with ESM bindings

  var getBatch = function getBatch() {
    return batch;
  };

  // well as nesting subscriptions of descendant components, so that we can ensure the
  // ancestor components re-render before descendants

  var CLEARED = null;
  var nullListeners = {
    notify: function notify() {}
  };

  function createListenerCollection() {
    var batch = getBatch(); // the current/next pattern is copied from redux's createStore code.
    // TODO: refactor+expose that code to be reusable here?

    var current = [];
    var next = [];
    return {
      clear: function clear() {
        next = CLEARED;
        current = CLEARED;
      },
      notify: function notify() {
        var listeners = current = next;
        batch(function () {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i]();
          }
        });
      },
      get: function get() {
        return next;
      },
      subscribe: function subscribe(listener) {
        var isSubscribed = true;
        if (next === current) next = current.slice();
        next.push(listener);
        return function unsubscribe() {
          if (!isSubscribed || current === CLEARED) return;
          isSubscribed = false;
          if (next === current) next = current.slice();
          next.splice(next.indexOf(listener), 1);
        };
      }
    };
  }

  var Subscription =
  /*#__PURE__*/
  function () {
    function Subscription(store, parentSub) {
      this.store = store;
      this.parentSub = parentSub;
      this.unsubscribe = null;
      this.listeners = nullListeners;
      this.handleChangeWrapper = this.handleChangeWrapper.bind(this);
    }

    var _proto = Subscription.prototype;

    _proto.addNestedSub = function addNestedSub(listener) {
      this.trySubscribe();
      return this.listeners.subscribe(listener);
    };

    _proto.notifyNestedSubs = function notifyNestedSubs() {
      this.listeners.notify();
    };

    _proto.handleChangeWrapper = function handleChangeWrapper() {
      if (this.onStateChange) {
        this.onStateChange();
      }
    };

    _proto.isSubscribed = function isSubscribed() {
      return Boolean(this.unsubscribe);
    };

    _proto.trySubscribe = function trySubscribe() {
      if (!this.unsubscribe) {
        this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.handleChangeWrapper) : this.store.subscribe(this.handleChangeWrapper);
        this.listeners = createListenerCollection();
      }
    };

    _proto.tryUnsubscribe = function tryUnsubscribe() {
      if (this.unsubscribe) {
        this.unsubscribe();
        this.unsubscribe = null;
        this.listeners.clear();
        this.listeners = nullListeners;
      }
    };

    return Subscription;
  }();

  var Provider =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(Provider, _Component);

    function Provider(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      var store = props.store;
      _this.notifySubscribers = _this.notifySubscribers.bind(_assertThisInitialized(_this));
      var subscription = new Subscription(store);
      subscription.onStateChange = _this.notifySubscribers;
      _this.state = {
        store: store,
        subscription: subscription
      };
      _this.previousState = store.getState();
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this._isMounted = true;
      this.state.subscription.trySubscribe();

      if (this.previousState !== this.props.store.getState()) {
        this.state.subscription.notifyNestedSubs();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.unsubscribe) this.unsubscribe();
      this.state.subscription.tryUnsubscribe();
      this._isMounted = false;
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (this.props.store !== prevProps.store) {
        this.state.subscription.tryUnsubscribe();
        var subscription = new Subscription(this.props.store);
        subscription.onStateChange = this.notifySubscribers;
        this.setState({
          store: this.props.store,
          subscription: subscription
        });
      }
    };

    _proto.notifySubscribers = function notifySubscribers() {
      this.state.subscription.notifyNestedSubs();
    };

    _proto.render = function render() {
      var Context = this.props.context || ReactReduxContext;
      return react.createElement(Context.Provider, {
        value: this.state
      }, this.props.children);
    };

    return Provider;
  }(react_2);

  Provider.propTypes = {
    store: propTypes.shape({
      subscribe: propTypes.func.isRequired,
      dispatch: propTypes.func.isRequired,
      getState: propTypes.func.isRequired
    }),
    context: propTypes.object,
    children: propTypes.any
  };

  function _extends$9() {
    _extends$9 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$9.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  var reactIs_production_min = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports,"__esModule",{value:!0});
  var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?Symbol.for("react.memo"):
  60115,r=b?Symbol.for("react.lazy"):60116;function t(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case h:return a;default:return u}}case r:case q:case d:return u}}}function v(a){return t(a)===m}exports.typeOf=t;exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;
  exports.Fragment=e;exports.Lazy=r;exports.Memo=q;exports.Portal=d;exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||"object"===typeof a&&null!==a&&(a.$$typeof===r||a.$$typeof===q||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n)};exports.isAsyncMode=function(a){return v(a)||t(a)===l};exports.isConcurrentMode=v;exports.isContextConsumer=function(a){return t(a)===k};
  exports.isContextProvider=function(a){return t(a)===h};exports.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return t(a)===n};exports.isFragment=function(a){return t(a)===e};exports.isLazy=function(a){return t(a)===r};exports.isMemo=function(a){return t(a)===q};exports.isPortal=function(a){return t(a)===d};exports.isProfiler=function(a){return t(a)===g};exports.isStrictMode=function(a){return t(a)===f};
  exports.isSuspense=function(a){return t(a)===p};
  });

  unwrapExports(reactIs_production_min);
  var reactIs_production_min_1 = reactIs_production_min.typeOf;
  var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
  var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
  var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
  var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
  var reactIs_production_min_6 = reactIs_production_min.Element;
  var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
  var reactIs_production_min_8 = reactIs_production_min.Fragment;
  var reactIs_production_min_9 = reactIs_production_min.Lazy;
  var reactIs_production_min_10 = reactIs_production_min.Memo;
  var reactIs_production_min_11 = reactIs_production_min.Portal;
  var reactIs_production_min_12 = reactIs_production_min.Profiler;
  var reactIs_production_min_13 = reactIs_production_min.StrictMode;
  var reactIs_production_min_14 = reactIs_production_min.Suspense;
  var reactIs_production_min_15 = reactIs_production_min.isValidElementType;
  var reactIs_production_min_16 = reactIs_production_min.isAsyncMode;
  var reactIs_production_min_17 = reactIs_production_min.isConcurrentMode;
  var reactIs_production_min_18 = reactIs_production_min.isContextConsumer;
  var reactIs_production_min_19 = reactIs_production_min.isContextProvider;
  var reactIs_production_min_20 = reactIs_production_min.isElement;
  var reactIs_production_min_21 = reactIs_production_min.isForwardRef;
  var reactIs_production_min_22 = reactIs_production_min.isFragment;
  var reactIs_production_min_23 = reactIs_production_min.isLazy;
  var reactIs_production_min_24 = reactIs_production_min.isMemo;
  var reactIs_production_min_25 = reactIs_production_min.isPortal;
  var reactIs_production_min_26 = reactIs_production_min.isProfiler;
  var reactIs_production_min_27 = reactIs_production_min.isStrictMode;
  var reactIs_production_min_28 = reactIs_production_min.isSuspense;

  var reactIs = createCommonjsModule(function (module) {

  {
    module.exports = reactIs_production_min;
  }
  });
  var reactIs_1 = reactIs.isValidElementType;
  var reactIs_2 = reactIs.isContextConsumer;

  /**
   * Copyright 2015, Yahoo! Inc.
   * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
   */

  var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
  };

  var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
  };

  var FORWARD_REF_STATICS = {
      '$$typeof': true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
  };

  var MEMO_STATICS = {
      '$$typeof': true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
  };

  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;

  function getStatics(component) {
      if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
      }
      return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
  }

  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;

  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== 'string') {
          // don't hoist over string (html) components

          if (objectPrototype) {
              var inheritedComponent = getPrototypeOf(sourceComponent);
              if (inheritedComponent && inheritedComponent !== objectPrototype) {
                  hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
              }
          }

          var keys = getOwnPropertyNames(sourceComponent);

          if (getOwnPropertySymbols$1) {
              keys = keys.concat(getOwnPropertySymbols$1(sourceComponent));
          }

          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);

          for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                  var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                  try {
                      // Avoid failures from read-only properties
                      defineProperty(targetComponent, key, descriptor);
                  } catch (e) {}
              }
          }

          return targetComponent;
      }

      return targetComponent;
  }

  var hoistNonReactStatics_cjs = hoistNonReactStatics;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var invariant$1 = function(condition, format, a, b, c, d, e, f) {

    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error(
          'Minified exception occurred; use the non-minified dev environment ' +
          'for the full error message and additional helpful warnings.'
        );
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(
          format.replace(/%s/g, function() { return args[argIndex++]; })
        );
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };

  var invariant_1$1 = invariant$1;

  var EMPTY_ARRAY$1 = [];
  var NO_SUBSCRIPTION_ARRAY = [null, null];

  function storeStateUpdatesReducer(state, action) {
    var updateCount = state[1];
    return [action.payload, updateCount + 1];
  }

  var initStateUpdates = function initStateUpdates() {
    return [null, 0];
  }; // React currently throws a warning when using useLayoutEffect on the server.
  // To get around it, we can conditionally useEffect on the server (no-op) and
  // useLayoutEffect in the browser. We need useLayoutEffect because we want
  // `connect` to perform sync updates to a ref to save the latest props after
  // a render is actually committed to the DOM.


  var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react_23 : react_21;
  function connectAdvanced(
  /*
    selectorFactory is a func that is responsible for returning the selector function used to
    compute new props from state, props, and dispatch. For example:
        export default connectAdvanced((dispatch, options) => (state, props) => ({
        thing: state.things[props.thingId],
        saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
      }))(YourComponent)
      Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
    outside of their selector as an optimization. Options passed to connectAdvanced are passed to
    the selectorFactory, along with displayName and WrappedComponent, as the second argument.
      Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
    props. Do not use connectAdvanced directly without memoizing results between calls to your
    selector, otherwise the Connect component will re-render on every state or props change.
  */
  selectorFactory, // options object:
  _ref) {
    if (_ref === void 0) {
      _ref = {};
    }

    var _ref2 = _ref,
        _ref2$getDisplayName = _ref2.getDisplayName,
        getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {
      return "ConnectAdvanced(" + name + ")";
    } : _ref2$getDisplayName,
        _ref2$methodName = _ref2.methodName,
        methodName = _ref2$methodName === void 0 ? 'connectAdvanced' : _ref2$methodName,
        _ref2$renderCountProp = _ref2.renderCountProp,
        renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,
        _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,
        shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,
        _ref2$storeKey = _ref2.storeKey,
        storeKey = _ref2$storeKey === void 0 ? 'store' : _ref2$storeKey,
        _ref2$withRef = _ref2.withRef,
        withRef = _ref2$withRef === void 0 ? false : _ref2$withRef,
        _ref2$forwardRef = _ref2.forwardRef,
        forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef,
        _ref2$context = _ref2.context,
        context = _ref2$context === void 0 ? ReactReduxContext : _ref2$context,
        connectOptions = _objectWithoutPropertiesLoose(_ref2, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"]);

    invariant_1$1(renderCountProp === undefined, "renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension");
    invariant_1$1(!withRef, 'withRef is removed. To access the wrapped instance, use a ref on the connected component');
    var customStoreWarningMessage = 'To use a custom Redux store for specific components, create a custom React context with ' + "React.createContext(), and pass the context object to React Redux's Provider and specific components" + ' like: <Provider context={MyContext}><ConnectedComponent context={MyContext} /></Provider>. ' + 'You may also pass a {context : MyContext} option to connect';
    invariant_1$1(storeKey === 'store', 'storeKey has been removed and does not do anything. ' + customStoreWarningMessage);
    var Context = context;
    return function wrapWithConnect(WrappedComponent) {

      var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
      var displayName = getDisplayName(wrappedComponentName);

      var selectorFactoryOptions = _extends$9({}, connectOptions, {
        getDisplayName: getDisplayName,
        methodName: methodName,
        renderCountProp: renderCountProp,
        shouldHandleStateChanges: shouldHandleStateChanges,
        storeKey: storeKey,
        displayName: displayName,
        wrappedComponentName: wrappedComponentName,
        WrappedComponent: WrappedComponent
      });

      var pure = connectOptions.pure;

      function createChildSelector(store) {
        return selectorFactory(store.dispatch, selectorFactoryOptions);
      } // If we aren't running in "pure" mode, we don't want to memoize values.
      // To avoid conditionally calling hooks, we fall back to a tiny wrapper
      // that just executes the given callback immediately.


      var usePureOnlyMemo = pure ? react_24 : function (callback) {
        return callback();
      };

      function ConnectFunction(props) {
        var _useMemo = react_24(function () {
          // Distinguish between actual "data" props that were passed to the wrapper component,
          // and values needed to control behavior (forwarded refs, alternate context instances).
          // To maintain the wrapperProps object reference, memoize this destructuring.
          var context = props.context,
              forwardedRef = props.forwardedRef,
              wrapperProps = _objectWithoutPropertiesLoose(props, ["context", "forwardedRef"]);

          return [context, forwardedRef, wrapperProps];
        }, [props]),
            propsContext = _useMemo[0],
            forwardedRef = _useMemo[1],
            wrapperProps = _useMemo[2];

        var ContextToUse = react_24(function () {
          // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.
          // Memoize the check that determines which context instance we should use.
          return propsContext && propsContext.Consumer && reactIs_2(react.createElement(propsContext.Consumer, null)) ? propsContext : Context;
        }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available

        var contextValue = react_19(ContextToUse); // The store _must_ exist as either a prop or in context

        var didStoreComeFromProps = Boolean(props.store);
        var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
        invariant_1$1(didStoreComeFromProps || didStoreComeFromContext, "Could not find \"store\" in the context of " + ("\"" + displayName + "\". Either wrap the root component in a <Provider>, ") + "or pass a custom React context provider to <Provider> and the corresponding " + ("React context consumer to " + displayName + " in connect options."));
        var store = props.store || contextValue.store;
        var childPropsSelector = react_24(function () {
          // The child props selector needs the store reference as an input.
          // Re-create this selector whenever the store changes.
          return createChildSelector(store);
        }, [store]);

        var _useMemo2 = react_24(function () {
          if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component
          // connected to the store via props shouldn't use subscription from context, or vice versa.

          var subscription = new Subscription(store, didStoreComeFromProps ? null : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
          // the middle of the notification loop, where `subscription` will then be null. This can
          // probably be avoided if Subscription's listeners logic is changed to not call listeners
          // that have been unsubscribed in the  middle of the notification loop.

          var notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);
          return [subscription, notifyNestedSubs];
        }, [store, didStoreComeFromProps, contextValue]),
            subscription = _useMemo2[0],
            notifyNestedSubs = _useMemo2[1]; // Determine what {store, subscription} value should be put into nested context, if necessary,
        // and memoize that value to avoid unnecessary context updates.


        var overriddenContextValue = react_24(function () {
          if (didStoreComeFromProps) {
            // This component is directly subscribed to a store from props.
            // We don't want descendants reading from this store - pass down whatever
            // the existing context value is from the nearest connected ancestor.
            return contextValue;
          } // Otherwise, put this component's subscription instance into context, so that
          // connected descendants won't update until after this component is done


          return _extends$9({}, contextValue, {
            subscription: subscription
          });
        }, [didStoreComeFromProps, contextValue, subscription]); // We need to force this wrapper component to re-render whenever a Redux store update
        // causes a change to the calculated child component props (or we caught an error in mapState)

        var _useReducer = react_25(storeStateUpdatesReducer, EMPTY_ARRAY$1, initStateUpdates),
            _useReducer$ = _useReducer[0],
            previousStateUpdateResult = _useReducer$[0],
            forceComponentUpdateDispatch = _useReducer[1]; // Propagate any mapState/mapDispatch errors upwards


        if (previousStateUpdateResult && previousStateUpdateResult.error) {
          throw previousStateUpdateResult.error;
        } // Set up refs to coordinate values between the subscription effect and the render logic


        var lastChildProps = react_26();
        var lastWrapperProps = react_26(wrapperProps);
        var childPropsFromStoreUpdate = react_26();
        var renderIsScheduled = react_26(false);
        var actualChildProps = usePureOnlyMemo(function () {
          // Tricky logic here:
          // - This render may have been triggered by a Redux store update that produced new child props
          // - However, we may have gotten new wrapper props after that
          // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.
          // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.
          // So, we'll use the child props from store update only if the wrapper props are the same as last time.
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          } // TODO We're reading the store directly in render() here. Bad idea?
          // This will likely cause Bad Things (TM) to happen in Concurrent Mode.
          // Note that we do this because on renders _not_ caused by store updates, we need the latest store state
          // to determine what the child props should be.


          return childPropsSelector(store.getState(), wrapperProps);
        }, [store, previousStateUpdateResult, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns
        // about useLayoutEffect in SSR, so we try to detect environment and fall back to
        // just useEffect instead to avoid the warning, since neither will run anyway.

        useIsomorphicLayoutEffect(function () {
          // We want to capture the wrapper props and child props we used for later comparisons
          lastWrapperProps.current = wrapperProps;
          lastChildProps.current = actualChildProps;
          renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update

          if (childPropsFromStoreUpdate.current) {
            childPropsFromStoreUpdate.current = null;
            notifyNestedSubs();
          }
        }); // Our re-subscribe logic only runs when the store/subscription setup changes

        useIsomorphicLayoutEffect(function () {
          // If we're not subscribed to the store, nothing to do here
          if (!shouldHandleStateChanges) return; // Capture values for checking if and when this component unmounts

          var didUnsubscribe = false;
          var lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component

          var checkForUpdates = function checkForUpdates() {
            if (didUnsubscribe) {
              // Don't run stale listeners.
              // Redux doesn't guarantee unsubscriptions happen until next dispatch.
              return;
            }

            var latestStoreState = store.getState();
            var newChildProps, error;

            try {
              // Actually run the selector with the most recent store state and wrapper props
              // to determine what the child props should be
              newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
            } catch (e) {
              error = e;
              lastThrownError = e;
            }

            if (!error) {
              lastThrownError = null;
            } // If the child props haven't changed, nothing to do here - cascade the subscription update


            if (newChildProps === lastChildProps.current) {
              if (!renderIsScheduled.current) {
                notifyNestedSubs();
              }
            } else {
              // Save references to the new child props.  Note that we track the "child props from store update"
              // as a ref instead of a useState/useReducer because we need a way to determine if that value has
              // been processed.  If this went into useState/useReducer, we couldn't clear out the value without
              // forcing another re-render, which we don't want.
              lastChildProps.current = newChildProps;
              childPropsFromStoreUpdate.current = newChildProps;
              renderIsScheduled.current = true; // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render

              forceComponentUpdateDispatch({
                type: 'STORE_UPDATED',
                payload: {
                  latestStoreState: latestStoreState,
                  error: error
                }
              });
            }
          }; // Actually subscribe to the nearest connected ancestor (or store)


          subscription.onStateChange = checkForUpdates;
          subscription.trySubscribe(); // Pull data from the store after first render in case the store has
          // changed since we began.

          checkForUpdates();

          var unsubscribeWrapper = function unsubscribeWrapper() {
            didUnsubscribe = true;
            subscription.tryUnsubscribe();

            if (lastThrownError) {
              // It's possible that we caught an error due to a bad mapState function, but the
              // parent re-rendered without this component and we're about to unmount.
              // This shouldn't happen as long as we do top-down subscriptions correctly, but
              // if we ever do those wrong, this throw will surface the error in our tests.
              // In that case, throw the error from here so it doesn't get lost.
              throw lastThrownError;
            }
          };

          return unsubscribeWrapper;
        }, [store, subscription, childPropsSelector]); // Now that all that's done, we can finally try to actually render the child component.
        // We memoize the elements for the rendered child component as an optimization.

        var renderedWrappedComponent = react_24(function () {
          return react.createElement(WrappedComponent, _extends$9({}, actualChildProps, {
            ref: forwardedRef
          }));
        }, [forwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering
        // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.

        var renderedChild = react_24(function () {
          if (shouldHandleStateChanges) {
            // If this component is subscribed to store updates, we need to pass its own
            // subscription instance down to our descendants. That means rendering the same
            // Context instance, and putting a different value into the context.
            return react.createElement(ContextToUse.Provider, {
              value: overriddenContextValue
            }, renderedWrappedComponent);
          }

          return renderedWrappedComponent;
        }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
        return renderedChild;
      } // If we're in "pure" mode, ensure our wrapper component only re-renders when incoming props have changed.


      var Connect = pure ? react.memo(ConnectFunction) : ConnectFunction;
      Connect.WrappedComponent = WrappedComponent;
      Connect.displayName = displayName;

      if (forwardRef) {
        var forwarded = react.forwardRef(function forwardConnectRef(props, ref) {
          return react.createElement(Connect, _extends$9({}, props, {
            forwardedRef: ref
          }));
        });
        forwarded.displayName = displayName;
        forwarded.WrappedComponent = WrappedComponent;
        return hoistNonReactStatics_cjs(forwarded, WrappedComponent);
      }

      return hoistNonReactStatics_cjs(Connect, WrappedComponent);
    };
  }

  var hasOwn = Object.prototype.hasOwnProperty;

  function is(x, y) {
    if (x === y) {
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }

  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;

    for (var i = 0; i < keysA.length; i++) {
      if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  }

  /**
   * @param {any} obj The object to inspect.
   * @returns {boolean} True if the argument appears to be a plain object.
   */

  /**
   * Prints a warning in the console if it exists.
   *
   * @param {String} message The warning message.
   * @returns {void}
   */

  function wrapMapToPropsConstant(getConstant) {
    return function initConstantSelector(dispatch, options) {
      var constant = getConstant(dispatch, options);

      function constantSelector() {
        return constant;
      }

      constantSelector.dependsOnOwnProps = false;
      return constantSelector;
    };
  } // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
  // to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
  // whether mapToProps needs to be invoked when props have changed.
  //
  // A length of one signals that mapToProps does not depend on props from the parent component.
  // A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
  // therefore not reporting its length accurately..

  function getDependsOnOwnProps(mapToProps) {
    return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
  } // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
  // this function wraps mapToProps in a proxy function which does several things:
  //
  //  * Detects whether the mapToProps function being called depends on props, which
  //    is used by selectorFactory to decide if it should reinvoke on props changes.
  //
  //  * On first call, handles mapToProps if returns another function, and treats that
  //    new function as the true mapToProps for subsequent calls.
  //
  //  * On first call, verifies the first result is a plain object, in order to warn
  //    the developer that their mapToProps function is not returning a valid result.
  //

  function wrapMapToPropsFunc(mapToProps, methodName) {
    return function initProxySelector(dispatch, _ref) {
      var displayName = _ref.displayName;

      var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
        return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
      }; // allow detectFactoryAndVerify to get ownProps


      proxy.dependsOnOwnProps = true;

      proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
        proxy.mapToProps = mapToProps;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
        var props = proxy(stateOrDispatch, ownProps);

        if (typeof props === 'function') {
          proxy.mapToProps = props;
          proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
          props = proxy(stateOrDispatch, ownProps);
        }
        return props;
      };

      return proxy;
    };
  }

  function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
    return typeof mapDispatchToProps === 'function' ? wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps') : undefined;
  }
  function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
    return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {
      return {
        dispatch: dispatch
      };
    }) : undefined;
  }
  function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
    return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(function (dispatch) {
      return bindActionCreators(mapDispatchToProps, dispatch);
    }) : undefined;
  }
  var defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

  function whenMapStateToPropsIsFunction(mapStateToProps) {
    return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps') : undefined;
  }
  function whenMapStateToPropsIsMissing(mapStateToProps) {
    return !mapStateToProps ? wrapMapToPropsConstant(function () {
      return {};
    }) : undefined;
  }
  var defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

  function defaultMergeProps(stateProps, dispatchProps, ownProps) {
    return _extends$9({}, ownProps, stateProps, dispatchProps);
  }
  function wrapMergePropsFunc(mergeProps) {
    return function initMergePropsProxy(dispatch, _ref) {
      var displayName = _ref.displayName,
          pure = _ref.pure,
          areMergedPropsEqual = _ref.areMergedPropsEqual;
      var hasRunOnce = false;
      var mergedProps;
      return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
        var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

        if (hasRunOnce) {
          if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
        } else {
          hasRunOnce = true;
          mergedProps = nextMergedProps;
        }

        return mergedProps;
      };
    };
  }
  function whenMergePropsIsFunction(mergeProps) {
    return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
  }
  function whenMergePropsIsOmitted(mergeProps) {
    return !mergeProps ? function () {
      return defaultMergeProps;
    } : undefined;
  }
  var defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];

  function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
    return function impureFinalPropsSelector(state, ownProps) {
      return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
    };
  }
  function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
    var areStatesEqual = _ref.areStatesEqual,
        areOwnPropsEqual = _ref.areOwnPropsEqual,
        areStatePropsEqual = _ref.areStatePropsEqual;
    var hasRunAtLeastOnce = false;
    var state;
    var ownProps;
    var stateProps;
    var dispatchProps;
    var mergedProps;

    function handleFirstCall(firstState, firstOwnProps) {
      state = firstState;
      ownProps = firstOwnProps;
      stateProps = mapStateToProps(state, ownProps);
      dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      hasRunAtLeastOnce = true;
      return mergedProps;
    }

    function handleNewPropsAndNewState() {
      stateProps = mapStateToProps(state, ownProps);
      if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }

    function handleNewProps() {
      if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
      if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }

    function handleNewState() {
      var nextStateProps = mapStateToProps(state, ownProps);
      var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
      stateProps = nextStateProps;
      if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      return mergedProps;
    }

    function handleSubsequentCalls(nextState, nextOwnProps) {
      var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
      var stateChanged = !areStatesEqual(nextState, state);
      state = nextState;
      ownProps = nextOwnProps;
      if (propsChanged && stateChanged) return handleNewPropsAndNewState();
      if (propsChanged) return handleNewProps();
      if (stateChanged) return handleNewState();
      return mergedProps;
    }

    return function pureFinalPropsSelector(nextState, nextOwnProps) {
      return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
    };
  } // TODO: Add more comments
  // If pure is true, the selector returned by selectorFactory will memoize its results,
  // allowing connectAdvanced's shouldComponentUpdate to return false if final
  // props have not changed. If false, the selector will always return a new
  // object and shouldComponentUpdate will always return true.

  function finalPropsSelectorFactory(dispatch, _ref2) {
    var initMapStateToProps = _ref2.initMapStateToProps,
        initMapDispatchToProps = _ref2.initMapDispatchToProps,
        initMergeProps = _ref2.initMergeProps,
        options = _objectWithoutPropertiesLoose(_ref2, ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"]);

    var mapStateToProps = initMapStateToProps(dispatch, options);
    var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
    var mergeProps = initMergeProps(dispatch, options);

    var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
    return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
  }

  /*
    connect is a facade over connectAdvanced. It turns its args into a compatible
    selectorFactory, which has the signature:

      (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
    
    connect passes its args to connectAdvanced as options, which will in turn pass them to
    selectorFactory each time a Connect component instance is instantiated or hot reloaded.

    selectorFactory returns a final props selector from its mapStateToProps,
    mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
    mergePropsFactories, and pure args.

    The resulting final props selector is called by the Connect component instance whenever
    it receives new props or store state.
   */

  function match(arg, factories, name) {
    for (var i = factories.length - 1; i >= 0; i--) {
      var result = factories[i](arg);
      if (result) return result;
    }

    return function (dispatch, options) {
      throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
    };
  }

  function strictEqual(a, b) {
    return a === b;
  } // createConnect with default args builds the 'official' connect behavior. Calling it with
  // different options opens up some testing and extensibility scenarios


  function createConnect(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$connectHOC = _ref.connectHOC,
        connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC,
        _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
        mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? defaultMapStateToPropsFactories : _ref$mapStateToPropsF,
        _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
        mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? defaultMapDispatchToPropsFactories : _ref$mapDispatchToPro,
        _ref$mergePropsFactor = _ref.mergePropsFactories,
        mergePropsFactories = _ref$mergePropsFactor === void 0 ? defaultMergePropsFactories : _ref$mergePropsFactor,
        _ref$selectorFactory = _ref.selectorFactory,
        selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;

    return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
      if (_ref2 === void 0) {
        _ref2 = {};
      }

      var _ref3 = _ref2,
          _ref3$pure = _ref3.pure,
          pure = _ref3$pure === void 0 ? true : _ref3$pure,
          _ref3$areStatesEqual = _ref3.areStatesEqual,
          areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,
          _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,
          areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua,
          _ref3$areStatePropsEq = _ref3.areStatePropsEqual,
          areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq,
          _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,
          areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE,
          extraOptions = _objectWithoutPropertiesLoose(_ref3, ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"]);

      var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
      var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
      var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');
      return connectHOC(selectorFactory, _extends$9({
        // used in error messages
        methodName: 'connect',
        // used to compute Connect's displayName from the wrapped component's displayName.
        getDisplayName: function getDisplayName(name) {
          return "Connect(" + name + ")";
        },
        // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
        shouldHandleStateChanges: Boolean(mapStateToProps),
        // passed through to selectorFactory
        initMapStateToProps: initMapStateToProps,
        initMapDispatchToProps: initMapDispatchToProps,
        initMergeProps: initMergeProps,
        pure: pure,
        areStatesEqual: areStatesEqual,
        areOwnPropsEqual: areOwnPropsEqual,
        areStatePropsEqual: areStatePropsEqual,
        areMergedPropsEqual: areMergedPropsEqual
      }, extraOptions));
    };
  }
  var connect = createConnect();

  /* eslint-disable import/no-unresolved */

  setBatch(reactDom_7);

  var index$1 = /*#__PURE__*/Object.freeze({
    Provider: Provider,
    connectAdvanced: connectAdvanced,
    ReactReduxContext: ReactReduxContext,
    connect: connect,
    batch: reactDom_7
  });

  function createThunkMiddleware(extraArgument) {
    return function (_ref) {
      var dispatch = _ref.dispatch,
          getState = _ref.getState;
      return function (next) {
        return function (action) {
          if (typeof action === 'function') {
            return action(dispatch, getState, extraArgument);
          }

          return next(action);
        };
      };
    };
  }

  var thunk = createThunkMiddleware();
  thunk.withExtraArgument = createThunkMiddleware;

  var index$2 = /*#__PURE__*/Object.freeze({
    'default': thunk
  });

  var reduxLogger = createCommonjsModule(function (module, exports) {
  !function(e,t){t(exports);}(commonjsGlobal,function(e){function t(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}});}function r(e,t){Object.defineProperty(this,"kind",{value:e,enumerable:!0}),t&&t.length&&Object.defineProperty(this,"path",{value:t,enumerable:!0});}function n(e,t,r){n.super_.call(this,"E",e),Object.defineProperty(this,"lhs",{value:t,enumerable:!0}),Object.defineProperty(this,"rhs",{value:r,enumerable:!0});}function o(e,t){o.super_.call(this,"N",e),Object.defineProperty(this,"rhs",{value:t,enumerable:!0});}function i(e,t){i.super_.call(this,"D",e),Object.defineProperty(this,"lhs",{value:t,enumerable:!0});}function a(e,t,r){a.super_.call(this,"A",e),Object.defineProperty(this,"index",{value:t,enumerable:!0}),Object.defineProperty(this,"item",{value:r,enumerable:!0});}function f(e,t,r){var n=e.slice((r||t)+1||e.length);return e.length=t<0?e.length+t:t,e.push.apply(e,n),e}function u(e){var t="undefined"==typeof e?"undefined":N(e);return "object"!==t?t:e===Math?"math":null===e?"null":Array.isArray(e)?"array":"[object Date]"===Object.prototype.toString.call(e)?"date":"function"==typeof e.toString&&/^\/.*\//.test(e.toString())?"regexp":"object"}function l(e,t,r,c,s,d,p){s=s||[],p=p||[];var g=s.slice(0);if("undefined"!=typeof d){if(c){if("function"==typeof c&&c(g,d))return;if("object"===("undefined"==typeof c?"undefined":N(c))){if(c.prefilter&&c.prefilter(g,d))return;if(c.normalize){var h=c.normalize(g,d,e,t);h&&(e=h[0],t=h[1]);}}}g.push(d);}"regexp"===u(e)&&"regexp"===u(t)&&(e=e.toString(),t=t.toString());var y="undefined"==typeof e?"undefined":N(e),v="undefined"==typeof t?"undefined":N(t),b="undefined"!==y||p&&p[p.length-1].lhs&&p[p.length-1].lhs.hasOwnProperty(d),m="undefined"!==v||p&&p[p.length-1].rhs&&p[p.length-1].rhs.hasOwnProperty(d);if(!b&&m)r(new o(g,t));else if(!m&&b)r(new i(g,e));else if(u(e)!==u(t))r(new n(g,e,t));else if("date"===u(e)&&e-t!==0)r(new n(g,e,t));else if("object"===y&&null!==e&&null!==t)if(p.filter(function(t){return t.lhs===e}).length)e!==t&&r(new n(g,e,t));else{if(p.push({lhs:e,rhs:t}),Array.isArray(e)){var w;e.length;for(w=0;w<e.length;w++)w>=t.length?r(new a(g,w,new i(void 0,e[w]))):l(e[w],t[w],r,c,g,w,p);for(;w<t.length;)r(new a(g,w,new o(void 0,t[w++])));}else{var x=Object.keys(e),S=Object.keys(t);x.forEach(function(n,o){var i=S.indexOf(n);i>=0?(l(e[n],t[n],r,c,g,n,p),S=f(S,i)):l(e[n],void 0,r,c,g,n,p);}),S.forEach(function(e){l(void 0,t[e],r,c,g,e,p);});}p.length=p.length-1;}else e!==t&&("number"===y&&isNaN(e)&&isNaN(t)||r(new n(g,e,t)));}function c(e,t,r,n){return n=n||[],l(e,t,function(e){e&&n.push(e);},r),n.length?n:void 0}function s(e,t,r){if(r.path&&r.path.length){var n,o=e[t],i=r.path.length-1;for(n=0;n<i;n++)o=o[r.path[n]];switch(r.kind){case"A":s(o[r.path[n]],r.index,r.item);break;case"D":delete o[r.path[n]];break;case"E":case"N":o[r.path[n]]=r.rhs;}}else switch(r.kind){case"A":s(e[t],r.index,r.item);break;case"D":e=f(e,t);break;case"E":case"N":e[t]=r.rhs;}return e}function d(e,t,r){if(e&&t&&r&&r.kind){for(var n=e,o=-1,i=r.path?r.path.length-1:0;++o<i;)"undefined"==typeof n[r.path[o]]&&(n[r.path[o]]="number"==typeof r.path[o]?[]:{}),n=n[r.path[o]];switch(r.kind){case"A":s(r.path?n[r.path[o]]:n,r.index,r.item);break;case"D":delete n[r.path[o]];break;case"E":case"N":n[r.path[o]]=r.rhs;}}}function p(e,t,r){if(r.path&&r.path.length){var n,o=e[t],i=r.path.length-1;for(n=0;n<i;n++)o=o[r.path[n]];switch(r.kind){case"A":p(o[r.path[n]],r.index,r.item);break;case"D":o[r.path[n]]=r.lhs;break;case"E":o[r.path[n]]=r.lhs;break;case"N":delete o[r.path[n]];}}else switch(r.kind){case"A":p(e[t],r.index,r.item);break;case"D":e[t]=r.lhs;break;case"E":e[t]=r.lhs;break;case"N":e=f(e,t);}return e}function g(e,t,r){if(e&&t&&r&&r.kind){var n,o,i=e;for(o=r.path.length-1,n=0;n<o;n++)"undefined"==typeof i[r.path[n]]&&(i[r.path[n]]={}),i=i[r.path[n]];switch(r.kind){case"A":p(i[r.path[n]],r.index,r.item);break;case"D":i[r.path[n]]=r.lhs;break;case"E":i[r.path[n]]=r.lhs;break;case"N":delete i[r.path[n]];}}}function h(e,t,r){if(e&&t){var n=function(n){r&&!r(e,t,n)||d(e,t,n);};l(e,t,n);}}function y(e){return "color: "+F[e].color+"; font-weight: bold"}function v(e){var t=e.kind,r=e.path,n=e.lhs,o=e.rhs,i=e.index,a=e.item;switch(t){case"E":return [r.join("."),n,"→",o];case"N":return [r.join("."),o];case"D":return [r.join(".")];case"A":return [r.join(".")+"["+i+"]",a];default:return []}}function b(e,t,r,n){var o=c(e,t);try{n?r.groupCollapsed("diff"):r.group("diff");}catch(e){r.log("diff");}o?o.forEach(function(e){var t=e.kind,n=v(e);r.log.apply(r,["%c "+F[t].text,y(t)].concat(P(n)));}):r.log("—— no diff ——");try{r.groupEnd();}catch(e){r.log("—— diff end —— ");}}function m(e,t,r,n){switch("undefined"==typeof e?"undefined":N(e)){case"object":return "function"==typeof e[n]?e[n].apply(e,P(r)):e[n];case"function":return e(t);default:return e}}function w(e){var t=e.timestamp,r=e.duration;return function(e,n,o){var i=["action"];return i.push("%c"+String(e.type)),t&&i.push("%c@ "+n),r&&i.push("%c(in "+o.toFixed(2)+" ms)"),i.join(" ")}}function x(e,t){var r=t.logger,n=t.actionTransformer,o=t.titleFormatter,i=void 0===o?w(t):o,a=t.collapsed,f=t.colors,u=t.level,l=t.diff,c="undefined"==typeof t.titleFormatter;e.forEach(function(o,s){var d=o.started,p=o.startedTime,g=o.action,h=o.prevState,y=o.error,v=o.took,w=o.nextState,x=e[s+1];x&&(w=x.prevState,v=x.started-d);var S=n(g),k="function"==typeof a?a(function(){return w},g,o):a,j=D(p),E=f.title?"color: "+f.title(S)+";":"",A=["color: gray; font-weight: lighter;"];A.push(E),t.timestamp&&A.push("color: gray; font-weight: lighter;"),t.duration&&A.push("color: gray; font-weight: lighter;");var O=i(S,j,v);try{k?f.title&&c?r.groupCollapsed.apply(r,["%c "+O].concat(A)):r.groupCollapsed(O):f.title&&c?r.group.apply(r,["%c "+O].concat(A)):r.group(O);}catch(e){r.log(O);}var N=m(u,S,[h],"prevState"),P=m(u,S,[S],"action"),C=m(u,S,[y,h],"error"),F=m(u,S,[w],"nextState");if(N)if(f.prevState){var L="color: "+f.prevState(h)+"; font-weight: bold";r[N]("%c prev state",L,h);}else r[N]("prev state",h);if(P)if(f.action){var T="color: "+f.action(S)+"; font-weight: bold";r[P]("%c action    ",T,S);}else r[P]("action    ",S);if(y&&C)if(f.error){var M="color: "+f.error(y,h)+"; font-weight: bold;";r[C]("%c error     ",M,y);}else r[C]("error     ",y);if(F)if(f.nextState){var _="color: "+f.nextState(w)+"; font-weight: bold";r[F]("%c next state",_,w);}else r[F]("next state",w);l&&b(h,w,r,k);try{r.groupEnd();}catch(e){r.log("—— log end ——");}});}function S(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=Object.assign({},L,e),r=t.logger,n=t.stateTransformer,o=t.errorTransformer,i=t.predicate,a=t.logErrors,f=t.diffPredicate;if("undefined"==typeof r)return function(){return function(e){return function(t){return e(t)}}};if(e.getState&&e.dispatch)return console.error("[redux-logger] redux-logger not installed. Make sure to pass logger instance as middleware:\n// Logger with default options\nimport { logger } from 'redux-logger'\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n// Or you can create your own logger with custom options http://bit.ly/redux-logger-options\nimport createLogger from 'redux-logger'\nconst logger = createLogger({\n  // ...options\n});\nconst store = createStore(\n  reducer,\n  applyMiddleware(logger)\n)\n"),function(){return function(e){return function(t){return e(t)}}};var u=[];return function(e){var r=e.getState;return function(e){return function(l){if("function"==typeof i&&!i(r,l))return e(l);var c={};u.push(c),c.started=O.now(),c.startedTime=new Date,c.prevState=n(r()),c.action=l;var s=void 0;if(a)try{s=e(l);}catch(e){c.error=o(e);}else s=e(l);c.took=O.now()-c.started,c.nextState=n(r());var d=t.diff&&"function"==typeof f?f(r,l):t.diff;if(x(u,Object.assign({},t,{diff:d})),u.length=0,c.error)throw c.error;return s}}}}var k,j,E=function(e,t){return new Array(t+1).join(e)},A=function(e,t){return E("0",t-e.toString().length)+e},D=function(e){return A(e.getHours(),2)+":"+A(e.getMinutes(),2)+":"+A(e.getSeconds(),2)+"."+A(e.getMilliseconds(),3)},O="undefined"!=typeof performance&&null!==performance&&"function"==typeof performance.now?performance:Date,N="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},P=function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)},C=[];k="object"===("undefined"==typeof commonjsGlobal?"undefined":N(commonjsGlobal))&&commonjsGlobal?commonjsGlobal:"undefined"!=typeof window?window:{},j=k.DeepDiff,j&&C.push(function(){"undefined"!=typeof j&&k.DeepDiff===c&&(k.DeepDiff=j,j=void 0);}),t(n,r),t(o,r),t(i,r),t(a,r),Object.defineProperties(c,{diff:{value:c,enumerable:!0},observableDiff:{value:l,enumerable:!0},applyDiff:{value:h,enumerable:!0},applyChange:{value:d,enumerable:!0},revertChange:{value:g,enumerable:!0},isConflict:{value:function(){return "undefined"!=typeof j},enumerable:!0},noConflict:{value:function(){return C&&(C.forEach(function(e){e();}),C=null),c},enumerable:!0}});var F={E:{color:"#2196F3",text:"CHANGED:"},N:{color:"#4CAF50",text:"ADDED:"},D:{color:"#F44336",text:"DELETED:"},A:{color:"#2196F3",text:"ARRAY:"}},L={level:"log",logger:console,logErrors:!0,collapsed:void 0,predicate:void 0,duration:!1,timestamp:!0,stateTransformer:function(e){return e},actionTransformer:function(e){return e},errorTransformer:function(e){return e},colors:{title:function(){return "inherit"},prevState:function(){return "#9E9E9E"},action:function(){return "#03A9F4"},nextState:function(){return "#4CAF50"},error:function(){return "#F20404"}},diff:!1,diffPredicate:void 0,transformer:void 0},T=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.dispatch,r=e.getState;return "function"==typeof t||"function"==typeof r?S()({dispatch:t,getState:r}):void console.error("\n[redux-logger v3] BREAKING CHANGE\n[redux-logger v3] Since 3.0.0 redux-logger exports by default logger with default settings.\n[redux-logger v3] Change\n[redux-logger v3] import createLogger from 'redux-logger'\n[redux-logger v3] to\n[redux-logger v3] import { createLogger } from 'redux-logger'\n")};e.defaults=L,e.createLogger=S,e.logger=T,e.default=T,Object.defineProperty(e,"__esModule",{value:!0});});
  });

  var reduxLogger$1 = unwrapExports(reduxLogger);
  var reduxLogger_1 = reduxLogger.createLogger;

  var reduxLogger$2 = /*#__PURE__*/Object.freeze({
    'default': reduxLogger$1,
    __moduleExports: reduxLogger,
    createLogger: reduxLogger_1
  });

  /**
   * Bundle of @devexpress/dx-core
   * Generated: 2019-05-17
   * Version: 1.11.0
   * License: https://js.devexpress.com/Licensing
   */

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
      return ar;
  }

  var DELAY = 200;
  var compare$2 = function (a, b) {
      var aPosition = a.position();
      var bPosition = b.position();
      for (var i = 0; i < Math.min(aPosition.length, bPosition.length); i += 1) {
          if (aPosition[i] < bPosition[i])
              return -1;
          if (aPosition[i] > bPosition[i])
              return 1;
      }
      return aPosition.length - bPosition.length;
  };
  /** @internal */
  var insertPlugin = function (array, newItem) {
      var result = array.slice();
      var nextItemIndex = array.findIndex(function (item) { return compare$2(newItem, item) <= 0; });
      var targetIndex = nextItemIndex < 0 ? array.length : nextItemIndex;
      var alreadyExists = (targetIndex >= 0 && targetIndex < array.length)
          && compare$2(newItem, array[targetIndex]) === 0;
      result.splice(targetIndex, alreadyExists ? 1 : 0, newItem);
      return result;
  };
  /** @internal */
  var removePlugin = function (array, item) {
      var itemIndex = array.indexOf(item);
      return itemIndex >= 0 ? __spread(array.slice(0, itemIndex), array.slice(itemIndex + 1)) : array;
  };
  /** @internal */
  var createClickHandlers = function (click, dblClick) {
      var timeoutId;
      var events = {};
      if (click) {
          events.onClick = function (e) {
              if (!timeoutId) {
                  timeoutId = setTimeout(function () {
                      clearTimeout(timeoutId);
                      click(e);
                  }, DELAY);
              }
          };
      }
      if (dblClick) {
          events.onDoubleClick = function (e) {
              clearTimeout(timeoutId);
              dblClick(e);
          };
      }
      return events;
  };
  /** @internal */
  var slice = function (arr) { return Array.prototype.slice.call(arr); }; // slice can be renamed to copy as well
  /* globals window:true */
  /** @internal */
  var isEdgeBrowser = function () { return /Edge/.test(window.navigator.userAgent); };

  var getDependencyError = function (pluginName, dependencyName) { return new Error("The '" + pluginName + "' plugin requires '" + dependencyName + "' to be defined before it."); };
  /** @internal */
  var PluginHost = /*#__PURE__*/ (function () {
      function PluginHost() {
          this.gettersCache = {};
          this.knownKeysCache = {};
          this.validationRequired = true;
          this.plugins = [];
          this.subscriptions = new Set();
      }
      PluginHost.prototype.ensureDependencies = function () {
          var defined = new Set();
          var knownOptionals = new Map();
          this.plugins
              .filter(function (plugin) { return plugin.container; })
              .forEach(function (plugin) {
              var pluginName = plugin.name || '';
              if (knownOptionals.has(pluginName)) {
                  throw (getDependencyError(knownOptionals.get(pluginName), pluginName));
              }
              (plugin.dependencies || [])
                  .forEach(function (dependency) {
                  if (defined.has(dependency.name))
                      return;
                  if (dependency.optional) {
                      if (!knownOptionals.has(dependency.name)) {
                          knownOptionals.set(dependency.name, pluginName);
                      }
                      return;
                  }
                  throw (getDependencyError(pluginName, dependency.name));
              });
              defined.add(pluginName);
          });
      };
      PluginHost.prototype.registerPlugin = function (plugin) {
          this.plugins = insertPlugin(this.plugins, plugin);
          this.cleanPluginsCache();
      };
      PluginHost.prototype.unregisterPlugin = function (plugin) {
          this.plugins = removePlugin(this.plugins, plugin);
          this.cleanPluginsCache();
      };
      PluginHost.prototype.knownKeys = function (postfix) {
          if (!this.knownKeysCache[postfix]) {
              this.knownKeysCache[postfix] = Array.from(this.plugins
                  .map(function (plugin) { return Object.keys(plugin); })
                  .map(function (keys) { return keys.filter(function (key) { return key.endsWith(postfix); })[0]; })
                  .filter(function (key) { return !!key; })
                  .reduce(function (acc, key) { return acc.add(key); }, new Set()))
                  .map(function (key) { return key.replace(postfix, ''); });
          }
          return this.knownKeysCache[postfix];
      };
      PluginHost.prototype.collect = function (key, upTo) {
          var _this = this;
          if (this.validationRequired) {
              this.ensureDependencies();
              this.validationRequired = false;
          }
          if (!this.gettersCache[key]) {
              this.gettersCache[key] = this.plugins.map(function (plugin) { return plugin[key]; }).filter(function (plugin) { return !!plugin; });
          }
          if (!upTo)
              return this.gettersCache[key];
          var upToIndex = this.plugins.indexOf(upTo);
          return this.gettersCache[key].filter(function (getter) {
              var pluginIndex = _this.plugins.findIndex(function (plugin) { return plugin[key] === getter; });
              return pluginIndex < upToIndex;
          });
      };
      PluginHost.prototype.get = function (key, upTo) {
          var plugins = this.collect(key, upTo);
          if (!plugins.length)
              return undefined;
          var result = plugins[0]();
          plugins.slice(1).forEach(function (plugin) {
              result = plugin(result);
          });
          return result;
      };
      PluginHost.prototype.registerSubscription = function (subscription) {
          this.subscriptions.add(subscription);
      };
      PluginHost.prototype.unregisterSubscription = function (subscription) {
          this.subscriptions.delete(subscription);
      };
      PluginHost.prototype.broadcast = function (event, message) {
          this.subscriptions.forEach(function (subscription) { return subscription[event] && subscription[event](message); });
      };
      PluginHost.prototype.cleanPluginsCache = function () {
          this.validationRequired = true;
          this.gettersCache = {};
          this.knownKeysCache = {};
      };
      return PluginHost;
  }());

  /** @internal */
  var EventEmitter = /*#__PURE__*/ (function () {
      function EventEmitter() {
          this.handlers = [];
      }
      EventEmitter.prototype.emit = function (e) {
          this.handlers.forEach(function (handler) { return handler(e); });
      };
      EventEmitter.prototype.subscribe = function (handler) {
          this.handlers.push(handler);
      };
      EventEmitter.prototype.unsubscribe = function (handler) {
          this.handlers.splice(this.handlers.indexOf(handler), 1);
      };
      return EventEmitter;
  }());

  /** @internal */
  var shallowEqual$1 = function (objA, objB) {
      if (objA === objB) {
          return true;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
          return false;
      }
      // Test for A's keys different from B.
      var hasOwn = Object.prototype.hasOwnProperty;
      // tslint:disable-next-line: prefer-for-of
      for (var i = 0; i < keysA.length; i += 1) {
          if (!hasOwn.call(objB, keysA[i])
              || objA[keysA[i]] !== objB[keysA[i]]) {
              return false;
          }
          var valA = objA[keysA[i]];
          var valB = objB[keysA[i]];
          if (valA !== valB) {
              return false;
          }
      }
      return true;
  };
  /** @internal */
  var argumentsShallowEqual = function (prev, next) {
      if (prev === null || next === null || prev.length !== next.length) {
          return false;
      }
      for (var i = 0; i < prev.length; i += 1) {
          if (prev[i] !== next[i]) {
              return false;
          }
      }
      return true;
  };

  /** @internal */
  var memoize = function (func) {
      var lastArgs = null;
      var lastResult = null;
      return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (lastArgs === null || !argumentsShallowEqual(lastArgs, args)) {
              lastResult = func.apply(void 0, __spread(args));
          }
          lastArgs = args;
          return lastResult;
      };
  };

  /** @internal */
  var easeInQuad = function (t) { return t * t; };
  /** @internal */
  var easeOutQuad = function (t) { return t * (2 - t); };
  /** @internal */
  var easeInOutQuad = function (t) { return (t < 0.5
      ? 2 * t * t
      : -1 + ((4 - (2 * t)) * t)); };
  /** @internal */
  var easeInCubic = function (t) { return t * t * t; };
  /** @internal */
  var easeOutCubic = function (t) { return ((t - 1) * (t - 1) * (t - 1)) + 1; };
  /** @internal */
  var easeInOutCubic = function (t) { return (t < 0.5
      ? 4 * t * t * t
      : ((t - 1) * ((2 * t) - 2) * ((2 * t) - 2)) + 1); };
  /** @internal */
  var easeInQuart = function (t) { return t * t * t * t; };
  /** @internal */
  var easeOutQuart = function (t) { return 1 - ((t - 1) * (t - 1) * (t - 1) * (t - 1)); };
  /** @internal */
  var easeInOutQuart = function (t) { return (t < 0.5
      ? 8 * t * t * t * t
      : 1 - (8 * (t - 1) * (t - 1) * (t - 1) * (t - 1))); };
  /** @internal */
  var easeInQuint = function (t) { return t * t * t * t * t; };
  /** @internal */
  var easeOutQuint = function (t) { return 1 + ((t - 1) * (t - 1) * (t - 1) * (t - 1) * (t - 1)); };
  /** @internal */
  var easeInOutQuint = function (t) { return (t < 0.5
      ? 16 * t * t * t * t * t
      : 1 + (16 * (t - 1) * (t - 1) * (t - 1) * (t - 1) * (t - 1))); };

  var processPattern = function (pattern, params) { return Object.keys(params).reduce(function (msg, key) { return msg.replace("{" + key + "}", params[key]); }, pattern); };
  /** @internal */
  var getMessagesFormatter = function (messages) { return function (key, params) {
      var message = messages[key];
      if (typeof message === 'function') {
          return message(params);
      }
      if (params) {
          return processPattern(message, params);
      }
      return message;
  }; };

  var dxCore_es = /*#__PURE__*/Object.freeze({
    EventEmitter: EventEmitter,
    PluginHost: PluginHost,
    argumentsShallowEqual: argumentsShallowEqual,
    createClickHandlers: createClickHandlers,
    easeInCubic: easeInCubic,
    easeInOutCubic: easeInOutCubic,
    easeInOutQuad: easeInOutQuad,
    easeInOutQuart: easeInOutQuart,
    easeInOutQuint: easeInOutQuint,
    easeInQuad: easeInQuad,
    easeInQuart: easeInQuart,
    easeInQuint: easeInQuint,
    easeOutCubic: easeOutCubic,
    easeOutQuad: easeOutQuad,
    easeOutQuart: easeOutQuart,
    easeOutQuint: easeOutQuint,
    getMessagesFormatter: getMessagesFormatter,
    isEdgeBrowser: isEdgeBrowser,
    memoize: memoize,
    shallowEqual: shallowEqual$1,
    slice: slice
  });

  /**
   * Bundle of @devexpress/dx-grid-core
   * Generated: 2019-05-17
   * Version: 1.11.0
   * License: https://js.devexpress.com/Licensing
   */

  var GRID_GROUP_TYPE = Symbol('group');
  var GRID_GROUP_CHECK = Symbol(GRID_GROUP_TYPE.toString() + "_check");
  var GRID_GROUP_LEVEL_KEY = Symbol(GRID_GROUP_TYPE.toString() + "_levelKey");
  var GRID_GROUP_COLLAPSED_ROWS = Symbol(GRID_GROUP_TYPE.toString() + "_collapsedRows");

  var warnIfRowIdUndefined = function (getRowId) { return function (row) {
      var result = getRowId(row);
      if (!row[GRID_GROUP_CHECK] && result === undefined) {
          // tslint:disable-next-line: no-console
          console.warn('The row id is undefined. Check the getRowId function. The row is', row);
      }
      return result;
  }; };
  var rowIdGetter = function (getRowId, rows) {
      if (!getRowId) {
          var map_1 = new Map(rows.map(function (row, rowIndex) { return [row, rowIndex]; }));
          return function (row) { return map_1.get(row); };
      }
      return warnIfRowIdUndefined(getRowId);
  };
  var defaultGetCellValue = function (row, columnName) { return row[columnName]; };
  var cellValueGetter = function (getCellValue, columns) {
      if (getCellValue === void 0) { getCellValue = defaultGetCellValue; }
      var useFastAccessor = true;
      var map = columns.reduce(function (acc, column) {
          if (column.getCellValue) {
              useFastAccessor = false;
              acc[column.name] = column.getCellValue;
          }
          return acc;
      }, {});
      if (useFastAccessor) {
          return getCellValue;
      }
      return function (row, columnName) { return (map[columnName]
          ? map[columnName](row, columnName)
          : getCellValue(row, columnName)); };
  };

  var changeColumnSorting = function (state, _a) {
      var columnName = _a.columnName, direction = _a.direction, keepOther = _a.keepOther, sortIndex = _a.sortIndex;
      var sorting = state.sorting;
      var nextSorting = [];
      if (keepOther === true) {
          nextSorting = sorting;
      }
      if (Array.isArray(keepOther)) {
          nextSorting = slice(sorting)
              .filter(function (s) {
              return keepOther.indexOf(s.columnName) > -1;
          });
      }
      var columnSortingIndex = sorting.findIndex(function (s) { return s.columnName === columnName; });
      var columnSorting = sorting[columnSortingIndex];
      var newColumnSorting = {
          columnName: columnName,
          direction: direction
              || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc'),
      };
      if (columnSortingIndex > -1) {
          nextSorting = slice(nextSorting);
          nextSorting.splice(columnSortingIndex, 1);
      }
      if (direction !== null) {
          var newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;
          var newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;
          nextSorting = slice(nextSorting);
          nextSorting.splice(newIndex, 0, newColumnSorting);
      }
      return {
          sorting: nextSorting,
      };
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __read$1(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spread$1() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read$1(arguments[i]));
      return ar;
  }

  var unique = function (arr) { return __spread$1(Array.from(new Set(arr))); };
  var getColumnSortingDirection = function (sorting, columnName) {
      var columnSorting = sorting.filter(function (s) { return s.columnName === columnName; })[0];
      return columnSorting ? columnSorting.direction : null;
  };
  var getPersistentSortedColumns = function (sorting, columnExtensions) {
      if (columnExtensions === void 0) { columnExtensions = []; }
      return columnExtensions.reduce(function (acc, _a) {
          var columnName = _a.columnName, sortingEnabled = _a.sortingEnabled;
          if (sortingEnabled === false) {
              if (sorting.findIndex(function (sortItem) { return sortItem.columnName === columnName; }) > -1) {
                  acc.push(columnName);
              }
          }
          return acc;
      }, []);
  };
  var calculateKeepOther = function (sorting, keepOther, persistentSortedColumns) {
      if (persistentSortedColumns === void 0) { persistentSortedColumns = []; }
      if (!persistentSortedColumns.length)
          return keepOther;
      if (!keepOther)
          return persistentSortedColumns;
      return Array.isArray(keepOther)
          ? unique(__spread$1(keepOther, persistentSortedColumns))
          : unique(__spread$1(sorting.map(function (item) { return item.columnName; }), persistentSortedColumns));
  };

  /* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */
  /* tslint:disable no-increment-decrement */
  var merge = function (array, auxiliary, lo, mid, hi, compare) {
      var i = lo;
      var j = mid + 1;
      var k = lo;
      while (true) {
          var cmp = compare(array[i], array[j]);
          if (cmp <= 0) {
              auxiliary[k++] = array[i++];
              if (i > mid) {
                  do {
                      auxiliary[k++] = array[j++];
                  } while (j <= hi);
                  break;
              }
          }
          else {
              auxiliary[k++] = array[j++];
              if (j > hi) {
                  do {
                      auxiliary[k++] = array[i++];
                  } while (i <= mid);
                  break;
              }
          }
      }
  };
  var sortArrayToAuxiliary = function (array, auxiliary, lo, hi, compare) {
      if (hi < lo)
          return;
      if (hi === lo) {
          auxiliary[lo] = array[lo];
          return;
      }
      var mid = Math.floor(lo + ((hi - lo) / 2));
      sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);
      sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);
      merge(array, auxiliary, lo, mid, hi, compare);
  };
  var sortAuxiliaryToArray = function (array, auxiliary, lo, hi, compare) {
      if (hi <= lo)
          return;
      var mid = Math.floor(lo + ((hi - lo) / 2));
      sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);
      sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);
      merge(auxiliary, array, lo, mid, hi, compare);
  };
  var mergeSort = (function (array, compare) {
      if (compare === void 0) { compare = function (a, b) {
          if (a < b)
              return -1;
          if (a > b)
              return 1;
          return 0;
      }; }
      var result = slice(array);
      var auxiliary = slice(array);
      sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);
      return result;
  });

  var NODE_CHECK = Symbol('node');
  var rowsToTree = function (rows, getRowLevelKey) {
      if (!rows.length)
          return rows;
      var levels = [{ children: [] }];
      rows.forEach(function (row) {
          var _a;
          var levelKey = getRowLevelKey(row);
          if (levelKey) {
              var levelIndex = levels.slice(1)
                  .findIndex(function (level) { return getRowLevelKey(level.root) === levelKey; }) + 1;
              if (levelIndex > 0) {
                  levels.splice(levelIndex, levels.length - levelIndex);
              }
              var node = (_a = {}, _a[NODE_CHECK] = true, _a.root = row, _a.children = [], _a);
              levels[levels.length - 1].children.push(node);
              levels.push(node);
          }
          else {
              levels[levels.length - 1].children.push(row);
          }
      });
      return levels[0].children;
  };
  var treeToRows = function (tree, rows) {
      if (rows === void 0) { rows = []; }
      if (!tree.length)
          return tree;
      return tree.reduce(function (acc, node) {
          if (node[NODE_CHECK]) {
              acc.push(node.root);
              treeToRows(node.children, rows);
          }
          else {
              acc.push(node);
          }
          return acc;
      }, rows);
  };

  var defaultCompare = function (a, b) {
      if (a === b)
          return 0;
      if (a === null) {
          return b === undefined ? -1 : 1;
      }
      if (a === undefined) {
          return 1;
      }
      if (b === null || b === undefined) {
          return -1;
      }
      return a < b ? -1 : 1;
  };
  var createCompare = function (sorting, getColumnCompare, getComparableValue) { return sorting.reduceRight(function (prevCompare, columnSorting) {
      var columnName = columnSorting.columnName;
      var inverse = columnSorting.direction === 'desc';
      var columnCompare = (getColumnCompare && getColumnCompare(columnName)) || defaultCompare;
      return function (aRow, bRow) {
          var a = getComparableValue(aRow, columnName);
          var b = getComparableValue(bRow, columnName);
          var result = columnCompare(a, b);
          if (result !== 0) {
              return inverse ? -result : result;
          }
          return prevCompare(aRow, bRow);
      };
  }, function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      return 0;
  }); };
  var sortTree = function (tree, compare) {
      var sortedTree = tree.map(function (node) {
          if (node[NODE_CHECK]) {
              return __assign({}, node, { children: sortTree(node.children, compare) });
          }
          return node;
      });
      return mergeSort(sortedTree, function (a, b) { return compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b); });
  };
  var sortHierarchicalRows = function (rows, compare, getRowLevelKey) {
      var tree = rowsToTree(rows, getRowLevelKey);
      var sortedTree = sortTree(tree, compare);
      return treeToRows(sortedTree);
  };
  var sortedRows = function (rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey) {
      if (!sorting.length || !rows.length)
          return rows;
      var compare;
      if (!getRowLevelKey) {
          compare = createCompare(sorting, getColumnCompare, getCellValue);
          return mergeSort(rows.slice(), compare);
      }
      compare = createCompare(sorting, getColumnCompare, function (row, columnName) {
          if (isGroupRow && isGroupRow(row)) {
              if (row.groupedBy === columnName) {
                  return row.value;
              }
              return undefined;
          }
          return getCellValue(row, columnName);
      });
      return sortHierarchicalRows(rows, compare, getRowLevelKey);
  };

  var changeColumnFilter = function (filters, _a) {
      var columnName = _a.columnName, config = _a.config;
      var filterIndex = filters.findIndex(function (f) { return f.columnName === columnName; });
      var nextState = slice(filters);
      if (config) {
          var filter = __assign({ columnName: columnName }, config);
          if (filterIndex > -1) {
              nextState.splice(filterIndex, 1, filter);
          }
          else {
              nextState.push(filter);
          }
      }
      else if (filterIndex > -1) {
          nextState.splice(filterIndex, 1);
      }
      return nextState;
  };

  var getColumnFilterConfig = function (filters, columnName) { return (filters.length && filters.filter(function (s) { return s.columnName === columnName; })[0] || null); };

  var filterExpression = function (filters, expression) {
      // tslint:disable-next-line: no-object-literal-type-assertion
      var selfFilterExpr = { filters: filters, operator: 'and' };
      if (!expression) {
          return selfFilterExpr;
      }
      return {
          operator: 'and',
          filters: [expression, selfFilterExpr],
      };
  };

  var operators = {
      or: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc || predicate(row); }, false)); }; },
      and: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc && predicate(row); }, true)); }; },
  };
  var toLowerCase = function (value) { return String(value).toLowerCase(); };
  var operationPredicates = {
      contains: function (value, filter) { return toLowerCase(value)
          .indexOf(toLowerCase(filter.value)) > -1; },
      notContains: function (value, filter) { return toLowerCase(value)
          .indexOf(toLowerCase(filter.value)) === -1; },
      startsWith: function (value, filter) { return toLowerCase(value)
          .startsWith(toLowerCase(filter.value)); },
      endsWith: function (value, filter) { return toLowerCase(value)
          .endsWith(toLowerCase(filter.value)); },
      equal: function (value, filter) { return String(value) === String(filter.value); },
      notEqual: function (value, filter) { return String(value) !== String(filter.value); },
      greaterThan: function (value, filter) { return value > filter.value; },
      greaterThanOrEqual: function (value, filter) { return value >= filter.value; },
      lessThan: function (value, filter) { return value < filter.value; },
      lessThanOrEqual: function (value, filter) { return value <= filter.value; },
  };
  var defaultFilterPredicate = function (value, filter) {
      var operation = filter.operation || 'contains';
      return operationPredicates[operation](value, filter);
  };
  var filterTree = function (tree, predicate) { return tree.reduce(function (acc, node) {
      if (node[NODE_CHECK]) {
          var filteredChildren = filterTree(node.children, predicate);
          if (filteredChildren.length > 0) {
              acc.push(__assign({}, node, { children: filteredChildren }));
              return acc;
          }
          if (predicate(node.root, true)) {
              acc.push(node.root);
              return acc;
          }
          return acc;
      }
      if (predicate(node)) {
          acc.push(node);
          return acc;
      }
      return acc;
  }, []); };
  var filterHierarchicalRows = function (rows, predicate, getRowLevelKey, getCollapsedRows) {
      var tree = rowsToTree(rows, getRowLevelKey);
      var collapsedRowsMeta = [];
      var filteredTree = filterTree(tree, function (row, isNode) {
          if (isNode) {
              var collapsedRows = getCollapsedRows && getCollapsedRows(row);
              if (collapsedRows && collapsedRows.length) {
                  var filteredCollapsedRows = collapsedRows.filter(predicate);
                  collapsedRowsMeta.push([row, filteredCollapsedRows]);
                  return !!filteredCollapsedRows.length || predicate(row);
              }
              if (predicate(row)) {
                  collapsedRowsMeta.push([row, []]);
                  return true;
              }
              return false;
          }
          return predicate(row);
      });
      return { rows: treeToRows(filteredTree), collapsedRowsMeta: new Map(collapsedRowsMeta) };
  };
  var buildPredicate = function (initialFilterExpression, getCellValue, getColumnPredicate) {
      var getSimplePredicate = function (filter) {
          var columnName = filter.columnName;
          var customPredicate = getColumnPredicate && getColumnPredicate(columnName);
          var predicate = customPredicate || defaultFilterPredicate;
          return function (row) { return predicate(getCellValue(row, columnName), filter, row); };
      };
      var getOperatorPredicate = function (filterExpression) {
          var build = operators[toLowerCase(filterExpression.operator)];
          return build && build(filterExpression.filters.map(getPredicate));
      };
      var getPredicate = function (filterExpression) { return (getOperatorPredicate(filterExpression)
          || getSimplePredicate(filterExpression)); };
      return getPredicate(initialFilterExpression);
  };
  var filteredRows = function (rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows) {
      if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {
          // tslint:disable-next-line:no-object-literal-type-assertion
          return { rows: rows };
      }
      var predicate = buildPredicate(filterExpression, getCellValue, getColumnPredicate);
      return getRowLevelKey
          ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows)
          : { rows: rows.filter(predicate) };
  };
  var filteredCollapsedRowsGetter = function (_a) {
      var collapsedRowsMeta = _a.collapsedRowsMeta;
      return function (row) { return collapsedRowsMeta && collapsedRowsMeta.get(row); };
  };
  var unwrappedFilteredRows = function (_a) {
      var rows = _a.rows;
      return rows;
  };

  var GROUP_KEY_SEPARATOR = '|';

  var applyColumnGrouping = function (grouping, _a) {
      var columnName = _a.columnName, groupIndex = _a.groupIndex;
      var nextGrouping = grouping;
      var groupingIndex = nextGrouping.findIndex(function (g) { return g.columnName === columnName; });
      var targetIndex = groupIndex;
      if (groupingIndex > -1) {
          nextGrouping = slice(grouping);
          nextGrouping.splice(groupingIndex, 1);
      }
      else if (groupIndex === undefined) {
          targetIndex = nextGrouping.length;
      }
      if (targetIndex > -1) {
          nextGrouping = slice(nextGrouping);
          nextGrouping.splice(targetIndex, 0, {
              columnName: columnName,
          });
      }
      return nextGrouping;
  };
  var changeColumnGrouping = function (_a, _b) {
      var grouping = _a.grouping, expandedGroups = _a.expandedGroups;
      var columnName = _b.columnName, groupIndex = _b.groupIndex;
      var nextGrouping = applyColumnGrouping(grouping, { columnName: columnName, groupIndex: groupIndex });
      var ungroupedColumnIndex = grouping.findIndex(function (group, index) { return !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName; });
      if (ungroupedColumnIndex === -1) {
          return {
              grouping: nextGrouping,
          };
      }
      var filteredExpandedGroups = expandedGroups.filter(function (group) { return group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex; });
      if (filteredExpandedGroups.length === expandedGroups.length) {
          return {
              grouping: nextGrouping,
          };
      }
      return {
          grouping: nextGrouping,
          expandedGroups: filteredExpandedGroups,
      };
  };
  var toggleExpandedGroups = function (state, _a) {
      var groupKey = _a.groupKey;
      var expandedGroups = slice(state.expandedGroups);
      var groupKeyIndex = expandedGroups.indexOf(groupKey);
      if (groupKeyIndex > -1) {
          expandedGroups.splice(groupKeyIndex, 1);
      }
      else {
          expandedGroups.push(groupKey);
      }
      return {
          expandedGroups: expandedGroups,
      };
  };
  var draftColumnGrouping = function (_a, _b) {
      var grouping = _a.grouping, draftGrouping = _a.draftGrouping;
      var columnName = _b.columnName, groupIndex = _b.groupIndex;
      return ({
          draftGrouping: applyColumnGrouping(draftGrouping || grouping, { columnName: columnName, groupIndex: groupIndex }),
      });
  };
  var cancelColumnGroupingDraft = function () { return ({
      draftGrouping: null,
  }); };

  var adjustSortIndex = function (groupingIndex, grouping, sorting) { return Math.max(grouping.slice(0, groupingIndex).reduce(function (acc, columnGrouping) {
      var columnSortingIndex = sorting.findIndex(function (columnSorting) { return columnSorting.columnName === columnGrouping.columnName; });
      return (columnSortingIndex === -1 ? acc - 1 : acc);
  }, groupingIndex), 0); };

  var groupRowChecker = function (row) { return row[GRID_GROUP_CHECK]; };
  var groupRowLevelKeyGetter = function (row) { return (row ? row[GRID_GROUP_LEVEL_KEY] : undefined); };
  var defaultColumnCriteria = function (value) { return ({
      value: value,
      key: String(value),
  }); };
  var groupedRows = function (rows, grouping, getCellValue, getColumnCriteria, keyPrefix) {
      if (keyPrefix === void 0) { keyPrefix = ''; }
      if (!grouping.length)
          return rows;
      var columnName = grouping[0].columnName;
      var groupCriteria = (getColumnCriteria && getColumnCriteria(columnName))
          || defaultColumnCriteria;
      var groups = new Map();
      rows.forEach(function (row) {
          var rawValue = getCellValue(row, columnName);
          var _a = groupCriteria(rawValue, row), key = _a.key, value = _a.value;
          var sameKeyItems = groups.get(key);
          if (!sameKeyItems) {
              var groupingValue = value === rawValue ? value : value || key;
              groups.set(key, [groupingValue, key, [row]]);
          }
          else {
              sameKeyItems[2].push(row);
          }
      });
      var groupedBy = grouping[0].columnName;
      var nestedGrouping = grouping.slice(1);
      return __spread$1(groups.values()).reduce(function (acc, _a) {
          var _b;
          var _c = __read$1(_a, 3), value = _c[0], key = _c[1], items = _c[2];
          var compoundKey = "" + keyPrefix + key;
          acc.push((_b = {
                  groupedBy: groupedBy,
                  compoundKey: compoundKey,
                  key: key,
                  value: value
              },
              _b[GRID_GROUP_CHECK] = true,
              _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy,
              _b));
          acc.push.apply(acc, __spread$1(groupedRows(items, nestedGrouping, getCellValue, getColumnCriteria, "" + compoundKey + GROUP_KEY_SEPARATOR)));
          return acc;
      }, []);
  };
  var expandedGroupRows = function (rows, grouping, expandedGroups) {
      if (!grouping.length)
          return rows;
      var groupingColumnNames = grouping.map(function (columnGrouping) { return columnGrouping.columnName; });
      var expandedGroupsSet = new Set(expandedGroups);
      var currentGroupExpanded = true;
      var currentGroupLevel = 0;
      return rows.reduce(function (acc, row) {
          var _a;
          if (!row[GRID_GROUP_CHECK]) {
              if (currentGroupExpanded) {
                  acc.push(row);
              }
              else {
                  acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);
              }
              return acc;
          }
          var groupLevel = groupingColumnNames.indexOf(row.groupedBy);
          if (groupLevel > currentGroupLevel && !currentGroupExpanded) {
              return acc;
          }
          currentGroupExpanded = expandedGroupsSet.has(row.compoundKey);
          currentGroupLevel = groupLevel;
          if (currentGroupExpanded) {
              acc.push(row);
          }
          else {
              acc.push(__assign({}, row, (_a = {}, _a[GRID_GROUP_COLLAPSED_ROWS] = [], _a)));
          }
          return acc;
      }, []);
  };
  var groupCollapsedRowsGetter = function (getCollapsedRows) { return function (row) { return (row[GRID_GROUP_COLLAPSED_ROWS] || (getCollapsedRows && getCollapsedRows(row))); }; };

  var customGroupedRows = function (currentRows, grouping, getChildGroups, rootRows, keyPrefix) {
      if (rootRows === void 0) { rootRows = currentRows; }
      if (keyPrefix === void 0) { keyPrefix = ''; }
      if (!currentRows || !currentRows.length)
          return [];
      if (!grouping.length)
          return currentRows;
      var groupedBy = grouping[0].columnName;
      var nestedGrouping = grouping.slice(1);
      return getChildGroups(currentRows, grouping[0], rootRows)
          .reduce(function (acc, _a) {
          var _b;
          var key = _a.key, _c = _a.value, value = _c === void 0 ? key : _c, childRows = _a.childRows;
          var compoundKey = "" + keyPrefix + key;
          acc.push((_b = {
                  groupedBy: groupedBy,
                  compoundKey: compoundKey,
                  key: key,
                  value: value
              },
              _b[GRID_GROUP_CHECK] = true,
              _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy,
              _b));
          acc.push.apply(acc, __spread$1(customGroupedRows(childRows, nestedGrouping, getChildGroups, rootRows, "" + compoundKey + GROUP_KEY_SEPARATOR)));
          return acc;
      }, []);
  };
  var customGroupingRowIdGetter = function (getRowId, rows) {
      var firstRow = rows.find(function (row) { return !row[GRID_GROUP_CHECK]; });
      if (!firstRow || getRowId(firstRow) !== undefined) {
          return getRowId;
      }
      var map = new Map(rows
          .filter(function (row) { return !row[GRID_GROUP_CHECK]; })
          .map(function (row, rowIndex) { return [row, rowIndex]; }));
      return function (row) { return map.get(row); };
  };

  var groupingPanelItems = function (columns, grouping, draftGrouping) {
      var items = draftGrouping.map(function (_a) {
          var columnName = _a.columnName;
          return ({
              column: columns.find(function (c) { return c.name === columnName; }),
              draft: !grouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }),
          });
      });
      grouping.forEach(function (_a, index) {
          var columnName = _a.columnName;
          if (draftGrouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }))
              return;
          items.splice(index, 0, {
              column: columns.find(function (c) { return c.name === columnName; }),
              draft: true,
          });
      });
      return items;
  };

  var setCurrentPage = function (prevPage, page) { return page; };
  var setPageSize = function (prevPageSize, size) { return size; };

  var clamp = function (value, max) { return (Math.max(Math.min(value, max), 0)); };

  // tslint:disable-next-line:max-line-length
  var PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';
  var paginatedRows = function (rows, pageSize, page) { return (pageSize
      ? rows.slice(pageSize * page, pageSize * (page + 1))
      : rows); };
  var rowsWithPageHeaders = function (rows, pageSize, getRowLevelKey) {
      if (!pageSize || !getRowLevelKey)
          return rows;
      var result = rows.slice();
      var headerRows = [];
      var currentIndex = 0;
      var _loop_1 = function () {
          var row = result[currentIndex];
          var levelKey = getRowLevelKey(row);
          if (levelKey) {
              var headerIndex = headerRows.findIndex(function (headerRow) { return getRowLevelKey(headerRow) === levelKey; });
              // tslint:disable-next-line:prefer-conditional-expression
              if (headerIndex === -1) {
                  headerRows = __spread$1(headerRows, [row]);
              }
              else {
                  headerRows = __spread$1(headerRows.slice(0, headerIndex), [row]);
              }
              if (headerRows.length >= pageSize) {
                  throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);
              }
          }
          var indexInPage = currentIndex % pageSize;
          if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {
              result = __spread$1(result.slice(0, currentIndex), [
                  headerRows[indexInPage]
              ], result.slice(currentIndex));
          }
          currentIndex += 1;
      };
      while (result.length > currentIndex) {
          _loop_1();
      }
      return result;
  };
  var rowCount = function (rows) { return rows.length; };
  var pageCount = function (count, pageSize) { return (pageSize ? Math.ceil(count / pageSize) : 1); };
  var currentPage = function (page, totalCount, pageSize, setCurrentPage) {
      var totalPages = pageCount(totalCount, pageSize);
      var adjustedCurrentPage = clamp(page, totalPages - 1);
      if (page !== adjustedCurrentPage) {
          setTimeout(function () { return setCurrentPage(adjustedCurrentPage); });
      }
      return adjustedCurrentPage;
  };

  var firstRowOnPage = function (currentPage, pageSize, totalCount) {
      if (totalCount === 0) {
          return 0;
      }
      return pageSize ? (currentPage * pageSize) + 1 : 1;
  };
  var lastRowOnPage = function (currentPage, pageSize, totalRowCount) {
      var result = totalRowCount;
      if (pageSize) {
          var index = (currentPage + 1) * pageSize;
          result = index > totalRowCount ? totalRowCount : index;
      }
      return result;
  };
  var calculateStartPage = function (currentPage, maxButtonCount, totalPageCount) { return (Math.max(Math.min(currentPage - Math.floor(maxButtonCount / 2), (totalPageCount - maxButtonCount) + 1), 1)); };

  var toggle = function (source, items, state) {
      var itemsSet = new Set(items);
      var sourceState = state;
      if (sourceState === undefined) {
          var availableSelection = source.filter(function (item) { return itemsSet.has(item); });
          sourceState = availableSelection.length !== itemsSet.size;
      }
      if (sourceState) {
          var sourceSet_1 = new Set(source);
          return __spread$1(source, items.filter(function (item) { return !sourceSet_1.has(item); }));
      }
      return source.filter(function (item) { return !itemsSet.has(item); });
  };

  var toggleSelection = function (selection, _a) {
      var rowIds = _a.rowIds, state = _a.state;
      return toggle(selection, rowIds, state);
  };

  var rowsWithAvailableToSelect = function (rows, getRowId, isGroupRow) {
      var dataRows = rows;
      if (isGroupRow) {
          dataRows = dataRows.filter(function (row) { return !isGroupRow(row); });
      }
      return { rows: rows, availableToSelect: dataRows.map(function (row) { return getRowId(row); }) };
  };
  var someSelected = function (_a, selection) {
      var availableToSelect = _a.availableToSelect;
      var selectionSet = new Set(selection);
      return availableToSelect.length !== 0 && selectionSet.size !== 0
          && availableToSelect.some(function (elem) { return selectionSet.has(elem); })
          && availableToSelect.some(function (elem) { return !selectionSet.has(elem); });
  };
  var allSelected = function (_a, selection) {
      var availableToSelect = _a.availableToSelect;
      var selectionSet = new Set(selection);
      return selectionSet.size !== 0 && availableToSelect.length !== 0
          && !availableToSelect.some(function (elem) { return !selectionSet.has(elem); });
  };
  var unwrapSelectedRows = function (_a) {
      var rows = _a.rows;
      return rows;
  };

  var startEditRows = function (prevEditingRowIds, _a) {
      var rowIds = _a.rowIds;
      return __spread$1(prevEditingRowIds, rowIds);
  };
  var stopEditRows = function (prevEditingRowIds, _a) {
      var rowIds = _a.rowIds;
      var rowIdSet = new Set(rowIds);
      return prevEditingRowIds.filter(function (id) { return !rowIdSet.has(id); });
  };
  var addRow = function (addedRows, _a) {
      var row = (_a === void 0 ? { row: {} } : _a).row;
      return __spread$1(addedRows, [row]);
  };
  var changeAddedRow = function (addedRows, _a) {
      var rowId = _a.rowId, change = _a.change;
      var result = addedRows.slice();
      result[rowId] = __assign({}, result[rowId], change);
      return result;
  };
  var cancelAddedRows = function (addedRows, _a) {
      var rowIds = _a.rowIds;
      var result = [];
      var indexSet = new Set(rowIds);
      addedRows.forEach(function (row, index) {
          if (!indexSet.has(index)) {
              result.push(row);
          }
      });
      return result;
  };
  var changeRow = function (prevRowChanges, _a) {
      var _b;
      var rowId = _a.rowId, change = _a.change;
      var prevChange = prevRowChanges[rowId] || {};
      return __assign({}, prevRowChanges, (_b = {}, _b[rowId] = __assign({}, prevChange, change), _b));
  };
  var cancelChanges = function (prevRowChanges, _a) {
      var rowIds = _a.rowIds;
      var result = __assign({}, prevRowChanges);
      rowIds.forEach(function (rowId) {
          delete result[rowId];
      });
      return result;
  };
  var deleteRows = function (deletedRowIds, _a) {
      var rowIds = _a.rowIds;
      return __spread$1(deletedRowIds, rowIds);
  };
  var cancelDeletedRows = function (deletedRowIds, _a) {
      var rowIds = _a.rowIds;
      var rowIdSet = new Set(rowIds);
      return deletedRowIds.filter(function (rowId) { return !rowIdSet.has(rowId); });
  };

  var changedRowsByIds = function (changes, rowIds) {
      var result = {};
      rowIds.forEach(function (rowId) {
          result[rowId] = changes[rowId];
      });
      return result;
  };
  var addedRowsByIds = function (addedRows, rowIds) {
      var rowIdSet = new Set(rowIds);
      var result = [];
      addedRows.forEach(function (row, index) {
          if (rowIdSet.has(index)) {
              result.push(row);
          }
      });
      return result;
  };
  var defaultCreateRowChange = function (row, value, columnName) {
      var _a;
      return (_a = {}, _a[columnName] = value, _a);
  };
  var createRowChangeGetter = function (createRowChange, columnExtensions) {
      if (createRowChange === void 0) { createRowChange = defaultCreateRowChange; }
      if (columnExtensions === void 0) { columnExtensions = []; }
      var map = columnExtensions.reduce(function (acc, columnExtension) {
          if (columnExtension.createRowChange) {
              acc[columnExtension.columnName] = columnExtension.createRowChange;
          }
          return acc;
      }, {});
      return function (row, value, columnName) {
          if (map[columnName]) {
              return map[columnName](row, value, columnName);
          }
          return createRowChange(row, value, columnName);
      };
  };

  var getRowChange = function (rowChanges, rowId) { return rowChanges[rowId] || {}; };

  var TABLE_REORDERING_TYPE = Symbol('reordering');

  var changeColumnOrder = function (order, _a) {
      var sourceColumnName = _a.sourceColumnName, targetColumnName = _a.targetColumnName;
      var sourceColumnIndex = order.indexOf(sourceColumnName);
      var targetColumnIndex = order.indexOf(targetColumnName);
      var newOrder = slice(order);
      newOrder.splice(sourceColumnIndex, 1);
      newOrder.splice(targetColumnIndex, 0, sourceColumnName);
      return newOrder;
  };

  var TABLE_DATA_TYPE = Symbol('data');
  var TABLE_NODATA_TYPE = Symbol('nodata');
  var TABLE_FLEX_TYPE = Symbol('flex');

  var orderedColumns = function (tableColumns, order) { return mergeSort(tableColumns, function (a, b) {
      if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE)
          return 0;
      var aPos = order.indexOf(a.column.name);
      var bPos = order.indexOf(b.column.name);
      return aPos - bPos;
  }); };
  var tableHeaderRowsWithReordering = function (tableHeaderRows) { return __spread$1(tableHeaderRows, [
      {
          key: TABLE_REORDERING_TYPE.toString(),
          type: TABLE_REORDERING_TYPE,
          height: 0,
      },
  ]); };
  var draftOrder = function (order, sourceColumnIndex, targetColumnIndex) {
      if (sourceColumnIndex === -1
          || targetColumnIndex === -1
          || sourceColumnIndex === targetColumnIndex) {
          return order;
      }
      var result = slice(order);
      var sourceColumn = order[sourceColumnIndex];
      result.splice(sourceColumnIndex, 1);
      result.splice(targetColumnIndex, 0, sourceColumn);
      return result;
  };

  var UNSET_COLUMN_WIDTH_ERROR = [
      'The "$1" column\'s width is not specified.',
      'The TableColumnResizing plugin requires that all columns have the specified width.',
  ].join('\n');
  var specifyWidths = function (tableColumns, widths, onAbsence) {
      if (!widths.length)
          return tableColumns;
      return tableColumns
          .reduce(function (acc, tableColumn) {
          if (tableColumn.type === TABLE_DATA_TYPE) {
              var columnName_1 = tableColumn.column.name;
              var column = widths.find(function (el) { return el.columnName === columnName_1; });
              var width = column && column.width;
              if (width === undefined) {
                  onAbsence(columnName_1);
                  acc.push(tableColumn);
              }
              else {
                  acc.push(__assign({}, tableColumn, { width: width }));
              }
          }
          else {
              acc.push(tableColumn);
          }
          return acc;
      }, []);
  };
  var tableColumnsWithWidths = function (tableColumns, columnWidths) { return specifyWidths(tableColumns, columnWidths, function (columnName) {
      throw new Error(UNSET_COLUMN_WIDTH_ERROR.replace('$1', columnName));
  }); };
  var tableColumnsWithDraftWidths = function (tableColumns, draftColumnWidths) { return specifyWidths(tableColumns, draftColumnWidths, function () { }); };

  var changeTableColumnWidth = function (state, _a) {
      var columnName = _a.columnName, shift = _a.shift, minColumnWidth = _a.minColumnWidth;
      var columnWidths = state.columnWidths;
      var nextColumnWidth = slice(columnWidths);
      var index = nextColumnWidth.findIndex(function (elem) { return elem.columnName === columnName; });
      var updatedColumn = nextColumnWidth[index];
      var size = Math.max(minColumnWidth, updatedColumn.width + shift);
      nextColumnWidth.splice(index, 1, { columnName: columnName, width: size });
      return {
          columnWidths: nextColumnWidth,
      };
  };
  var draftTableColumnWidth = function (state, _a) {
      var columnName = _a.columnName, shift = _a.shift, minColumnWidth = _a.minColumnWidth;
      var columnWidths = state.columnWidths;
      var updatedColumn = columnWidths.find(function (elem) { return elem.columnName === columnName; });
      var size = Math.max(minColumnWidth, updatedColumn.width + shift);
      return {
          draftColumnWidths: [{ columnName: updatedColumn.columnName, width: size }],
      };
  };
  var cancelTableColumnWidthDraft = function () { return ({
      draftColumnWidths: [],
  }); };

  var TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');

  var TABLE_ADDED_TYPE = Symbol('added');
  var TABLE_EDIT_TYPE = Symbol('edit');

  var TABLE_HEADING_TYPE = Symbol('heading');

  var isHeadingEditCommandsTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };
  var isEditCommandsTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE
      || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };

  var tableColumnsWithEditing = function (tableColumns, width) { return __spread$1([
      { width: width, key: TABLE_EDIT_COMMAND_TYPE.toString(), type: TABLE_EDIT_COMMAND_TYPE }
  ], tableColumns); };

  var isEditTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE)
      && tableColumn.type === TABLE_DATA_TYPE; };
  var isAddedTableRow = function (tableRow) { return tableRow.type === TABLE_ADDED_TYPE; };
  var isEditTableRow = function (tableRow) { return tableRow.type === TABLE_EDIT_TYPE; };

  var tableRowsWithEditing = function (tableRows, editingRowIds, addedRows, rowHeight) {
      var rowIds = new Set(editingRowIds);
      var editedTableRows = tableRows
          .map(function (tableRow) { return (tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId)
          ? __assign({}, tableRow, { type: TABLE_EDIT_TYPE, height: rowHeight }) : tableRow); });
      var addedTableRows = addedRows
          .map(function (row, rowIndex) { return ({
          row: row,
          key: TABLE_ADDED_TYPE.toString() + "_" + rowIndex,
          type: TABLE_ADDED_TYPE,
          rowId: rowIndex,
          height: rowHeight,
      }); });
      return __spread$1(slice(addedTableRows).reverse(), editedTableRows);
  };

  var TABLE_FILTER_TYPE = Symbol('filter');
  var DEFAULT_FILTER_OPERATIONS = [
      'contains',
      'notContains',
      'startsWith',
      'endsWith',
      'equal',
      'notEqual',
  ];

  var isFilterTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isFilterTableRow = function (tableRow) { return tableRow.type === TABLE_FILTER_TYPE; };
  var getColumnFilterOperations = function (getAvailableFilterOperations, columnName) { return (getAvailableFilterOperations && getAvailableFilterOperations(columnName))
      || DEFAULT_FILTER_OPERATIONS; };
  var isFilterValueEmpty = function (value) { return value === undefined || !String(value).length; };
  var getSelectedFilterOperation = function (filterOperations, columnName, columnFilter, columnFilterOperations) {
      if (columnFilter && columnFilter.operation) {
          return columnFilter.operation;
      }
      if (filterOperations[columnName]) {
          return filterOperations[columnName];
      }
      return columnFilterOperations[0];
  };

  var tableHeaderRowsWithFilter = function (headerRows, rowHeight) { return __spread$1(headerRows, [
      { key: TABLE_FILTER_TYPE.toString(), type: TABLE_FILTER_TYPE, height: rowHeight }
  ]); };

  var TABLE_GROUP_TYPE = Symbol('group');

  var isGroupTableCell = function (tableRow, tableColumn) { return !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE
      && tableColumn.column
      && tableColumn.column.name === tableRow.row.groupedBy); };
  var isGroupIndentTableCell = function (tableRow, tableColumn, grouping) {
      if (tableRow.type !== TABLE_GROUP_TYPE || tableColumn.type !== TABLE_GROUP_TYPE)
          return false;
      if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name)
          return false;
      var rowGroupIndex = grouping.findIndex(function (columnGrouping) { return columnGrouping.columnName === tableRow.row.groupedBy; });
      var columnGroupIndex = grouping.findIndex(function (columnGrouping) { return !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name; });
      return columnGroupIndex < rowGroupIndex;
  };
  var isGroupTableRow = function (tableRow) { return tableRow.type === TABLE_GROUP_TYPE; };

  var tableColumnsWithDraftGrouping = function (tableColumns, grouping, draftGrouping, showColumnWhenGrouped) { return tableColumns
      .reduce(function (acc, tableColumn) {
      if (tableColumn.type !== TABLE_DATA_TYPE) {
          acc.push(tableColumn);
          return acc;
      }
      var columnName = tableColumn.column && tableColumn.column.name || '';
      var columnGroupingExists = grouping
          .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });
      var columnDraftGroupingExists = draftGrouping
          .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });
      if ((!columnGroupingExists && !columnDraftGroupingExists)
          || showColumnWhenGrouped(columnName)) {
          acc.push(tableColumn);
      }
      else if ((!columnGroupingExists && columnDraftGroupingExists)
          || (columnGroupingExists && !columnDraftGroupingExists)) {
          acc.push(__assign({}, tableColumn, { draft: true }));
      }
      return acc;
      // tslint:disable-next-line: prefer-array-literal
  }, []); };
  var tableColumnsWithGrouping = function (columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped) { return __spread$1(grouping.map(function (columnGrouping) {
      var groupedColumn = columns.find(function (column) { return column.name === columnGrouping.columnName; });
      return {
          key: TABLE_GROUP_TYPE.toString() + "_" + groupedColumn.name,
          type: TABLE_GROUP_TYPE,
          column: groupedColumn,
          width: indentColumnWidth,
      };
  }), tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped)); };
  var tableRowsWithGrouping = function (tableRows, isGroupRow) { return tableRows.map(function (tableRow) {
      if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {
          return tableRow;
      }
      return __assign({}, tableRow, { key: TABLE_GROUP_TYPE.toString() + "_" + tableRow.row.compoundKey, type: TABLE_GROUP_TYPE });
  }); };
  var tableGroupCellColSpanGetter = function (getTableCellColSpan) { return function (params) {
      var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
      if (tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE
          && tableRow.row.groupedBy === tableColumn.column.name) {
          return tableColumns.length - tableColumns.indexOf(tableColumn);
      }
      return getTableCellColSpan(params);
  }; };

  var isHeadingTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isHeadingTableRow = function (tableRow) { return (tableRow.type === TABLE_HEADING_TYPE); };
  var findChainByColumnIndex = function (chains, columnIndex) { return (chains.find(function (chain) { return (chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length); })); };
  var splitHeaderColumnChains = function (tableColumnChains, tableColumns, shouldSplitChain, extendChainProps) { return (tableColumnChains.map(function (row, rowIndex) { return row
      .reduce(function (acc, chain) {
      var currentChain = null;
      chain.columns.forEach(function (col) {
          var column = tableColumns.find(function (c) { return c.key === col.key; });
          var isNewGroup = shouldSplitChain(currentChain, column, rowIndex);
          if (isNewGroup) {
              var start = currentChain
                  ? (currentChain.start + currentChain.columns.length)
                  : chain.start;
              acc.push(__assign({}, chain, extendChainProps(column), { start: start, columns: [] }));
              currentChain = acc[acc.length - 1];
          }
          currentChain.columns.push(column);
      });
      return acc;
  }, []); })); };
  var generateSimpleChains = function (rows, columns) { return (rows.map(function () { return ([{
          columns: columns,
          start: 0,
      }]); })); };

  var tableRowsWithHeading = function (headerRows) { return __spread$1([
      { key: TABLE_HEADING_TYPE.toString(), type: TABLE_HEADING_TYPE }
  ], headerRows); };

  var TABLE_BAND_TYPE = Symbol('band');
  var BAND_GROUP_CELL = 'bandGroupCell';
  var BAND_HEADER_CELL = 'bandHeaderCell';
  var BAND_EMPTY_CELL = 'bandEmptyCell';
  var BAND_DUPLICATE_RENDER = 'bandDuplicateRender';

  var isBandedTableRow = function (tableRow) { return (tableRow.type === TABLE_BAND_TYPE); };
  var isBandedOrHeaderRow = function (tableRow) { return isBandedTableRow(tableRow)
      || tableRow.type === TABLE_HEADING_TYPE; };
  var isNoDataColumn = function (columnType) { return columnType !== TABLE_DATA_TYPE; };
  var getColumnMeta = function (columnName, bands, tableRowLevel, level, title, result) {
      if (level === void 0) { level = 0; }
      if (title === void 0) { title = null; }
      if (result === void 0) { result = null; }
      return bands.reduce(function (acc, column) {
          if (column.columnName === columnName) {
              return __assign({}, acc, { title: title, level: level });
          }
          if (column.children !== undefined) {
              return getColumnMeta(columnName, column.children, tableRowLevel, level + 1, level > tableRowLevel ? title : column.title, acc);
          }
          return acc;
      }, result || { level: level, title: title });
  };
  var getBandComponent = function (_a, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains) {
      var currentTableColumn = _a.tableColumn, tableRow = _a.tableRow, rowSpan = _a.rowSpan;
      if (rowSpan)
          return { type: BAND_DUPLICATE_RENDER, payload: null };
      var maxLevel = tableHeaderRows.filter(function (column) { return column.type === TABLE_BAND_TYPE; }).length + 1;
      var level = tableRow.level;
      var currentRowLevel = level === undefined
          ? maxLevel - 1 : level;
      var currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE
          ? getColumnMeta(currentTableColumn.column.name, columnBands, currentRowLevel)
          : { level: 0, title: '' };
      if (currentColumnMeta.level < currentRowLevel)
          return { type: BAND_EMPTY_CELL, payload: null };
      var currentColumnIndex = tableColumns
          .findIndex(function (column) { return column.key === currentTableColumn.key; });
      var previousTableColumn = tableColumns[currentColumnIndex - 1];
      var beforeBorder = false;
      if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE
          && isNoDataColumn(previousTableColumn.type)) {
          beforeBorder = true;
      }
      if (currentColumnMeta.level === currentRowLevel) {
          return {
              type: BAND_HEADER_CELL,
              payload: __assign({ tableRow: tableHeaderRows.find(function (row) { return row.type === TABLE_HEADING_TYPE; }), rowSpan: maxLevel - currentRowLevel }, beforeBorder && { beforeBorder: beforeBorder }),
          };
      }
      var currentColumnChain = findChainByColumnIndex(tableHeaderColumnChains[currentRowLevel], currentColumnIndex);
      if (currentColumnChain.start < currentColumnIndex) {
          return { type: null, payload: null };
      }
      return {
          type: BAND_GROUP_CELL,
          payload: __assign({ colSpan: currentColumnChain.columns.length, value: currentColumnMeta.title, column: currentColumnMeta }, beforeBorder && { beforeBorder: beforeBorder }),
      };
  };

  var tableRowsWithBands = function (tableHeaderRows, columnBands, tableColumns) {
      var tableDataColumns = tableColumns.filter(function (column) { return column.type === TABLE_DATA_TYPE; });
      var getMaxNestedLevel = function (bands, level, result) {
          if (level === void 0) { level = 0; }
          if (result === void 0) { result = null; }
          return (bands.reduce(function (acc, column) {
              if (column.children !== undefined) {
                  return getMaxNestedLevel(column.children, level + 1, acc);
              }
              var isDataColumn = tableDataColumns.findIndex(function (dataColumn) { return !!dataColumn.column && dataColumn.column.name === column.columnName; }) > -1;
              if (level > acc.level && isDataColumn) {
                  return __assign({}, acc, { level: level });
              }
              return acc;
          }, result || { level: 0 }));
      };
      var tableBandHeaders = Array.from({
          length: getMaxNestedLevel(columnBands, 0).level,
      })
          .map(function (row, index) { return ({
          key: TABLE_BAND_TYPE.toString() + "_" + index,
          type: TABLE_BAND_TYPE,
          level: index,
      }); });
      return __spread$1(tableBandHeaders, tableHeaderRows);
  };
  var tableHeaderColumnChainsWithBands = function (tableHeaderRows, tableColumns, bands) {
      var chains = generateSimpleChains(tableHeaderRows, tableColumns);
      var maxBandRowIndex = tableHeaderRows
          .filter(function (row) { return row.type === TABLE_BAND_TYPE; })
          .length;
      var rawBandChains = chains.slice(0, maxBandRowIndex);
      var currentBand = null;
      var shouldSplitChain = function (chain, column, rowIndex) {
          if (rowIndex > maxBandRowIndex)
              return false;
          var columnName = column.column && column.column.name || '';
          currentBand = getColumnMeta(columnName, bands, rowIndex);
          return !chain
              || chain.bandTitle !== currentBand.title;
      };
      var extendChainProps = function () { return ({
          bandTitle: (currentBand || {}).title,
      }); };
      var bandChains = splitHeaderColumnChains(rawBandChains, tableColumns, shouldSplitChain, extendChainProps);
      return __spread$1(bandChains, chains.slice(maxBandRowIndex));
  };

  var toggleDetailRowExpanded = function (prevExpanded, _a) {
      var rowId = _a.rowId, state = _a.state;
      return toggle(prevExpanded, [rowId], state);
  };

  var TABLE_DETAIL_TYPE = Symbol('detail');

  var isDetailRowExpanded = function (expandedDetailRowIds, rowId) { return expandedDetailRowIds.indexOf(rowId) > -1; };
  var isDetailToggleTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE; };
  var isDetailTableRow = function (tableRow) { return tableRow.type === TABLE_DETAIL_TYPE; };
  var isDetailTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };

  var tableRowsWithExpandedDetail = function (tableRows, expandedDetailRowIds, rowHeight) {
      var result = tableRows;
      expandedDetailRowIds
          .forEach(function (expandedRowId) {
          var rowIndex = result.findIndex(function (tableRow) { return tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId; });
          if (rowIndex === -1)
              return;
          var insertIndex = rowIndex + 1;
          var _a = result[rowIndex], row = _a.row, rowId = _a.rowId;
          result = __spread$1(result.slice(0, insertIndex), [
              {
                  rowId: rowId,
                  row: row,
                  key: TABLE_DETAIL_TYPE.toString() + "_" + rowId,
                  type: TABLE_DETAIL_TYPE,
                  height: rowHeight,
              }
          ], result.slice(insertIndex));
      });
      return result;
  };
  var tableColumnsWithDetail = function (tableColumns, toggleColumnWidth) { return __spread$1([
      { key: TABLE_DETAIL_TYPE.toString(), type: TABLE_DETAIL_TYPE, width: toggleColumnWidth }
  ], tableColumns); };
  var tableDetailCellColSpanGetter = function (getTableCellColSpan) { return function (params) {
      var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
      if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {
          return tableColumns.length;
      }
      return getTableCellColSpan(params);
  }; };

  var TABLE_SELECT_TYPE = Symbol('select');

  var isSelectTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE; };
  var isSelectAllTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE; };

  var tableColumnsWithSelection = function (tableColumns, selectionColumnWidth) { return __spread$1([
      { key: TABLE_SELECT_TYPE.toString(), type: TABLE_SELECT_TYPE, width: selectionColumnWidth }
  ], tableColumns); };

  var TABLE_STUB_TYPE = Symbol('stub');
  var getVisibleBoundaryWithFixed = function (visibleBoundary, items) { return items.reduce(function (acc, item, index) {
      if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {
          acc.push([index, index]);
      }
      return acc;
  }, [visibleBoundary]); };
  var getVisibleBoundary = function (items, viewportStart, viewportSize, getItemSize, offset, itemSize) {
      if (offset === void 0) { offset = 0; }
      if (itemSize === void 0) { itemSize = 0; }
      var start = null;
      var end = null;
      var index = 0;
      var beforePosition = offset * itemSize;
      var noVisibleRowsLoaded = itemSize > 0 &&
          beforePosition + items.length * itemSize < viewportStart ||
          viewportStart < beforePosition;
      if (noVisibleRowsLoaded) {
          beforePosition = viewportStart;
          index = items.length;
          start = Math.round(viewportStart / itemSize) - offset;
          end = start;
      }
      var viewportEnd = viewportStart + viewportSize;
      while (end === null && index < items.length) {
          var item = items[index];
          var afterPosition = beforePosition + getItemSize(item);
          var isVisible = (beforePosition >= viewportStart && beforePosition < viewportEnd)
              || (afterPosition > viewportStart && afterPosition <= viewportEnd)
              || (beforePosition < viewportStart && afterPosition > viewportEnd);
          if (isVisible && start === null) {
              start = index;
          }
          if (!isVisible && start !== null) {
              end = index - 1;
              break;
          }
          index += 1;
          beforePosition = afterPosition;
      }
      if (start !== null && end === null) {
          end = index - 1;
      }
      start = start === null ? 0 : start;
      end = end === null ? 0 : end;
      return [start + offset, end + offset];
  };
  var getRenderBoundary = function (itemsCount, visibleBoundary, overscan) {
      var _a = __read$1(visibleBoundary, 2), start = _a[0], end = _a[1];
      start = Math.max(0, start - overscan);
      end = Math.min(itemsCount - 1, end + overscan);
      return [start, end];
  };
  var getColumnBoundaries = function (columns, left, width, getColumnWidth) { return (getVisibleBoundaryWithFixed(getColumnsRenderBoundary(columns.length, getVisibleBoundary(columns, left, width, getColumnWidth, 0)), columns)); };
  var getRowsVisibleBoundary = function (rows, top, height, getRowHeight, offset, rowHeight) {
      var boundaries = getVisibleBoundary(rows, top, height, getRowHeight, offset, rowHeight);
      var start = boundaries[0];
      var end = boundaries[1];
      return {
          start: start,
          end: end,
      };
  };
  var getColumnsRenderBoundary = function (columnCount, visibleBoundary) { return getRenderBoundary(columnCount, visibleBoundary, 1); };
  var getRowsRenderBoundary = function (rowsCount, visibleBoundary) { return getRenderBoundary(rowsCount, visibleBoundary, 3); };
  var getSpanBoundary = function (items, visibleBoundaries, getItemSpan) { return visibleBoundaries
      .map(function (visibleBoundary) {
      var _a = __read$1(visibleBoundary, 2), start = _a[0], end = _a[1];
      for (var index = 0; index <= visibleBoundary[1]; index += 1) {
          var span = getItemSpan(items[index]);
          if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {
              start = index;
          }
          if (index + (span - 1) > visibleBoundary[1]) {
              end = index + (span - 1);
          }
      }
      return [start, end];
  }); };
  var collapseBoundaries = function (itemsCount, visibleBoundaries, spanBoundaries) {
      var breakpoints = new Set([0, itemsCount]);
      spanBoundaries.forEach(function (rowBoundaries) { return rowBoundaries
          .forEach(function (boundary) {
          breakpoints.add(boundary[0]);
          if (boundary[1] - 1 < itemsCount) {
              // next interval starts after span end point
              breakpoints.add(boundary[1] + 1);
          }
      }); });
      visibleBoundaries
          .filter(function (boundary) { return boundary.every(function (bound) { return 0 <= bound && bound < itemsCount; }); })
          .forEach(function (boundary) {
          for (var point = boundary[0]; point <= boundary[1]; point += 1) {
              breakpoints.add(point);
          }
          if (boundary[1] + 1 < itemsCount) {
              // close last visible point
              breakpoints.add(boundary[1] + 1);
          }
      });
      var bp = __spread$1(breakpoints).sort(function (a, b) { return a - b; });
      var bounds = [];
      for (var i = 0; i < bp.length - 1; i += 1) {
          bounds.push([
              bp[i],
              bp[i + 1] - 1,
          ]);
      }
      return bounds;
  };
  var getColumnsSize = function (columns, startIndex, endIndex, getColumnSize) {
      var size = 0;
      for (var i = startIndex; i <= endIndex; i += 1) {
          size += getColumnSize(columns[i], 0) || 0;
      }
      return size;
  };
  var getCollapsedColumns = function (columns, visibleBoundaries, boundaries, getColumnWidth) {
      var collapsedColumns = [];
      boundaries.forEach(function (boundary) {
          var isVisible = visibleBoundaries.reduce(function (acc, visibleBoundary) { return (acc || (visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1])); }, false);
          if (isVisible) {
              var column = columns[boundary[0]];
              collapsedColumns.push(__assign({}, column, { width: getColumnWidth(column) }));
          }
          else {
              collapsedColumns.push({
                  key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                  type: TABLE_STUB_TYPE,
                  width: getColumnsSize(columns, boundary[0], boundary[1], getColumnWidth),
              });
          }
      });
      return collapsedColumns;
  };
  var getCollapsedRows = function (rows, visibleBoundary, boundaries, getRowHeight, getCells, offset) {
      var collapsedRows = [];
      boundaries.forEach(function (boundary) {
          var isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];
          if (isVisible) {
              var row = rows[boundary[0] - offset];
              collapsedRows.push({
                  row: row,
                  cells: getCells(row),
              });
          }
          else {
              var row = {};
              collapsedRows.push({
                  row: {
                      key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                      type: TABLE_STUB_TYPE,
                      height: getColumnsSize(rows, boundary[0], boundary[1], getRowHeight),
                  },
                  cells: getCells(row),
              });
          }
      });
      return collapsedRows;
  };
  var getCollapsedCells = function (columns, spanBoundaries, boundaries, getColSpan) {
      var collapsedCells = [];
      var index = 0;
      var _loop_1 = function () {
          var boundary = boundaries[index];
          var isSpan = spanBoundaries.reduce(function (acc, spanBoundary) { return (acc || (spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1])); }, false);
          if (isSpan) {
              var column = columns[boundary[0]];
              var realColSpan = getColSpan(column);
              var realColSpanEnd_1 = (realColSpan + boundary[0]) - 1;
              var colSpanEnd = boundaries.findIndex(function (colSpanBoundary) { return colSpanBoundary[0]
                  <= realColSpanEnd_1 && realColSpanEnd_1
                  <= colSpanBoundary[1]; });
              collapsedCells.push({
                  column: column,
                  colSpan: (colSpanEnd - index) + 1,
              });
              index += 1;
          }
          else {
              collapsedCells.push({
                  column: {
                      key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                      type: TABLE_STUB_TYPE,
                  },
                  colSpan: 1,
              });
              index += 1;
          }
      };
      while (index < boundaries.length) {
          _loop_1();
      }
      return collapsedCells;
  };
  var getCollapsedGrid = function (_a) {
      var rows = _a.rows, columns = _a.columns, rowsVisibleBoundary = _a.rowsVisibleBoundary, columnsVisibleBoundary = _a.columnsVisibleBoundary, _b = _a.getColumnWidth, getColumnWidth = _b === void 0 ? function (column) { return column.width; } : _b, _c = _a.getRowHeight, getRowHeight = _c === void 0 ? function (row) { return row.height; } : _c, _d = _a.getColSpan, getColSpan = _d === void 0 ? function () { return 1; } : _d, totalRowCount = _a.totalRowCount, offset = _a.offset;
      if (!columns.length) {
          return {
              columns: [],
              rows: [],
          };
      }
      var boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];
      var rowSpanBoundaries = rows
          .slice(boundaries[0], boundaries[1])
          .map(function (row) { return getSpanBoundary(columns, columnsVisibleBoundary, function (column) { return getColSpan(row, column); }); });
      var columnBoundaries = collapseBoundaries(columns.length, columnsVisibleBoundary, rowSpanBoundaries, 0);
      var rowBoundaries = collapseBoundaries(totalRowCount, [boundaries], [], offset);
      return {
          columns: getCollapsedColumns(columns, columnsVisibleBoundary, columnBoundaries, getColumnWidth),
          rows: getCollapsedRows(rows, boundaries, rowBoundaries, getRowHeight, function (row) { return getCollapsedCells(columns, getSpanBoundary(columns, columnsVisibleBoundary, function (column) { return getColSpan(row, column); }), columnBoundaries, function (column) { return getColSpan(row, column); }); }, offset),
      };
  };
  var getColumnWidthGetter = function (tableColumns, tableWidth, minColumnWidth) {
      var colsHavingWidth = tableColumns.filter(function (col) { return col.width !== undefined; });
      var columnsWidth = colsHavingWidth.reduce(function (acc, col) { return (acc + col.width); }, 0);
      var autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);
      var autoColWidth = Math.max(autoWidth, minColumnWidth);
      return function (column) { return (column.type === TABLE_FLEX_TYPE
          ? null
          : column.width || autoColWidth); };
  };
  var getCollapsedGrids = function (_a) {
      var _b = _a.headerRows, headerRows = _b === void 0 ? [] : _b, _c = _a.bodyRows, bodyRows = _c === void 0 ? [] : _c, _d = _a.footerRows, footerRows = _d === void 0 ? [] : _d, columns = _a.columns, loadedRowsStart = _a.loadedRowsStart, totalRowCount = _a.totalRowCount, getCellColSpan = _a.getCellColSpan, viewportLeft = _a.viewportLeft, containerWidth = _a.containerWidth, visibleRowBoundaries = _a.visibleRowBoundaries, getColumnWidth = _a.getColumnWidth, getRowHeight = _a.getRowHeight;
      var getColSpan = function (tableRow, tableColumn) { return getCellColSpan({ tableRow: tableRow, tableColumn: tableColumn, tableColumns: columns }); };
      var columnBoundaries = getColumnBoundaries(columns, viewportLeft, containerWidth, getColumnWidth);
      var getCollapsedGridBlock = function (rows, rowsVisibleBoundary, rowCount, offset) {
          if (rowCount === void 0) { rowCount = rows.length; }
          if (offset === void 0) { offset = 0; }
          return getCollapsedGrid({
              rows: rows,
              columns: columns,
              rowsVisibleBoundary: rowsVisibleBoundary,
              columnsVisibleBoundary: columnBoundaries,
              getColumnWidth: getColumnWidth,
              getRowHeight: getRowHeight,
              getColSpan: getColSpan,
              totalRowCount: rowCount,
              offset: offset,
          });
      };
      var headerGrid = getCollapsedGridBlock(headerRows, getRenderRowBounds(visibleRowBoundaries.header, headerRows.length));
      var bodyGrid = getCollapsedGridBlock(bodyRows, adjustedRenderRowBounds(visibleRowBoundaries.body, bodyRows.length, loadedRowsStart), totalRowCount || 1, loadedRowsStart);
      var footerGrid = getCollapsedGridBlock(footerRows, getRenderRowBounds(visibleRowBoundaries.footer, footerRows.length));
      return {
          headerGrid: headerGrid,
          bodyGrid: bodyGrid,
          footerGrid: footerGrid,
      };
  };
  var getRenderRowBounds = function (visibleBounds, rowCount) { return getRowsRenderBoundary(rowCount, [visibleBounds.start, visibleBounds.end]); };
  var adjustedRenderRowBounds = function (visibleBounds, rowCount, loadedRowsStart) {
      var renderRowBoundaries = getRenderRowBounds(visibleBounds, loadedRowsStart + rowCount);
      var adjustedInterval = intervalUtil.intersect({ start: renderRowBoundaries[0], end: renderRowBoundaries[1] }, { start: loadedRowsStart, end: loadedRowsStart + rowCount });
      return [adjustedInterval.start, adjustedInterval.end];
  };

  var isDataTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isHeaderStubTableCell = function (tableRow, headerRows) { return headerRows.indexOf(tableRow) > -1; };
  var isDataTableRow = function (tableRow) { return tableRow.type === TABLE_DATA_TYPE; };
  var isNoDataTableRow = function (tableRow) { return tableRow.type === TABLE_NODATA_TYPE; };
  var isNoDataTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };
  var isStubTableCell = function (tableRow) { return (tableRow.type === TABLE_STUB_TYPE); };

  var getColumnExtension = function (columnExtensions, columnName) {
      if (!columnExtensions) {
          // tslint:disable-next-line:no-object-literal-type-assertion
          return {};
      }
      var columnExtension = columnExtensions.find(function (extension) { return extension.columnName === columnName; });
      if (!columnExtension) {
          // tslint:disable-next-line:no-object-literal-type-assertion
          return {};
      }
      return columnExtension;
  };
  var getColumnExtensionValueGetter = function (columnExtensions, extensionName, defaultValue) { return function (columnName) {
      if (columnExtensions) {
          var columnExtension = getColumnExtension(columnExtensions, columnName);
          var extensionValue = columnExtension[extensionName];
          return extensionValue !== undefined ? extensionValue : defaultValue;
      }
      return defaultValue;
  }; };

  var tableColumnsWithDataRows = function (columns, columnExtensions) { return columns.map(function (column) {
      var name = column.name;
      var columnExtension = getColumnExtension(columnExtensions, name);
      return {
          column: column,
          key: TABLE_DATA_TYPE.toString() + "_" + name,
          type: TABLE_DATA_TYPE,
          width: columnExtension.width,
          align: columnExtension.align,
          wordWrapEnabled: columnExtension.wordWrapEnabled,
      };
  }); };
  var tableRowsWithDataRows = function (rows, getRowId, isRemoteRowsLoading) { return (!rows.length && !isRemoteRowsLoading
      ? [{ key: TABLE_NODATA_TYPE.toString(), type: TABLE_NODATA_TYPE }]
      : rows.map(function (row, dataIndex) {
          var rowId = getRowId(row);
          return {
              row: row,
              // dataIndex,
              rowId: rowId,
              type: TABLE_DATA_TYPE,
              key: TABLE_DATA_TYPE.toString() + "_" + rowId,
          };
      })); };
  var tableCellColSpanGetter = function (params) {
      var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
      if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {
          return tableColumns.length;
      }
      return 1;
  };

  var visibleTableColumns = function (tableColumns, hiddenColumnNames) { return tableColumns.filter(function (tableColumn) { return tableColumn.type !== TABLE_DATA_TYPE
      || hiddenColumnNames.indexOf(tableColumn.column.name) === -1; }); };

  var tableDataColumnsExist = function (tableColumns) { return tableColumns.some(function (column) { return column.type === TABLE_DATA_TYPE; }); };

  var columnChooserItems = function (columns, hiddenColumnNames) { return columns.map(function (column) { return ({
      column: column,
      hidden: hiddenColumnNames.indexOf(column.name) !== -1,
  }); }); };

  var toggleColumn = function (hiddenColumnNames, columnName) { return (hiddenColumnNames.indexOf(columnName) === -1
      ? __spread$1(hiddenColumnNames, [columnName]) : hiddenColumnNames.filter(function (hiddenColumn) { return hiddenColumn !== columnName; })); };

  var toggleRowExpanded = function (prevExpanded, _a) {
      var rowId = _a.rowId, state = _a.state;
      return toggle(prevExpanded, [rowId], state);
  };

  var GRID_TREE_NODE_TYPE = Symbol('treeNode');

  var customTreeRows = function (currentRow, getChildRows, rootRows, level) {
      if (level === void 0) { level = 0; }
      var childRows = getChildRows(currentRow, rootRows);
      if (!childRows)
          return { rows: [], treeMeta: [], empty: true };
      return childRows
          .reduce(function (acc, row) {
          var _a, _b;
          var nestedResult = customTreeRows(row, getChildRows, rootRows, level + 1);
          (_a = acc.rows).push.apply(_a, __spread$1([row], nestedResult.rows));
          (_b = acc.treeMeta).push.apply(_b, __spread$1([[row, { level: level, leaf: !!nestedResult.empty }]], nestedResult.treeMeta));
          return acc;
      }, { rows: [], treeMeta: [] });
  };
  var customTreeRowsWithMeta = function (rows, getChildRows) {
      var result = customTreeRows(null, getChildRows, rows);
      return {
          rows: result.rows,
          treeMeta: new Map(result.treeMeta),
      };
  };
  var customTreeRowIdGetter = function (getRowId, _a) {
      var rows = _a.rows, treeMeta = _a.treeMeta;
      var firstNestedRowIndex = rows.findIndex(function (row) { return treeMeta.get(row).level > 0; });
      if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {
          return getRowId;
      }
      var map = new Map(rows
          .map(function (row, rowIndex) { return [row, rowIndex]; }));
      return function (row) { return map.get(row); };
  };
  var customTreeRowLevelKeyGetter = function (getRowLevelKey, _a) {
      var treeMeta = _a.treeMeta;
      return function (row) {
          var rowMeta = treeMeta.get(row);
          if (rowMeta !== undefined) {
              return GRID_TREE_NODE_TYPE.toString() + "_" + rowMeta.level;
          }
          return getRowLevelKey && getRowLevelKey();
      };
  };
  var expandedTreeRows = function (_a, getRowId, expandedRowIds) {
      var rows = _a.rows, treeMeta = _a.treeMeta;
      var expandedRowIdsSet = new Set(expandedRowIds);
      var currentExpanded = true;
      var currentLevel = 0;
      var collapsedRowsMeta = new Map();
      var resultRows = [];
      rows.forEach(function (row) {
          var rowMeta = treeMeta.get(row);
          var level = rowMeta && rowMeta.level;
          if (level === undefined && currentExpanded) {
              resultRows.push(row);
          }
          else if (!currentExpanded && (level === undefined || level > currentLevel)) {
              var lastRow = resultRows[resultRows.length - 1];
              var collapsedItems = collapsedRowsMeta.get(lastRow);
              if (!collapsedItems) {
                  collapsedItems = [];
                  collapsedRowsMeta.set(lastRow, collapsedItems);
              }
              collapsedItems.push(row);
          }
          else {
              currentExpanded = expandedRowIdsSet.has(getRowId(row));
              currentLevel = level;
              resultRows.push(row);
          }
      });
      return {
          treeMeta: treeMeta,
          collapsedRowsMeta: collapsedRowsMeta,
          rows: resultRows,
      };
  };
  var collapsedTreeRowsGetter = function (getCollapsedRows, _a) {
      var collapsedRowsMeta = _a.collapsedRowsMeta;
      return function (row) { return collapsedRowsMeta.get(row) || (getCollapsedRows && getCollapsedRows(row)); };
  };
  var isTreeRowLeafGetter = function (_a) {
      var treeMeta = _a.treeMeta;
      return function (row) {
          var rowMeta = treeMeta.get(row);
          return rowMeta && rowMeta.leaf;
      };
  };
  var getTreeRowLevelGetter = function (_a) {
      var treeMeta = _a.treeMeta;
      return function (row) {
          var rowMeta = treeMeta.get(row);
          return (rowMeta && rowMeta.level);
      };
  };
  var unwrappedCustomTreeRows = function (_a) {
      var rows = _a.rows;
      return rows;
  };

  var isTreeTableCell = function (tableRow, tableColumn, forColumnName) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE
      && tableColumn.column.name === forColumnName; };

  var changeSearchValue = function (prevSearchValue, searchValue) { return searchValue; };

  var searchFilterExpression = function (searchValue, columns, filterExpression) {
      var filters = columns.map(function (_a) {
          var name = _a.name;
          return ({ columnName: name, value: searchValue });
      });
      var selfFilterExpression = { filters: filters, operator: 'or' };
      if (!filterExpression) {
          return selfFilterExpression;
      }
      return {
          operator: 'and',
          filters: [filterExpression, selfFilterExpression],
      };
  };

  var getAvailableFilterOperationsGetter = function (getAvailableFilterOperations, availableFilterOperations, columnNames) { return function (columnName) { return (columnNames.indexOf(columnName) > -1 && availableFilterOperations)
      // tslint:disable-next-line: max-line-length
      || (typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName))
      || undefined; }; };

  var FIXED_COLUMN_LEFT_SIDE = 'left';
  var FIXED_COLUMN_RIGHT_SIDE = 'right';
  var TABLE_FIXED_TYPE = Symbol('fixed');

  var getFixedColumnKeys = function (tableColumns, fixedNames) { return tableColumns
      .filter(function (tableColumn) { return ((tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column.name) !== -1)
      || fixedNames.indexOf(tableColumn.type) !== -1); })
      .map(function (_a) {
      var key = _a.key;
      return key;
  }); };
  var isFixedTableRow = function (tableRow) { return tableRow.type === TABLE_FIXED_TYPE; };
  var calculatePosition = function (array, index, tableColumnDimensions) { return (index === 0
      ? 0
      : array
          .slice(0, index)
          .reduce(function (acc, target) { return acc + tableColumnDimensions[target] || 0; }, 0)); };
  var calculateFixedColumnProps = function (_a, _b, tableColumns, tableColumnDimensions, tableHeaderColumnChains) {
      var tableColumn = _a.tableColumn;
      var leftColumns = _b.leftColumns, rightColumns = _b.rightColumns;
      var side = tableColumn.fixed;
      var targetArray = side === FIXED_COLUMN_LEFT_SIDE
          ? getFixedColumnKeys(tableColumns, leftColumns)
          : slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();
      var index = tableColumns.findIndex(function (_a) {
          var key = _a.key;
          return key === tableColumn.key;
      });
      var fixedIndex = targetArray.indexOf(tableColumn.key);
      var columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index);
      var showLeftDivider = columnChain.start === index && index !== 0;
      var showRightDivider = columnChain.start + columnChain.columns.length - 1 === index
          && index < tableColumns.length - 1;
      var position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);
      return {
          showRightDivider: showRightDivider,
          showLeftDivider: showLeftDivider,
          position: position,
          side: side,
      };
  };

  var tableColumnsWithFixed = function (tableColumns, leftColumns, rightColumns) { return tableColumns
      .map(function (tableColumn) {
      var fixed;
      if ((tableColumn.type === TABLE_DATA_TYPE
          && leftColumns.indexOf(tableColumn.column.name) !== -1)
          || leftColumns.indexOf(tableColumn.type) !== -1) {
          fixed = FIXED_COLUMN_LEFT_SIDE;
      }
      if ((tableColumn.type === TABLE_DATA_TYPE
          && rightColumns.indexOf(tableColumn.column.name) !== -1)
          || rightColumns.indexOf(tableColumn.type) !== -1) {
          fixed = FIXED_COLUMN_RIGHT_SIDE;
      }
      return fixed ? __assign({}, tableColumn, { fixed: fixed }) : tableColumn;
  }); };
  var tableHeaderRowsWithFixed = function (tableHeaderRows) { return __spread$1(tableHeaderRows, [
      { key: TABLE_FIXED_TYPE.toString(), type: TABLE_FIXED_TYPE, height: 0 },
  ]); };
  var tableHeaderColumnChainsWithFixed = function (tableHeaderColumnChains, tableHeaderRows, tableColumns) {
      var chains = tableHeaderColumnChains
          || generateSimpleChains(tableHeaderRows, tableColumns);
      var shouldSplitChain = function (currentGroup, column) { return (!currentGroup || currentGroup.fixed !== column.fixed); };
      var extendChainProps = function (column) { return ({
          fixed: column.fixed,
      }); };
      return splitHeaderColumnChains(chains, tableColumns, shouldSplitChain, extendChainProps);
  };

  var defaultSummaryCalculators = {
      count: function (rows) { return rows.length; },
      sum: function (rows, getValue) { return rows.reduce(function (acc, row) { return acc + getValue(row); }, 0); },
      max: function (rows, getValue) { return (rows.length
          ? rows.reduce(function (acc, row) { return Math.max(acc, getValue(row)); }, -Infinity)
          : null); },
      min: function (rows, getValue) { return (rows.length
          ? rows.reduce(function (acc, row) { return Math.min(acc, getValue(row)); }, Infinity)
          : null); },
      avg: function (rows, getValue) { return (rows.length
          ? rows.reduce(function (acc, row) { return acc + getValue(row); }, 0) / rows.length
          : null); },
  };
  var defaultSummaryCalculator = function (type, rows, getValue) {
      var summaryCalculator = defaultSummaryCalculators[type];
      if (!summaryCalculator) {
          throw new Error("The summary type '" + type + "' is not defined");
      }
      return summaryCalculator(rows, getValue);
  };
  var rowsSummary = function (rows, summaryItems, getCellValue, calculator) { return summaryItems
      .reduce(function (acc, _a) {
      var type = _a.type, columnName = _a.columnName;
      var getValue = function (row) { return getCellValue(row, columnName); };
      acc.push(calculator(type, rows, getValue));
      return acc;
  }, []); };
  var totalSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {
      if (calculator === void 0) { calculator = defaultSummaryCalculator; }
      var plainRows = rows.reduce(function (acc, row) {
          if (getRowLevelKey && getRowLevelKey(row)) {
              if (!isGroupRow || !isGroupRow(row)) {
                  acc.push(row);
              }
              var collapsedRows = getCollapsedRows && getCollapsedRows(row);
              if (collapsedRows) {
                  acc.push.apply(acc, __spread$1(collapsedRows));
              }
              return acc;
          }
          acc.push(row);
          return acc;
      }, []);
      return rowsSummary(plainRows, summaryItems, getCellValue, calculator);
  };
  var groupSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, calculator) {
      if (calculator === void 0) { calculator = defaultSummaryCalculator; }
      var levels = [];
      var summaries = {};
      rows.forEach(function (row) {
          var levelKey = getRowLevelKey(row);
          if (!levelKey) {
              levels.forEach(function (level) {
                  level.rows.push(row);
              });
          }
          var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
          if (levelIndex > -1) {
              levels.slice(levelIndex).forEach(function (level) {
                  summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
              });
              levels = levels.slice(0, levelIndex);
          }
          if (isGroupRow(row)) {
              levels.push({
                  levelKey: levelKey,
                  row: row,
                  rows: [],
              });
          }
      }, {});
      levels.forEach(function (level) {
          summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
      });
      return summaries;
  };
  var treeSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator) {
      if (calculator === void 0) { calculator = defaultSummaryCalculator; }
      var levels = [];
      var summaries = {};
      rows.forEach(function (row) {
          var levelKey = getRowLevelKey(row);
          if (!levelKey) {
              levels[levels.length - 1].rows.push(row);
              return;
          }
          var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
          if (levelIndex > -1) {
              levels.slice(levelIndex).forEach(function (level) {
                  if (level.rows.length) {
                      summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
                  }
              });
              levels = levels.slice(0, levelIndex);
          }
          if (!isGroupRow || !isGroupRow(row)) {
              if (levels.length) {
                  levels[levels.length - 1].rows.push(row);
              }
              levels.push({
                  levelKey: levelKey,
                  row: row,
                  rows: [],
              });
          }
      }, {});
      levels.forEach(function (level) {
          if (level.rows.length) {
              summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
          }
      });
      return summaries;
  };

  var TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');
  var TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');
  var TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');

  var tableRowsWithTotalSummaries = function (footerRows) { return __spread$1([
      { key: TABLE_TOTAL_SUMMARY_TYPE.toString(), type: TABLE_TOTAL_SUMMARY_TYPE }
  ], footerRows); };
  var tableRowsWithSummaries = function (tableRows, getRowLevelKey, isGroupRow, getRowId) {
      if (!getRowLevelKey)
          return tableRows;
      var result = [];
      var closeLevel = function (level) {
          if (!level.opened)
              return;
          if (isGroupRow && isGroupRow(level.row)) {
              var compoundKey = level.row.compoundKey;
              result.push({
                  key: TABLE_GROUP_SUMMARY_TYPE.toString() + "_" + compoundKey,
                  type: TABLE_GROUP_SUMMARY_TYPE,
                  row: level.row,
              });
          }
          else {
              var rowId = getRowId(level.row);
              result.push({
                  key: TABLE_TREE_SUMMARY_TYPE.toString() + "_" + rowId,
                  type: TABLE_TREE_SUMMARY_TYPE,
                  row: level.row,
              });
          }
      };
      var levels = [];
      tableRows.forEach(function (tableRow) {
          var row = tableRow.row;
          var levelKey = getRowLevelKey(row);
          if (levelKey) {
              var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
              if (levelIndex > -1) {
                  levels.slice(levelIndex).reverse().forEach(closeLevel);
                  levels = levels.slice(0, levelIndex);
              }
              if (!isGroupRow || !isGroupRow(row)) {
                  levels = levels.map(function (level) { return (__assign({}, level, { opened: true })); });
              }
              levels.push({
                  levelKey: levelKey,
                  row: row,
                  opened: false,
              });
          }
          else {
              levels = levels.map(function (level) { return (__assign({}, level, { opened: true })); });
          }
          result.push(tableRow);
      });
      levels.slice().reverse().forEach(closeLevel);
      return result;
  };

  var isTotalSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isGroupSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isTreeSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isTotalSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TOTAL_SUMMARY_TYPE); };
  var isGroupSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_GROUP_SUMMARY_TYPE); };
  var isTreeSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TREE_SUMMARY_TYPE); };
  var getColumnSummaries = function (summaryItems, columnName, summaryValues) { return summaryItems
      .map(function (item, index) { return [item, index]; })
      .filter(function (_a) {
      var _b = __read$1(_a, 1), item = _b[0];
      return item.columnName === columnName;
  })
      .map(function (_a) {
      var _b = __read$1(_a, 2), item = _b[0], index = _b[1];
      return ({
          type: item.type,
          value: summaryValues[index],
      });
  }); };

  var getTargetColumnGeometries = function (columnGeometries, sourceIndex) {
      var sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;
      var getWidthDifference = function (index) { return columnGeometries[index].right
          - columnGeometries[index].left
          - sourceWidth; };
      return columnGeometries
          .map(function (_a, targetIndex) {
          var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
          var leftBorder = left;
          if (targetIndex > 0 && targetIndex <= sourceIndex) {
              leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));
          }
          if (targetIndex > sourceIndex) {
              leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));
          }
          var rightBorder = right;
          if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {
              rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));
          }
          if (targetIndex < sourceIndex) {
              rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));
          }
          return {
              top: top,
              bottom: bottom,
              right: rightBorder,
              left: leftBorder,
          };
      });
  };

  var getTableColumnGeometries = function (columns, tableWidth) {
      var columnWidths = columns
          .map(function (column) { return column.width; });
      var freeSpace = tableWidth;
      var restrictedSpace = columnWidths
          .reduce(function (accum, width) { return accum + (width || 0); }, 0);
      var freeSpacePortions = columnWidths
          .reduce(function (accum, width) { return accum + (width === undefined ? 1 : 0); }, 0);
      var freeSpacePortion = (freeSpace - restrictedSpace) / freeSpacePortions;
      var lastRightPosition = 0;
      return columnWidths
          .map(function (width) { return (width === undefined ? freeSpacePortion : width); })
          .map(function (width) {
          lastRightPosition += width;
          return {
              left: lastRightPosition - width,
              right: lastRightPosition,
          };
      });
  };
  var getTableTargetColumnIndex = function (columnGeometries, sourceIndex, offset) { return getTargetColumnGeometries(columnGeometries, sourceIndex)
      .findIndex(function (_a) {
      var left = _a.left, right = _a.right;
      return offset > left && offset < right;
  }); };
  var ANIMATION_DURATION = 200;
  var getAnimationProgress = function (animation) { return (new Date().getTime() - animation.startTime) / ANIMATION_DURATION; };
  var getAnimations = function (prevColumns, nextColumns, tableWidth, prevAnimations) {
      var resizing = prevColumns.map(function (column) { return column.key; }).join()
          === nextColumns.map(function (column) { return column.key; }).join();
      var prevColumnGeometries = new Map(getTableColumnGeometries(prevColumns, tableWidth)
          .map(function (geometry, index) { return [prevColumns[index].key, geometry]; })
          .map(function (_a) {
          var _b = __read$1(_a, 2), key = _b[0], geometry = _b[1];
          var animation = prevAnimations.get(key);
          if (!animation)
              return [key, geometry];
          var progress = easeOutCubic(getAnimationProgress(animation));
          var _c = animation.left, to = _c.to, from = _c.from;
          var left = ((to - from) * progress) + from;
          return [key, {
                  left: left,
                  right: geometry.right - (geometry.left - left),
              }];
          // tslint:disable-next-line:array-type
      }));
      var nextColumnGeometries = new Map(getTableColumnGeometries(nextColumns, tableWidth)
          // tslint:disable-next-line:array-type
          .map(function (geometry, index) { return [nextColumns[index].key, geometry]; }));
      return new Map(__spread$1(nextColumnGeometries.keys()).map(function (key) {
          var prev = prevColumnGeometries.get(key);
          var next = nextColumnGeometries.get(key);
          var result = { startTime: new Date().getTime(), style: {} };
          var takePrevColumnIntoAccount = !!prevAnimations.get(key) || (prev && !resizing);
          if (Math.abs((takePrevColumnIntoAccount ? prev.left : next.left) - next.left) > 1) {
              result.left = { from: prev.left, to: next.left };
          }
          return [key, result];
      })
          .filter(function (animation) { return animation[1].left; }));
  };
  var filterActiveAnimations = function (animations) { return new Map(__spread$1(animations.entries()).filter(function (_a) {
      var _b = __read$1(_a, 2), animation = _b[1];
      return getAnimationProgress(animation) < 1;
  })); };
  var evalAnimations = function (animations) { return new Map(__spread$1(animations.entries()).map(function (_a) {
      var _b = __read$1(_a, 2), key = _b[0], animation = _b[1];
      var progress = easeOutCubic(getAnimationProgress(animation));
      var result = __assign({}, animation.style);
      if (animation.left) {
          var offset = (animation.left.to - animation.left.from) * (progress - 1);
          result.transform = "translateX(" + offset + "px)";
      }
      return [key, result];
  })); };

  var isOnTheSameLine = function (geometry, y) { return (y >= geometry.top && y <= geometry.bottom); };
  var rectToObject = function (_a) {
      var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
      return ({
          top: top, right: right, bottom: bottom, left: left,
      });
  };
  var collapseGapsBetweenItems = function (geometries) { return (geometries.map(function (geometry, index) {
      if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {
          return __assign({}, geometry, { right: geometries[index + 1].left });
      }
      return geometry;
  })); };
  var getGroupCellTargetIndex = function (geometries, sourceIndex, _a) {
      var x = _a.x, y = _a.y;
      if (geometries.length === 0)
          return 0;
      var targetGeometries = sourceIndex !== -1
          ? getTargetColumnGeometries(geometries, sourceIndex)
          : geometries.map(rectToObject);
      var targetIndex = collapseGapsBetweenItems(targetGeometries)
          .findIndex(function (geometry, index) {
          var inVerticalBounds = isOnTheSameLine(geometry, y);
          var inHorizontalBounds = x >= geometry.left && x <= geometry.right;
          var shouldGoFirst = index === 0 && x < geometry.left;
          var shouldGoOnLineBreak = !inVerticalBounds
              && !!geometries[index - 1]
              && isOnTheSameLine(geometries[index - 1], y);
          return (inVerticalBounds && inHorizontalBounds)
              || shouldGoFirst
              || shouldGoOnLineBreak;
      });
      return targetIndex === -1 ? geometries.length : targetIndex;
  };

  /** how many rows up and down before next page request */
  var pageTriggersMeta = function (_a, _b) {
      var containerHeight = _a.containerHeight, visibleRowBoundaries = _a.visibleRowBoundaries, estimatedRowHeight = _a.estimatedRowHeight;
      var pageSize = _b.pageSize, virtualRows = _b.virtualRows;
      var loadedCount = virtualRows.rows.length;
      if (loadedCount === 0) {
          return null;
      }
      var loadedRowsStart = virtualRows.skip;
      var topTriggerIndex = loadedRowsStart > 0 ? loadedRowsStart + pageSize : 0;
      var bottomTriggerIndex = loadedRowsStart + loadedCount - pageSize;
      var bodyBoundaries = visibleRowBoundaries.body;
      var firstRowIndex = bodyBoundaries.start;
      var visibleCount = bodyBoundaries.end - bodyBoundaries.start;
      var middleIndex = firstRowIndex + Math.round(visibleCount / 2);
      var middlePosition = visibleRowBoundaries.viewportTop + containerHeight / 2;
      var topTriggerOffset = (middleIndex - topTriggerIndex) * estimatedRowHeight;
      var bottomTriggerOffset = (bottomTriggerIndex - middleIndex) * estimatedRowHeight;
      var topTriggerPosition = middlePosition - topTriggerOffset;
      var bottomTriggerPosition = middlePosition + bottomTriggerOffset;
      return {
          topTriggerIndex: topTriggerIndex,
          topTriggerPosition: topTriggerPosition,
          bottomTriggerIndex: bottomTriggerIndex,
          bottomTriggerPosition: bottomTriggerPosition,
      };
  };

  var getVisibleRowsBounds = function (state, getters, estimatedRowHeight, getRowHeight) {
      var viewportTop = state.viewportTop, containerHeight = state.containerHeight, headerHeight = state.headerHeight, footerHeight = state.footerHeight;
      var loadedRowsStart = getters.loadedRowsStart, bodyRows = getters.bodyRows, _a = getters.headerRows, headerRows = _a === void 0 ? [] : _a, _b = getters.footerRows, footerRows = _b === void 0 ? [] : _b;
      return {
          viewportTop: viewportTop,
          header: getRowsVisibleBoundary(headerRows, 0, headerHeight, getRowHeight, 0, estimatedRowHeight),
          body: getRowsVisibleBoundary(bodyRows, viewportTop, containerHeight - headerHeight - footerHeight, getRowHeight, loadedRowsStart, estimatedRowHeight),
          footer: getRowsVisibleBoundary(footerRows, 0, footerHeight, getRowHeight, 0, estimatedRowHeight),
      };
  };
  var nextPageReferenceIndex = function (payload, getters) {
      var triggersMeta = pageTriggersMeta(payload, getters);
      if (triggersMeta === null) {
          return null;
      }
      var topTriggerPosition = triggersMeta.topTriggerPosition, bottomTriggerPosition = triggersMeta.bottomTriggerPosition, topTriggerIndex = triggersMeta.topTriggerIndex, bottomTriggerIndex = triggersMeta.bottomTriggerIndex;
      var viewportTop = payload.viewportTop, estimatedRowHeight = payload.estimatedRowHeight, containerHeight = payload.containerHeight;
      var referencePosition = viewportTop + containerHeight / 2;
      var getReferenceIndex = function (triggetIndex, triggerPosition) { return (triggetIndex + Math.round((referencePosition - triggerPosition) / estimatedRowHeight)); };
      var referenceIndex = null;
      if (referencePosition < topTriggerPosition) {
          referenceIndex = getReferenceIndex(topTriggerIndex, topTriggerPosition);
      }
      if (bottomTriggerPosition < referencePosition) {
          referenceIndex = getReferenceIndex(bottomTriggerIndex, bottomTriggerPosition);
      }
      return referenceIndex;
  };

  var empty = {
      start: Number.POSITIVE_INFINITY,
      end: Number.NEGATIVE_INFINITY,
  };
  var getRowsInterval = function (r) { return (r === emptyVirtualRows
      ? empty
      : {
          start: r.skip,
          end: r.skip + r.rows.length,
      }); };
  var getLength = function (a) { return a.end - a.start; };
  var intersect = function (a, b) {
      if (a.end < b.start || b.end < a.start) {
          return empty;
      }
      return {
          start: Math.max(a.start, b.start),
          end: Math.min(a.end, b.end),
      };
  };
  var difference = function (a, b) {
      if (empty === intervalUtil.intersect(a, b)) {
          return a;
      }
      if (b.end < a.end) {
          return {
              start: b.end,
              end: a.end,
          };
      }
      if (a.start < b.start) {
          return {
              start: a.start,
              end: b.start,
          };
      }
      return empty;
  };
  var intervalUtil = {
      empty: empty,
      getRowsInterval: getRowsInterval,
      getLength: getLength,
      intersect: intersect,
      difference: difference,
  };

  var emptyVirtualRows = {
      skip: Number.POSITIVE_INFINITY,
      rows: [],
  };
  var pluckSubarray = function (source, sourceStart, left, right) { return (source.slice(left - sourceStart, right - sourceStart)); };
  var mergeRows = function (rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart) {
      var breakpoints = [
          rowsInterval.start, rowsInterval.end,
          cacheInterval.start, cacheInterval.end,
      ]
          .filter(function (i) { return 0 <= i && i < Number.POSITIVE_INFINITY; })
          .sort(function (a, b) { return a - b; });
      var result = [];
      if (breakpoints.length > 1) {
          for (var i = 0; i < breakpoints.length - 1; i += 1) {
              var left = breakpoints[i];
              var right = breakpoints[i + 1];
              var chunk = rowsInterval.start <= left && right <= rowsInterval.end
                  ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority
                  : pluckSubarray(cacheRows, cacheStart, left, right);
              result = result.concat(chunk);
          }
      }
      return {
          skip: breakpoints[0],
          rows: result,
      };
  };
  var calculateRequestedRange = function (loadedInterval, newRange, referenceIndex, pageSize) {
      if (Math.abs(loadedInterval.start - newRange.start) >= 2 * pageSize) {
          var useFirstHalf = referenceIndex % pageSize < pageSize / 2;
          var start = useFirstHalf
              ? newRange.start
              : newRange.start + pageSize;
          var end = Math.min(newRange.end, start + 2 * pageSize);
          return { start: start, end: end };
      }
      return intervalUtil.difference(newRange, loadedInterval);
  };
  var rowToPageIndex = function (rowIndex, pageSize) { return Math.floor(rowIndex / pageSize); };
  var recalculateBounds = function (middleIndex, pageSize, totalCount) {
      var currentPageIndex = rowToPageIndex(middleIndex, pageSize);
      var prevPageIndex = currentPageIndex - 1;
      var nextPageIndex = currentPageIndex + 2;
      var start = Math.max(0, prevPageIndex * pageSize);
      var end = Math.min(nextPageIndex * pageSize, totalCount);
      return {
          start: start,
          end: end,
      };
  };
  var trimRowsToInterval = function (virtualRows, targetInterval) {
      var rowsInterval = intervalUtil.getRowsInterval(virtualRows);
      var intersection = intervalUtil.intersect(rowsInterval, targetInterval);
      if (intervalUtil.empty === intersection) {
          return emptyVirtualRows;
      }
      var rows = pluckSubarray(virtualRows.rows, virtualRows.skip, intersection.start, intersection.end);
      return {
          rows: rows,
          skip: intersection.start,
      };
  };
  var getAvailableRowCount = function (infiniteScroll, newCount, lastCount, totalRowCount) { return (infiniteScroll
      ? Math.max(newCount, lastCount)
      : totalRowCount); };

  var virtualRowsWithCache = function (skip, rows, cache) {
      var rowsInterval = intervalUtil.getRowsInterval({ skip: skip, rows: rows });
      var cacheInterval = intervalUtil.getRowsInterval(cache);
      return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);
  };
  var plainRows = function (virtualRows) { return virtualRows.rows; };
  var loadedRowsStart = function (virtualRows) { return virtualRows.skip; };

  var dxGridCore_es = /*#__PURE__*/Object.freeze({
    BAND_DUPLICATE_RENDER: BAND_DUPLICATE_RENDER,
    BAND_EMPTY_CELL: BAND_EMPTY_CELL,
    BAND_GROUP_CELL: BAND_GROUP_CELL,
    BAND_HEADER_CELL: BAND_HEADER_CELL,
    DEFAULT_FILTER_OPERATIONS: DEFAULT_FILTER_OPERATIONS,
    FIXED_COLUMN_LEFT_SIDE: FIXED_COLUMN_LEFT_SIDE,
    FIXED_COLUMN_RIGHT_SIDE: FIXED_COLUMN_RIGHT_SIDE,
    GROUP_KEY_SEPARATOR: GROUP_KEY_SEPARATOR,
    TABLE_ADDED_TYPE: TABLE_ADDED_TYPE,
    TABLE_BAND_TYPE: TABLE_BAND_TYPE,
    TABLE_DATA_TYPE: TABLE_DATA_TYPE,
    TABLE_DETAIL_TYPE: TABLE_DETAIL_TYPE,
    TABLE_EDIT_COMMAND_TYPE: TABLE_EDIT_COMMAND_TYPE,
    TABLE_EDIT_TYPE: TABLE_EDIT_TYPE,
    TABLE_FILTER_TYPE: TABLE_FILTER_TYPE,
    TABLE_FIXED_TYPE: TABLE_FIXED_TYPE,
    TABLE_FLEX_TYPE: TABLE_FLEX_TYPE,
    TABLE_GROUP_SUMMARY_TYPE: TABLE_GROUP_SUMMARY_TYPE,
    TABLE_GROUP_TYPE: TABLE_GROUP_TYPE,
    TABLE_HEADING_TYPE: TABLE_HEADING_TYPE,
    TABLE_NODATA_TYPE: TABLE_NODATA_TYPE,
    TABLE_REORDERING_TYPE: TABLE_REORDERING_TYPE,
    TABLE_SELECT_TYPE: TABLE_SELECT_TYPE,
    TABLE_STUB_TYPE: TABLE_STUB_TYPE,
    TABLE_TOTAL_SUMMARY_TYPE: TABLE_TOTAL_SUMMARY_TYPE,
    TABLE_TREE_SUMMARY_TYPE: TABLE_TREE_SUMMARY_TYPE,
    addRow: addRow,
    addedRowsByIds: addedRowsByIds,
    adjustSortIndex: adjustSortIndex,
    allSelected: allSelected,
    calculateFixedColumnProps: calculateFixedColumnProps,
    calculateKeepOther: calculateKeepOther,
    calculateRequestedRange: calculateRequestedRange,
    calculateStartPage: calculateStartPage,
    cancelAddedRows: cancelAddedRows,
    cancelChanges: cancelChanges,
    cancelColumnGroupingDraft: cancelColumnGroupingDraft,
    cancelDeletedRows: cancelDeletedRows,
    cancelTableColumnWidthDraft: cancelTableColumnWidthDraft,
    cellValueGetter: cellValueGetter,
    changeAddedRow: changeAddedRow,
    changeColumnFilter: changeColumnFilter,
    changeColumnGrouping: changeColumnGrouping,
    changeColumnOrder: changeColumnOrder,
    changeColumnSorting: changeColumnSorting,
    changeRow: changeRow,
    changeSearchValue: changeSearchValue,
    changeTableColumnWidth: changeTableColumnWidth,
    changedRowsByIds: changedRowsByIds,
    clamp: clamp,
    collapsedTreeRowsGetter: collapsedTreeRowsGetter,
    columnChooserItems: columnChooserItems,
    createRowChangeGetter: createRowChangeGetter,
    currentPage: currentPage,
    customGroupedRows: customGroupedRows,
    customGroupingRowIdGetter: customGroupingRowIdGetter,
    customTreeRowIdGetter: customTreeRowIdGetter,
    customTreeRowLevelKeyGetter: customTreeRowLevelKeyGetter,
    customTreeRowsWithMeta: customTreeRowsWithMeta,
    defaultFilterPredicate: defaultFilterPredicate,
    defaultSummaryCalculator: defaultSummaryCalculator,
    deleteRows: deleteRows,
    draftColumnGrouping: draftColumnGrouping,
    draftOrder: draftOrder,
    draftTableColumnWidth: draftTableColumnWidth,
    emptyVirtualRows: emptyVirtualRows,
    evalAnimations: evalAnimations,
    expandedGroupRows: expandedGroupRows,
    expandedTreeRows: expandedTreeRows,
    filterActiveAnimations: filterActiveAnimations,
    filterExpression: filterExpression,
    filteredCollapsedRowsGetter: filteredCollapsedRowsGetter,
    filteredRows: filteredRows,
    findChainByColumnIndex: findChainByColumnIndex,
    firstRowOnPage: firstRowOnPage,
    generateSimpleChains: generateSimpleChains,
    getAnimations: getAnimations,
    getAvailableFilterOperationsGetter: getAvailableFilterOperationsGetter,
    getAvailableRowCount: getAvailableRowCount,
    getBandComponent: getBandComponent,
    getCollapsedGrid: getCollapsedGrid,
    getCollapsedGrids: getCollapsedGrids,
    getColumnBoundaries: getColumnBoundaries,
    getColumnExtension: getColumnExtension,
    getColumnExtensionValueGetter: getColumnExtensionValueGetter,
    getColumnFilterConfig: getColumnFilterConfig,
    getColumnFilterOperations: getColumnFilterOperations,
    getColumnMeta: getColumnMeta,
    getColumnSortingDirection: getColumnSortingDirection,
    getColumnSummaries: getColumnSummaries,
    getColumnWidthGetter: getColumnWidthGetter,
    getColumnsRenderBoundary: getColumnsRenderBoundary,
    getFixedColumnKeys: getFixedColumnKeys,
    getGroupCellTargetIndex: getGroupCellTargetIndex,
    getPersistentSortedColumns: getPersistentSortedColumns,
    getRowChange: getRowChange,
    getRowsRenderBoundary: getRowsRenderBoundary,
    getRowsVisibleBoundary: getRowsVisibleBoundary,
    getSelectedFilterOperation: getSelectedFilterOperation,
    getTableColumnGeometries: getTableColumnGeometries,
    getTableTargetColumnIndex: getTableTargetColumnIndex,
    getTreeRowLevelGetter: getTreeRowLevelGetter,
    getVisibleRowsBounds: getVisibleRowsBounds,
    groupCollapsedRowsGetter: groupCollapsedRowsGetter,
    groupRowChecker: groupRowChecker,
    groupRowLevelKeyGetter: groupRowLevelKeyGetter,
    groupSummaryValues: groupSummaryValues,
    groupedRows: groupedRows,
    groupingPanelItems: groupingPanelItems,
    intervalUtil: intervalUtil,
    isAddedTableRow: isAddedTableRow,
    isBandedOrHeaderRow: isBandedOrHeaderRow,
    isBandedTableRow: isBandedTableRow,
    isDataTableCell: isDataTableCell,
    isDataTableRow: isDataTableRow,
    isDetailRowExpanded: isDetailRowExpanded,
    isDetailTableCell: isDetailTableCell,
    isDetailTableRow: isDetailTableRow,
    isDetailToggleTableCell: isDetailToggleTableCell,
    isEditCommandsTableCell: isEditCommandsTableCell,
    isEditTableCell: isEditTableCell,
    isEditTableRow: isEditTableRow,
    isFilterTableCell: isFilterTableCell,
    isFilterTableRow: isFilterTableRow,
    isFilterValueEmpty: isFilterValueEmpty,
    isFixedTableRow: isFixedTableRow,
    isGroupIndentTableCell: isGroupIndentTableCell,
    isGroupSummaryTableCell: isGroupSummaryTableCell,
    isGroupSummaryTableRow: isGroupSummaryTableRow,
    isGroupTableCell: isGroupTableCell,
    isGroupTableRow: isGroupTableRow,
    isHeaderStubTableCell: isHeaderStubTableCell,
    isHeadingEditCommandsTableCell: isHeadingEditCommandsTableCell,
    isHeadingTableCell: isHeadingTableCell,
    isHeadingTableRow: isHeadingTableRow,
    isNoDataColumn: isNoDataColumn,
    isNoDataTableCell: isNoDataTableCell,
    isNoDataTableRow: isNoDataTableRow,
    isSelectAllTableCell: isSelectAllTableCell,
    isSelectTableCell: isSelectTableCell,
    isStubTableCell: isStubTableCell,
    isTotalSummaryTableCell: isTotalSummaryTableCell,
    isTotalSummaryTableRow: isTotalSummaryTableRow,
    isTreeRowLeafGetter: isTreeRowLeafGetter,
    isTreeSummaryTableCell: isTreeSummaryTableCell,
    isTreeSummaryTableRow: isTreeSummaryTableRow,
    isTreeTableCell: isTreeTableCell,
    lastRowOnPage: lastRowOnPage,
    loadedRowsStart: loadedRowsStart,
    mergeRows: mergeRows,
    nextPageReferenceIndex: nextPageReferenceIndex,
    orderedColumns: orderedColumns,
    pageCount: pageCount,
    pageTriggersMeta: pageTriggersMeta,
    paginatedRows: paginatedRows,
    plainRows: plainRows,
    recalculateBounds: recalculateBounds,
    rowCount: rowCount,
    rowIdGetter: rowIdGetter,
    rowToPageIndex: rowToPageIndex,
    rowsWithAvailableToSelect: rowsWithAvailableToSelect,
    rowsWithPageHeaders: rowsWithPageHeaders,
    searchFilterExpression: searchFilterExpression,
    setCurrentPage: setCurrentPage,
    setPageSize: setPageSize,
    someSelected: someSelected,
    sortedRows: sortedRows,
    splitHeaderColumnChains: splitHeaderColumnChains,
    startEditRows: startEditRows,
    stopEditRows: stopEditRows,
    tableCellColSpanGetter: tableCellColSpanGetter,
    tableColumnsWithDataRows: tableColumnsWithDataRows,
    tableColumnsWithDetail: tableColumnsWithDetail,
    tableColumnsWithDraftWidths: tableColumnsWithDraftWidths,
    tableColumnsWithEditing: tableColumnsWithEditing,
    tableColumnsWithFixed: tableColumnsWithFixed,
    tableColumnsWithGrouping: tableColumnsWithGrouping,
    tableColumnsWithSelection: tableColumnsWithSelection,
    tableColumnsWithWidths: tableColumnsWithWidths,
    tableDataColumnsExist: tableDataColumnsExist,
    tableDetailCellColSpanGetter: tableDetailCellColSpanGetter,
    tableGroupCellColSpanGetter: tableGroupCellColSpanGetter,
    tableHeaderColumnChainsWithBands: tableHeaderColumnChainsWithBands,
    tableHeaderColumnChainsWithFixed: tableHeaderColumnChainsWithFixed,
    tableHeaderRowsWithFilter: tableHeaderRowsWithFilter,
    tableHeaderRowsWithFixed: tableHeaderRowsWithFixed,
    tableHeaderRowsWithReordering: tableHeaderRowsWithReordering,
    tableRowsWithBands: tableRowsWithBands,
    tableRowsWithDataRows: tableRowsWithDataRows,
    tableRowsWithEditing: tableRowsWithEditing,
    tableRowsWithExpandedDetail: tableRowsWithExpandedDetail,
    tableRowsWithGrouping: tableRowsWithGrouping,
    tableRowsWithHeading: tableRowsWithHeading,
    tableRowsWithSummaries: tableRowsWithSummaries,
    tableRowsWithTotalSummaries: tableRowsWithTotalSummaries,
    toggleColumn: toggleColumn,
    toggleDetailRowExpanded: toggleDetailRowExpanded,
    toggleExpandedGroups: toggleExpandedGroups,
    toggleRowExpanded: toggleRowExpanded,
    toggleSelection: toggleSelection,
    totalSummaryValues: totalSummaryValues,
    treeSummaryValues: treeSummaryValues,
    trimRowsToInterval: trimRowsToInterval,
    unwrapSelectedRows: unwrapSelectedRows,
    unwrappedCustomTreeRows: unwrappedCustomTreeRows,
    unwrappedFilteredRows: unwrappedFilteredRows,
    virtualRowsWithCache: virtualRowsWithCache,
    visibleTableColumns: visibleTableColumns
  });

  /**
   * Bundle of @devexpress/dx-react-core
   * Generated: 2019-05-17
   * Version: 1.11.0
   * License: https://js.devexpress.com/Licensing
   */

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign$1 = function() {
      __assign$1 = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign$1.apply(this, arguments);
  };

  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
              t[p[i]] = s[p[i]];
      return t;
  }

  function __read$2(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spread$2() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read$2(arguments[i]));
      return ar;
  }

  /** @internal */
  var PluginHostContext = react_8(null);
  /** @internal */
  var PositionContext = react_8(function () { return []; });
  /** @internal */
  var TemplateHostContext = react_8(null);

  /** @internal */
  var PluginIndexer = /*#__PURE__*/ (function (_super) {
      __extends(PluginIndexer, _super);
      function PluginIndexer() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.indexes = {};
          _this.memoize = function (index, positionContext) {
              if (_this.indexes[index])
                  return _this.indexes[index];
              var fn = function () {
                  var calculatedPosition = positionContext();
                  return __spread$2(calculatedPosition, [index]);
              };
              _this.indexes[index] = fn;
              return fn;
          };
          return _this;
      }
      PluginIndexer.prototype.render = function () {
          var _this = this;
          var children = this.props.children;
          return (react_9(PositionContext.Consumer, null, function (positionContext) { return (react_1.map(children, function (child, index) {
              if (!child || !child.type)
                  return child;
              var childPosition = _this.memoize(index, positionContext);
              return (react_9(PositionContext.Provider, { key: String(index), value: childPosition }, child));
          })); }));
      };
      return PluginIndexer;
  }(react_4));

  /** @internal */
  var PLUGIN_HOST_CONTEXT = 'dxcore_pluginHost_context';
  /** @internal */
  var POSITION_CONTEXT = 'dxcore_position_context';
  /** @internal */
  var TEMPLATE_HOST_CONTEXT = 'dxcore_templateHost_context';
  /** @internal */
  var RERENDER_TEMPLATE_EVENT = Symbol('rerenderTemplate');
  /** @internal */
  var RERENDER_TEMPLATE_SCOPE_EVENT = Symbol('rerenderTemplateScope');
  /** @internal */
  var UPDATE_CONNECTION_EVENT = Symbol('updateConnection');

  /** @internal */
  var withContext = function (Context, name) { return function (Component) { return function (props) { return (react_9(Context.Consumer, null, function (context) {
      var _a;
      return (react_9(Component, __assign$1({}, props, (_a = {}, _a[name] = context, _a))));
  })); }; }; };
  /** @internal */
  var withHostAndPosition = function (Component) { return withContext(PluginHostContext, PLUGIN_HOST_CONTEXT)(withContext(PositionContext, POSITION_CONTEXT)(Component)); };

  /** @internal */
  var PluginBase = /*#__PURE__*/ (function (_super) {
      __extends(PluginBase, _super);
      function PluginBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      PluginBase.prototype.componentDidMount = function () {
          var _a = this.props, _b = PLUGIN_HOST_CONTEXT, pluginHost = _a[_b], _c = POSITION_CONTEXT, position = _a[_c];
          var _d = this.props, name = _d.name, dependencies = _d.dependencies;
          this.plugin = {
              position: position,
              name: name,
              dependencies: dependencies,
              container: true,
          };
          pluginHost.registerPlugin(this.plugin);
      };
      PluginBase.prototype.componentDidUpdate = function () {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = this.props[_a];
          pluginHost.ensureDependencies();
      };
      PluginBase.prototype.componentWillUnmount = function () {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = this.props[_a];
          pluginHost.unregisterPlugin(this.plugin);
      };
      PluginBase.prototype.render = function () {
          var children = this.props.children;
          return (react_9(PluginIndexer, null, children));
      };
      return PluginBase;
  }(react_4));
  var Plugin = withHostAndPosition(PluginBase);

  var getRenderingData = function (props) {
      var name = props.name, params = props.params;
      if (name) {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = props[_a];
          return {
              params: params,
              templates: pluginHost.collect(name + "Template")
                  .filter(function (template) { return template.predicate(params); })
                  .reverse(),
          };
      }
      var _b = TEMPLATE_HOST_CONTEXT, templateHost = props[_b];
      return {
          params: params || templateHost.params(),
          templates: templateHost.templates(),
      };
  };
  var TemplatePlaceholderBase = /*#__PURE__*/ (function (_super) {
      __extends(TemplatePlaceholderBase, _super);
      function TemplatePlaceholderBase() {
          var _a;
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.subscription = (_a = {},
              _a[RERENDER_TEMPLATE_EVENT] = function (id) {
                  if (_this.template && _this.template.id === id) {
                      _this.forceUpdate();
                  }
              },
              _a[RERENDER_TEMPLATE_SCOPE_EVENT] = function (name) {
                  var propsName = _this.props.name;
                  if (propsName === name) {
                      _this.forceUpdate();
                  }
              },
              _a);
          _this.template = null;
          _this.params = {};
          return _this;
      }
      TemplatePlaceholderBase.prototype.componentDidMount = function () {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = this.props[_a];
          pluginHost.registerSubscription(this.subscription);
      };
      TemplatePlaceholderBase.prototype.shouldComponentUpdate = function (nextProps) {
          var _a = getRenderingData(nextProps), params = _a.params, templates = _a.templates;
          var children = this.props.children;
          var _b = __read$2(templates, 1), template = _b[0];
          return children !== nextProps.children || this.template !== template
              || !shallowEqual$1(this.params, params);
      };
      TemplatePlaceholderBase.prototype.componentWillUnmount = function () {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = this.props[_a];
          pluginHost.unregisterSubscription(this.subscription);
      };
      TemplatePlaceholderBase.prototype.render = function () {
          var _this = this;
          var _a;
          var _b = getRenderingData(this.props), params = _b.params, templates = _b.templates;
          this.params = params;
          _a = __read$2(templates, 1), this.template = _a[0];
          var restTemplates = templates.slice(1);
          var content = null;
          if (this.template) {
              var templateContent = this.template.children;
              content = templateContent() || null;
              if (content && typeof content === 'function') {
                  content = content(params);
              }
          }
          var templatePlaceholder = this.props.children;
          return (react_9(TemplateHostContext.Provider, { value: {
                  templates: function () { return restTemplates; },
                  params: function () { return _this.params; },
              } }, templatePlaceholder ? templatePlaceholder(content) : content));
      };
      return TemplatePlaceholderBase;
  }(react_2));
  /** A React component to which a related Template is rendered. */
  var TemplatePlaceholder = withContext(PluginHostContext, PLUGIN_HOST_CONTEXT)(withContext(TemplateHostContext, TEMPLATE_HOST_CONTEXT)(TemplatePlaceholderBase));

  /** @internal */
  var PluginHostBase = /*#__PURE__*/ (function (_super) {
      __extends(PluginHostBase, _super);
      function PluginHostBase(props) {
          var _this = _super.call(this, props) || this;
          _this.host = new PluginHost();
          return _this;
      }
      PluginHostBase.prototype.render = function () {
          var children = this.props.children;
          return (react_9(PluginHostContext.Provider, { value: this.host },
              react_9(PluginIndexer, null, children),
              react_9(TemplatePlaceholder, { name: "root" })));
      };
      return PluginHostBase;
  }(react_4));
  var PluginHost$1 = PluginHostBase;

  /** @internal */
  var getAvailableGetters = function (pluginHost, getGetterValue) {
      if (getGetterValue === void 0) { getGetterValue = function (getterName) { return pluginHost.get(getterName + "Getter"); }; }
      var trackedDependencies = {};
      var getters;
      if (typeof Proxy !== 'undefined') {
          getters = new Proxy({}, {
              get: function (target, prop) {
                  if (typeof prop !== 'string')
                      return undefined;
                  var result = getGetterValue(prop);
                  trackedDependencies[prop] = result;
                  return result;
              },
              getOwnPropertyDescriptor: function (target, prop) {
                  return {
                      configurable: true,
                      enumerable: true,
                      value: this.get(target, prop, undefined),
                  };
              },
              ownKeys: function () {
                  return pluginHost.knownKeys('Getter');
              },
          });
      }
      else {
          getters = pluginHost.knownKeys('Getter')
              .reduce(function (acc, getterName) {
              Object.defineProperty(acc, getterName, {
                  get: function () {
                      var result = getGetterValue(getterName);
                      trackedDependencies[getterName] = result;
                      return result;
                  },
              });
              return acc;
          }, {});
      }
      return { getters: getters, trackedDependencies: trackedDependencies };
  };
  /** @internal */
  var isTrackedDependenciesChanged = function (pluginHost, prevTrackedDependencies, getGetterValue) {
      if (getGetterValue === void 0) { getGetterValue = function (getterName) { return pluginHost.get(getterName + "Getter"); }; }
      var trackedDependencies = Object.keys(prevTrackedDependencies)
          // tslint:disable-next-line: prefer-object-spread
          .reduce(function (acc, getterName) {
          var _a;
          return Object.assign(acc, (_a = {},
              _a[getterName] = getGetterValue(getterName),
              _a));
      }, {});
      return !shallowEqual$1(prevTrackedDependencies, trackedDependencies);
  };
  /** @internal */
  var getAvailableActions = function (pluginHost, getAction) {
      if (getAction === void 0) { getAction = function (actionName) { return pluginHost.collect(actionName + "Action").slice().reverse()[0]; }; }
      var actions;
      if (typeof Proxy !== 'undefined') {
          actions = new Proxy({}, {
              get: function (target, prop) {
                  if (typeof prop !== 'string')
                      return undefined;
                  return getAction(prop);
              },
              getOwnPropertyDescriptor: function (target, prop) {
                  return {
                      configurable: true,
                      enumerable: true,
                      value: this.get(target, prop, undefined),
                  };
              },
              ownKeys: function () {
                  return pluginHost.knownKeys('Action');
              },
          });
      }
      else {
          actions = pluginHost.knownKeys('Action')
              .reduce(function (acc, actionName) {
              Object.defineProperty(acc, actionName, {
                  get: function () { return getAction(actionName); },
              });
              return acc;
          }, {});
      }
      return actions;
  };

  var ActionBase = /*#__PURE__*/ (function (_super) {
      __extends(ActionBase, _super);
      function ActionBase(props) {
          var _a;
          var _this = _super.call(this, props) || this;
          var _b = PLUGIN_HOST_CONTEXT, pluginHost = props[_b], _c = POSITION_CONTEXT, positionContext = props[_c];
          var name = props.name;
          _this.plugin = (_a = {
                  position: function () { return positionContext(); }
              },
              _a[name + "Action"] = function (params) {
                  var action = _this.props.action;
                  var getters = getAvailableGetters(pluginHost, function (getterName) { return pluginHost.get(getterName + "Getter", _this.plugin); }).getters;
                  var nextParams = params;
                  var actions = getAvailableActions(pluginHost, function (actionName) { return (actionName === name
                      ? function (newParams) { nextParams = newParams; }
                      : pluginHost.collect(actionName + "Action", _this.plugin).slice().reverse()[0]); });
                  action(params, getters, actions);
                  var nextAction = pluginHost.collect(name + "Action", _this.plugin).slice().reverse()[0];
                  if (nextAction) {
                      nextAction(nextParams);
                  }
              },
              _a);
          pluginHost.registerPlugin(_this.plugin);
          return _this;
      }
      ActionBase.prototype.componentWillUnmount = function () {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = this.props[_a];
          pluginHost.unregisterPlugin(this.plugin);
      };
      ActionBase.prototype.render = function () {
          return null;
      };
      return ActionBase;
  }(react_4));
  var Action = withHostAndPosition(ActionBase);

  var GetterBase = /*#__PURE__*/ (function (_super) {
      __extends(GetterBase, _super);
      function GetterBase(props) {
          var _a;
          var _this = _super.call(this, props) || this;
          var _b = PLUGIN_HOST_CONTEXT, pluginHost = props[_b], _c = POSITION_CONTEXT, positionContext = props[_c];
          var name = props.name;
          var lastComputed;
          var lastTrackedDependencies = {};
          var lastResult;
          _this.plugin = (_a = {
                  position: function () { return positionContext(); }
              },
              _a[name + "Getter"] = function (original) {
                  var _a = _this.props, value = _a.value, computed = _a.computed;
                  if (computed === undefined)
                      return value;
                  var getGetterValue = function (getterName) { return ((getterName === name)
                      ? original
                      : pluginHost.get(getterName + "Getter", _this.plugin)); };
                  if (computed === lastComputed
                      && !isTrackedDependenciesChanged(pluginHost, lastTrackedDependencies, getGetterValue)) {
                      return lastResult;
                  }
                  var _b = getAvailableGetters(pluginHost, getGetterValue), getters = _b.getters, trackedDependencies = _b.trackedDependencies;
                  var actions = getAvailableActions(pluginHost);
                  lastComputed = computed;
                  lastTrackedDependencies = trackedDependencies;
                  lastResult = computed(getters, actions);
                  return lastResult;
              },
              _a);
          pluginHost.registerPlugin(_this.plugin);
          return _this;
      }
      GetterBase.prototype.componentDidUpdate = function () {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = this.props[_a];
          pluginHost.broadcast(UPDATE_CONNECTION_EVENT);
      };
      GetterBase.prototype.componentWillUnmount = function () {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = this.props[_a];
          pluginHost.unregisterPlugin(this.plugin);
      };
      GetterBase.prototype.render = function () {
          return null;
      };
      return GetterBase;
  }(react_4));
  var Getter = withHostAndPosition(GetterBase);

  var globalTemplateId = 0;
  /** @internal */
  var TemplateBase = /*#__PURE__*/ (function (_super) {
      __extends(TemplateBase, _super);
      function TemplateBase(props) {
          var _a;
          var _this = _super.call(this, props) || this;
          _this.children = function () { return void 0; };
          globalTemplateId += 1;
          _this.id = globalTemplateId;
          var _b = PLUGIN_HOST_CONTEXT, pluginHost = props[_b], _c = POSITION_CONTEXT, positionContext = props[_c];
          var name = props.name, predicate = props.predicate;
          _this.plugin = (_a = {
                  position: function () { return positionContext(); }
              },
              _a[name + "Template"] = {
                  id: _this.id,
                  predicate: function (params) { return (predicate ? predicate(params) : true); },
                  children: function () {
                      var children = _this.props.children;
                      return children;
                  },
              },
              _a);
          pluginHost.registerPlugin(_this.plugin);
          pluginHost.broadcast(RERENDER_TEMPLATE_SCOPE_EVENT, name);
          return _this;
      }
      TemplateBase.prototype.componentDidUpdate = function () {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = this.props[_a];
          pluginHost.broadcast(RERENDER_TEMPLATE_EVENT, this.id);
      };
      TemplateBase.prototype.componentWillUnmount = function () {
          var _a = PLUGIN_HOST_CONTEXT, pluginHost = this.props[_a];
          var name = this.props.name;
          pluginHost.unregisterPlugin(this.plugin);
          pluginHost.broadcast(RERENDER_TEMPLATE_SCOPE_EVENT, name);
      };
      TemplateBase.prototype.render = function () {
          return null;
      };
      return TemplateBase;
  }(react_4));
  /*** A React component that defines a markup that is rendered
   * as the corresponding TemplatePlaceholder.
   */
  var Template = withHostAndPosition(TemplateBase);

  /** @internal */
  var TemplateConnectorBase = /*#__PURE__*/ (function (_super) {
      __extends(TemplateConnectorBase, _super);
      function TemplateConnectorBase(props, context) {
          var _a;
          var _this = _super.call(this, props, context) || this;
          _this.trackedDependencies = {};
          _this.subscription = (_a = {},
              _a[UPDATE_CONNECTION_EVENT] = function () { return _this.updateConnection(); },
              _a);
          return _this;
      }
      TemplateConnectorBase.prototype.componentDidMount = function () {
          var pluginHost = this.context;
          pluginHost.registerSubscription(this.subscription);
      };
      TemplateConnectorBase.prototype.componentWillUnmount = function () {
          var pluginHost = this.context;
          pluginHost.unregisterSubscription(this.subscription);
      };
      TemplateConnectorBase.prototype.updateConnection = function () {
          var pluginHost = this.context;
          if (isTrackedDependenciesChanged(pluginHost, this.trackedDependencies)) {
              this.forceUpdate();
          }
      };
      TemplateConnectorBase.prototype.render = function () {
          var pluginHost = this.context;
          var children = this.props.children;
          var _a = getAvailableGetters(pluginHost), getters = _a.getters, trackedDependencies = _a.trackedDependencies;
          this.trackedDependencies = trackedDependencies;
          var actions = getAvailableActions(pluginHost);
          return children(getters, actions);
      };
      return TemplateConnectorBase;
  }(react_2));
  TemplateConnectorBase.contextType = PluginHostContext;
  /** A React component that provides access to Getters and Actions within a Template. */
  var TemplateConnector = TemplateConnectorBase;

  var TIMEOUT = 180;
  /** @internal */
  var TouchStrategy = /*#__PURE__*/ (function () {
      function TouchStrategy(delegate) {
          this.delegate = delegate;
          this.touchStartTimeout = null;
          this.dragging = false;
      }
      TouchStrategy.prototype.isDragging = function () {
          return this.dragging;
      };
      TouchStrategy.prototype.isWaiting = function () {
          return !!this.touchStartTimeout;
      };
      TouchStrategy.prototype.cancelWaiting = function () {
          clearTimeout(this.touchStartTimeout);
          this.touchStartTimeout = undefined;
      };
      TouchStrategy.prototype.start = function (e) {
          var _this = this;
          var _a = e.touches[0], x = _a.clientX, y = _a.clientY;
          this.touchStartTimeout = setTimeout(function () {
              _this.delegate.onStart({ x: x, y: y });
              _this.dragging = true;
          }, TIMEOUT);
      };
      TouchStrategy.prototype.move = function (e) {
          this.cancelWaiting();
          if (this.dragging) {
              var _a = e.touches[0], clientX = _a.clientX, clientY = _a.clientY;
              e.preventDefault();
              this.delegate.onMove({ x: clientX, y: clientY });
          }
      };
      TouchStrategy.prototype.end = function (e) {
          this.cancelWaiting();
          if (this.dragging) {
              var _a = e.changedTouches[0], clientX = _a.clientX, clientY = _a.clientY;
              this.delegate.onEnd({ x: clientX, y: clientY });
          }
          this.mouseInitialOffset = null;
          this.dragging = false;
      };
      return TouchStrategy;
  }());

  /* globals document:true */
  var gestureCover;
  /** @internal */
  var toggleGestureCover = function (toggle, cursor) {
      var style = {
          pointerEvents: toggle ? 'all' : 'none',
      };
      if (toggle && cursor) {
          style = __assign$1({}, style, { cursor: cursor });
      }
      if (!gestureCover) {
          style = __assign$1({}, style, { position: 'fixed', top: 0, right: 0, left: 0, bottom: 0, opacity: 0, zIndex: 2147483647 });
          gestureCover = document.createElement('div');
          document.body.appendChild(gestureCover);
      }
      Object.keys(style).forEach(function (key) { gestureCover.style[key] = style[key]; });
  };

  /* globals window:true document:true */
  var BOUNDARY = 10;
  var clamp$1 = function (value, min, max) { return Math.max(Math.min(value, max), min); };
  var isBoundExceeded = function (_a, _b) {
      var initialX = _a.x, initialY = _a.y;
      var x = _b.x, y = _b.y;
      return clamp$1(x, initialX - BOUNDARY, initialX + BOUNDARY) !== x
          || clamp$1(y, initialY - BOUNDARY, initialY + BOUNDARY) !== y;
  };
  /** @internal */
  var MouseStrategy = /*#__PURE__*/ (function () {
      function MouseStrategy(delegate) {
          this.delegate = delegate;
          this.mouseInitialOffset = null;
          this.dragging = false;
      }
      MouseStrategy.prototype.isDragging = function () {
          return this.dragging;
      };
      MouseStrategy.prototype.start = function (e) {
          var x = e.clientX, y = e.clientY;
          this.e = e;
          this.mouseInitialOffset = { x: x, y: y };
      };
      MouseStrategy.prototype.move = function (e) {
          var x = e.clientX, y = e.clientY;
          var dragStarted = false;
          if (!this.dragging && this.mouseInitialOffset) {
              if (isBoundExceeded(this.mouseInitialOffset, { x: x, y: y })) {
                  this.delegate.onStart(this.mouseInitialOffset);
                  var selection = window.getSelection && window.getSelection();
                  if (selection && selection.removeAllRanges) {
                      selection.removeAllRanges();
                  }
                  dragStarted = true;
                  this.dragging = true;
              }
          }
          if (this.dragging) {
              e.preventDefault();
              this.delegate.onMove({ x: x, y: y });
          }
          if (dragStarted) {
              var cursor = window.getComputedStyle(document.elementFromPoint(x, y)).cursor;
              toggleGestureCover(true, cursor);
          }
      };
      MouseStrategy.prototype.end = function (e) {
          if (this.dragging) {
              var x = e.clientX, y = e.clientY;
              toggleGestureCover(false);
              this.delegate.onEnd({ x: x, y: y });
          }
          this.mouseInitialOffset = null;
          this.dragging = false;
      };
      return MouseStrategy;
  }());

  /* globals window:true */
  var eventEmitter;
  /** @internal */
  var getSharedEventEmitter = function () {
      if (!eventEmitter) {
          eventEmitter = new EventEmitter();
          ['mousemove', 'mouseup', 'touchmove', 'touchend', 'touchcancel']
              .forEach(function (name) { return window.addEventListener(name, function (e) { return eventEmitter.emit([name, e]); }, { passive: false }); });
      }
      return eventEmitter;
  };

  /* globals document:true window:true */
  /** @internal */
  var clear = function () {
      var selection = window.getSelection && window.getSelection();
      if (selection) {
          if (selection.empty) {
              selection.empty();
          }
          else if (selection.removeAllRanges) {
              selection.removeAllRanges();
          }
      }
  };

  var draggingHandled = Symbol('draggingHandled');
  /** @internal */
  var Draggable = /*#__PURE__*/ (function (_super) {
      __extends(Draggable, _super);
      function Draggable(props, context) {
          var _this = _super.call(this, props, context) || this;
          var delegate = {
              onStart: function (_a) {
                  var x = _a.x, y = _a.y;
                  var onStart = _this.props.onStart;
                  if (!onStart)
                      return;
                  reactDom_7(function () {
                      onStart({ x: x, y: y });
                  });
              },
              onMove: function (_a) {
                  var x = _a.x, y = _a.y;
                  var onUpdate = _this.props.onUpdate;
                  if (!onUpdate)
                      return;
                  reactDom_7(function () {
                      onUpdate({ x: x, y: y });
                  });
              },
              onEnd: function (_a) {
                  var x = _a.x, y = _a.y;
                  var onEnd = _this.props.onEnd;
                  if (!onEnd)
                      return;
                  reactDom_7(function () {
                      onEnd({ x: x, y: y });
                  });
              },
          };
          _this.mouseStrategy = new MouseStrategy(delegate);
          _this.touchStrategy = new TouchStrategy(delegate);
          _this.mouseDownListener = _this.mouseDownListener.bind(_this);
          _this.touchStartListener = _this.touchStartListener.bind(_this);
          _this.globalListener = _this.globalListener.bind(_this);
          return _this;
      }
      Draggable.prototype.componentDidMount = function () {
          getSharedEventEmitter().subscribe(this.globalListener);
          this.setupNodeSubscription();
      };
      Draggable.prototype.shouldComponentUpdate = function (nextProps) {
          var children = this.props.children;
          return nextProps.children !== children;
      };
      Draggable.prototype.componentDidUpdate = function () {
          this.setupNodeSubscription();
      };
      Draggable.prototype.componentWillUnmount = function () {
          getSharedEventEmitter().unsubscribe(this.globalListener);
      };
      Draggable.prototype.setupNodeSubscription = function () {
          var node = reactDom_2(this);
          if (!node)
              return;
          node.removeEventListener('mousedown', this.mouseDownListener);
          node.removeEventListener('touchstart', this.touchStartListener);
          node.addEventListener('mousedown', this.mouseDownListener, { passive: true });
          node.addEventListener('touchstart', this.touchStartListener, { passive: true });
      };
      Draggable.prototype.mouseDownListener = function (e) {
          if (this.touchStrategy.isWaiting() || e[draggingHandled])
              return;
          this.mouseStrategy.start(e);
          e[draggingHandled] = true;
      };
      Draggable.prototype.touchStartListener = function (e) {
          if (e[draggingHandled])
              return;
          this.touchStrategy.start(e);
          e[draggingHandled] = true;
      };
      Draggable.prototype.globalListener = function (_a) {
          var _b = __read$2(_a, 2), name = _b[0], e = _b[1];
          switch (name) {
              case 'mousemove':
                  this.mouseStrategy.move(e);
                  break;
              case 'mouseup':
                  this.mouseStrategy.end(e);
                  break;
              case 'touchmove': {
                  this.touchStrategy.move(e);
                  break;
              }
              case 'touchend':
              case 'touchcancel': {
                  this.touchStrategy.end(e);
                  break;
              }
              default:
                  break;
          }
          if (this.mouseStrategy.isDragging() || this.touchStrategy.isDragging()) {
              clear();
          }
      };
      Draggable.prototype.render = function () {
          var children = this.props.children;
          return children;
      };
      return Draggable;
  }(react_2));

  /** @internal */
  var DragDropContext = react_8(null);

  /** @internal */
  var DragDropProviderCore = /*#__PURE__*/ (function () {
      function DragDropProviderCore() {
          this.payload = null;
          this.dragEmitter = new EventEmitter();
      }
      DragDropProviderCore.prototype.start = function (payload, clientOffset) {
          this.payload = payload;
          this.dragEmitter.emit({ clientOffset: clientOffset, payload: this.payload });
      };
      DragDropProviderCore.prototype.update = function (clientOffset) {
          this.dragEmitter.emit({ clientOffset: clientOffset, payload: this.payload });
      };
      DragDropProviderCore.prototype.end = function (clientOffset) {
          this.dragEmitter.emit({ clientOffset: clientOffset, payload: this.payload, end: true });
          this.payload = null;
      };
      return DragDropProviderCore;
  }());
  var defaultProps = {
      onChange: function (_a) {
          var payload = _a.payload, clientOffset = _a.clientOffset;
      },
  };
  /** @internal */
  // tslint:disable-next-line: max-classes-per-file
  var DragDropProvider = /*#__PURE__*/ (function (_super) {
      __extends(DragDropProvider, _super);
      function DragDropProvider(props) {
          var _this = _super.call(this, props) || this;
          var onChange = _this.props.onChange;
          _this.dragDropProvider = new DragDropProviderCore();
          _this.dragDropProvider.dragEmitter.subscribe(function (_a) {
              var payload = _a.payload, clientOffset = _a.clientOffset, end = _a.end;
              onChange({
                  payload: end ? null : payload,
                  clientOffset: end ? null : clientOffset,
              });
          });
          return _this;
      }
      DragDropProvider.prototype.shouldComponentUpdate = function (nextProps) {
          var children = this.props.children;
          return nextProps.children !== children;
      };
      DragDropProvider.prototype.render = function () {
          var children = this.props.children;
          return (react_9(DragDropContext.Provider, { value: this.dragDropProvider }, children));
      };
      DragDropProvider.defaultProps = defaultProps;
      return DragDropProvider;
  }(react_2));

  var defaultProps$1 = {
      onStart: function (_a) {
          var clientOffset = _a.clientOffset;
      },
      onUpdate: function (_a) {
          var clientOffset = _a.clientOffset;
      },
      onEnd: function (_a) {
          var clientOffset = _a.clientOffset;
      },
  };
  /** @internal */
  var DragSource = /*#__PURE__*/ (function (_super) {
      __extends(DragSource, _super);
      function DragSource() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      DragSource.prototype.shouldComponentUpdate = function (nextProps) {
          var children = this.props.children;
          return nextProps.children !== children;
      };
      DragSource.prototype.render = function () {
          var dragDropProvider = this.context;
          var _a = this.props, onStart = _a.onStart, onUpdate = _a.onUpdate, onEnd = _a.onEnd, payload = _a.payload, children = _a.children;
          return (react_9(Draggable, { onStart: function (_a) {
                  var x = _a.x, y = _a.y;
                  dragDropProvider.start(payload, { x: x, y: y });
                  onStart({ clientOffset: { x: x, y: y } });
              }, onUpdate: function (_a) {
                  var x = _a.x, y = _a.y;
                  dragDropProvider.update({ x: x, y: y });
                  onUpdate({ clientOffset: { x: x, y: y } });
              }, onEnd: function (_a) {
                  var x = _a.x, y = _a.y;
                  dragDropProvider.end({ x: x, y: y });
                  onEnd({ clientOffset: { x: x, y: y } });
              } }, children));
      };
      DragSource.defaultProps = defaultProps$1;
      return DragSource;
  }(react_2));
  DragSource.contextType = DragDropContext;

  var clamp$1$1 = function (value, min, max) { return Math.max(Math.min(value, max), min); };
  var defaultProps$2 = {
      onEnter: function (args) { },
      onOver: function (args) { },
      onLeave: function (args) { },
      onDrop: function (args) { },
  };
  /** @internal */
  var DropTarget = /*#__PURE__*/ (function (_super) {
      __extends(DropTarget, _super);
      function DropTarget(props) {
          var _this = _super.call(this, props) || this;
          _this.isOver = false;
          _this.handleDrag = _this.handleDrag.bind(_this);
          return _this;
      }
      DropTarget.prototype.componentDidMount = function () {
          var dragEmitter = this.context.dragEmitter;
          dragEmitter.subscribe(this.handleDrag);
      };
      DropTarget.prototype.shouldComponentUpdate = function (nextProps) {
          var children = this.props.children;
          return nextProps.children !== children;
      };
      DropTarget.prototype.componentWillUnmount = function () {
          var dragEmitter = this.context.dragEmitter;
          dragEmitter.unsubscribe(this.handleDrag);
      };
      DropTarget.prototype.handleDrag = function (_a) {
          var payload = _a.payload, clientOffset = _a.clientOffset, end = _a.end;
          var _b = reactDom_2(this).getBoundingClientRect(), left = _b.left, top = _b.top, right = _b.right, bottom = _b.bottom;
          var _c = this.props, onDrop = _c.onDrop, onEnter = _c.onEnter, onLeave = _c.onLeave, onOver = _c.onOver;
          var isOver = clientOffset
              && clamp$1$1(clientOffset.x, left, right) === clientOffset.x
              && clamp$1$1(clientOffset.y, top, bottom) === clientOffset.y;
          if (!this.isOver && isOver)
              onEnter({ payload: payload, clientOffset: clientOffset });
          if (this.isOver && isOver)
              onOver({ payload: payload, clientOffset: clientOffset });
          if (this.isOver && !isOver)
              onLeave({ payload: payload, clientOffset: clientOffset });
          if (isOver && end)
              onDrop({ payload: payload, clientOffset: clientOffset });
          this.isOver = isOver && !end;
      };
      DropTarget.prototype.render = function () {
          var children = this.props.children;
          return react_1.only(children);
      };
      DropTarget.defaultProps = defaultProps$2;
      return DropTarget;
  }(react_2));
  DropTarget.contextType = DragDropContext;

  /** @internal */
  var RefHolder = /*#__PURE__*/ (function (_super) {
      __extends(RefHolder, _super);
      function RefHolder() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      RefHolder.prototype.render = function () {
          var children = this.props.children;
          return children;
      };
      return RefHolder;
  }(react_4));

  /* globals document:true */
  var styles = {
      root: {
          position: 'relative',
      },
      triggersRoot: {
          position: 'absolute',
          top: 0,
          left: 0,
          height: '100%',
          width: '100%',
          overflow: 'hidden',
          zIndex: -1,
          visibility: 'hidden',
          opacity: 0,
      },
      expandTrigger: {
          position: 'absolute',
          top: 0,
          left: 0,
          height: '100%',
          width: '100%',
          overflow: 'auto',
      },
      contractTrigger: {
          position: 'absolute',
          top: 0,
          left: 0,
          height: '100%',
          width: '100%',
          overflow: 'auto',
          minHeight: '1px',
          minWidth: '1px',
      },
      contractNotifier: {
          position: 'absolute',
          top: 0,
          left: 0,
          width: '200%',
          height: '200%',
      },
  };
  /** @internal */
  var Sizer = /*#__PURE__*/ (function (_super) {
      __extends(Sizer, _super);
      function Sizer(props) {
          var _this = _super.call(this, props) || this;
          _this.setupListeners = _this.setupListeners.bind(_this);
          _this.rootRef = react_11();
          return _this;
      }
      Sizer.prototype.componentDidMount = function () {
          this.createListeners();
          this.setupListeners();
      };
      // There is no need to remove listeners as divs are removed from DOM when component is unmount.
      // But there is a little chance that component unmounting and 'scroll' event happen roughly
      // at the same time so that `setupListeners` is called after component is unmount.
      Sizer.prototype.componentWillUnmount = function () {
          this.expandTrigger.removeEventListener('scroll', this.setupListeners);
          this.contractTrigger.removeEventListener('scroll', this.setupListeners);
      };
      Sizer.prototype.setupListeners = function () {
          var size = { height: this.rootNode.clientHeight, width: this.rootNode.clientWidth };
          this.contractTrigger.scrollTop = size.height;
          this.contractTrigger.scrollLeft = size.width;
          var scrollOffset = 2;
          this.expandNotifier.style.width = size.width + scrollOffset + "px";
          this.expandNotifier.style.height = size.height + scrollOffset + "px";
          this.expandTrigger.scrollTop = scrollOffset;
          this.expandTrigger.scrollLeft = scrollOffset;
          var onSizeChange = this.props.onSizeChange;
          onSizeChange(size);
      };
      Sizer.prototype.createListeners = function () {
          this.rootNode = reactDom_2(this.rootRef.current);
          this.triggersRoot = document.createElement('div');
          Object.assign(this.triggersRoot.style, styles.triggersRoot);
          this.rootNode.appendChild(this.triggersRoot);
          this.expandTrigger = document.createElement('div');
          Object.assign(this.expandTrigger.style, styles.expandTrigger);
          this.expandTrigger.addEventListener('scroll', this.setupListeners);
          this.triggersRoot.appendChild(this.expandTrigger);
          this.expandNotifier = document.createElement('div');
          this.expandTrigger.appendChild(this.expandNotifier);
          this.contractTrigger = document.createElement('div');
          Object.assign(this.contractTrigger.style, styles.contractTrigger);
          this.contractTrigger.addEventListener('scroll', this.setupListeners);
          this.triggersRoot.appendChild(this.contractTrigger);
          this.contractNotifier = document.createElement('div');
          Object.assign(this.contractNotifier.style, styles.contractNotifier);
          this.contractTrigger.appendChild(this.contractNotifier);
      };
      Sizer.prototype.render = function () {
          var _a = this.props, onSizeChange = _a.onSizeChange, Container = _a.containerComponent, style = _a.style, restProps = __rest(_a, ["onSizeChange", "containerComponent", "style"]);
          return (react_9(RefHolder, { ref: this.rootRef },
              react_9(Container // NOTE: should have `position: relative`
              , __assign$1({ style: style ? __assign$1({}, styles.root, style) : styles.root }, restProps))));
      };
      Sizer.defaultProps = {
          containerComponent: 'div',
      };
      return Sizer;
  }(react_4));

  /*** A function that creates a new component that allows you to pass additional properties
   * to the wrapped component.
   */
  var connectProps = function (WrappedComponent, getAdditionalProps) {
      var storedAdditionalProps = getAdditionalProps();
      var components = new Set();
      var RenderComponent = /*#__PURE__*/ (function (_super) {
          __extends(RenderComponent, _super);
          function RenderComponent() {
              return _super !== null && _super.apply(this, arguments) || this;
          }
          RenderComponent.prototype.componentDidMount = function () {
              components.add(this);
          };
          RenderComponent.prototype.componentWillUnmount = function () {
              components.delete(this);
          };
          RenderComponent.prototype.render = function () {
              return react_9(WrappedComponent, __assign$1({}, this.props, storedAdditionalProps));
          };
          return RenderComponent;
      }(react_4));
      RenderComponent.update = function () {
          storedAdditionalProps = getAdditionalProps();
          Array.from(components.values()).forEach(function (component) { return component.forceUpdate(); });
      };
      return RenderComponent;
  };

  /** @internal */
  var createStateHelper = function (component, controlledStateProperties) {
      if (controlledStateProperties === void 0) { controlledStateProperties = {}; }
      var notifyStateChange = function (nextState, state) {
          Object.keys(controlledStateProperties).forEach(function (propertyName) {
              var changeEvent = controlledStateProperties[propertyName]();
              if (changeEvent && nextState[propertyName] !== state[propertyName]) {
                  changeEvent(nextState[propertyName]);
              }
          });
      };
      var lastStateUpdater;
      var initialState = null;
      var lastInitialState = null;
      var applyReducer = function (reduce, payload, callback) {
          var stateUpdater = function (prevState) {
              if (initialState === null) {
                  initialState = prevState;
              }
              var stateChange = reduce(__assign$1({}, prevState), payload);
              var state = __assign$1({}, prevState, stateChange);
              if (typeof callback === 'function') {
                  callback(state, prevState);
              }
              if (stateUpdater === lastStateUpdater) {
                  if (lastInitialState !== initialState) {
                      notifyStateChange(state, initialState);
                      lastInitialState = initialState;
                  }
                  initialState = null;
              }
              return stateChange;
          };
          lastStateUpdater = stateUpdater;
          component.setState(stateUpdater);
      };
      var applyFieldReducer = function (field, reduce, payload) {
          applyReducer(function (state) {
              var _a;
              return (_a = {},
                  _a[field] = reduce(state[field], payload),
                  _a);
          });
      };
      return {
          applyReducer: applyReducer,
          applyFieldReducer: applyFieldReducer,
      };
  };

  var makeBoundComponent = function (Target, components, exposed) {
      var Component = /*#__PURE__*/ (function (_super) {
          __extends(Component, _super);
          function Component() {
              return _super !== null && _super.apply(this, arguments) || this;
          }
          Component.prototype.render = function () {
              return react_9(Target, __assign$1({}, components, this.props));
          };
          return Component;
      }(react_4));
      Component.components = Target.components;
      Object.assign(Component, exposed);
      return Component;
  };
  // type ITargetComponentStatic = new() => ITargetComponent;
  /** @internal */
  var withComponents = function (components) { return function (Target) {
      var props = {};
      var exposed = {};
      var targetComponents = Target.components;
      Object.entries(targetComponents).forEach(function (_a) {
          var _b = __read$2(_a, 2), fieldName = _b[0], componentName = _b[1];
          var component = components[componentName];
          if (component && component !== Target[componentName]) {
              props[fieldName] = component;
          }
          exposed[componentName] = component || Target[componentName];
      });
      return Object.keys(props).length > 0
          ? makeBoundComponent(Target, props, exposed) : Target;
  }; };

  /* globals Element */
  /** @internal */
  var RefType = propTypes_16({
      current: propTypes_9((typeof Element !== 'undefined') ? Element : Object),
  });

  var dxReactCore_es = /*#__PURE__*/Object.freeze({
    Action: Action,
    DragDropProvider: DragDropProvider,
    DragSource: DragSource,
    Draggable: Draggable,
    DropTarget: DropTarget,
    Getter: Getter,
    Plugin: Plugin,
    PluginHost: PluginHost$1,
    RefHolder: RefHolder,
    RefType: RefType,
    Sizer: Sizer,
    Template: Template,
    TemplateConnector: TemplateConnector,
    TemplatePlaceholder: TemplatePlaceholder,
    connectProps: connectProps,
    createStateHelper: createStateHelper,
    withComponents: withComponents
  });

  /**
   * Bundle of @devexpress/dx-react-grid
   * Generated: 2019-05-17
   * Version: 1.11.0
   * License: https://js.devexpress.com/Licensing
   */

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics$1 = function(d, b) {
      extendStatics$1 = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
      return extendStatics$1(d, b);
  };

  function __extends$1(d, b) {
      extendStatics$1(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign$2 = function() {
      __assign$2 = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign$2.apply(this, arguments);
  };

  function __rest$1(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
              t[p[i]] = s[p[i]];
      return t;
  }

  function __read$3(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spread$3() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read$3(arguments[i]));
      return ar;
  }

  var GridCore = /*#__PURE__*/ (function (_super) {
      __extends$1(GridCore, _super);
      function GridCore() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      GridCore.prototype.render = function () {
          var _a = this.props, rows = _a.rows, columns = _a.columns, getRowId = _a.getRowId, getCellValue = _a.getCellValue, Root = _a.rootComponent;
          return (react_9(Plugin, null,
              react_9(Getter, { name: "skip", value: 0 }),
              react_9(Getter, { name: "loadedRowsStart", value: 0 }),
              react_9(Getter, { name: "rows", value: rows }),
              react_9(Getter, { name: "getRowId", value: rowIdGetter(getRowId, rows) }),
              react_9(Getter, { name: "columns", value: columns }),
              react_9(Getter, { name: "getCellValue", value: cellValueGetter(getCellValue, columns) }),
              react_9(Template, { name: "root" },
                  react_9(Root, null,
                      react_9(TemplatePlaceholder, { name: "header" }),
                      react_9(TemplatePlaceholder, { name: "body" }),
                      react_9(TemplatePlaceholder, { name: "footer" })))));
      };
      return GridCore;
  }(react_4));

  var GridBase = function (_a) {
      var rows = _a.rows, columns = _a.columns, getRowId = _a.getRowId, getCellValue = _a.getCellValue, rootComponent = _a.rootComponent, children = _a.children;
      return (react_9(PluginHost$1, null,
          react_9(GridCore, { rows: rows, columns: columns, getRowId: getRowId, getCellValue: getCellValue, rootComponent: rootComponent }),
          children));
  };
  /***
   * The Grid is a root container component designed to process and display data specified via
   * the `rows` property. You can configure columns using the `columns` property. The Grid's
   * functionality  is implemented in several plugins specified as child components.
   * See the plugins concept for details.
   * */
  var Grid = GridBase;

  var pluginDependencies = [
      { name: 'TableColumnVisibility' },
      { name: 'Toolbar' },
  ];
  var ColumnChooserBase = /*#__PURE__*/ (function (_super) {
      __extends$1(ColumnChooserBase, _super);
      function ColumnChooserBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              visible: false,
          };
          _this.handleToggle = _this.handleToggle.bind(_this);
          _this.handleHide = _this.handleHide.bind(_this);
          _this.setButtonRef = _this.setButtonRef.bind(_this);
          return _this;
      }
      ColumnChooserBase.prototype.setButtonRef = function (button) {
          this.button = button;
      };
      ColumnChooserBase.prototype.handleToggle = function () {
          var visible = this.state.visible;
          this.setState({ visible: !visible });
      };
      ColumnChooserBase.prototype.handleHide = function () {
          this.setState({ visible: false });
      };
      ColumnChooserBase.prototype.render = function () {
          var _this = this;
          var _a = this.props, Overlay = _a.overlayComponent, Container = _a.containerComponent, Item = _a.itemComponent, ToggleButton = _a.toggleButtonComponent, messages = _a.messages;
          var getMessage = getMessagesFormatter(messages);
          var visible = this.state.visible;
          return (react_9(Plugin, { name: "ColumnChooser", dependencies: pluginDependencies },
              react_9(Template, { name: "toolbarContent" },
                  react_9(TemplatePlaceholder, null),
                  react_9(TemplateConnector, null, function (_a, _b) {
                      var columns = _a.columns, hiddenColumnNames = _a.hiddenColumnNames, isColumnTogglingEnabled = _a.isColumnTogglingEnabled;
                      var toggleColumnVisibility = _b.toggleColumnVisibility;
                      return (react_9(react_3, null,
                          react_9(ToggleButton, { buttonRef: _this.setButtonRef, onToggle: _this.handleToggle, getMessage: getMessage, active: visible }),
                          react_9(Overlay, { visible: visible, target: _this.button, onHide: _this.handleHide },
                              react_9(Container, null, columnChooserItems(columns, hiddenColumnNames)
                                  .map(function (item) {
                                  var columnName = item.column.name;
                                  var togglingEnabled = isColumnTogglingEnabled(columnName);
                                  return (react_9(Item, { key: columnName, item: item, disabled: !togglingEnabled, onToggle: function () { return toggleColumnVisibility(columnName); } }));
                              })))));
                  }))));
      };
      ColumnChooserBase.defaultProps = {
          messages: {},
      };
      ColumnChooserBase.components = {
          overlayComponent: 'Overlay',
          containerComponent: 'Container',
          itemComponent: 'Item',
          toggleButtonComponent: 'ToggleButton',
      };
      return ColumnChooserBase;
  }(react_4));
  /***
   * The ColumnChooser plugin allows a user to toggle grid columns' visibility at runtime.
   * The column chooser lists columns with checkboxes that control a corresponding
   * column's visibility.
   * */
  var ColumnChooser = ColumnChooserBase;

  var columnExtensionValueGetter = function (columnExtensions, defaultValue) { return (getColumnExtensionValueGetter(columnExtensions, 'filteringEnabled', defaultValue)); };
  var filterExpressionComputed = function (_a) {
      var filters = _a.filters, filterExpressionValue = _a.filterExpression;
      return filterExpression(filters, filterExpressionValue);
  };
  var FilteringStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(FilteringStateBase, _super);
      function FilteringStateBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              filters: props.filters || props.defaultFilters,
          };
          var stateHelper = createStateHelper(_this, {
              filters: function () {
                  var onFiltersChange = _this.props.onFiltersChange;
                  return onFiltersChange;
              },
          });
          _this.changeColumnFilter = stateHelper.applyFieldReducer
              .bind(stateHelper, 'filters', changeColumnFilter);
          return _this;
      }
      // tslint:disable-next-line:member-ordering
      FilteringStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.filters, filters = _a === void 0 ? prevState.filters : _a;
          return {
              filters: filters,
          };
      };
      FilteringStateBase.prototype.render = function () {
          var filters = this.state.filters;
          var _a = this.props, columnExtensions = _a.columnExtensions, columnFilteringEnabled = _a.columnFilteringEnabled;
          return (react_9(Plugin, { name: "FilteringState" },
              react_9(Getter, { name: "filters", value: filters }),
              react_9(Getter, { name: "filterExpression", computed: filterExpressionComputed }),
              react_9(Getter, { name: "isColumnFilteringEnabled", value: columnExtensionValueGetter(columnExtensions, columnFilteringEnabled) }),
              react_9(Action, { name: "changeColumnFilter", action: this.changeColumnFilter })));
      };
      FilteringStateBase.defaultProps = {
          defaultFilters: [],
          columnFilteringEnabled: true,
      };
      return FilteringStateBase;
  }(react_4));
  /** A plugin that manages the filtering state. */
  var FilteringState = FilteringStateBase;

  var pluginDependencies$1 = [
      { name: 'FilteringState', optional: true },
      { name: 'SearchState', optional: true },
  ];
  var getCollapsedRowsComputed = function (_a) {
      var rows = _a.rows;
      return filteredCollapsedRowsGetter(rows);
  };
  var unwrappedRowsComputed = function (_a) {
      var rows = _a.rows;
      return unwrappedFilteredRows(rows);
  };
  var IntegratedFilteringBase = /*#__PURE__*/ (function (_super) {
      __extends$1(IntegratedFilteringBase, _super);
      function IntegratedFilteringBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      IntegratedFilteringBase.prototype.render = function () {
          var columnExtensions = this.props.columnExtensions;
          var getColumnPredicate = function (columnName) { return getColumnExtension(columnExtensions, columnName).predicate; };
          var rowsComputed = function (_a) {
              var rows = _a.rows, filterExpression = _a.filterExpression, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, getCollapsedRows = _a.getCollapsedRows;
              return filteredRows(rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows);
          };
          return (react_9(Plugin, { name: "IntegratedFiltering", dependencies: pluginDependencies$1 },
              react_9(Getter, { name: "rows", computed: rowsComputed }),
              react_9(Getter, { name: "getCollapsedRows", computed: getCollapsedRowsComputed }),
              react_9(Getter, { name: "rows", computed: unwrappedRowsComputed })));
      };
      return IntegratedFilteringBase;
  }(react_4));
  IntegratedFilteringBase.defaultPredicate = defaultFilterPredicate;
  var IntegratedFiltering = IntegratedFilteringBase;

  var columnExtensionValueGetter$1 = function (columnExtensions, defaultValue) { return getColumnExtensionValueGetter(columnExtensions, 'editingEnabled', defaultValue); };
  var EditingStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(EditingStateBase, _super);
      function EditingStateBase(props) {
          var _this = _super.call(this, props) || this;
          var rowChanges = props.rowChanges || props.defaultRowChanges;
          var addedRows = props.addedRows || props.defaultAddedRows;
          var getRowChanges = function () {
              var stateRowChanges = _this.state.rowChanges;
              return stateRowChanges;
          };
          var getAddedRows = function () {
              var stateAddedRows = _this.state.addedRows;
              return stateAddedRows;
          };
          _this.state = {
              addedRows: addedRows,
              rowChanges: rowChanges,
              editingRowIds: props.editingRowIds || props.defaultEditingRowIds,
              deletedRowIds: props.deletedRowIds || props.defaultDeletedRowIds,
          };
          var stateHelper = createStateHelper(_this, {
              editingRowIds: function () {
                  var onEditingRowIdsChange = _this.props.onEditingRowIdsChange;
                  return onEditingRowIdsChange;
              },
              addedRows: function () {
                  var onAddedRowsChange = _this.props.onAddedRowsChange;
                  return onAddedRowsChange;
              },
              rowChanges: function () {
                  var onRowChangesChange = _this.props.onRowChangesChange;
                  return onRowChangesChange;
              },
              deletedRowIds: function () {
                  var onDeletedRowIdsChange = _this.props.onDeletedRowIdsChange;
                  return onDeletedRowIdsChange;
              },
          });
          _this.startEditRows = stateHelper.applyFieldReducer
              .bind(stateHelper, 'editingRowIds', startEditRows);
          _this.stopEditRows = stateHelper.applyFieldReducer
              .bind(stateHelper, 'editingRowIds', stopEditRows);
          _this.changeRow = stateHelper.applyFieldReducer
              .bind(stateHelper, 'rowChanges', changeRow);
          _this.cancelChangedRows = stateHelper.applyFieldReducer
              .bind(stateHelper, 'rowChanges', cancelChanges);
          _this.commitChangedRows = function (_a) {
              var rowIds = _a.rowIds;
              var onCommitChanges = _this.props.onCommitChanges;
              onCommitChanges({
                  changed: changedRowsByIds(getRowChanges(), rowIds),
              });
              _this.cancelChangedRows({ rowIds: rowIds });
          };
          _this.addRow = stateHelper.applyFieldReducer
              .bind(stateHelper, 'addedRows', addRow);
          _this.changeAddedRow = stateHelper.applyFieldReducer
              .bind(stateHelper, 'addedRows', changeAddedRow);
          _this.cancelAddedRows = stateHelper.applyFieldReducer
              .bind(stateHelper, 'addedRows', cancelAddedRows);
          _this.commitAddedRows = function (_a) {
              var rowIds = _a.rowIds;
              var onCommitChanges = _this.props.onCommitChanges;
              onCommitChanges({
                  added: addedRowsByIds(getAddedRows(), rowIds),
              });
              _this.cancelAddedRows({ rowIds: rowIds });
          };
          _this.deleteRows = stateHelper.applyFieldReducer
              .bind(stateHelper, 'deletedRowIds', deleteRows);
          _this.cancelDeletedRows = stateHelper.applyFieldReducer
              .bind(stateHelper, 'deletedRowIds', cancelDeletedRows);
          _this.commitDeletedRows = function (_a) {
              var rowIds = _a.rowIds;
              var onCommitChanges = _this.props.onCommitChanges;
              onCommitChanges({ deleted: rowIds });
              _this.cancelDeletedRows({ rowIds: rowIds });
          };
          return _this;
      }
      EditingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.editingRowIds, editingRowIds = _a === void 0 ? prevState.editingRowIds : _a, _b = nextProps.rowChanges, rowChanges = _b === void 0 ? prevState.rowChanges : _b, _c = nextProps.addedRows, addedRows = _c === void 0 ? prevState.addedRows : _c, _d = nextProps.deletedRowIds, deletedRowIds = _d === void 0 ? prevState.deletedRowIds : _d;
          return {
              editingRowIds: editingRowIds,
              rowChanges: rowChanges,
              addedRows: addedRows,
              deletedRowIds: deletedRowIds,
          };
      };
      EditingStateBase.prototype.render = function () {
          var _a = this.props, createRowChange = _a.createRowChange, columnExtensions = _a.columnExtensions, columnEditingEnabled = _a.columnEditingEnabled;
          var _b = this.state, editingRowIds = _b.editingRowIds, rowChanges = _b.rowChanges, addedRows = _b.addedRows, deletedRowIds = _b.deletedRowIds;
          return (react_9(Plugin, { name: "EditingState" },
              react_9(Getter, { name: "createRowChange", value: createRowChangeGetter(createRowChange, columnExtensions) }),
              react_9(Getter, { name: "editingRowIds", value: editingRowIds }),
              react_9(Action, { name: "startEditRows", action: this.startEditRows }),
              react_9(Action, { name: "stopEditRows", action: this.stopEditRows }),
              react_9(Getter, { name: "rowChanges", value: rowChanges }),
              react_9(Action, { name: "changeRow", action: this.changeRow }),
              react_9(Action, { name: "cancelChangedRows", action: this.cancelChangedRows }),
              react_9(Action, { name: "commitChangedRows", action: this.commitChangedRows }),
              react_9(Getter, { name: "addedRows", value: addedRows }),
              react_9(Action, { name: "addRow", action: this.addRow }),
              react_9(Action, { name: "changeAddedRow", action: this.changeAddedRow }),
              react_9(Action, { name: "cancelAddedRows", action: this.cancelAddedRows }),
              react_9(Action, { name: "commitAddedRows", action: this.commitAddedRows }),
              react_9(Getter, { name: "deletedRowIds", value: deletedRowIds }),
              react_9(Action, { name: "deleteRows", action: this.deleteRows }),
              react_9(Action, { name: "cancelDeletedRows", action: this.cancelDeletedRows }),
              react_9(Action, { name: "commitDeletedRows", action: this.commitDeletedRows }),
              react_9(Getter, { name: "isColumnEditingEnabled", value: columnExtensionValueGetter$1(columnExtensions, columnEditingEnabled) })));
      };
      EditingStateBase.defaultProps = {
          columnEditingEnabled: true,
          defaultEditingRowIds: [],
          defaultRowChanges: {},
          defaultAddedRows: [],
          defaultDeletedRowIds: [],
      };
      return EditingStateBase;
  }(react_4));
  /***
   * A plugin that manages grid rows' editing state. It arranges grid rows
   * by different lists depending on a row's state.
   * */
  var EditingState = EditingStateBase;

  var PagingStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(PagingStateBase, _super);
      function PagingStateBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              currentPage: props.currentPage || props.defaultCurrentPage,
              pageSize: props.pageSize !== undefined ? props.pageSize : props.defaultPageSize,
          };
          var stateHelper = createStateHelper(_this, {
              currentPage: function () {
                  var onCurrentPageChange = _this.props.onCurrentPageChange;
                  return onCurrentPageChange;
              },
              pageSize: function () {
                  var onPageSizeChange = _this.props.onPageSizeChange;
                  return onPageSizeChange;
              },
          });
          _this.setCurrentPage = stateHelper.applyFieldReducer
              .bind(stateHelper, 'currentPage', setCurrentPage);
          _this.setPageSize = stateHelper.applyFieldReducer
              .bind(stateHelper, 'pageSize', setPageSize);
          return _this;
      }
      PagingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.currentPage, currentPage = _a === void 0 ? prevState.currentPage : _a, _b = nextProps.pageSize, pageSize = _b === void 0 ? prevState.pageSize : _b;
          return {
              currentPage: currentPage,
              pageSize: pageSize,
          };
      };
      PagingStateBase.prototype.render = function () {
          var _a = this.state, pageSize = _a.pageSize, currentPage = _a.currentPage;
          return (react_9(Plugin, { name: "PagingState" },
              react_9(Getter, { name: "currentPage", value: currentPage }),
              react_9(Getter, { name: "pageSize", value: pageSize }),
              react_9(Action, { name: "setCurrentPage", action: this.setCurrentPage }),
              react_9(Action, { name: "setPageSize", action: this.setPageSize })));
      };
      PagingStateBase.defaultProps = {
          defaultPageSize: 10,
          defaultCurrentPage: 0,
      };
      return PagingStateBase;
  }(react_4));
  /***
   * A plugin that manages the paging state. It controls the total page count depending on the
   * total row count and the specified page size, controls the currently selected page number
   * and changes it in response to the corresponding actions.
   * */
  var PagingState = PagingStateBase;

  var pluginDependencies$2 = [
      { name: 'PagingState' },
  ];
  var rowsWithHeadersComputed = function (_a) {
      var rows = _a.rows, pageSize = _a.pageSize, getRowLevelKey = _a.getRowLevelKey;
      return rowsWithPageHeaders(rows, pageSize, getRowLevelKey);
  };
  var totalCountComputed = function (_a) {
      var rows = _a.rows;
      return rowCount(rows);
  };
  var paginatedRowsComputed = function (_a) {
      var rows = _a.rows, pageSize = _a.pageSize, page = _a.currentPage;
      return paginatedRows(rows, pageSize, page);
  };
  var currentPageComputed = function (_a, _b) {
      var page = _a.currentPage, totalCount = _a.totalCount, pageSize = _a.pageSize;
      var setCurrentPage = _b.setCurrentPage;
      return currentPage(page, totalCount, pageSize, setCurrentPage);
  };
  // eslint-disable-next-line react/prefer-stateless-function
  var IntegratedPagingBase = /*#__PURE__*/ (function (_super) {
      __extends$1(IntegratedPagingBase, _super);
      function IntegratedPagingBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      IntegratedPagingBase.prototype.render = function () {
          return (react_9(Plugin, { name: "IntegratedPaging", dependencies: pluginDependencies$2 },
              react_9(Getter, { name: "rows", computed: rowsWithHeadersComputed }),
              react_9(Getter, { name: "totalCount", computed: totalCountComputed }),
              react_9(Getter, { name: "currentPage", computed: currentPageComputed }),
              react_9(Getter, { name: "rows", computed: paginatedRowsComputed })));
      };
      return IntegratedPagingBase;
  }(react_4));
  /***
   * A plugin that performs built-in data paging. It also changes the current page if the provided
   * one cannot be applied due to fewer available pages.
   * */
  var IntegratedPaging = IntegratedPagingBase;

  var pluginDependencies$3 = [
      { name: 'PagingState' },
  ];
  var CustomPagingBase = /*#__PURE__*/ (function (_super) {
      __extends$1(CustomPagingBase, _super);
      function CustomPagingBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      CustomPagingBase.prototype.render = function () {
          var totalCount = this.props.totalCount;
          return (react_9(Plugin, { name: "CustomPaging", dependencies: pluginDependencies$3 },
              react_9(Getter, { name: "totalCount", value: totalCount })));
      };
      CustomPagingBase.defaultProps = {
          totalCount: 0,
      };
      return CustomPagingBase;
  }(react_4));
  /** A plugin that allows implementing a custom totalCount calculation logic. */
  var CustomPaging = CustomPagingBase;

  var dependencies = [
      { name: 'SortingState', optional: true },
  ];
  var columnExtensionValueGetter$2 = function (columnExtensions, defaultValue) { return getColumnExtensionValueGetter(columnExtensions, 'groupingEnabled', defaultValue); };
  var GroupingStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(GroupingStateBase, _super);
      function GroupingStateBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              grouping: props.grouping || props.defaultGrouping,
              draftGrouping: null,
              expandedGroups: props.expandedGroups || props.defaultExpandedGroups,
          };
          _this.stateHelper = createStateHelper(_this, {
              grouping: function () {
                  var onGroupingChange = _this.props.onGroupingChange;
                  return onGroupingChange;
              },
              expandedGroups: function () {
                  var onExpandedGroupsChange = _this.props.onExpandedGroupsChange;
                  return onExpandedGroupsChange;
              },
          });
          _this.changeColumnGrouping = _this.changeColumnGrouping.bind(_this);
          _this.toggleGroupExpanded = _this.stateHelper.applyReducer
              .bind(_this.stateHelper, toggleExpandedGroups);
          _this.draftColumnGrouping = _this.stateHelper.applyReducer
              .bind(_this.stateHelper, draftColumnGrouping);
          _this.cancelColumnGroupingDraft = _this.stateHelper.applyReducer
              .bind(_this.stateHelper, cancelColumnGroupingDraft);
          _this.changeColumnSorting = _this.changeColumnSorting.bind(_this);
          return _this;
      }
      GroupingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.grouping, grouping = _a === void 0 ? prevState.grouping : _a, _b = nextProps.expandedGroups, expandedGroups = _b === void 0 ? prevState.expandedGroups : _b;
          return {
              grouping: grouping,
              expandedGroups: expandedGroups,
          };
      };
      GroupingStateBase.prototype.changeColumnSorting = function (_a, _b, _c) {
          var sorting = _b.sorting;
          var changeColumnSorting = _c.changeColumnSorting;
          var columnName = _a.columnName, keepOther = _a.keepOther, restParams = __rest$1(_a, ["columnName", "keepOther"]);
          var grouping = this.state.grouping;
          var groupingIndex = grouping
              .findIndex(function (columnGrouping) { return columnGrouping.columnName === columnName; });
          if (groupingIndex === -1) {
              changeColumnSorting(__assign$2({ columnName: columnName, keepOther: keepOther || grouping.map(function (columnGrouping) { return columnGrouping.columnName; }) }, restParams));
              return false;
          }
          var sortIndex = adjustSortIndex(groupingIndex, grouping, sorting);
          changeColumnSorting(__assign$2({ columnName: columnName,
              sortIndex: sortIndex, keepOther: true }, restParams));
          return false;
      };
      GroupingStateBase.prototype.changeColumnGrouping = function (_a, getters, actions) {
          var columnName = _a.columnName, groupIndex = _a.groupIndex;
          this.stateHelper.applyReducer(changeColumnGrouping, { columnName: columnName, groupIndex: groupIndex }, function (nextState, state) {
              var grouping = nextState.grouping;
              var prevGrouping = state.grouping;
              var sorting = getters.sorting;
              var changeColumnSorting = actions.changeColumnSorting;
              if (!sorting)
                  return;
              var columnSortingIndex = sorting
                  .findIndex(function (columnSorting) { return columnSorting.columnName === columnName; });
              var prevGroupingIndex = prevGrouping
                  .findIndex(function (columnGrouping) { return columnGrouping.columnName === columnName; });
              var groupingIndex = grouping
                  .findIndex(function (columnGrouping) { return columnGrouping.columnName === columnName; });
              if (columnSortingIndex === -1
                  || (prevGroupingIndex === prevGrouping.length - 1 && groupingIndex === -1))
                  return;
              var sortIndex = adjustSortIndex(groupingIndex === -1 ? grouping.length : groupingIndex, grouping, sorting);
              if (columnSortingIndex === sortIndex)
                  return;
              changeColumnSorting(__assign$2({ sortIndex: sortIndex, keepOther: true }, sorting[columnSortingIndex]));
          });
      };
      GroupingStateBase.prototype.render = function () {
          var _a = this.state, grouping = _a.grouping, draftGrouping = _a.draftGrouping, expandedGroups = _a.expandedGroups;
          var _b = this.props, columnExtensions = _b.columnExtensions, columnGroupingEnabled = _b.columnGroupingEnabled;
          return (react_9(Plugin, { name: "GroupingState", dependencies: dependencies },
              react_9(Getter, { name: "grouping", value: grouping }),
              react_9(Getter, { name: "draftGrouping", value: draftGrouping || grouping }),
              react_9(Getter, { name: "isColumnGroupingEnabled", value: columnExtensionValueGetter$2(columnExtensions, columnGroupingEnabled) }),
              react_9(Action, { name: "changeColumnGrouping", action: this.changeColumnGrouping }),
              react_9(Action, { name: "draftColumnGrouping", action: this.draftColumnGrouping }),
              react_9(Action, { name: "cancelColumnGroupingDraft", action: this.cancelColumnGroupingDraft }),
              react_9(Getter, { name: "expandedGroups", value: expandedGroups }),
              react_9(Action, { name: "toggleGroupExpanded", action: this.toggleGroupExpanded }),
              react_9(Action, { name: "changeColumnSorting", action: this.changeColumnSorting })));
      };
      GroupingStateBase.defaultProps = {
          defaultGrouping: [],
          defaultExpandedGroups: [],
          columnGroupingEnabled: true,
      };
      return GroupingStateBase;
  }(react_4));
  /***
   * A plugin that manages the grouping state. It lists columns used for grouping and stores
   * information about expanded/collapsed groups.
   * */
  var GroupingState = GroupingStateBase;

  var pluginDependencies$4 = [
      { name: 'GroupingState' },
  ];
  var getCollapsedRowsComputed$1 = function (_a) {
      var getCollapsedRows = _a.getCollapsedRows;
      return groupCollapsedRowsGetter(getCollapsedRows);
  };
  var expandedGroupedRowsComputed = function (_a) {
      var rows = _a.rows, grouping = _a.grouping, expandedGroups = _a.expandedGroups;
      return expandedGroupRows(rows, grouping, expandedGroups);
  };
  var IntegratedGroupingBase = /*#__PURE__*/ (function (_super) {
      __extends$1(IntegratedGroupingBase, _super);
      function IntegratedGroupingBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      IntegratedGroupingBase.prototype.render = function () {
          var columnExtensions = this.props.columnExtensions;
          var getColumnCriteria = function (columnName) { return getColumnExtension(columnExtensions, columnName).criteria; };
          var groupedRowsComputed = function (_a) {
              var rows = _a.rows, grouping = _a.grouping, getCellValue = _a.getCellValue;
              return groupedRows(rows, grouping, getCellValue, getColumnCriteria);
          };
          return (react_9(Plugin, { name: "IntegratedGrouping", dependencies: pluginDependencies$4 },
              react_9(Getter, { name: "isGroupRow", value: groupRowChecker }),
              react_9(Getter, { name: "getRowLevelKey", value: groupRowLevelKeyGetter }),
              react_9(Getter, { name: "getCollapsedRows", computed: getCollapsedRowsComputed$1 }),
              react_9(Getter, { name: "rows", computed: groupedRowsComputed }),
              react_9(Getter, { name: "rows", computed: expandedGroupedRowsComputed })));
      };
      return IntegratedGroupingBase;
  }(react_4));
  /* tslint:disable: max-line-length */
  /** A plugin that performs built-in grouping and group expanding/collapsing. */
  var IntegratedGrouping = IntegratedGroupingBase;
  /* tslint:enable: max-line-length */

  var pluginDependencies$5 = [
      { name: 'GroupingState' },
  ];
  var getCollapsedRowsComputed$2 = function (_a) {
      var getCollapsedRows = _a.getCollapsedRows;
      return groupCollapsedRowsGetter(getCollapsedRows);
  };
  var expandedGroupedRowsComputed$1 = function (_a) {
      var rows = _a.rows, grouping = _a.grouping, expandedGroups = _a.expandedGroups;
      return expandedGroupRows(rows, grouping, expandedGroups);
  };
  var getRowIdComputed = function (_a) {
      var getRowId = _a.getRowId, rows = _a.rows;
      return customGroupingRowIdGetter(getRowId, rows);
  };
  var CustomGroupingBase = /*#__PURE__*/ (function (_super) {
      __extends$1(CustomGroupingBase, _super);
      function CustomGroupingBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      CustomGroupingBase.prototype.render = function () {
          var _a = this.props, getChildGroups = _a.getChildGroups, appliedGrouping = _a.grouping, appliedExpandedGroups = _a.expandedGroups;
          var groupedRowsComputed = function (_a) {
              var rows = _a.rows, grouping = _a.grouping;
              return customGroupedRows(rows, grouping, getChildGroups);
          };
          return (react_9(Plugin, { name: "CustomGrouping", dependencies: pluginDependencies$5 },
              appliedGrouping && (react_9(Getter, { name: "grouping", value: appliedGrouping })),
              appliedExpandedGroups && (react_9(Getter, { name: "expandedGroups", value: appliedExpandedGroups })),
              react_9(Getter, { name: "isGroupRow", value: groupRowChecker }),
              react_9(Getter, { name: "getRowLevelKey", value: groupRowLevelKeyGetter }),
              react_9(Getter, { name: "getCollapsedRows", computed: getCollapsedRowsComputed$2 }),
              react_9(Getter, { name: "rows", computed: groupedRowsComputed }),
              react_9(Getter, { name: "getRowId", computed: getRowIdComputed }),
              react_9(Getter, { name: "rows", computed: expandedGroupedRowsComputed$1 })));
      };
      return CustomGroupingBase;
  }(react_4));
  // tslint:disable-next-line: max-line-length
  /** A plugin that converts custom formatted grouped data to a supported format and performs local group expanding/collapsing. */
  var CustomGrouping = CustomGroupingBase;

  var SelectionStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(SelectionStateBase, _super);
      function SelectionStateBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              selection: props.selection || props.defaultSelection,
          };
          var stateHelper = createStateHelper(_this, {
              selection: function () {
                  var onSelectionChange = _this.props.onSelectionChange;
                  return onSelectionChange;
              },
          });
          _this.toggleSelection = stateHelper.applyFieldReducer
              .bind(stateHelper, 'selection', toggleSelection);
          return _this;
      }
      SelectionStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.selection, selection = _a === void 0 ? prevState.selection : _a;
          return {
              selection: selection,
          };
      };
      SelectionStateBase.prototype.render = function () {
          var selection = this.state.selection;
          return (react_9(Plugin, { name: "SelectionState" },
              react_9(Getter, { name: "selection", value: selection }),
              react_9(Action, { name: "toggleSelection", action: this.toggleSelection })));
      };
      SelectionStateBase.defaultProps = {
          defaultSelection: [],
      };
      return SelectionStateBase;
  }(react_4));
  /** A plugin that manages the selection state. */
  var SelectionState$1 = SelectionStateBase;

  var rowsWithAvailableToSelectComputed = function (_a) {
      var rows = _a.rows, getRowId = _a.getRowId, isGroupRow = _a.isGroupRow;
      return rowsWithAvailableToSelect(rows, getRowId, isGroupRow);
  };
  var allSelectedComputed = function (_a) {
      var rows = _a.rows, selection = _a.selection;
      return allSelected(rows, selection);
  };
  var someSelectedComputed = function (_a) {
      var rows = _a.rows, selection = _a.selection;
      return someSelected(rows, selection);
  };
  var selectAllAvailableComputed = function (_a) {
      var availableToSelect = _a.rows.availableToSelect;
      return !!availableToSelect.length;
  };
  var toggleSelectAll = function (state, _a, _b) {
      var availableToSelect = _a.rows.availableToSelect;
      var toggleSelection = _b.toggleSelection;
      toggleSelection({ state: state, rowIds: availableToSelect });
  };
  var unwrapRowsComputed = function (_a) {
      var rows = _a.rows;
      return unwrapSelectedRows(rows);
  };
  var pluginDependencies$6 = [
      { name: 'SelectionState' },
  ];
  // eslint-disable-next-line react/prefer-stateless-function
  var IntegratedSelectionBase = /*#__PURE__*/ (function (_super) {
      __extends$1(IntegratedSelectionBase, _super);
      function IntegratedSelectionBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      IntegratedSelectionBase.prototype.render = function () {
          return (react_9(Plugin, { name: "IntegratedSelection", dependencies: pluginDependencies$6 },
              react_9(Getter, { name: "rows", computed: rowsWithAvailableToSelectComputed }),
              react_9(Getter, { name: "allSelected", computed: allSelectedComputed }),
              react_9(Getter, { name: "someSelected", computed: someSelectedComputed }),
              react_9(Getter, { name: "selectAllAvailable", computed: selectAllAvailableComputed }),
              react_9(Action, { name: "toggleSelectAll", action: toggleSelectAll }),
              react_9(Getter, { name: "rows", computed: unwrapRowsComputed })));
      };
      return IntegratedSelectionBase;
  }(react_4));
  /* tslint:disable: max-line-length */
  /** A plugin that performs built-in selection. */
  var IntegratedSelection = IntegratedSelectionBase;
  /* tslint:enable: max-line-length */

  var columnExtensionValueGetter$3 = function (columnExtensions, defaultValue) { return getColumnExtensionValueGetter(columnExtensions, 'sortingEnabled', defaultValue); };
  var SortingStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(SortingStateBase, _super);
      function SortingStateBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              sorting: props.sorting || props.defaultSorting,
          };
          var stateHelper = createStateHelper(_this, {
              sorting: function () {
                  var onSortingChange = _this.props.onSortingChange;
                  return onSortingChange;
              },
          });
          _this.changeColumnSorting = stateHelper.applyReducer
              .bind(stateHelper, function (prevState, payload) {
              var _a = _this.props.sorting, sorting = _a === void 0 ? prevState.sorting : _a;
              var persistentSortedColumns = getPersistentSortedColumns(sorting, props.columnExtensions);
              var keepOther = calculateKeepOther(prevState.sorting, payload.keepOther, persistentSortedColumns);
              return changeColumnSorting(prevState, __assign$2({}, payload, { keepOther: keepOther }));
          });
          return _this;
      }
      SortingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.sorting, sorting = _a === void 0 ? prevState.sorting : _a;
          return {
              sorting: sorting,
          };
      };
      SortingStateBase.prototype.render = function () {
          var sorting = this.state.sorting;
          var _a = this.props, columnExtensions = _a.columnExtensions, columnSortingEnabled = _a.columnSortingEnabled;
          return (react_9(Plugin, { name: "SortingState" },
              react_9(Getter, { name: "sorting", value: sorting }),
              react_9(Getter, { name: "isColumnSortingEnabled", value: columnExtensionValueGetter$3(columnExtensions, columnSortingEnabled) }),
              react_9(Action, { name: "changeColumnSorting", action: this.changeColumnSorting })));
      };
      SortingStateBase.defaultProps = {
          defaultSorting: [],
          columnSortingEnabled: true,
      };
      return SortingStateBase;
  }(react_4));
  // tslint:disable-next-line: max-line-length
  /** A plugin that manages the sorting state. It controls the list of columns that participate in sorting. */
  var SortingState = SortingStateBase;

  var pluginDependencies$7 = [
      { name: 'SortingState' },
  ];
  var IntegratedSortingBase = /*#__PURE__*/ (function (_super) {
      __extends$1(IntegratedSortingBase, _super);
      function IntegratedSortingBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      IntegratedSortingBase.prototype.render = function () {
          var columnExtensions = this.props.columnExtensions;
          var getColumnCompare = function (columnName) { return getColumnExtension(columnExtensions, columnName).compare; };
          var rowsComputed = function (_a) {
              var rows = _a.rows, sorting = _a.sorting, getCellValue = _a.getCellValue, isGroupRow = _a.isGroupRow, getRowLevelKey = _a.getRowLevelKey;
              return sortedRows(rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey);
          };
          return (react_9(Plugin, { name: "IntegratedSorting", dependencies: pluginDependencies$7 },
              react_9(Getter, { name: "rows", computed: rowsComputed })));
      };
      return IntegratedSortingBase;
  }(react_4));
  /** A plugin that performs built-in data sorting. */
  var IntegratedSorting = IntegratedSortingBase;

  var getTargetColumns = function (payload, columns) { return payload
      .filter(function (item) { return item.type === 'column'; })
      .map(function (item) { return columns.find(function (column) { return column.name === item.columnName; }); }); };
  // tslint:disable-next-line: max-line-length
  var DragDropProviderBase = /*#__PURE__*/ (function (_super) {
      __extends$1(DragDropProviderBase, _super);
      function DragDropProviderBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              payload: null,
              clientOffset: null,
          };
          _this.change = function (_a) {
              var payload = _a.payload, clientOffset = _a.clientOffset;
              return _this.setState({ payload: payload, clientOffset: clientOffset });
          };
          return _this;
      }
      DragDropProviderBase.prototype.render = function () {
          var _a = this.props, Container = _a.containerComponent, Column = _a.columnComponent;
          var _b = this.state, payload = _b.payload, clientOffset = _b.clientOffset;
          return (react_9(Plugin, { name: "DragDropProvider" },
              react_9(Getter, { name: "draggingEnabled", value: true }),
              react_9(Template, { name: "root" },
                  react_9(DragDropProvider, { onChange: this.change },
                      react_9(TemplatePlaceholder, null)),
                  payload && (react_9(TemplateConnector, null, function (_a) {
                      var columns = _a.columns;
                      return (react_9(Container, { clientOffset: clientOffset }, getTargetColumns(payload, columns)
                          .map(function (column) { return (react_9(Column, { key: column.name, column: column })); })));
                  })))));
      };
      DragDropProviderBase.components = {
          containerComponent: 'Container',
          columnComponent: 'Column',
      };
      return DragDropProviderBase;
  }(react_4));
  // tslint:disable-next-line: max-line-length
  /** A plugin that implements the drag-and-drop functionality and visualizes columns that are being dragged. */
  var DragDropProvider$1 = DragDropProviderBase;

  var pluginDependencies$8 = [
      { name: 'Table' },
      { name: 'DragDropProvider', optional: true },
  ];
  var tableHeaderRowsComputed = function (_a) {
      var tableHeaderRows = _a.tableHeaderRows;
      return tableHeaderRowsWithReordering(tableHeaderRows);
  };
  // tslint:disable-next-line: max-line-length
  var TableColumnReorderingRaw = /*#__PURE__*/ (function (_super) {
      __extends$1(TableColumnReorderingRaw, _super);
      function TableColumnReorderingRaw(props) {
          var _this = _super.call(this, props) || this;
          _this.cellDimensionGetters = {};
          _this.cellDimensions = [];
          _this.state = {
              order: props.defaultOrder,
              sourceColumnIndex: -1,
              targetColumnIndex: -1,
          };
          _this.onOver = _this.handleOver.bind(_this);
          _this.onLeave = _this.handleLeave.bind(_this);
          _this.onDrop = _this.handleDrop.bind(_this);
          return _this;
      }
      TableColumnReorderingRaw.prototype.getState = function () {
          var orderState = this.state.order;
          var _a = this.props.order, order = _a === void 0 ? orderState : _a;
          return __assign$2({}, this.state, { order: order });
      };
      TableColumnReorderingRaw.prototype.getDraftOrder = function () {
          var _a = this.getState(), order = _a.order, sourceColumnIndex = _a.sourceColumnIndex, targetColumnIndex = _a.targetColumnIndex;
          return draftOrder(order, sourceColumnIndex, targetColumnIndex);
      };
      TableColumnReorderingRaw.prototype.getAvailableColumns = function () {
          var _this = this;
          return this.getDraftOrder()
              .filter(function (columnName) { return !!_this.cellDimensionGetters[columnName]; });
      };
      TableColumnReorderingRaw.prototype.cacheCellDimensions = function () {
          var _this = this;
          this.cellDimensions = (this.cellDimensions && this.cellDimensions.length)
              ? this.cellDimensions
              : this.getAvailableColumns()
                  .map(function (columnName) { return _this.cellDimensionGetters[columnName](); });
      };
      TableColumnReorderingRaw.prototype.resetCellDimensions = function () {
          this.cellDimensions = [];
      };
      TableColumnReorderingRaw.prototype.ensureCellDimensionGetters = function (tableColumns) {
          var _this = this;
          Object.keys(this.cellDimensionGetters)
              .forEach(function (columnName) {
              var columnIndex = tableColumns
                  .findIndex(function (_a) {
                  var type = _a.type, column = _a.column;
                  return type === TABLE_DATA_TYPE && column.name === columnName;
              });
              if (columnIndex === -1) {
                  delete _this.cellDimensionGetters[columnName];
              }
          });
      };
      // tslint:disable-next-line: max-line-length
      TableColumnReorderingRaw.prototype.storeCellDimensionsGetter = function (tableColumn, getter, tableColumns) {
          if (tableColumn.type === TABLE_DATA_TYPE) {
              this.cellDimensionGetters[tableColumn.column.name] = getter;
          }
          this.ensureCellDimensionGetters(tableColumns);
      };
      TableColumnReorderingRaw.prototype.handleOver = function (_a) {
          var payload = _a.payload, x = _a.clientOffset.x;
          var sourceColumnName = payload[0].columnName;
          var availableColumns = this.getAvailableColumns();
          var relativeSourceColumnIndex = availableColumns.indexOf(sourceColumnName);
          if (relativeSourceColumnIndex === -1)
              return;
          this.cacheCellDimensions();
          var cellDimensions = this.cellDimensions;
          var overlappedColumns = cellDimensions
              .filter(function (_a) {
              var left = _a.left, right = _a.right;
              return left <= x && x <= right;
          });
          if (overlappedColumns.length > 1)
              return;
          var relativeTargetIndex = getTableTargetColumnIndex(cellDimensions, relativeSourceColumnIndex, x);
          if (relativeTargetIndex === -1)
              return;
          var _b = this.getState(), prevSourceColumnIndex = _b.sourceColumnIndex, prevTargetColumnIndex = _b.targetColumnIndex;
          var draftOrder = this.getDraftOrder();
          var targetColumnIndex = draftOrder.indexOf(availableColumns[relativeTargetIndex]);
          if (targetColumnIndex === prevTargetColumnIndex)
              return;
          var sourceColumnIndex = prevSourceColumnIndex === -1
              ? draftOrder.indexOf(sourceColumnName)
              : prevSourceColumnIndex;
          this.setState({
              sourceColumnIndex: sourceColumnIndex,
              targetColumnIndex: targetColumnIndex,
          });
      };
      TableColumnReorderingRaw.prototype.handleLeave = function () {
          this.setState({
              sourceColumnIndex: -1,
              targetColumnIndex: -1,
          });
          this.resetCellDimensions();
      };
      TableColumnReorderingRaw.prototype.handleDrop = function () {
          var _a = this.getState(), sourceColumnIndex = _a.sourceColumnIndex, targetColumnIndex = _a.targetColumnIndex, order = _a.order;
          var onOrderChange = this.props.onOrderChange;
          if (sourceColumnIndex === -1 && targetColumnIndex === -1)
              return;
          var nextOrder = changeColumnOrder(order, {
              sourceColumnName: order[sourceColumnIndex],
              targetColumnName: order[targetColumnIndex],
          });
          this.setState({
              order: nextOrder,
              sourceColumnIndex: -1,
              targetColumnIndex: -1,
          });
          if (onOrderChange) {
              onOrderChange(nextOrder);
          }
          this.resetCellDimensions();
      };
      TableColumnReorderingRaw.prototype.render = function () {
          var _this = this;
          var _a = this.props, Container = _a.tableContainerComponent, Row = _a.rowComponent, Cell = _a.cellComponent;
          var columnsComputed = function (_a) {
              var tableColumns = _a.tableColumns;
              return orderedColumns(tableColumns, _this.getDraftOrder());
          };
          this.cellDimensionGetters = {};
          return (react_9(Plugin, { name: "TableColumnReordering", dependencies: pluginDependencies$8 },
              react_9(Getter, { name: "tableColumns", computed: columnsComputed }),
              react_9(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed }),
              react_9(Template, { name: "table" }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var draggingEnabled = _a.draggingEnabled;
                  return (react_9(Container, __assign$2({}, params, { onOver: _this.onOver, onLeave: _this.onLeave, onDrop: _this.onDrop, draggingEnabled: draggingEnabled }),
                      react_9(TemplatePlaceholder, null)));
              })); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return tableRow.type === TABLE_REORDERING_TYPE;
                  } }, function (params) { return (react_9(Row, __assign$2({}, params))); }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return tableRow.type === TABLE_REORDERING_TYPE;
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var tableColumns = _a.tableColumns;
                  return (react_9(Cell, __assign$2({}, params, { getCellDimensions: function (getter) { return _this.storeCellDimensionsGetter(params.tableColumn, getter, tableColumns); } })));
              })); })));
      };
      TableColumnReorderingRaw.defaultProps = {
          defaultOrder: [],
      };
      TableColumnReorderingRaw.components = {
          tableContainerComponent: 'TableContainer',
          rowComponent: 'Row',
          cellComponent: 'Cell',
      };
      return TableColumnReorderingRaw;
  }(react_4));
  var TableContainer = function (_a) {
      var onOver = _a.onOver, onLeave = _a.onLeave, onDrop = _a.onDrop, children = _a.children, draggingEnabled = _a.draggingEnabled;
      return (draggingEnabled ? (react_9(DropTarget, { onOver: onOver, onLeave: onLeave, onDrop: onDrop }, children)) : children);
  };
  /** A plugin that manages the displayed columns' order. */
  var TableColumnReordering = withComponents({ TableContainer: TableContainer })(TableColumnReorderingRaw);

  var RowPlaceholder = function (props) { return react_9(TemplatePlaceholder, { name: "tableRow", params: props }); };
  var CellPlaceholder = function (props) { return react_9(TemplatePlaceholder, { name: "tableCell", params: props }); };
  var tableHeaderRows = [];
  var tableBodyRowsComputed = function (_a) {
      var rows = _a.rows, getRowId = _a.getRowId, isDataLoading = _a.isDataLoading;
      return (tableRowsWithDataRows(rows, getRowId, isDataLoading));
  };
  var tableFooterRows = [];
  var defaultMessages = {
      noData: 'No data',
  };
  var TableBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableBase, _super);
      function TableBase(props) {
          var _this = _super.call(this, props) || this;
          _this.tableColumnsComputed = memoize(function (columnExtensions) { return function (_a) {
              var columns = _a.columns;
              return tableColumnsWithDataRows(columns, columnExtensions);
          }; });
          return _this;
      }
      TableBase.prototype.render = function () {
          var _a = this.props, Layout = _a.layoutComponent, Cell = _a.cellComponent, Row = _a.rowComponent, NoDataRow = _a.noDataRowComponent, NoDataCell = _a.noDataCellComponent, StubRow = _a.stubRowComponent, StubCell = _a.stubCellComponent, StubHeaderCell = _a.stubHeaderCellComponent, columnExtensions = _a.columnExtensions, messages = _a.messages, containerComponent = _a.containerComponent, tableComponent = _a.tableComponent, headComponent = _a.headComponent, bodyComponent = _a.bodyComponent, footerComponent = _a.footerComponent;
          var getMessage = getMessagesFormatter(__assign$2({}, defaultMessages, messages));
          var tableColumnsComputed = this.tableColumnsComputed(columnExtensions);
          return (react_9(Plugin, { name: "Table" },
              react_9(Getter, { name: "tableHeaderRows", value: tableHeaderRows }),
              react_9(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed }),
              react_9(Getter, { name: "tableFooterRows", value: tableFooterRows }),
              react_9(Getter, { name: "tableColumns", computed: tableColumnsComputed }),
              react_9(Getter, { name: "getTableCellColSpan", value: tableCellColSpanGetter }),
              react_9(Getter, { name: "visibleBoundaries", value: [] }),
              react_9(Template, { name: "body" },
                  react_9(TemplatePlaceholder, { name: "table" })),
              react_9(Template, { name: "table" },
                  react_9(TemplateConnector, null, function (_a) {
                      var headerRows = _a.tableHeaderRows, bodyRows = _a.tableBodyRows, footerRows = _a.tableFooterRows, columns = _a.tableColumns, getTableCellColSpan = _a.getTableCellColSpan;
                      return (react_9(TemplatePlaceholder, { name: "tableLayout", params: {
                              tableComponent: tableComponent,
                              headComponent: headComponent,
                              bodyComponent: bodyComponent,
                              footerComponent: footerComponent,
                              containerComponent: containerComponent,
                              headerRows: headerRows,
                              bodyRows: bodyRows,
                              footerRows: footerRows,
                              columns: columns,
                              rowComponent: RowPlaceholder,
                              cellComponent: CellPlaceholder,
                              getCellColSpan: getTableCellColSpan,
                          } }));
                  })),
              react_9(Template, { name: "tableLayout" }, function (params) { return (react_9(Layout, __assign$2({}, params))); }),
              react_9(Template, { name: "tableCell" }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var headerRows = _a.tableHeaderRows;
                  return (isHeaderStubTableCell(params.tableRow, headerRows)
                      ? react_9(StubHeaderCell, __assign$2({}, params))
                      : react_9(StubCell, __assign$2({}, params)));
              })); }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isDataTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var getCellValue = _a.getCellValue;
                  var columnName = params.tableColumn.column.name;
                  var value = getCellValue(params.tableRow.row, columnName);
                  return (react_9(TemplatePlaceholder, { name: "valueFormatter", params: {
                          value: value,
                          row: params.tableRow.row,
                          column: params.tableColumn.column,
                      } }, function (content) { return (react_9(Cell, __assign$2({}, params, { row: params.tableRow.row, column: params.tableColumn.column, value: value }), content)); }));
              })); }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isNoDataTableRow(tableRow);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var tableColumns = _a.tableColumns;
                  if (isNoDataTableCell(params.tableColumn, tableColumns)) {
                      return (react_9(NoDataCell, __assign$2({}, params, { getMessage: getMessage })));
                  }
                  return null;
              })); }),
              react_9(Template, { name: "tableRow" }, function (params) { return (react_9(StubRow, __assign$2({}, params))); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isDataTableRow(tableRow);
                  } }, function (params) { return (react_9(Row, __assign$2({}, params, { row: params.tableRow.row }))); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isNoDataTableRow(tableRow);
                  } }, function (params) { return react_9(NoDataRow, __assign$2({}, params)); })));
      };
      TableBase.COLUMN_TYPE = TABLE_DATA_TYPE;
      TableBase.ROW_TYPE = TABLE_DATA_TYPE;
      TableBase.NODATA_ROW_TYPE = TABLE_NODATA_TYPE;
      TableBase.defaultProps = {
          messages: {},
      };
      TableBase.components = {
          tableComponent: 'Table',
          headComponent: 'TableHead',
          bodyComponent: 'TableBody',
          footerComponent: 'TableFooter',
          containerComponent: 'Container',
          layoutComponent: 'Layout',
          rowComponent: 'Row',
          cellComponent: 'Cell',
          noDataRowComponent: 'NoDataRow',
          noDataCellComponent: 'NoDataCell',
          stubRowComponent: 'StubRow',
          stubCellComponent: 'StubCell',
          stubHeaderCellComponent: 'StubHeaderCell',
      };
      return TableBase;
  }(react_4));
  /***
   * A plugin that renders Grid data as a table. This plugin enables you to customize
   * table rows and columns, and contains the Table Row and Table Cell components
   * that can be extended by other plugins
   * */
  var Table = TableBase;

  var TableSelectionBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableSelectionBase, _super);
      function TableSelectionBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      TableSelectionBase.prototype.render = function () {
          var _a = this.props, highlightRow = _a.highlightRow, selectByRowClick = _a.selectByRowClick, showSelectionColumn = _a.showSelectionColumn, showSelectAll = _a.showSelectAll, HeaderCell = _a.headerCellComponent, Cell = _a.cellComponent, Row = _a.rowComponent, selectionColumnWidth = _a.selectionColumnWidth;
          var tableColumnsComputed = function (_a) {
              var tableColumns = _a.tableColumns;
              return tableColumnsWithSelection(tableColumns, selectionColumnWidth);
          };
          return (react_9(Plugin, { name: "TableSelection", dependencies: [
                  { name: 'Table' },
                  { name: 'SelectionState' },
                  { name: 'IntegratedSelection', optional: !showSelectAll },
              ] },
              showSelectionColumn && (react_9(Getter, { name: "tableColumns", computed: tableColumnsComputed })),
              (showSelectionColumn && showSelectAll) && (react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isSelectAllTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a, _b) {
                  var selectAllAvailable = _a.selectAllAvailable, allSelected = _a.allSelected, someSelected = _a.someSelected;
                  var toggleSelectAll = _b.toggleSelectAll;
                  return (react_9(HeaderCell, __assign$2({}, params, { disabled: !selectAllAvailable, allSelected: allSelected, someSelected: someSelected, onToggle: function (select) { return toggleSelectAll(select); } })));
              })); })),
              showSelectionColumn && (react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isSelectTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a, _b) {
                  var selection = _a.selection;
                  var toggleSelection = _b.toggleSelection;
                  return (react_9(Cell, __assign$2({}, params, { row: params.tableRow.row, selected: selection.indexOf(params.tableRow.rowId) !== -1, onToggle: function () { return toggleSelection({ rowIds: [params.tableRow.rowId] }); } })));
              })); })),
              (highlightRow || selectByRowClick) && (react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isDataTableRow(tableRow);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a, _b) {
                  var selection = _a.selection;
                  var toggleSelection = _b.toggleSelection;
                  return (react_9(Row, __assign$2({}, params, { selectByRowClick: selectByRowClick, selected: highlightRow && selection.indexOf(params.tableRow.rowId) !== -1, onToggle: function () { return toggleSelection({ rowIds: [params.tableRow.rowId] }); } })));
              })); }))));
      };
      TableSelectionBase.defaultProps = {
          highlightRow: false,
          selectByRowClick: false,
          showSelectAll: false,
          showSelectionColumn: true,
      };
      TableSelectionBase.components = {
          rowComponent: 'Row',
          cellComponent: 'Cell',
          headerCellComponent: 'HeaderCell',
      };
      TableSelectionBase.COLUMN_TYPE = TABLE_SELECT_TYPE;
      return TableSelectionBase;
  }(react_4));
  /***
   * A plugin that visualizes table rows' selection state by rendering selection checkboxes
   * and highlighting the selected rows.
   * */
  var TableSelection = TableSelectionBase;

  // tslint:disable-next-line: max-line-length
  var RowDetailStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(RowDetailStateBase, _super);
      function RowDetailStateBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds,
          };
          var stateHelper = createStateHelper(_this, {
              expandedRowIds: function () {
                  var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;
                  return onExpandedRowIdsChange;
              },
          });
          _this.toggleDetailRowExpanded = stateHelper.applyFieldReducer
              .bind(stateHelper, 'expandedRowIds', toggleDetailRowExpanded);
          return _this;
      }
      RowDetailStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.expandedRowIds, expandedRowIds = _a === void 0 ? prevState.expandedRowIds : _a;
          return {
              expandedRowIds: expandedRowIds,
          };
      };
      RowDetailStateBase.prototype.render = function () {
          var expandedRowIds = this.state.expandedRowIds;
          return (react_9(Plugin, { name: "RowDetailState" },
              react_9(Getter, { name: "expandedDetailRowIds", value: expandedRowIds }),
              react_9(Action, { name: "toggleDetailRowExpanded", action: this.toggleDetailRowExpanded })));
      };
      RowDetailStateBase.defaultProps = {
          defaultExpandedRowIds: [],
      };
      return RowDetailStateBase;
  }(react_4));
  /** A plugin that manages the expanded state for table row details. */
  var RowDetailState = RowDetailStateBase;

  var getCellColSpanComputed = function (_a) {
      var getTableCellColSpan = _a.getTableCellColSpan;
      return tableDetailCellColSpanGetter(getTableCellColSpan);
  };
  var pluginDependencies$9 = [
      { name: 'RowDetailState' },
      { name: 'Table' },
  ];
  var TableRowDetailBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableRowDetailBase, _super);
      function TableRowDetailBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      TableRowDetailBase.prototype.render = function () {
          var _a = this.props, rowHeight = _a.rowHeight, Content = _a.contentComponent, ToggleCell = _a.toggleCellComponent, Cell = _a.cellComponent, Row = _a.rowComponent, toggleColumnWidth = _a.toggleColumnWidth;
          var tableColumnsComputed = function (_a) {
              var tableColumns = _a.tableColumns;
              return tableColumnsWithDetail(tableColumns, toggleColumnWidth);
          };
          var tableBodyRowsComputed = function (_a) {
              var tableBodyRows = _a.tableBodyRows, expandedDetailRowIds = _a.expandedDetailRowIds;
              return tableRowsWithExpandedDetail(tableBodyRows, expandedDetailRowIds, rowHeight);
          };
          return (react_9(Plugin, { name: "TableRowDetail", dependencies: pluginDependencies$9 },
              react_9(Getter, { name: "tableColumns", computed: tableColumnsComputed }),
              react_9(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed }),
              react_9(Getter, { name: "getTableCellColSpan", computed: getCellColSpanComputed }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isDetailToggleTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a, _b) {
                  var expandedDetailRowIds = _a.expandedDetailRowIds;
                  var toggleDetailRowExpanded = _b.toggleDetailRowExpanded;
                  return (react_9(ToggleCell, __assign$2({}, params, { row: params.tableRow.row, expanded: isDetailRowExpanded(expandedDetailRowIds, params.tableRow.rowId), onToggle: function () { return toggleDetailRowExpanded({ rowId: params.tableRow.rowId }); } })));
              })); }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isDetailTableRow(tableRow);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var tableColumns = _a.tableColumns;
                  if (isDetailTableCell(params.tableColumn, tableColumns)) {
                      return (react_9(Cell, __assign$2({}, params, { row: params.tableRow.row }), Content && react_9(Content, { row: params.tableRow.row })));
                  }
                  return null;
              })); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isDetailTableRow(tableRow);
                  } }, function (params) { return (react_9(Row, __assign$2({}, params, { row: params.tableRow.row }))); })));
      };
      TableRowDetailBase.ROW_TYPE = TABLE_DETAIL_TYPE;
      TableRowDetailBase.COLUMN_TYPE = TABLE_DETAIL_TYPE;
      TableRowDetailBase.defaultProps = {
          contentComponent: function () { return null; },
      };
      TableRowDetailBase.components = {
          rowComponent: 'Row',
          cellComponent: 'Cell',
          toggleCellComponent: 'ToggleCell',
      };
      return TableRowDetailBase;
  }(react_4));
  /** A plugin that renders detail rows. */
  var TableRowDetail = TableRowDetailBase;

  var pluginDependencies$a = [
      { name: 'GroupingState' },
      { name: 'Table' },
      { name: 'DataTypeProvider', optional: true },
      { name: 'TableSelection', optional: true },
  ];
  var tableBodyRowsComputed$1 = function (_a) {
      var tableBodyRows = _a.tableBodyRows, isGroupRow = _a.isGroupRow;
      return tableRowsWithGrouping(tableBodyRows, isGroupRow);
  };
  var getCellColSpanComputed$1 = function (_a) {
      var getTableCellColSpan = _a.getTableCellColSpan;
      return tableGroupCellColSpanGetter(getTableCellColSpan);
  };
  var showColumnWhenGroupedGetter = function (showColumnsWhenGrouped, columnExtensions) {
      if (columnExtensions === void 0) { columnExtensions = []; }
      var map = columnExtensions.reduce(function (acc, columnExtension) {
          acc[columnExtension.columnName] = columnExtension.showWhenGrouped;
          return acc;
      }, {});
      return function (columnName) { return map[columnName] || showColumnsWhenGrouped; };
  };
  var TableGroupRowBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableGroupRowBase, _super);
      function TableGroupRowBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      TableGroupRowBase.prototype.render = function () {
          var _a = this.props, GroupCell = _a.cellComponent, Content = _a.contentComponent, Icon = _a.iconComponent, GroupRow = _a.rowComponent, GroupIndentCell = _a.indentCellComponent, indentColumnWidth = _a.indentColumnWidth, showColumnsWhenGrouped = _a.showColumnsWhenGrouped, columnExtensions = _a.columnExtensions;
          var tableColumnsComputed = function (_a) {
              var columns = _a.columns, tableColumns = _a.tableColumns, grouping = _a.grouping, draftGrouping = _a.draftGrouping;
              return tableColumnsWithGrouping(columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGroupedGetter(showColumnsWhenGrouped, columnExtensions));
          };
          return (react_9(Plugin, { name: "TableGroupRow", dependencies: pluginDependencies$a },
              react_9(Getter, { name: "tableColumns", computed: tableColumnsComputed }),
              react_9(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed$1 }),
              react_9(Getter, { name: "getTableCellColSpan", computed: getCellColSpanComputed$1 }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return isGroupTableRow(tableRow);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a, _b) {
                  var grouping = _a.grouping, expandedGroups = _a.expandedGroups;
                  var toggleGroupExpanded = _b.toggleGroupExpanded;
                  if (isGroupTableCell(params.tableRow, params.tableColumn)) {
                      return (react_9(TemplatePlaceholder, { name: "valueFormatter", params: {
                              column: params.tableColumn.column,
                              value: params.tableRow.row.value,
                          } }, function (content) { return (react_9(GroupCell, __assign$2({}, params, { contentComponent: Content, iconComponent: Icon, row: params.tableRow.row, column: params.tableColumn.column, expanded: expandedGroups.indexOf(params.tableRow.row.compoundKey) !== -1, onToggle: function () { return toggleGroupExpanded({ groupKey: params.tableRow.row.compoundKey }); } }), content)); }));
                  }
                  if (isGroupIndentTableCell(params.tableRow, params.tableColumn, grouping)) {
                      if (GroupIndentCell) {
                          return (react_9(GroupIndentCell, __assign$2({}, params, { row: params.tableRow.row, column: params.tableColumn.column })));
                      }
                      return react_9(TemplatePlaceholder, null);
                  }
                  return null;
              })); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return isGroupTableRow(tableRow);
                  } }, function (params) { return (react_9(GroupRow, __assign$2({}, params, { row: params.tableRow.row }))); })));
      };
      TableGroupRowBase.ROW_TYPE = TABLE_GROUP_TYPE;
      TableGroupRowBase.COLUMN_TYPE = TABLE_GROUP_TYPE;
      TableGroupRowBase.defaultProps = {
          showColumnsWhenGrouped: false,
      };
      TableGroupRowBase.components = {
          rowComponent: 'Row',
          cellComponent: 'Cell',
          contentComponent: 'Content',
          iconComponent: 'Icon',
      };
      return TableGroupRowBase;
  }(react_4));
  /** A plugin that renders group rows and enables them to expand and collapse. */
  var TableGroupRow = TableGroupRowBase;

  var tableHeaderRowsComputed$1 = function (_a) {
      var tableHeaderRows = _a.tableHeaderRows;
      return tableRowsWithHeading(tableHeaderRows || []);
  };
  var TableHeaderRowBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableHeaderRowBase, _super);
      function TableHeaderRowBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      TableHeaderRowBase.prototype.render = function () {
          var _a = this.props, showSortingControls = _a.showSortingControls, showGroupingControls = _a.showGroupingControls, HeaderCell = _a.cellComponent, HeaderRow = _a.rowComponent, Content = _a.contentComponent, SortLabel = _a.sortLabelComponent, GroupButton = _a.groupButtonComponent, Title = _a.titleComponent, messages = _a.messages;
          var getMessage = getMessagesFormatter(messages);
          return (react_9(Plugin, { name: "TableHeaderRow", dependencies: [
                  { name: 'Table' },
                  { name: 'SortingState', optional: !showSortingControls },
                  { name: 'GroupingState', optional: !showGroupingControls },
                  { name: 'DragDropProvider', optional: true },
                  { name: 'TableColumnResizing', optional: true },
              ] },
              react_9(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed$1 }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isHeadingTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a, _b) {
                  var sorting = _a.sorting, tableColumns = _a.tableColumns, draggingEnabled = _a.draggingEnabled, tableColumnResizingEnabled = _a.tableColumnResizingEnabled, isColumnSortingEnabled = _a.isColumnSortingEnabled, isColumnGroupingEnabled = _a.isColumnGroupingEnabled;
                  var changeColumnSorting = _b.changeColumnSorting, changeColumnGrouping = _b.changeColumnGrouping, changeTableColumnWidth = _b.changeTableColumnWidth, draftTableColumnWidth = _b.draftTableColumnWidth, cancelTableColumnWidthDraft = _b.cancelTableColumnWidthDraft;
                  var _c = params.tableColumn.column, columnName = _c.name, columnTitle = _c.title;
                  var atLeastOneDataColumn = tableColumns
                      .filter(function (_a) {
                      var type = _a.type;
                      return type === TABLE_DATA_TYPE;
                  }).length > 1;
                  var sortingEnabled = isColumnSortingEnabled
                      && isColumnSortingEnabled(columnName);
                  var groupingEnabled = isColumnGroupingEnabled
                      && isColumnGroupingEnabled(columnName)
                      && atLeastOneDataColumn;
                  return (react_9(HeaderCell, __assign$2({}, params, { column: params.tableColumn.column, draggingEnabled: draggingEnabled && atLeastOneDataColumn, resizingEnabled: tableColumnResizingEnabled, onWidthChange: function (_a) {
                          var shift = _a.shift;
                          return changeTableColumnWidth({ columnName: columnName, shift: shift });
                      }, onWidthDraft: function (_a) {
                          var shift = _a.shift;
                          return draftTableColumnWidth({ columnName: columnName, shift: shift });
                      }, onWidthDraftCancel: function () { return cancelTableColumnWidthDraft(); }, 
                      // @deprecated
                      sortingEnabled: sortingEnabled, 
                      // @deprecated
                      groupingEnabled: groupingEnabled, 
                      // @deprecated
                      showSortingControls: showSortingControls, 
                      // @deprecated
                      showGroupingControls: showGroupingControls, 
                      // @deprecated
                      sortingDirection: showSortingControls && sorting !== undefined
                          ? getColumnSortingDirection(sorting, columnName) : undefined, 
                      // @deprecated
                      onSort: function (_a) {
                          var direction = _a.direction, keepOther = _a.keepOther;
                          return changeColumnSorting({
                              columnName: columnName, direction: direction, keepOther: keepOther,
                          });
                      }, 
                      // @deprecated
                      onGroup: function () { return changeColumnGrouping({ columnName: columnName }); }, 
                      // @deprecated
                      before: (react_9(TemplatePlaceholder, { name: "tableHeaderCellBefore", params: {
                              column: params.tableColumn.column,
                          } })) }),
                      react_9(TemplatePlaceholder, { name: "tableHeaderCellBefore", params: {
                              column: params.tableColumn.column,
                          } }),
                      react_9(Content, { column: params.tableColumn.column, align: params.tableColumn.align }, showSortingControls ? (react_9(SortLabel, { column: params.tableColumn.column, align: params.tableColumn.align, direction: getColumnSortingDirection(sorting, columnName) || null, disabled: !sortingEnabled, onSort: function (_a) {
                              var direction = _a.direction, keepOther = _a.keepOther;
                              changeColumnSorting({ columnName: columnName, direction: direction, keepOther: keepOther });
                          }, getMessage: getMessage },
                          react_9(Title, null, columnTitle || columnName))) : (react_9(Title, null, columnTitle || columnName))),
                      showGroupingControls ? (react_9(GroupButton, { disabled: !groupingEnabled, onGroup: function () { return changeColumnGrouping({ columnName: columnName }); } })) : null));
              })); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isHeadingTableRow(tableRow);
                  } }, function (params) { return react_9(HeaderRow, __assign$2({}, params)); })));
      };
      TableHeaderRowBase.ROW_TYPE = TABLE_HEADING_TYPE;
      TableHeaderRowBase.defaultProps = {
          showSortingControls: false,
          showGroupingControls: false,
          messages: {},
      };
      TableHeaderRowBase.components = {
          cellComponent: 'Cell',
          rowComponent: 'Row',
          contentComponent: 'Content',
          sortLabelComponent: 'SortLabel',
          titleComponent: 'Title',
          groupButtonComponent: 'GroupButton',
      };
      return TableHeaderRowBase;
  }(react_4));
  TableHeaderRowBase.components = {
      cellComponent: 'Cell',
      rowComponent: 'Row',
      contentComponent: 'Content',
      sortLabelComponent: 'SortLabel',
      titleComponent: 'Title',
      groupButtonComponent: 'GroupButton',
  };
  /***
   * A plugin that renders the table's header row. The Column's `title` field specifies the
   * column's title in the header row.The plugin also allows you to manage a column's sorting
   * and grouping state and initiate column dragging.
   * */
  var TableHeaderRow = TableHeaderRowBase;

  var CellPlaceholder$1 = function (props) { return react_9(TemplatePlaceholder, { params: props }); };
  var TableBandHeaderBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableBandHeaderBase, _super);
      function TableBandHeaderBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      TableBandHeaderBase.prototype.render = function () {
          var _a = this.props, Cell = _a.cellComponent, Row = _a.rowComponent, HeaderCell = _a.bandedHeaderCellComponent, InvisibleCell = _a.invisibleCellComponent, columnBands = _a.columnBands;
          var tableHeaderRowsComputed = function (_a) {
              var tableHeaderRows = _a.tableHeaderRows, tableColumns = _a.tableColumns;
              return tableRowsWithBands(tableHeaderRows, columnBands, tableColumns);
          };
          var tableHeaderColumnChainsComputed = function (_a) {
              var tableHeaderRows = _a.tableHeaderRows, tableColumns = _a.tableColumns;
              return tableHeaderColumnChainsWithBands(tableHeaderRows, tableColumns, columnBands);
          };
          return (react_9(Plugin, { name: "TableBandHeader", dependencies: [
                  { name: 'Table' },
                  { name: 'TableHeaderRow' },
                  { name: 'TableSelection', optional: true },
                  { name: 'TableEditColumn', optional: true },
              ] },
              react_9(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed }),
              react_9(Getter, { name: "tableHeaderColumnChains", computed: tableHeaderColumnChainsComputed }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isBandedOrHeaderRow(tableRow);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var tableColumns = _a.tableColumns, tableHeaderRows = _a.tableHeaderRows, tableHeaderColumnChains = _a.tableHeaderColumnChains;
                  var bandComponent = getBandComponent(params, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains);
                  switch (bandComponent.type) {
                      case BAND_DUPLICATE_RENDER:
                          return react_9(TemplatePlaceholder, null);
                      case BAND_EMPTY_CELL:
                          return react_9(InvisibleCell, null);
                      case BAND_GROUP_CELL: {
                          var _b = bandComponent.payload, value = _b.value, payload = __rest$1(_b, ["value"]);
                          return (react_9(Cell, __assign$2({}, params, payload), value));
                      }
                      case BAND_HEADER_CELL:
                          return (react_9(TemplatePlaceholder, { name: "tableCell", params: __assign$2({}, params, bandComponent.payload) }));
                      default:
                          return null;
                  }
              })); }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isHeadingTableCell(tableRow, tableColumn);
                  } }, function (params) { return react_9(HeaderCell, __assign$2({ component: CellPlaceholder$1 }, params)); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isBandedTableRow(tableRow);
                  } }, function (params) { return react_9(Row, __assign$2({}, params)); })));
      };
      TableBandHeaderBase.ROW_TYPE = TABLE_BAND_TYPE;
      TableBandHeaderBase.components = {
          cellComponent: 'Cell',
          rowComponent: 'Row',
          bandedHeaderCellComponent: 'BandedHeaderCell',
          invisibleCellComponent: 'InvisibleCell',
      };
      return TableBandHeaderBase;
  }(react_4));
  TableBandHeaderBase.components = {
      cellComponent: 'Cell',
      rowComponent: 'Row',
      bandedHeaderCellComponent: 'BandedHeaderCell',
      invisibleCellComponent: 'InvisibleCell',
  };
  /** A plugin that renders the banded cells. */
  var TableBandHeader = TableBandHeaderBase;

  var pluginDependencies$b = [
      { name: 'FilteringState' },
      { name: 'Table' },
      { name: 'DataTypeProvider', optional: true },
  ];
  var defaultMessages$1 = {
      filterPlaceholder: 'Filter...',
      contains: 'Contains',
      notContains: 'Does not contain',
      startsWith: 'Starts with',
      endsWith: 'Ends with',
      equal: 'Equals',
      notEqual: 'Does not equal',
      greaterThan: 'Greater than',
      greaterThanOrEqual: 'Greater than or equal to',
      lessThan: 'Less than',
      lessThanOrEqual: 'Less than or equal to',
  };
  var TableFilterRowBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableFilterRowBase, _super);
      function TableFilterRowBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              filterOperations: {},
          };
          return _this;
      }
      TableFilterRowBase.prototype.render = function () {
          var _this = this;
          var _a = this.props, rowHeight = _a.rowHeight, showFilterSelector = _a.showFilterSelector, FilterCell = _a.cellComponent, FilterRow = _a.rowComponent, FilterSelector = _a.filterSelectorComponent, iconComponent = _a.iconComponent, toggleButtonComponent = _a.toggleButtonComponent, EditorComponent = _a.editorComponent, messages = _a.messages;
          var getMessage = getMessagesFormatter(__assign$2({}, defaultMessages$1, messages));
          var tableHeaderRowsComputed = function (_a) {
              var tableHeaderRows = _a.tableHeaderRows;
              return tableHeaderRowsWithFilter(tableHeaderRows, rowHeight);
          };
          return (react_9(Plugin, { name: "TableFilterRow", dependencies: pluginDependencies$b },
              react_9(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isFilterTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a, _b) {
                  var filters = _a.filters, isColumnFilteringEnabled = _a.isColumnFilteringEnabled, getAvailableFilterOperations = _a.getAvailableFilterOperations;
                  var changeColumnFilter = _b.changeColumnFilter;
                  var filterOperations = _this.state.filterOperations;
                  var columnName = params.tableColumn.column.name;
                  var filter = getColumnFilterConfig(filters, columnName);
                  var onFilter = function (config) { return changeColumnFilter({ columnName: columnName, config: config }); };
                  var columnFilterOperations = getColumnFilterOperations(getAvailableFilterOperations, columnName);
                  var selectedFilterOperation = getSelectedFilterOperation(filterOperations, columnName, filter, columnFilterOperations);
                  var handleFilterOperationChange = function (value) {
                      var _a;
                      _this.setState({
                          filterOperations: __assign$2({}, filterOperations, (_a = {}, _a[columnName] = value, _a)),
                      });
                      if (filter && !isFilterValueEmpty(filter.value)) {
                          onFilter({ value: filter.value, operation: value });
                      }
                  };
                  var handleFilterValueChange = function (value) { return onFilter(!isFilterValueEmpty(value)
                      ? { value: value, operation: selectedFilterOperation }
                      : null); };
                  var filteringEnabled = isColumnFilteringEnabled(columnName);
                  return (react_9(TemplatePlaceholder, { name: "valueEditor", params: {
                          column: params.tableColumn.column,
                          value: filter ? filter.value : undefined,
                          onValueChange: handleFilterValueChange,
                      } }, function (content) { return (react_9(FilterCell, __assign$2({}, params, { getMessage: getMessage, column: params.tableColumn.column, filter: filter, filteringEnabled: filteringEnabled, onFilter: onFilter }),
                      showFilterSelector
                          ? (react_9(FilterSelector, { toggleButtonComponent: toggleButtonComponent, iconComponent: iconComponent, value: selectedFilterOperation, availableValues: columnFilterOperations, onChange: handleFilterOperationChange, disabled: !filteringEnabled, getMessage: getMessage })) : null,
                      content || (react_9(EditorComponent, { value: filter ? filter.value : undefined, disabled: !filteringEnabled, getMessage: getMessage, onChange: handleFilterValueChange })))); }));
              })); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isFilterTableRow(tableRow);
                  } }, function (params) { return react_9(FilterRow, __assign$2({}, params)); })));
      };
      TableFilterRowBase.ROW_TYPE = TABLE_FILTER_TYPE;
      TableFilterRowBase.defaultProps = {
          showFilterSelector: false,
          messages: {},
      };
      TableFilterRowBase.components = {
          rowComponent: 'Row',
          cellComponent: 'Cell',
          filterSelectorComponent: 'FilterSelector',
          iconComponent: 'Icon',
          editorComponent: 'Editor',
          toggleButtonComponent: 'ToggleButton',
      };
      return TableFilterRowBase;
  }(react_4));
  /** A plugin that renders a filter row. */
  var TableFilterRow = TableFilterRowBase;

  var pluginDependencies$c = [
      { name: 'EditingState' },
      { name: 'Table' },
      { name: 'DataTypeProvider', optional: true },
  ];
  var TableEditRowBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableEditRowBase, _super);
      function TableEditRowBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      TableEditRowBase.prototype.render = function () {
          var _a = this.props, EditCell = _a.cellComponent, EditRow = _a.rowComponent, rowHeight = _a.rowHeight;
          var tableBodyRowsComputed = function (_a) {
              var tableBodyRows = _a.tableBodyRows, editingRowIds = _a.editingRowIds, addedRows = _a.addedRows;
              return tableRowsWithEditing(tableBodyRows, editingRowIds, addedRows, rowHeight);
          };
          return (react_9(Plugin, { name: "TableEditRow", dependencies: pluginDependencies$c },
              react_9(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isEditTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a, _b) {
                  var getCellValue = _a.getCellValue, createRowChange = _a.createRowChange, rowChanges = _a.rowChanges, isColumnEditingEnabled = _a.isColumnEditingEnabled;
                  var changeAddedRow = _b.changeAddedRow, changeRow = _b.changeRow;
                  var _c = params.tableRow, rowId = _c.rowId, row = _c.row;
                  var column = params.tableColumn.column;
                  var columnName = column.name;
                  var isNew = isAddedTableRow(params.tableRow);
                  var changedRow = isNew
                      ? row
                      : __assign$2({}, row, getRowChange(rowChanges, rowId));
                  var value = getCellValue(changedRow, columnName);
                  var onValueChange = function (newValue) {
                      var changeArgs = {
                          rowId: rowId,
                          change: createRowChange(changedRow, newValue, columnName),
                      };
                      if (isNew) {
                          changeAddedRow(changeArgs);
                      }
                      else {
                          changeRow(changeArgs);
                      }
                  };
                  return (react_9(TemplatePlaceholder, { name: "valueEditor", params: {
                          column: column,
                          row: row,
                          value: value,
                          onValueChange: onValueChange,
                      } }, function (content) { return (react_9(EditCell, __assign$2({}, params, { row: row, column: column, value: value, editingEnabled: isColumnEditingEnabled(columnName), onValueChange: onValueChange }), content)); }));
              })); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!(isEditTableRow(tableRow) || isAddedTableRow(tableRow));
                  } }, function (params) { return (react_9(EditRow, __assign$2({}, params, { row: params.tableRow.row }))); })));
      };
      TableEditRowBase.ADDED_ROW_TYPE = TABLE_ADDED_TYPE;
      TableEditRowBase.EDIT_ROW_TYPE = TABLE_EDIT_TYPE;
      TableEditRowBase.components = {
          rowComponent: 'Row',
          cellComponent: 'Cell',
      };
      return TableEditRowBase;
  }(react_4));
  /** A plugin that renders a row being edited. */
  var TableEditRow = TableEditRowBase;

  var pluginDependencies$d = [
      { name: 'EditingState' },
      { name: 'Table' },
  ];
  var defaultMessages$2 = {
      addCommand: 'New',
      editCommand: 'Edit',
      deleteCommand: 'Delete',
      commitCommand: 'Save',
      cancelCommand: 'Cancel',
  };
  var TableEditColumnBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableEditColumnBase, _super);
      function TableEditColumnBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      TableEditColumnBase.prototype.render = function () {
          var _a = this.props, Cell = _a.cellComponent, HeaderCell = _a.headerCellComponent, Command = _a.commandComponent, showAddCommand = _a.showAddCommand, showEditCommand = _a.showEditCommand, showDeleteCommand = _a.showDeleteCommand, width = _a.width, messages = _a.messages;
          var getMessage = getMessagesFormatter(__assign$2({}, defaultMessages$2, messages));
          var tableColumnsComputed = function (_a) {
              var tableColumns = _a.tableColumns;
              return tableColumnsWithEditing(tableColumns, width);
          };
          return (react_9(Plugin, { name: "TableEditColumn", dependencies: pluginDependencies$d },
              react_9(Getter, { name: "tableColumns", computed: tableColumnsComputed }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isHeadingEditCommandsTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (getters, actions) { return (react_9(HeaderCell, __assign$2({}, params), showAddCommand && (react_9(Command, { id: "add", text: getMessage('addCommand'), onExecute: function () { return actions.addRow(); } })))); })); }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isEditCommandsTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (getters, actions) {
                  var isEdit = isEditTableRow(params.tableRow);
                  var isNew = isAddedTableRow(params.tableRow);
                  var isEditing = isEdit || isNew;
                  var rowIds = [params.tableRow.rowId];
                  return (react_9(Cell, __assign$2({}, params, { row: params.tableRow.row }),
                      showEditCommand && !isEditing && (react_9(Command, { id: "edit", text: getMessage('editCommand'), onExecute: function () { return actions.startEditRows({ rowIds: rowIds }); } })),
                      showDeleteCommand && !isEditing && (react_9(Command, { id: "delete", text: getMessage('deleteCommand'), onExecute: function () {
                              actions.deleteRows({ rowIds: rowIds });
                              actions.commitDeletedRows({ rowIds: rowIds });
                          } })),
                      isEditing && (react_9(Command, { id: "commit", text: getMessage('commitCommand'), onExecute: function () {
                              if (isNew) {
                                  actions.commitAddedRows({ rowIds: rowIds });
                              }
                              else {
                                  actions.stopEditRows({ rowIds: rowIds });
                                  actions.commitChangedRows({ rowIds: rowIds });
                              }
                          } })),
                      isEditing && (react_9(Command, { id: "cancel", text: getMessage('cancelCommand'), onExecute: function () {
                              if (isNew) {
                                  actions.cancelAddedRows({ rowIds: rowIds });
                              }
                              else {
                                  actions.stopEditRows({ rowIds: rowIds });
                                  actions.cancelChangedRows({ rowIds: rowIds });
                              }
                          } }))));
              })); })));
      };
      TableEditColumnBase.COLUMN_TYPE = TABLE_EDIT_COMMAND_TYPE;
      TableEditColumnBase.defaultProps = {
          showAddCommand: false,
          showEditCommand: false,
          showDeleteCommand: false,
          width: 140,
          messages: {},
      };
      TableEditColumnBase.components = {
          cellComponent: 'Cell',
          headerCellComponent: 'HeaderCell',
          commandComponent: 'Command',
      };
      return TableEditColumnBase;
  }(react_4));
  /***
   * A plugin that renders a command column. This column contains controls used for row editing,
   * creating, or deleting and committing/canceling changes.
   * */
  var TableEditColumn = TableEditColumnBase;

  var pluginDependencies$e = [
      { name: 'Table' },
  ];
  // tslint:disable-next-line: max-line-length
  var TableColumnResizingBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableColumnResizingBase, _super);
      function TableColumnResizingBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              columnWidths: props.columnWidths || props.defaultColumnWidths,
              draftColumnWidths: [],
          };
          var stateHelper = createStateHelper(_this, {
              columnWidths: function () {
                  var onColumnWidthsChange = _this.props.onColumnWidthsChange;
                  return onColumnWidthsChange;
              },
          });
          _this.tableColumnsComputed = memoize(function (columnWidths) { return function (_a) {
              var tableColumns = _a.tableColumns;
              return tableColumnsWithWidths(tableColumns, columnWidths);
          }; });
          _this.tableColumnsDraftComputed = memoize(function (draftColumnWidths) { return function (_a) {
              var tableColumns = _a.tableColumns;
              return tableColumnsWithDraftWidths(tableColumns, draftColumnWidths);
          }; });
          _this.changeTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {
              var minColumnWidth = _this.props.minColumnWidth;
              return changeTableColumnWidth(prevState, __assign$2({}, payload, { minColumnWidth: minColumnWidth }));
          });
          _this.draftTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {
              var minColumnWidth = _this.props.minColumnWidth;
              return draftTableColumnWidth(prevState, __assign$2({}, payload, { minColumnWidth: minColumnWidth }));
          });
          _this.cancelTableColumnWidthDraft = stateHelper.applyReducer.bind(stateHelper, cancelTableColumnWidthDraft);
          return _this;
      }
      TableColumnResizingBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.columnWidths, columnWidths = _a === void 0 ? prevState.columnWidths : _a;
          return {
              columnWidths: columnWidths,
          };
      };
      TableColumnResizingBase.prototype.render = function () {
          var _a = this.state, columnWidths = _a.columnWidths, draftColumnWidths = _a.draftColumnWidths;
          var tableColumnsComputed = this.tableColumnsComputed(columnWidths);
          var tableColumnsDraftComputed = this.tableColumnsDraftComputed(draftColumnWidths);
          return (react_9(Plugin, { name: "TableColumnResizing", dependencies: pluginDependencies$e },
              react_9(Getter, { name: "tableColumnResizingEnabled", value: true }),
              react_9(Getter, { name: "tableColumns", computed: tableColumnsComputed }),
              react_9(Getter, { name: "tableColumns", computed: tableColumnsDraftComputed }),
              react_9(Action, { name: "changeTableColumnWidth", action: this.changeTableColumnWidth }),
              react_9(Action, { name: "draftTableColumnWidth", action: this.draftTableColumnWidth }),
              react_9(Action, { name: "cancelTableColumnWidthDraft", action: this.cancelTableColumnWidthDraft })));
      };
      TableColumnResizingBase.defaultProps = {
          defaultColumnWidths: [],
      };
      return TableColumnResizingBase;
  }(react_4));
  /* tslint:disable: max-line-length */
  /** A plugin that manages table column widths. */
  var TableColumnResizing = TableColumnResizingBase;
  /* tslint:enable: max-line-length */

  var pluginDependencies$f = [
      { name: 'PagingState' },
  ];
  var defaultMessages$3 = {
      showAll: 'All',
      info: function (_a) {
          var from = _a.from, to = _a.to, count = _a.count;
          return "" + from + (from < to ? "-" + to : '') + " of " + count;
      },
  };
  var PagingPanelBase = /*#__PURE__*/ (function (_super) {
      __extends$1(PagingPanelBase, _super);
      function PagingPanelBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      PagingPanelBase.prototype.render = function () {
          var _a = this.props, Pager = _a.containerComponent, pageSizes = _a.pageSizes, messages = _a.messages;
          var getMessage = getMessagesFormatter(__assign$2({}, defaultMessages$3, messages));
          return (react_9(Plugin, { name: "PagingPanel", dependencies: pluginDependencies$f },
              react_9(Template, { name: "footer" },
                  react_9(TemplatePlaceholder, null),
                  react_9(TemplateConnector, null, function (_a, _b) {
                      var currentPage = _a.currentPage, pageSize = _a.pageSize, totalCount = _a.totalCount;
                      var setCurrentPage = _b.setCurrentPage, setPageSize = _b.setPageSize;
                      return (react_9(Pager, { currentPage: currentPage, pageSize: pageSize, totalCount: totalCount, totalPages: pageCount(totalCount, pageSize), pageSizes: pageSizes, getMessage: getMessage, onCurrentPageChange: setCurrentPage, onPageSizeChange: setPageSize }));
                  }))));
      };
      PagingPanelBase.defaultProps = {
          pageSizes: [],
          messages: {},
      };
      PagingPanelBase.components = {
          containerComponent: 'Container',
      };
      return PagingPanelBase;
  }(react_4));
  /** A plugin that renders the paging panel used for navigation through data pages. */
  var PagingPanel = PagingPanelBase;

  var defaultProps$3 = {
      draggingEnabled: false,
      onDragStart: function () { },
      onDragEnd: function () { },
  };
  // tslint:disable-next-line: max-line-length
  var ItemLayout = /*#__PURE__*/ (function (_super) {
      __extends$1(ItemLayout, _super);
      function ItemLayout(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              dragging: false,
          };
          return _this;
      }
      ItemLayout.prototype.render = function () {
          var _this = this;
          var _a = this.props, item = _a.item, Item = _a.itemComponent, draggingEnabled = _a.draggingEnabled, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd;
          var dragging = this.state.dragging;
          var itemElement = react_9(Item, { item: __assign$2({}, item, { draft: dragging || item.draft }) });
          return (draggingEnabled ? (react_9(DragSource, { payload: [{ type: 'column', columnName: item.column.name }], onStart: function () {
                  _this.setState({ dragging: true });
                  onDragStart();
              }, onEnd: function () {
                  _this.setState({ dragging: false });
                  onDragEnd();
              } }, itemElement)) : (itemElement));
      };
      ItemLayout.defaultProps = defaultProps$3;
      return ItemLayout;
  }(react_4));

  var defaultProps$1$1 = {
      onGroup: function () { },
      draggingEnabled: false,
      isColumnGroupingEnabled: function () { return false; },
      onGroupDraft: function () { },
      onGroupDraftCancel: function () { },
  };
  // tslint:disable-next-line: max-line-length
  var GroupPanelLayoutBase = /*#__PURE__*/ (function (_super) {
      __extends$1(GroupPanelLayoutBase, _super);
      function GroupPanelLayoutBase(props) {
          var _this = _super.call(this, props) || this;
          _this.itemRefs = [];
          _this.draggingColumnName = null;
          _this.state = {
              sourceColumnName: null,
              targetItemIndex: -1,
          };
          _this.handleDragEvent = function (eventHandler, _a) {
              var payload = _a.payload, restArgs = __rest$1(_a, ["payload"]);
              var isColumnGroupingEnabled = _this.props.isColumnGroupingEnabled;
              var columnName = payload[0].columnName;
              if (isColumnGroupingEnabled(columnName)) {
                  eventHandler(__assign$2({ payload: payload }, restArgs));
              }
          };
          _this.onEnter = function (_a) {
              var payload = _a.payload;
              _this.setState({
                  sourceColumnName: payload[0].columnName,
              });
          };
          _this.onOver = function (_a) {
              var clientOffset = _a.clientOffset;
              var _b = _this.props, onGroupDraft = _b.onGroupDraft, items = _b.items;
              var _c = _this.state, sourceColumnName = _c.sourceColumnName, prevTargetItemIndex = _c.targetItemIndex;
              // eslint-disable-next-line react/no-find-dom-node
              var itemGeometries = _this.itemRefs
                  .map(function (ref) { return reactDom_2(ref).getBoundingClientRect(); });
              var sourceItemIndex = items.findIndex(function (_a) {
                  var column = _a.column;
                  return column.name === sourceColumnName;
              });
              var targetItemIndex = getGroupCellTargetIndex(itemGeometries, sourceItemIndex, clientOffset);
              if (prevTargetItemIndex === targetItemIndex)
                  return;
              onGroupDraft({
                  columnName: sourceColumnName,
                  groupIndex: targetItemIndex,
              });
              _this.setState({ targetItemIndex: targetItemIndex });
          };
          _this.onLeave = function () {
              var onGroupDraft = _this.props.onGroupDraft;
              var sourceColumnName = _this.state.sourceColumnName;
              if (!_this.draggingColumnName) {
                  _this.resetState();
                  return;
              }
              onGroupDraft({
                  columnName: sourceColumnName,
                  groupIndex: -1,
              });
              _this.setState({
                  targetItemIndex: -1,
              });
          };
          _this.onDrop = function () {
              var onGroup = _this.props.onGroup;
              var _a = _this.state, sourceColumnName = _a.sourceColumnName, targetItemIndex = _a.targetItemIndex;
              _this.resetState();
              onGroup({
                  columnName: sourceColumnName,
                  groupIndex: targetItemIndex,
              });
          };
          _this.onDragStart = function (columnName) {
              _this.draggingColumnName = columnName;
          };
          _this.onDragEnd = function () {
              _this.draggingColumnName = null;
              var _a = _this.state, sourceColumnName = _a.sourceColumnName, targetItemIndex = _a.targetItemIndex;
              var onGroup = _this.props.onGroup;
              if (sourceColumnName && targetItemIndex === -1) {
                  onGroup({
                      columnName: sourceColumnName,
                  });
              }
              _this.resetState();
          };
          return _this;
      }
      GroupPanelLayoutBase.prototype.resetState = function () {
          var onGroupDraftCancel = this.props.onGroupDraftCancel;
          onGroupDraftCancel();
          this.setState({
              sourceColumnName: null,
              targetItemIndex: -1,
          });
      };
      GroupPanelLayoutBase.prototype.render = function () {
          var _this = this;
          var _a = this.props, items = _a.items, EmptyMessage = _a.emptyMessageComponent, Container = _a.containerComponent, Item = _a.itemComponent, draggingEnabled = _a.draggingEnabled, isColumnGroupingEnabled = _a.isColumnGroupingEnabled;
          this.itemRefs = [];
          var groupPanel = (items.length ? (react_9(Container, null, items.map(function (item) {
              var columnName = item.column.name;
              return (react_9(ItemLayout, { key: columnName, ref: function (element) { return element && _this.itemRefs.push(element); }, item: item, itemComponent: Item, draggingEnabled: draggingEnabled && isColumnGroupingEnabled(columnName), onDragStart: function () { return _this.onDragStart(columnName); }, onDragEnd: _this.onDragEnd }));
          }))) : (react_9(EmptyMessage, null)));
          return draggingEnabled
              ? (react_9(DropTarget, { onEnter: function (args) { return _this.handleDragEvent(_this.onEnter, args); }, onOver: function (args) { return _this.handleDragEvent(_this.onOver, args); }, onLeave: function (args) { return _this.handleDragEvent(_this.onLeave, args); }, onDrop: function (args) { return _this.handleDragEvent(_this.onDrop, args); } }, groupPanel))
              : groupPanel;
      };
      GroupPanelLayoutBase.defaultProps = defaultProps$1$1;
      return GroupPanelLayoutBase;
  }(react_4));
  /** @internal */
  var GroupPanelLayout = GroupPanelLayoutBase;

  var defaultMessages$4 = {
      groupByColumn: 'Drag a column header here to group by that column',
  };
  var defaultProps$2$1 = {
      showSortingControls: false,
      showGroupingControls: false,
      messages: {},
  };
  var GroupingPanelRaw = /*#__PURE__*/ (function (_super) {
      __extends$1(GroupingPanelRaw, _super);
      function GroupingPanelRaw() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      GroupingPanelRaw.prototype.render = function () {
          var _a = this.props, LayoutComponent = _a.layoutComponent, Container = _a.containerComponent, Item = _a.itemComponent, EmptyMessage = _a.emptyMessageComponent, showSortingControls = _a.showSortingControls, showGroupingControls = _a.showGroupingControls, messages = _a.messages;
          var getMessage = getMessagesFormatter(__assign$2({}, defaultMessages$4, messages));
          var EmptyMessagePlaceholder = function () { return (react_9(EmptyMessage, { getMessage: getMessage })); };
          var ItemPlaceholder = function (_a) {
              var item = _a.item;
              var columnName = item.column.name;
              return (react_9(TemplateConnector, null, function (_a, _b) {
                  var sorting = _a.sorting, isColumnSortingEnabled = _a.isColumnSortingEnabled, isColumnGroupingEnabled = _a.isColumnGroupingEnabled;
                  var changeColumnGrouping = _b.changeColumnGrouping, changeColumnSorting = _b.changeColumnSorting;
                  var sortingEnabled = isColumnSortingEnabled && isColumnSortingEnabled(columnName);
                  var groupingEnabled = isColumnGroupingEnabled && isColumnGroupingEnabled(columnName);
                  return (react_9(Item, { item: item, sortingEnabled: sortingEnabled, groupingEnabled: groupingEnabled, showSortingControls: showSortingControls, sortingDirection: showSortingControls
                          ? getColumnSortingDirection(sorting, columnName) : undefined, showGroupingControls: showGroupingControls, onGroup: function () { return changeColumnGrouping({ columnName: columnName }); }, onSort: function (_a) {
                          var direction = _a.direction, keepOther = _a.keepOther;
                          return changeColumnSorting({ columnName: columnName, direction: direction, keepOther: keepOther });
                      } }));
              }));
          };
          return (react_9(Plugin, { name: "GroupingPanel", dependencies: [
                  { name: 'GroupingState' },
                  { name: 'Toolbar' },
                  { name: 'SortingState', optional: !showSortingControls },
              ] },
              react_9(Template, { name: "toolbarContent" },
                  react_9(TemplateConnector, null, function (_a, _b) {
                      var columns = _a.columns, grouping = _a.grouping, draftGrouping = _a.draftGrouping, draggingEnabled = _a.draggingEnabled, isColumnGroupingEnabled = _a.isColumnGroupingEnabled;
                      var changeColumnGrouping = _b.changeColumnGrouping, draftColumnGrouping = _b.draftColumnGrouping, cancelColumnGroupingDraft = _b.cancelColumnGroupingDraft;
                      return (react_9(LayoutComponent, { items: groupingPanelItems(columns, grouping, draftGrouping), isColumnGroupingEnabled: isColumnGroupingEnabled, draggingEnabled: draggingEnabled, onGroup: changeColumnGrouping, onGroupDraft: draftColumnGrouping, onGroupDraftCancel: cancelColumnGroupingDraft, itemComponent: ItemPlaceholder, emptyMessageComponent: EmptyMessagePlaceholder, containerComponent: Container }));
                  }),
                  react_9(TemplatePlaceholder, null))));
      };
      GroupingPanelRaw.defaultProps = defaultProps$2$1;
      GroupingPanelRaw.components = {
          layoutComponent: 'Layout',
          containerComponent: 'Container',
          itemComponent: 'Item',
          emptyMessageComponent: 'EmptyMessage',
      };
      return GroupingPanelRaw;
  }(react_4));
  /***
   * A plugin that renders the Grouping Panel in the Grid's header. This panel displays grouped
   * columns and allows a user to modify grouping options.Optionally, the plugin allows an end-user
   * to change grouped columns' sorting order and render sorting indicators.
   * */
  var GroupingPanel = withComponents({ Layout: GroupPanelLayout })(GroupingPanelRaw);

  var DataTypeProviderBase = /*#__PURE__*/ (function (_super) {
      __extends$1(DataTypeProviderBase, _super);
      function DataTypeProviderBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      DataTypeProviderBase.prototype.render = function () {
          var _a = this.props, columnNames = _a.for, Formatter = _a.formatterComponent, Editor = _a.editorComponent, availableFilterOperations = _a.availableFilterOperations;
          var getAvailableFilterOperationsComputed = function (_a) {
              var getAvailableFilterOperations = _a.getAvailableFilterOperations;
              return getAvailableFilterOperationsGetter(getAvailableFilterOperations, availableFilterOperations, columnNames);
          };
          return (react_9(Plugin, { name: "DataTypeProvider" },
              react_9(Getter, { name: "getAvailableFilterOperations", computed: getAvailableFilterOperationsComputed }),
              Formatter
                  ? (react_9(Template, { name: "valueFormatter", predicate: function (_a) {
                          var column = _a.column;
                          return columnNames.includes(column.name);
                      } }, function (params) { return react_9(Formatter, __assign$2({}, params)); }))
                  : null,
              Editor
                  ? (react_9(Template, { name: "valueEditor", predicate: function (_a) {
                          var column = _a.column;
                          return columnNames.includes(column.name);
                      } }, function (params) { return react_9(Editor, __assign$2({}, params)); }))
                  : null));
      };
      return DataTypeProviderBase;
  }(react_4));
  // tslint:disable-next-line: max-line-length
  /** A plugin that allows you to customize formatting options and editors depending on the data type. */
  var DataTypeProvider = DataTypeProviderBase;

  var pluginDependencies$g = [
      { name: 'Table' },
  ];
  var defaultMessages$5 = {
      noColumns: 'Nothing to show',
  };
  var visibleTableColumnsComputed = function (_a) {
      var tableColumns = _a.tableColumns, hiddenColumnNames = _a.hiddenColumnNames;
      return visibleTableColumns(tableColumns, hiddenColumnNames);
  };
  var columnExtensionValueGetter$4 = function (columnExtensions, defaultValue) { return getColumnExtensionValueGetter(columnExtensions, 'togglingEnabled', defaultValue); };
  // tslint:disable-next-line: max-line-length
  var TableColumnVisibilityBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableColumnVisibilityBase, _super);
      function TableColumnVisibilityBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              hiddenColumnNames: props.hiddenColumnNames || props.defaultHiddenColumnNames,
          };
          var stateHelper = createStateHelper(_this, {
              hiddenColumnNames: function () {
                  var onHiddenColumnNamesChange = _this.props.onHiddenColumnNamesChange;
                  return onHiddenColumnNamesChange;
              },
          });
          _this.toggleColumnVisibility = stateHelper.applyFieldReducer.bind(stateHelper, 'hiddenColumnNames', toggleColumn);
          return _this;
      }
      TableColumnVisibilityBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.hiddenColumnNames, hiddenColumnNames = _a === void 0 ? prevState.hiddenColumnNames : _a;
          return {
              hiddenColumnNames: hiddenColumnNames,
          };
      };
      TableColumnVisibilityBase.prototype.render = function () {
          var _a = this.props, EmptyMessage = _a.emptyMessageComponent, messages = _a.messages;
          var getMessage = getMessagesFormatter(__assign$2({}, defaultMessages$5, messages));
          var hiddenColumnNames = this.state.hiddenColumnNames;
          var _b = this.props, columnExtensions = _b.columnExtensions, columnTogglingEnabled = _b.columnTogglingEnabled;
          return (react_9(Plugin, { name: "TableColumnVisibility", dependencies: pluginDependencies$g },
              react_9(Getter, { name: "hiddenColumnNames", value: hiddenColumnNames }),
              react_9(Getter, { name: "tableColumns", computed: visibleTableColumnsComputed }),
              react_9(Getter, { name: "isColumnTogglingEnabled", value: columnExtensionValueGetter$4(columnExtensions, columnTogglingEnabled) }),
              react_9(Action, { name: "toggleColumnVisibility", action: this.toggleColumnVisibility }),
              react_9(Template, { name: "table" }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var tableColumns = _a.tableColumns;
                  return (tableDataColumnsExist(tableColumns)
                      ? react_9(TemplatePlaceholder, null)
                      : (react_9(EmptyMessage, __assign$2({ getMessage: getMessage }, params))));
              })); })));
      };
      TableColumnVisibilityBase.defaultProps = {
          defaultHiddenColumnNames: [],
          messages: {},
          columnTogglingEnabled: true,
      };
      TableColumnVisibilityBase.components = {
          emptyMessageComponent: 'EmptyMessage',
      };
      return TableColumnVisibilityBase;
  }(react_4));
  TableColumnVisibilityBase.components = {
      emptyMessageComponent: 'EmptyMessage',
  };
  /* tslint:disable: max-line-length */
  /** A plugin that manages Grid columns' visibility. */
  var TableColumnVisibility = TableColumnVisibilityBase;
  /* tslint:enable: max-line-length */

  var ToolbarBase = /*#__PURE__*/ (function (_super) {
      __extends$1(ToolbarBase, _super);
      function ToolbarBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      ToolbarBase.prototype.render = function () {
          var _a = this.props, Root = _a.rootComponent, FlexibleSpaceComponent = _a.flexibleSpaceComponent;
          return (react_9(Plugin, { name: "Toolbar" },
              react_9(Template, { name: "header" },
                  react_9(Root, null,
                      react_9(TemplatePlaceholder, { name: "toolbarContent" })),
                  react_9(TemplatePlaceholder, null)),
              react_9(Template, { name: "toolbarContent" },
                  react_9(FlexibleSpaceComponent, null))));
      };
      ToolbarBase.components = {
          rootComponent: 'Root',
          flexibleSpaceComponent: 'FlexibleSpace',
      };
      return ToolbarBase;
  }(react_4));
  /** A plugin that renders the Grid toolbar. */
  var Toolbar = ToolbarBase;

  var TreeDataStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TreeDataStateBase, _super);
      function TreeDataStateBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds,
          };
          var stateHelper = createStateHelper(_this, {
              expandedRowIds: function () {
                  var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;
                  return onExpandedRowIdsChange;
              },
          });
          _this.toggleRowExpanded = stateHelper.applyFieldReducer
              .bind(stateHelper, 'expandedRowIds', toggleRowExpanded);
          return _this;
      }
      TreeDataStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.expandedRowIds, expandedRowIds = _a === void 0 ? prevState.expandedRowIds : _a;
          return {
              expandedRowIds: expandedRowIds,
          };
      };
      TreeDataStateBase.prototype.render = function () {
          var expandedRowIds = this.state.expandedRowIds;
          return (react_9(Plugin, { name: "TreeDataState" },
              react_9(Getter, { name: "expandedRowIds", value: expandedRowIds }),
              ' ',
              react_9(Action, { name: "toggleRowExpanded", action: this.toggleRowExpanded })));
      };
      TreeDataStateBase.defaultProps = {
          defaultExpandedRowIds: [],
      };
      return TreeDataStateBase;
  }(react_4));
  /** A plugin that manages the expanded state for tree rows. */
  var TreeDataState = TreeDataStateBase;

  var pluginDependencies$h = [
      { name: 'TreeDataState' },
  ];
  var expandedTreeRowsComputed = function (_a) {
      var rows = _a.rows, getRowId = _a.getRowId, expandedRowIds = _a.expandedRowIds;
      return expandedTreeRows(rows, getRowId, expandedRowIds);
  };
  var getRowIdComputed$1 = function (_a) {
      var getRowId = _a.getRowId, rows = _a.rows;
      return customTreeRowIdGetter(getRowId, rows);
  };
  var getRowLevelKeyComputed = function (_a) {
      var getRowLevelKey = _a.getRowLevelKey, rows = _a.rows;
      return customTreeRowLevelKeyGetter(getRowLevelKey, rows);
  };
  var isTreeRowLeafComputed = function (_a) {
      var rows = _a.rows;
      return isTreeRowLeafGetter(rows);
  };
  var getTreeRowLevelComputed = function (_a) {
      var rows = _a.rows;
      return getTreeRowLevelGetter(rows);
  };
  var collapsedTreeRowsGetterComputed = function (_a) {
      var rows = _a.rows, getCollapsedRows = _a.getCollapsedRows;
      return collapsedTreeRowsGetter(getCollapsedRows, rows);
  };
  var unwrappedTreeRowsComputed = function (_a) {
      var rows = _a.rows;
      return unwrappedCustomTreeRows(rows);
  };
  var CustomTreeDataBase = /*#__PURE__*/ (function (_super) {
      __extends$1(CustomTreeDataBase, _super);
      function CustomTreeDataBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      CustomTreeDataBase.prototype.render = function () {
          var getChildRows = this.props.getChildRows;
          var treeRowsComputed = function (_a) {
              var rows = _a.rows;
              return customTreeRowsWithMeta(rows, getChildRows);
          };
          return (react_9(Plugin, { name: "CustomTreeData", dependencies: pluginDependencies$h },
              react_9(Getter, { name: "rows", computed: treeRowsComputed }),
              react_9(Getter, { name: "getRowId", computed: getRowIdComputed$1 }),
              react_9(Getter, { name: "getRowLevelKey", computed: getRowLevelKeyComputed }),
              react_9(Getter, { name: "isTreeRowLeaf", computed: isTreeRowLeafComputed }),
              react_9(Getter, { name: "getTreeRowLevel", computed: getTreeRowLevelComputed }),
              react_9(Getter, { name: "rows", computed: expandedTreeRowsComputed }),
              react_9(Getter, { name: "getCollapsedRows", computed: collapsedTreeRowsGetterComputed }),
              react_9(Getter, { name: "rows", computed: unwrappedTreeRowsComputed })));
      };
      return CustomTreeDataBase;
  }(react_4));
  /***
   * A plugin that converts custom formatted tree data to a supported format and performs
   * local row expanding/collapsing.
   * */
  var CustomTreeData = CustomTreeDataBase;

  var TableTreeColumnBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableTreeColumnBase, _super);
      function TableTreeColumnBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      TableTreeColumnBase.prototype.render = function () {
          var _a = this.props, forColumnName = _a.for, showSelectionControls = _a.showSelectionControls, showSelectAll = _a.showSelectAll, Indent = _a.indentComponent, ExpandButton = _a.expandButtonComponent, Checkbox = _a.checkboxComponent, Content = _a.contentComponent, Cell = _a.cellComponent;
          return (react_9(Plugin, { name: "TableTreeColumn", dependencies: [
                  { name: 'DataTypeProvider', optional: true },
                  { name: 'TreeDataState' },
                  { name: 'SelectionState', optional: !showSelectionControls },
                  { name: 'IntegratedSelection', optional: !showSelectAll },
                  { name: 'Table' },
                  { name: 'TableHeaderRow', optional: true },
              ] },
              react_9(Getter, { name: "tableTreeColumnName", value: forColumnName }),
              react_9(Template, { name: "tableHeaderCellBefore", predicate: function (_a) {
                      var column = _a.column;
                      return column.name === forColumnName;
                  } },
                  react_9(ExpandButton, { visible: false, expanded: false, onToggle: function () { } }),
                  showSelectionControls && showSelectAll && (react_9(TemplateConnector, null, function (_a, _b) {
                      var selectAllAvailable = _a.selectAllAvailable, allSelected = _a.allSelected, someSelected = _a.someSelected;
                      var toggleSelectAll = _b.toggleSelectAll;
                      return (react_9(Checkbox, { disabled: !selectAllAvailable, checked: allSelected, indeterminate: someSelected, onChange: toggleSelectAll }));
                  }))),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isTreeTableCell(tableRow, tableColumn, forColumnName);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a, _b) {
                  var getCollapsedRows = _a.getCollapsedRows, expandedRowIds = _a.expandedRowIds, selection = _a.selection, isTreeRowLeaf = _a.isTreeRowLeaf, getTreeRowLevel = _a.getTreeRowLevel, getCellValue = _a.getCellValue;
                  var toggleRowExpanded = _b.toggleRowExpanded, toggleSelection = _b.toggleSelection;
                  var _c = params.tableRow, row = _c.row, rowId = _c.rowId;
                  var columnName = params.tableColumn.column.name;
                  var value = getCellValue(row, columnName);
                  var collapsedRows = getCollapsedRows(row);
                  return (react_9(TemplatePlaceholder, { name: "valueFormatter", params: {
                          value: value,
                          row: row,
                          column: params.tableColumn.column,
                      } }, function (content) { return (react_9(Cell, __assign$2({}, params, { row: row, column: params.tableColumn.column, value: value }),
                      react_9(Indent, { level: getTreeRowLevel(row) }),
                      react_9(ExpandButton, { visible: collapsedRows ? !!collapsedRows.length : !isTreeRowLeaf(row), expanded: expandedRowIds.indexOf(rowId) > -1, onToggle: function () { return toggleRowExpanded({ rowId: rowId }); } }),
                      showSelectionControls && (react_9(Checkbox, { disabled: false, checked: selection.indexOf(rowId) > -1, indeterminate: false, onChange: function () { return toggleSelection({ rowIds: [rowId] }); } })),
                      react_9(Content, null, content || value))); }));
              })); })));
      };
      TableTreeColumnBase.defaultProps = {
          showSelectionControls: false,
          showSelectAll: false,
      };
      TableTreeColumnBase.components = {
          cellComponent: 'Cell',
          contentComponent: 'Content',
          indentComponent: 'Indent',
          expandButtonComponent: 'ExpandButton',
          checkboxComponent: 'Checkbox',
      };
      return TableTreeColumnBase;
  }(react_4));
  /** A plugin that renders a table column with a toggle button and sorting indicators. */
  var TableTreeColumn = TableTreeColumnBase;

  var SearchStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(SearchStateBase, _super);
      function SearchStateBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              value: props.value || props.defaultValue,
          };
          var stateHelper = createStateHelper(_this, {
              value: function () {
                  var onValueChange = _this.props.onValueChange;
                  return onValueChange;
              },
          });
          _this.changeValue = stateHelper.applyFieldReducer
              .bind(stateHelper, 'value', changeSearchValue);
          return _this;
      }
      SearchStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.value, value = _a === void 0 ? prevState.value : _a;
          return {
              value: value,
          };
      };
      SearchStateBase.prototype.render = function () {
          var value = this.state.value;
          var filterExpressionComputed = function (_a) {
              var filterExpression = _a.filterExpression, columns = _a.columns;
              return searchFilterExpression(value, columns, filterExpression);
          };
          return (react_9(Plugin, { name: "SearchState" },
              react_9(Getter, { name: "filterExpression", computed: filterExpressionComputed }),
              react_9(Getter, { name: "searchValue", value: value }),
              react_9(Action, { name: "changeSearchValue", action: this.changeValue })));
      };
      SearchStateBase.defaultProps = {
          defaultValue: '',
      };
      return SearchStateBase;
  }(react_4));
  /** A plugin that manages the search state. */
  var SearchState = SearchStateBase;

  var pluginDependencies$i = [
      { name: 'Toolbar' },
      { name: 'SearchState' },
  ];
  var defaultMessages$6 = {
      searchPlaceholder: 'Search...',
  };
  var SearchPanelBase = /*#__PURE__*/ (function (_super) {
      __extends$1(SearchPanelBase, _super);
      function SearchPanelBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      SearchPanelBase.prototype.render = function () {
          var _a = this.props, Input = _a.inputComponent, messages = _a.messages;
          var getMessage = getMessagesFormatter(__assign$2({}, defaultMessages$6, messages));
          return (react_9(Plugin, { name: "SearchPanel", dependencies: pluginDependencies$i },
              react_9(Template, { name: "toolbarContent" },
                  react_9(TemplatePlaceholder, null),
                  react_9(TemplateConnector, null, function (_a, _b) {
                      var searchValue = _a.searchValue;
                      var changeSearchValue = _b.changeSearchValue;
                      return (react_9(Input, { value: searchValue, onValueChange: changeSearchValue, getMessage: getMessage }));
                  }))));
      };
      SearchPanelBase.defaultProps = {
          messages: {},
      };
      SearchPanelBase.components = {
          inputComponent: 'Input',
      };
      return SearchPanelBase;
  }(react_4));
  /** A plugin that renders the Search Panel. */
  var SearchPanel = SearchPanelBase;

  var tableHeaderRowsComputed$2 = function (_a) {
      var tableHeaderRows = _a.tableHeaderRows;
      return tableHeaderRowsWithFixed(tableHeaderRows);
  };
  var tableHeaderColumnChainsComputed = function (_a) {
      var tableColumns = _a.tableColumns, tableHeaderRows = _a.tableHeaderRows, tableHeaderColumnChains = _a.tableHeaderColumnChains;
      return tableHeaderColumnChainsWithFixed(tableHeaderColumnChains, tableHeaderRows, tableColumns);
  };
  var CellPlaceholder$2 = function (props) { return react_9(TemplatePlaceholder, { params: props }); };
  var pluginDependencies$j = [
      { name: 'Table' },
      { name: 'TableBandHeader', optional: true },
      { name: 'TableColumnReordering', optional: true },
      { name: 'TableEditColumn', optional: true },
      { name: 'TableEditRow', optional: true },
      { name: 'TableFilterRow', optional: true },
      { name: 'TableHeaderRow', optional: true },
      { name: 'TableSelection', optional: true },
      { name: 'TableSummaryRow', optional: true },
      { name: 'TableTreeColumn', optional: true },
  ];
  // tslint:disable-next-line: max-line-length
  var TableFixedColumnsBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableFixedColumnsBase, _super);
      function TableFixedColumnsBase(props) {
          var _this = _super.call(this, props) || this;
          _this.state = {
              tableColumnDimensions: {},
          };
          return _this;
      }
      TableFixedColumnsBase.prototype.handleListenerSizeChange = function (key, width) {
          this.setState(function (state) {
              var _a;
              return ({
                  tableColumnDimensions: __assign$2({}, state.tableColumnDimensions, (_a = {}, _a[key] = width, _a)),
              });
          });
      };
      TableFixedColumnsBase.prototype.render = function () {
          var _this = this;
          var _a = this.props, Cell = _a.cellComponent, ListenerRow = _a.listenerRowComponent, ListenerCell = _a.listenerCellComponent;
          var leftColumns = this.props.leftColumns;
          var rightColumns = this.props.rightColumns;
          var tableColumnsComputed = function (_a) {
              var tableColumns = _a.tableColumns;
              return tableColumnsWithFixed(tableColumns, leftColumns, rightColumns);
          };
          return (react_9(Plugin, { name: "TableFixedColumns", dependencies: pluginDependencies$j },
              react_9(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed$2 }),
              react_9(Getter, { name: "tableColumns", computed: tableColumnsComputed }),
              react_9(Getter, { name: "tableHeaderColumnChains", computed: tableHeaderColumnChainsComputed }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableColumn = _a.tableColumn;
                      return !!tableColumn.fixed;
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var tableColumns = _a.tableColumns, tableHeaderColumnChains = _a.tableHeaderColumnChains;
                  var tableColumnDimensions = _this.state.tableColumnDimensions;
                  var fixedColumnProps = calculateFixedColumnProps(params, { leftColumns: leftColumns, rightColumns: rightColumns }, tableColumns, tableColumnDimensions, tableHeaderColumnChains);
                  return (react_9(Cell, __assign$2({}, params, fixedColumnProps, { component: CellPlaceholder$2 })));
              })); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isFixedTableRow(tableRow);
                  } }, function (params) { return (react_9(ListenerRow, __assign$2({}, params))); }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isFixedTableRow(tableRow);
                  } }, function (params) { return (react_9(ListenerCell, __assign$2({}, params, { listen: !!params.tableColumn.fixed, onSizeChange: function (_a) {
                      var width = _a.width;
                      return _this.handleListenerSizeChange(params.tableColumn.key, width);
                  } }))); })));
      };
      TableFixedColumnsBase.components = {
          cellComponent: 'Cell',
          listenerRowComponent: 'ListenerRow',
          listenerCellComponent: 'ListenerCell',
      };
      TableFixedColumnsBase.defaultProps = {
          leftColumns: [],
          rightColumns: [],
      };
      return TableFixedColumnsBase;
  }(react_4));
  /** A plugin that enables you to fix columns to the left and right sides of the grid. */
  var TableFixedColumns = TableFixedColumnsBase;

  var SummaryStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(SummaryStateBase, _super);
      function SummaryStateBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      SummaryStateBase.prototype.render = function () {
          var _a = this.props, totalItems = _a.totalItems, groupItems = _a.groupItems, treeItems = _a.treeItems;
          return (react_9(Plugin, { name: "SummaryState" },
              react_9(Getter, { name: "totalSummaryItems", value: totalItems }),
              react_9(Getter, { name: "groupSummaryItems", value: groupItems }),
              react_9(Getter, { name: "treeSummaryItems", value: treeItems })));
      };
      return SummaryStateBase;
  }(react_4));
  /** A plugin that provides items for total, group, and tree summaries. */
  var SummaryState = SummaryStateBase;

  var pluginDependencies$k = [
      { name: 'SummaryState' },
  ];
  var IntegratedSummaryBase = /*#__PURE__*/ (function (_super) {
      __extends$1(IntegratedSummaryBase, _super);
      function IntegratedSummaryBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      IntegratedSummaryBase.prototype.render = function () {
          var calculator = this.props.calculator;
          var totalSummaryValuesComputed = function (_a) {
              var rows = _a.rows, totalSummaryItems = _a.totalSummaryItems, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getCollapsedRows = _a.getCollapsedRows;
              return totalSummaryValues(rows, totalSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator);
          };
          var groupSummaryValuesComputed = function (_a) {
              var rows = _a.rows, groupSummaryItems = _a.groupSummaryItems, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow;
              return groupSummaryValues(rows, groupSummaryItems, getCellValue, getRowLevelKey, isGroupRow, calculator);
          };
          var treeSummaryValuesComputed = function (_a) {
              var rows = _a.rows, treeSummaryItems = _a.treeSummaryItems, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getRowId = _a.getRowId;
              return treeSummaryValues(rows, treeSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator);
          };
          return (react_9(Plugin, { name: "IntegratedSummary", dependencies: pluginDependencies$k },
              react_9(Getter, { name: "totalSummaryValues", computed: totalSummaryValuesComputed }),
              react_9(Getter, { name: "groupSummaryValues", computed: groupSummaryValuesComputed }),
              react_9(Getter, { name: "treeSummaryValues", computed: treeSummaryValuesComputed })));
      };
      IntegratedSummaryBase.defaultCalculator = defaultSummaryCalculator;
      return IntegratedSummaryBase;
  }(react_4));
  /** A plugin that performs a built-in data summary calculation. */
  var IntegratedSummary = IntegratedSummaryBase;

  var pluginDependencies$l = [
      { name: 'SummaryState' },
  ];
  var CustomSummaryBase = /*#__PURE__*/ (function (_super) {
      __extends$1(CustomSummaryBase, _super);
      function CustomSummaryBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      CustomSummaryBase.prototype.render = function () {
          var _a = this.props, totalValues = _a.totalValues, groupValues = _a.groupValues, treeValues = _a.treeValues;
          return (react_9(Plugin, { name: "CustomSummary", dependencies: pluginDependencies$l },
              react_9(Getter, { name: "totalSummaryValues", value: totalValues }),
              react_9(Getter, { name: "groupSummaryValues", value: groupValues }),
              react_9(Getter, { name: "treeSummaryValues", value: treeValues })));
      };
      return CustomSummaryBase;
  }(react_4));
  /** A plugin that allows you to calculate a custom summary. */
  var CustomSummary = CustomSummaryBase;

  var dependencies$1 = [
      { name: 'DataTypeProvider', optional: true },
      { name: 'SummaryState' },
      { name: 'CustomSummary', optional: true },
      { name: 'IntegratedSummary', optional: true },
      { name: 'Table' },
      { name: 'TableTreeColumn', optional: true },
  ];
  var defaultMessages$7 = {
      sum: 'Sum',
      min: 'Min',
      max: 'Max',
      avg: 'Avg',
      count: 'Count',
  };
  var tableBodyRowsComputed$2 = function (_a) {
      var tableBodyRows = _a.tableBodyRows, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getRowId = _a.getRowId;
      return tableRowsWithSummaries(tableBodyRows, getRowLevelKey, isGroupRow, getRowId);
  };
  var tableFooterRowsComputed = function (_a) {
      var tableFooterRows = _a.tableFooterRows;
      return tableRowsWithTotalSummaries(tableFooterRows);
  };
  var defaultTypelessSummaries = ['count'];
  var TableSummaryRowBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableSummaryRowBase, _super);
      function TableSummaryRowBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      TableSummaryRowBase.prototype.renderContent = function (column, columnSummaries) {
          var _a = this.props, formatlessSummaryTypes = _a.formatlessSummaryTypes, Item = _a.itemComponent, messages = _a.messages;
          var getMessage = getMessagesFormatter(__assign$2({}, defaultMessages$7, messages));
          var SummaryItem = function (_a) {
              var summary = _a.summary, children = _a.children;
              return (react_9(Item, { getMessage: getMessage, type: summary.type, value: summary.value }, children || String(summary.value)));
          };
          return (react_9(react_3, null, columnSummaries.map(function (summary) {
              if (summary.value === null
                  || formatlessSummaryTypes.includes(summary.type)
                  || defaultTypelessSummaries.includes(summary.type)) {
                  return react_9(SummaryItem, { key: summary.type, summary: summary });
              }
              return (react_9(TemplatePlaceholder, { key: summary.type, name: "valueFormatter", params: {
                      column: column,
                      value: summary.value,
                  } }, function (content) { return (react_9(SummaryItem, { summary: summary }, content)); }));
          })));
      };
      TableSummaryRowBase.prototype.render = function () {
          var _this = this;
          var _a = this.props, TotalRow = _a.totalRowComponent, GroupRow = _a.groupRowComponent, TreeRow = _a.treeRowComponent, TotalCell = _a.totalCellComponent, GroupCell = _a.groupCellComponent, TreeCell = _a.treeCellComponent, TreeColumnCell = _a.treeColumnCellComponent, TreeColumnContent = _a.treeColumnContentComponent, TreeColumnIndent = _a.treeColumnIndentComponent;
          return (react_9(Plugin, { name: "TableSummaryRow", dependencies: dependencies$1 },
              react_9(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed$2 }),
              react_9(Getter, { name: "tableFooterRows", computed: tableFooterRowsComputed }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isTotalSummaryTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var totalSummaryItems = _a.totalSummaryItems, totalSummaryValues = _a.totalSummaryValues;
                  var columnSummaries = getColumnSummaries(totalSummaryItems, params.tableColumn.column.name, totalSummaryValues);
                  return (react_9(TotalCell, __assign$2({}, params, { column: params.tableColumn.column }), _this.renderContent(params.tableColumn.column, columnSummaries)));
              })); }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isGroupSummaryTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var groupSummaryItems = _a.groupSummaryItems, groupSummaryValues = _a.groupSummaryValues;
                  var columnSummaries = getColumnSummaries(groupSummaryItems, params.tableColumn.column.name, groupSummaryValues[params.tableRow.row.compoundKey]);
                  return (react_9(GroupCell, __assign$2({}, params, { column: params.tableColumn.column }), _this.renderContent(params.tableColumn.column, columnSummaries)));
              })); }),
              react_9(Template, { name: "tableCell", predicate: function (_a) {
                      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                      return isTreeSummaryTableCell(tableRow, tableColumn);
                  } }, function (params) { return (react_9(TemplateConnector, null, function (_a) {
                  var treeSummaryItems = _a.treeSummaryItems, treeSummaryValues = _a.treeSummaryValues, tableTreeColumnName = _a.tableTreeColumnName, getRowId = _a.getRowId, getTreeRowLevel = _a.getTreeRowLevel;
                  var columnSummaries = getColumnSummaries(treeSummaryItems, params.tableColumn.column.name, treeSummaryValues[getRowId(params.tableRow.row)]);
                  if (tableTreeColumnName === params.tableColumn.column.name) {
                      return (react_9(TreeColumnCell, __assign$2({}, params, { column: params.tableColumn.column }),
                          react_9(TreeColumnIndent, { level: getTreeRowLevel(params.tableRow.row) }),
                          react_9(TreeColumnContent, null, _this.renderContent(params.tableColumn.column, columnSummaries))));
                  }
                  return (react_9(TreeCell, __assign$2({}, params, { column: params.tableColumn.column }), _this.renderContent(params.tableColumn.column, columnSummaries)));
              })); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isTotalSummaryTableRow(tableRow);
                  } }, function (params) { return (react_9(TotalRow, __assign$2({}, params))); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isGroupSummaryTableRow(tableRow);
                  } }, function (params) { return (react_9(GroupRow, __assign$2({}, params))); }),
              react_9(Template, { name: "tableRow", predicate: function (_a) {
                      var tableRow = _a.tableRow;
                      return !!isTreeSummaryTableRow(tableRow);
                  } }, function (params) { return (react_9(TreeRow, __assign$2({}, params))); })));
      };
      TableSummaryRowBase.TREE_ROW_TYPE = TABLE_TREE_SUMMARY_TYPE;
      TableSummaryRowBase.GROUP_ROW_TYPE = TABLE_GROUP_SUMMARY_TYPE;
      TableSummaryRowBase.TOTAL_ROW_TYPE = TABLE_TOTAL_SUMMARY_TYPE;
      TableSummaryRowBase.defaultProps = {
          formatlessSummaryTypes: [],
          messages: {},
      };
      TableSummaryRowBase.components = {
          totalRowComponent: 'TotalRow',
          groupRowComponent: 'GroupRow',
          treeRowComponent: 'TreeRow',
          totalCellComponent: 'TotalCell',
          groupCellComponent: 'GroupCell',
          treeCellComponent: 'TreeCell',
          treeColumnCellComponent: 'TableTreeCell',
          treeColumnContentComponent: 'TableTreeContent',
          treeColumnIndentComponent: 'TableTreeIndent',
          itemComponent: 'Item',
      };
      return TableSummaryRowBase;
  }(react_4));
  /** A plugin that renders table rows that display a total, group, and tree summary. */
  var TableSummaryRow = TableSummaryRowBase;

  var virtualRowsComputed = function (_a) {
      var skip = _a.skip, rows = _a.rows, virtualRowsCache = _a.virtualRowsCache;
      return virtualRowsWithCache(skip, rows, virtualRowsCache);
  };
  var rowsComputed = function (_a) {
      var virtualRows = _a.virtualRows;
      return plainRows(virtualRows);
  };
  var loadedRowsStartComputed = function (_a) {
      var virtualRows = _a.virtualRows;
      return loadedRowsStart(virtualRows);
  };
  // tslint:disable-next-line: max-line-length
  var VirtualTableStateBase = /*#__PURE__*/ (function (_super) {
      __extends$1(VirtualTableStateBase, _super);
      function VirtualTableStateBase(props) {
          var _this = _super.call(this, props) || this;
          _this.requestTimer = 0;
          _this.requestNextPageAction = function (_a, _b) {
              var referenceIndex = _a.referenceIndex, forceReload = _a.forceReload;
              var virtualRows = _b.virtualRows, skip = _b.skip;
              var _c = _this.props, pageSize = _c.pageSize, totalRowCount = _c.totalRowCount;
              var newBounds;
              var requestedRange;
              var actualVirtualRows = virtualRows;
              if (forceReload) {
                  newBounds = requestedRange = { start: skip, end: skip + pageSize * 2 };
                  actualVirtualRows = emptyVirtualRows;
              }
              else {
                  var loadedInterval = intervalUtil.getRowsInterval(virtualRows);
                  newBounds = recalculateBounds(referenceIndex, pageSize, totalRowCount);
                  requestedRange = calculateRequestedRange(loadedInterval, newBounds, referenceIndex, pageSize);
              }
              var requestedPageIndex = _this.state.requestedPageIndex;
              var newPageIndex = requestedRange.start;
              var loadCount = (requestedRange.end - requestedRange.start);
              var shouldLoadRows = (newPageIndex !== requestedPageIndex && loadCount > 0) || forceReload;
              if (shouldLoadRows) {
                  _this.requestNextPage(newPageIndex, loadCount, actualVirtualRows, newBounds);
              }
          };
          _this.clearRowsCacheAction = function (_, __, _a) {
              var requestNextPage = _a.requestNextPage;
              _this.setState({
                  virtualRowsCache: emptyVirtualRows,
              });
              requestNextPage({ forceReload: true });
          };
          _this.state = {
              virtualRowsCache: emptyVirtualRows,
              requestedPageIndex: undefined,
              availableRowCount: props.totalRowCount || 0,
          };
          return _this;
      }
      VirtualTableStateBase.prototype.requestNextPage = function (newPageIndex, loadCount, virtualRows, newBounds) {
          var _this = this;
          var _a = this.props, getRows = _a.getRows, infiniteScrolling = _a.infiniteScrolling, totalRowCount = _a.totalRowCount;
          var stateAvailableCount = this.state.availableRowCount;
          if (this.requestTimer !== 0) {
              clearTimeout(this.requestTimer);
          }
          this.requestTimer = window.setTimeout(function () {
              getRows(newPageIndex, loadCount);
              var virtualRowsCache = trimRowsToInterval(virtualRows, newBounds);
              var newRowCount = infiniteScrolling
                  ? Math.max(newBounds.end + loadCount, stateAvailableCount)
                  : totalRowCount;
              _this.setState({
                  virtualRowsCache: virtualRowsCache,
                  availableRowCount: newRowCount,
                  requestedPageIndex: newPageIndex,
              });
          }, 50);
      };
      VirtualTableStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
          var _a = nextProps.availableRowCount, availableRowCount = _a === void 0 ? prevState.availableRowCount : _a;
          return {
              availableRowCount: availableRowCount,
          };
      };
      VirtualTableStateBase.prototype.componentDidMount = function () {
          var _a = this.props, getRows = _a.getRows, pageSize = _a.pageSize, infiniteScrolling = _a.infiniteScrolling, totalRowCount = _a.totalRowCount;
          getRows(0, 2 * pageSize);
          var newRowCount = infiniteScrolling ? 2 * pageSize : totalRowCount;
          this.setState({
              availableRowCount: newRowCount,
          });
      };
      VirtualTableStateBase.prototype.componentWillUnmount = function () {
          if (this.requestTimer !== 0) {
              window.clearTimeout(this.requestTimer);
          }
      };
      VirtualTableStateBase.prototype.render = function () {
          var _a = this.state, virtualRowsCache = _a.virtualRowsCache, stateRowCount = _a.availableRowCount;
          var _b = this.props, skip = _b.skip, pageSize = _b.pageSize, loading = _b.loading, infiniteScrolling = _b.infiniteScrolling, totalRowCount = _b.totalRowCount;
          var availableRowCount = infiniteScrolling ? stateRowCount : totalRowCount;
          return (react_9(Plugin, { name: "VirtualTableState" },
              react_9(Getter, { name: "isDataRemote", value: true }),
              react_9(Getter, { name: "isDataLoading", value: loading }),
              react_9(Getter, { name: "isScrollingInfinite", value: infiniteScrolling }),
              react_9(Getter, { name: "skip", value: skip }),
              react_9(Getter, { name: "virtualRowsCache", value: virtualRowsCache }),
              react_9(Getter, { name: "pageSize", value: pageSize }),
              react_9(Getter, { name: "availableRowCount", value: availableRowCount }),
              react_9(Getter, { name: "virtualRows", computed: virtualRowsComputed }),
              react_9(Getter, { name: "rows", computed: rowsComputed }),
              react_9(Getter, { name: "loadedRowsStart", computed: loadedRowsStartComputed }),
              react_9(Action, { name: "requestNextPage", action: this.requestNextPageAction }),
              react_9(Action, { name: "clearRowCache", action: this.clearRowsCacheAction }),
              react_9(Action, { name: "changeColumnSorting", action: this.clearRowsCacheAction }),
              react_9(Action, { name: "changeColumnFilter", action: this.clearRowsCacheAction })));
      };
      VirtualTableStateBase.defaultProps = {
          pageSize: 100,
      };
      return VirtualTableStateBase;
  }(react_4));
  var VirtualTableState = VirtualTableStateBase;

  /* globals requestAnimationFrame cancelAnimationFrame */
  var TableLayoutBase = /*#__PURE__*/ (function (_super) {
      __extends$1(TableLayoutBase, _super);
      function TableLayoutBase(props) {
          var _this = _super.call(this, props) || this;
          _this.savedOffsetWidth = -1;
          _this.raf = -1;
          _this.state = {
              animationState: new Map(),
          };
          _this.animations = new Map();
          _this.savedScrollWidth = {};
          _this.tableRef = react_11();
          return _this;
      }
      TableLayoutBase.prototype.componentDidUpdate = function (prevProps) {
          var columns = this.props.columns;
          var prevColumns = prevProps.columns;
          var animationState = this.state.animationState;
          var activeAnimationExists = !shallowEqual$1(columns, prevColumns)
              || !!animationState.size || !!this.animations.size;
          // NOTE: animation should be recomputed only when columns are changed or
          // an active animation is in progress. Otherwise it will be recalculated on
          // each scroll event.
          if (activeAnimationExists) {
              this.processAnimation(prevColumns);
          }
      };
      TableLayoutBase.prototype.processAnimation = function (prevColumns) {
          var columns = this.props.columns;
          var tableWidth = this.getTableWidth(prevColumns, columns);
          this.animations = getAnimations(prevColumns, columns, tableWidth, this.animations);
          cancelAnimationFrame(this.raf);
          this.raf = requestAnimationFrame(this.processAnimationFrame.bind(this));
      };
      TableLayoutBase.prototype.getTableWidth = function (prevColumns, columns) {
          var _a = this.tableRef.current, offsetWidth = _a.offsetWidth, scrollWidth = _a.scrollWidth;
          var animationState = this.state.animationState;
          var widthChanged = this.savedOffsetWidth !== offsetWidth
              || !this.savedScrollWidth[columns.length];
          var columnCountChanged = columns.length !== prevColumns.length;
          if (columnCountChanged || (widthChanged && !animationState.size)) {
              this.savedScrollWidth = {};
              this.savedScrollWidth[columns.length] = scrollWidth;
              this.savedOffsetWidth = offsetWidth;
          }
          return this.savedScrollWidth[columns.length];
      };
      TableLayoutBase.prototype.getColumns = function () {
          var columns = this.props.columns;
          var animationState = this.state.animationState;
          var result = columns;
          var isFixedWidth = columns.filter(function (column) { return column.width === undefined; }).length === 0;
          if (isFixedWidth) {
              // presumably a flex column added here instead of in a getter in the Table plugin
              // to make sure that all manipulations on taleColumns have already done earlier
              result = __spread$3(result, [{ key: TABLE_FLEX_TYPE.toString(), type: TABLE_FLEX_TYPE }]);
          }
          if (animationState.size) {
              result = result
                  .map(function (column) { return (animationState.has(column.key)
                  ? __assign$2({}, column, { animationState: animationState.get(column.key) }) : column); });
          }
          return result;
      };
      TableLayoutBase.prototype.processAnimationFrame = function () {
          var animationComponentState = this.state.animationState;
          this.animations = filterActiveAnimations(this.animations);
          if (!this.animations.size) {
              if (animationComponentState.size) {
                  this.setState({ animationState: new Map() });
              }
              return;
          }
          var animationState = evalAnimations(this.animations);
          this.setState({ animationState: animationState });
      };
      TableLayoutBase.prototype.render = function () {
          var _a = this.props, Layout = _a.layoutComponent, minColumnWidth = _a.minColumnWidth, restProps = __rest$1(_a, ["layoutComponent", "minColumnWidth"]);
          var columns = this.getColumns();
          var minWidth = columns
              .map(function (column) { return column.width || (column.type === TABLE_FLEX_TYPE ? 0 : minColumnWidth); })
              .reduce(function (acc, width) { return acc + width; }, 0);
          return (react_9(Layout, __assign$2({}, restProps, { tableRef: this.tableRef, columns: columns, minWidth: minWidth, minColumnWidth: minColumnWidth })));
      };
      return TableLayoutBase;
  }(react_4));
  /** @internal */
  var TableLayout = TableLayoutBase;

  /** @internal */
  var ColumnGroup = /*#__PURE__*/ (function (_super) {
      __extends$1(ColumnGroup, _super);
      function ColumnGroup() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      ColumnGroup.prototype.render = function () {
          var columns = this.props.columns;
          return (react_9("colgroup", null, columns.map(function (_a) {
              var key = _a.key, width = _a.width;
              return (react_9("col", { key: key, style: width !== undefined
                      ? { width: width + "px" }
                      : undefined }));
          })));
      };
      return ColumnGroup;
  }(react_4));

  var getRowStyle = function (_a) {
      var row = _a.row;
      return (row.height !== undefined
          ? ({ height: row.height + "px" })
          : undefined);
  };

  var VirtualRowLayout = /*#__PURE__*/ (function (_super) {
      __extends$1(VirtualRowLayout, _super);
      function VirtualRowLayout() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      VirtualRowLayout.prototype.shouldComponentUpdate = function (nextProps) {
          var _a = this.props, prevCells = _a.cells, prevRow = _a.row;
          var nextCells = nextProps.cells, nextRow = nextProps.row;
          if (prevRow !== nextRow || prevCells.length !== nextCells.length) {
              return true;
          }
          var propsAreNotEqual = nextCells.some(function (nextCell, i) {
              var prevCell = prevCells[i];
              return prevCell.column !== nextCell.column || prevCell.colSpan !== nextCell.colSpan;
          });
          return propsAreNotEqual;
      };
      VirtualRowLayout.prototype.render = function () {
          var _a = this.props, row = _a.row, cells = _a.cells, Row = _a.rowComponent, Cell = _a.cellComponent;
          return (react_9(Row, { tableRow: row, style: getRowStyle({ row: row }) }, cells.map(function (_a) {
              var column = _a.column, colSpan = _a.colSpan;
              return (react_9(Cell, { key: column.key, tableRow: row, tableColumn: column, colSpan: colSpan }));
          })));
      };
      return VirtualRowLayout;
  }(react_2));

  // tslint:disable-next-line: max-line-length
  var VirtualTableLayoutBlock = /*#__PURE__*/ (function (_super) {
      __extends$1(VirtualTableLayoutBlock, _super);
      function VirtualTableLayoutBlock() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      VirtualTableLayoutBlock.prototype.render = function () {
          var _a = this.props, name = _a.name, tableRef = _a.tableRef, collapsedGrid = _a.collapsedGrid, minWidth = _a.minWidth, blockRefsHandler = _a.blockRefsHandler, rowRefsHandler = _a.rowRefsHandler, Table = _a.tableComponent, Body = _a.bodyComponent, cellComponent = _a.cellComponent, rowComponent = _a.rowComponent, marginBottom = _a.marginBottom;
          return (react_9(RefHolder, { ref: function (ref) { return blockRefsHandler(name, ref); } },
              react_9(Table, { tableRef: tableRef, style: __assign$2({ minWidth: minWidth + "px" }, marginBottom ? { marginBottom: marginBottom + "px" } : null) },
                  react_9(ColumnGroup, { columns: collapsedGrid.columns }),
                  react_9(Body, null, collapsedGrid.rows.map(function (visibleRow) {
                      var row = visibleRow.row, _a = visibleRow.cells, cells = _a === void 0 ? [] : _a;
                      return (react_9(RefHolder, { key: row.key, ref: function (ref) { return rowRefsHandler(row, ref); } },
                          react_9(VirtualRowLayout, { row: row, cells: cells, rowComponent: rowComponent, cellComponent: cellComponent })));
                  })))));
      };
      VirtualTableLayoutBlock.defaultProps = {
          blockRefsHandler: function () { },
          rowRefsHandler: function () { },
          tableRef: react_11(),
      };
      return VirtualTableLayoutBlock;
  }(react_4));

  var AUTO_HEIGHT = 'auto';
  var defaultProps$3$1 = {
      headerRows: [],
      footerRows: [],
      headComponent: function () { return null; },
      headTableComponent: function () { return null; },
      footerComponent: function () { return null; },
      footerTableComponent: function () { return null; },
      ensureNextVirtualPage: function () { return void 0; },
  };
  /** @internal */
  // tslint:disable-next-line: max-line-length
  var VirtualTableLayout = /*#__PURE__*/ (function (_super) {
      __extends$1(VirtualTableLayout, _super);
      function VirtualTableLayout(props) {
          var _this = _super.call(this, props) || this;
          _this.rowRefs = new Map();
          _this.blockRefs = new Map();
          _this.isEdgeBrowser = false;
          _this.getRowHeight = function (row) {
              var rowHeights = _this.state.rowHeights;
              var estimatedRowHeight = _this.props.estimatedRowHeight;
              if (row) {
                  var storedHeight = rowHeights.get(row.key);
                  if (storedHeight !== undefined)
                      return storedHeight;
                  if (row.height)
                      return row.height;
              }
              return estimatedRowHeight;
          };
          _this.registerRowRef = function (row, ref) {
              if (ref === null) {
                  _this.rowRefs.delete(row);
              }
              else {
                  _this.rowRefs.set(row, ref);
              }
          };
          _this.registerBlockRef = function (name, ref) {
              if (ref === null) {
                  _this.blockRefs.delete(name);
              }
              else {
                  _this.blockRefs.set(name, ref);
              }
          };
          _this.updateViewport = function (e, visibleRowBoundaries, ensureNextVirtualPage) {
              var node = e.target;
              if (_this.shouldSkipScrollEvent(e)) {
                  return;
              }
              var estimatedRowHeight = _this.props.estimatedRowHeight;
              var containerHeight = _this.state.containerHeight;
              var viewportTop = node.scrollTop, viewportLeft = node.scrollLeft;
              ensureNextVirtualPage({
                  estimatedRowHeight: estimatedRowHeight,
                  visibleRowBoundaries: visibleRowBoundaries,
                  viewportTop: viewportTop,
                  containerHeight: containerHeight,
              });
              _this.setState({
                  viewportTop: viewportTop,
                  viewportLeft: viewportLeft,
              });
          };
          _this.handleContainerSizeChange = function (_a) {
              var width = _a.width, height = _a.height;
              _this.setState({ containerWidth: width, containerHeight: height });
          };
          _this.state = {
              rowHeights: new Map(),
              viewportTop: 0,
              viewportLeft: 0,
              containerWidth: 800,
              containerHeight: 600,
              height: 0,
              headerHeight: 0,
              bodyHeight: 0,
              footerHeight: 0,
          };
          var headerHeight = props.headerRows
              .reduce(function (acc, row) { return acc + _this.getRowHeight(row); }, 0);
          var footerHeight = props.footerRows
              .reduce(function (acc, row) { return acc + _this.getRowHeight(row); }, 0);
          _this.state = __assign$2({ headerHeight: headerHeight,
              footerHeight: footerHeight }, _this.state);
          _this.getColumnWidthGetter = memoize(function (tableColumns, tableWidth, minColumnWidth) { return (getColumnWidthGetter(tableColumns, tableWidth, minColumnWidth)); });
          return _this;
      }
      VirtualTableLayout.prototype.componentDidMount = function () {
          this.isEdgeBrowser = isEdgeBrowser();
          this.storeRowHeights();
          this.storeBlockHeights();
      };
      VirtualTableLayout.prototype.componentDidUpdate = function () {
          this.storeRowHeights();
          this.storeBlockHeights();
      };
      VirtualTableLayout.getDerivedStateFromProps = function (nextProps, prevState) {
          var prevRowHeight = prevState.rowHeights;
          var rowHeights = __spread$3(nextProps.headerRows, nextProps.bodyRows, nextProps.footerRows).reduce(function (acc, row) {
              var rowHeight = prevRowHeight.get(row.key);
              if (rowHeight !== undefined) {
                  acc.set(row.key, rowHeight);
              }
              return acc;
          }, new Map());
          return { rowHeights: rowHeights };
      };
      VirtualTableLayout.prototype.storeRowHeights = function () {
          var _this = this;
          var rowsWithChangedHeights = Array.from(this.rowRefs.entries())
              .map(function (_a) {
              var _b = __read$3(_a, 2), row = _b[0], ref = _b[1];
              return [row, reactDom_2(ref)];
          })
              .filter(function (_a) {
              var _b = __read$3(_a, 2), node = _b[1];
              return !!node;
          })
              .map(function (_a) {
              var _b = __read$3(_a, 2), row = _b[0], node = _b[1];
              return [row, node.getBoundingClientRect().height];
          })
              .filter(function (_a) {
              var _b = __read$3(_a, 1), row = _b[0];
              return row.type !== TABLE_STUB_TYPE;
          })
              .filter(function (_a) {
              var _b = __read$3(_a, 2), row = _b[0], height = _b[1];
              return height !== _this.getRowHeight(row);
          });
          if (rowsWithChangedHeights.length) {
              var rowHeights_1 = this.state.rowHeights;
              rowsWithChangedHeights
                  .forEach(function (_a) {
                  var _b = __read$3(_a, 2), row = _b[0], height = _b[1];
                  return rowHeights_1.set(row.key, height);
              });
              this.setState({
                  rowHeights: rowHeights_1,
              });
          }
      };
      VirtualTableLayout.prototype.storeBlockHeights = function () {
          var _this = this;
          var getBlockHeight = function (blockName) { return (_this.blockRefs.get(blockName)
              ? reactDom_2(_this.blockRefs.get(blockName)).getBoundingClientRect().height
              : 0); };
          var headerHeight = getBlockHeight('header');
          var bodyHeight = getBlockHeight('body');
          var footerHeight = getBlockHeight('footer');
          var _a = this.state, prevHeaderHeight = _a.headerHeight, prevBodyHeight = _a.bodyHeight, prevFooterHeight = _a.footerHeight;
          if (prevHeaderHeight !== headerHeight
              || prevBodyHeight !== bodyHeight
              || prevFooterHeight !== footerHeight) {
              this.setState({
                  headerHeight: headerHeight,
                  bodyHeight: bodyHeight,
                  footerHeight: footerHeight,
              });
          }
      };
      VirtualTableLayout.prototype.shouldSkipScrollEvent = function (e) {
          var node = e.target;
          // NOTE: prevent nested scroll to update viewport
          if (node !== e.currentTarget) {
              return true;
          }
          // NOTE: prevent iOS to flicker in bounces and correct rendering on high dpi screens
          var correction = this.isEdgeBrowser ? 1 : 0;
          var nodeHorizontalOffset = parseInt(node.scrollLeft + node.clientWidth, 10) - correction;
          var nodeVerticalOffset = parseInt(node.scrollTop + node.clientHeight, 10) - correction;
          if (node.scrollTop < 0
              || node.scrollLeft < 0
              || nodeHorizontalOffset > Math.max(node.scrollWidth, node.clientWidth)
              || nodeVerticalOffset > Math.max(node.scrollHeight, node.clientHeight)) {
              return true;
          }
          return false;
      };
      VirtualTableLayout.prototype.getVisibleBoundaries = function () {
          var _a = this.props, loadedRowsStart = _a.loadedRowsStart, bodyRows = _a.bodyRows, headerRows = _a.headerRows, footerRows = _a.footerRows, estimatedRowHeight = _a.estimatedRowHeight;
          return getVisibleRowsBounds(this.state, { loadedRowsStart: loadedRowsStart, bodyRows: bodyRows, headerRows: headerRows, footerRows: footerRows }, estimatedRowHeight, this.getRowHeight);
      };
      VirtualTableLayout.prototype.getCollapsedGrids = function (visibleRowBoundaries) {
          var _a = this.state, viewportLeft = _a.viewportLeft, containerWidth = _a.containerWidth;
          var _b = this.props, headerRows = _b.headerRows, bodyRows = _b.bodyRows, footerRows = _b.footerRows, columns = _b.columns, loadedRowsStart = _b.loadedRowsStart, totalRowCount = _b.totalRowCount, getCellColSpan = _b.getCellColSpan, minColumnWidth = _b.minColumnWidth;
          var getColumnWidth = this.getColumnWidthGetter(columns, containerWidth, minColumnWidth);
          return getCollapsedGrids({
              headerRows: headerRows,
              bodyRows: bodyRows,
              footerRows: footerRows,
              columns: columns,
              loadedRowsStart: loadedRowsStart,
              totalRowCount: totalRowCount,
              getCellColSpan: getCellColSpan,
              viewportLeft: viewportLeft,
              containerWidth: containerWidth,
              visibleRowBoundaries: visibleRowBoundaries,
              getColumnWidth: getColumnWidth,
              getRowHeight: this.getRowHeight,
          });
      };
      VirtualTableLayout.prototype.render = function () {
          var _this = this;
          var _a = this.props, Container = _a.containerComponent, HeadTable = _a.headTableComponent, FootTable = _a.footerTableComponent, Table = _a.tableComponent, Head = _a.headComponent, Body = _a.bodyComponent, Footer = _a.footerComponent, tableRef = _a.tableRef, height = _a.height, headerRows = _a.headerRows, footerRows = _a.footerRows, ensureNextVirtualPage = _a.ensureNextVirtualPage, minColumnWidth = _a.minColumnWidth, minWidth = _a.minWidth, cellComponent = _a.cellComponent, rowComponent = _a.rowComponent;
          var _b = this.state, containerHeight = _b.containerHeight, headerHeight = _b.headerHeight, bodyHeight = _b.bodyHeight, footerHeight = _b.footerHeight;
          var visibleRowBoundaries = this.getVisibleBoundaries();
          var collapsedGrids = this.getCollapsedGrids(visibleRowBoundaries);
          var commonProps = {
              cellComponent: cellComponent,
              rowComponent: rowComponent,
              minColumnWidth: minColumnWidth,
              minWidth: minWidth,
              blockRefsHandler: this.registerBlockRef,
              rowRefsHandler: this.registerRowRef,
          };
          return (react_9(Sizer, { onSizeChange: this.handleContainerSizeChange, containerComponent: Container, style: __assign$2({}, (height === AUTO_HEIGHT ? null : { height: height })), onScroll: function (e) { return _this.updateViewport(e, visibleRowBoundaries, ensureNextVirtualPage); } },
              (!!headerRows.length) && (react_9(VirtualTableLayoutBlock, __assign$2({}, commonProps, { name: "header", collapsedGrid: collapsedGrids.headerGrid, tableComponent: HeadTable, bodyComponent: Head }))),
              react_9(VirtualTableLayoutBlock, __assign$2({}, commonProps, { name: "body", collapsedGrid: collapsedGrids.bodyGrid, tableComponent: Table, bodyComponent: Body, tableRef: tableRef, marginBottom: Math.max(0, containerHeight - headerHeight - bodyHeight - footerHeight) })),
              (!!footerRows.length) && (react_9(VirtualTableLayoutBlock, __assign$2({}, commonProps, { name: "footer", collapsedGrid: collapsedGrids.footerGrid, tableComponent: FootTable, bodyComponent: Footer })))));
      };
      VirtualTableLayout.defaultProps = defaultProps$3$1;
      return VirtualTableLayout;
  }(react_4));

  var getColumnStyle = function (_a) {
      var column = _a.column;
      return column.animationState;
  };
  /** @internal */
  var RowLayout = /*#__PURE__*/ (function (_super) {
      __extends$1(RowLayout, _super);
      function RowLayout() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      RowLayout.prototype.render = function () {
          var _a = this.props, row = _a.row, columns = _a.columns, Row = _a.rowComponent, Cell = _a.cellComponent, getCellColSpan = _a.getCellColSpan;
          var getColSpan = function (tableRow, tableColumn) { return getCellColSpan({ tableRow: tableRow, tableColumn: tableColumn, tableColumns: columns }); };
          return (react_9(Row, { tableRow: row, style: getRowStyle({ row: row }) }, columns
              .map(function (column) { return (react_9(Cell, { key: column.key, tableRow: row, tableColumn: column, style: getColumnStyle({ column: column }), colSpan: getColSpan(row, column) })); })));
      };
      return RowLayout;
  }(react_4));

  /** @internal */
  var RowsBlockLayout = /*#__PURE__*/ (function (_super) {
      __extends$1(RowsBlockLayout, _super);
      function RowsBlockLayout() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      RowsBlockLayout.prototype.render = function () {
          var _a = this.props, rows = _a.rows, columns = _a.columns, Block = _a.blockComponent, rowComponent = _a.rowComponent, cellComponent = _a.cellComponent, getCellColSpan = _a.getCellColSpan;
          return (react_9(Block, null, rows
              .map(function (row) { return (react_9(RowLayout, { key: row.key, row: row, columns: columns, rowComponent: rowComponent, cellComponent: cellComponent, getCellColSpan: getCellColSpan })); })));
      };
      return RowsBlockLayout;
  }(react_4));

  var defaultProps$4 = {
      headerRows: [],
      footerRows: [],
      headComponent: function () { return null; },
      footerComponent: function () { return null; },
  };
  /** @internal */
  var StaticTableLayout = /*#__PURE__*/ (function (_super) {
      __extends$1(StaticTableLayout, _super);
      function StaticTableLayout() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      StaticTableLayout.prototype.render = function () {
          var _a = this.props, headerRows = _a.headerRows, bodyRows = _a.bodyRows, footerRows = _a.footerRows, columns = _a.columns, minWidth = _a.minWidth, Container = _a.containerComponent, Table = _a.tableComponent, headComponent = _a.headComponent, bodyComponent = _a.bodyComponent, footerComponent = _a.footerComponent, rowComponent = _a.rowComponent, cellComponent = _a.cellComponent, getCellColSpan = _a.getCellColSpan, tableRef = _a.tableRef;
          var commonProps = {
              columns: columns,
              rowComponent: rowComponent,
              cellComponent: cellComponent,
              getCellColSpan: getCellColSpan,
          };
          return (react_9(Container, null,
              react_9(Table, { tableRef: tableRef, style: { minWidth: minWidth + "px" } },
                  react_9(ColumnGroup, { columns: columns }),
                  !!headerRows.length && (react_9(RowsBlockLayout, __assign$2({ rows: headerRows, blockComponent: headComponent }, commonProps))),
                  react_9(RowsBlockLayout, __assign$2({ rows: bodyRows, blockComponent: bodyComponent }, commonProps)),
                  !!footerRows.length && (react_9(RowsBlockLayout, __assign$2({ rows: footerRows, blockComponent: footerComponent }, commonProps))))));
      };
      StaticTableLayout.defaultProps = defaultProps$4;
      return StaticTableLayout;
  }(react_4));

  var RemoteDataLoader = /*#__PURE__*/ (function (_super) {
      __extends$1(RemoteDataLoader, _super);
      function RemoteDataLoader() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.ensureNextVirtualPage = function (payload, getters, _a) {
              var requestNextPage = _a.requestNextPage;
              var isDataRemote = getters.isDataRemote;
              if (!isDataRemote) {
                  return;
              }
              var referenceIndex = nextPageReferenceIndex(payload, getters);
              if (referenceIndex !== null) {
                  requestNextPage({ referenceIndex: referenceIndex });
              }
          };
          return _this;
      }
      RemoteDataLoader.prototype.render = function () {
          return (react_9(Plugin, { name: "RemoteDataLoader" },
              react_9(Action, { name: "ensureNextVirtualPage", action: this.ensureNextVirtualPage })));
      };
      return RemoteDataLoader;
  }(react_4));

  /** @internal */
  var makeVirtualTable = function (Table, _a) {
      var VirtualLayout = _a.VirtualLayout, FixedHeader = _a.FixedHeader, FixedFooter = _a.FixedFooter, SkeletonCell = _a.SkeletonCell, defaultEstimatedRowHeight = _a.defaultEstimatedRowHeight, defaultHeight = _a.defaultHeight;
      var VirtualTable = /*#__PURE__*/ (function (_super) {
          __extends$1(VirtualTable, _super);
          function VirtualTable(props) {
              var _this = _super.call(this, props) || this;
              _this.layoutRenderComponent = connectProps(VirtualLayout, function () {
                  var _a = _this.props, headTableComponent = _a.headTableComponent, footerTableComponent = _a.footerTableComponent;
                  return {
                      headTableComponent: headTableComponent,
                      footerTableComponent: footerTableComponent,
                  };
              });
              return _this;
          }
          VirtualTable.prototype.componentDidUpdate = function () {
              this.layoutRenderComponent.update();
          };
          VirtualTable.prototype.render = function () {
              var _a = this.props, height = _a.height, estimatedRowHeight = _a.estimatedRowHeight, SkeletonStubCell = _a.skeletonCellComponent, children = _a.children, restProps = __rest$1(_a, ["height", "estimatedRowHeight", "skeletonCellComponent", "children"]);
              return (react_9(Plugin, { name: "VirtualTable" },
                  react_9(Table, __assign$2({ layoutComponent: this.layoutRenderComponent }, restProps)),
                  react_9(RemoteDataLoader, null),
                  react_9(Template, { name: "tableLayout" }, function (params) {
                      return (react_9(TemplateConnector, null, function (_a, _b) {
                          var availableRowCount = _a.availableRowCount, loadedRowsStart = _a.loadedRowsStart, tableBodyRows = _a.tableBodyRows;
                          var ensureNextVirtualPage = _b.ensureNextVirtualPage;
                          var totalRowCount = availableRowCount || tableBodyRows.length;
                          return (react_9(TemplatePlaceholder, { params: __assign$2({}, params, { totalRowCount: totalRowCount,
                                  loadedRowsStart: loadedRowsStart,
                                  height: height,
                                  estimatedRowHeight: estimatedRowHeight,
                                  ensureNextVirtualPage: ensureNextVirtualPage }) }));
                      }));
                  }),
                  react_9(Template, { name: "tableCell", predicate: function (_a) {
                          var tableRow = _a.tableRow;
                          return !!isStubTableCell(tableRow);
                      } }, function (params) { return (react_9(SkeletonStubCell, __assign$2({}, params))); })));
          };
          VirtualTable.defaultProps = {
              estimatedRowHeight: defaultEstimatedRowHeight,
              height: defaultHeight,
              headTableComponent: FixedHeader,
              footerTableComponent: FixedFooter,
              skeletonCellComponent: SkeletonCell,
          };
          return VirtualTable;
      }(react_4));
      Object.values(Table.components).forEach(function (name) {
          VirtualTable[name] = Table[name];
      });
      VirtualTable.FixedHeader = FixedHeader;
      VirtualTable.FixedFooter = FixedFooter;
      VirtualTable.SkeletonCell = SkeletonCell;
      return VirtualTable;
  };

  var Node$1 = /*#__PURE__*/ (function () {
      function Node(start, rows) {
          this.prev = null;
          this.next = null;
          this.start = start;
          this.rows = rows;
      }
      return Node;
  }());
  // tslint:disable-next-line:max-classes-per-file
  var LRUCache = /*#__PURE__*/ (function () {
      function LRUCache(pageSize, capacity) {
          if (capacity === void 0) { capacity = Number.POSITIVE_INFINITY; }
          this.pages = new Map();
          this.pageSize = pageSize;
          this.capacity = capacity;
          this.initList();
      }
      LRUCache.prototype.initList = function () {
          this.head = new Node$1(-1, []);
          this.tail = new Node$1(-1, []);
          this.head.next = this.tail;
          this.tail.prev = this.head;
      };
      LRUCache.prototype.addPage = function (pageStart, rows) {
          if (this.pages.has(pageStart)) {
              this.removePage(pageStart);
          }
          var node = new Node$1(pageStart, rows);
          var last = this.tail.prev;
          last.next = node;
          node.next = this.tail;
          node.prev = last;
          this.tail.prev = node;
          this.pages.set(pageStart, node);
          if (this.pages.size > this.capacity) {
              this.removePage(this.head.next.start);
          }
      };
      LRUCache.prototype.removePage = function (start) {
          var node = this.pages.get(start);
          node.prev.next = node.next;
          node.next.prev = node.prev;
          this.pages.delete(start);
      };
      LRUCache.prototype.getPage = function (pageStart) {
          if (!this.pages.has(pageStart)) {
              return null;
          }
          var rows = this.pages.get(pageStart).rows;
          this.removePage(pageStart);
          this.addPage(pageStart, rows);
          return rows;
      };
      LRUCache.prototype.clear = function () {
          this.pages.clear();
          this.initList();
      };
      return LRUCache;
  }());
  var createRowCache = function (pageSize, capacity) {
      if (capacity === void 0) { capacity = Number.POSITIVE_INFINITY; }
      var cache = new LRUCache(pageSize, capacity / pageSize);
      return {
          getRows: function (skip, count) {
              var result = [];
              var pageCount = Math.ceil(count / pageSize);
              for (var i = 0; i < pageCount; i += 1) {
                  var pageStart = skip + i * pageSize;
                  var chunk = cache.getPage(pageStart);
                  // add incomplete page to result only if it is last one
                  if (chunk === null || (i !== pageCount - 1 && chunk.length !== pageSize)) {
                      return result;
                  }
                  result = result.concat(chunk);
              }
              return result;
          },
          setRows: function (skip, rows) {
              var pageCount = Math.ceil(rows.length / pageSize);
              for (var i = 0; i < pageCount; i += 1) {
                  var pageStart = i * pageSize;
                  var rowsChunk = rows.slice(pageStart, pageStart + pageSize);
                  // put incomplete page only if it is last one
                  if (rowsChunk.length === pageSize || i === pageCount - 1) {
                      cache.addPage(pageStart + skip, rowsChunk);
                  }
              }
          },
          invalidate: function () { return cache.clear(); },
      };
  };

  var dxReactGrid_es = /*#__PURE__*/Object.freeze({
    ColumnChooser: ColumnChooser,
    CustomGrouping: CustomGrouping,
    CustomPaging: CustomPaging,
    CustomSummary: CustomSummary,
    CustomTreeData: CustomTreeData,
    DataTypeProvider: DataTypeProvider,
    DragDropProvider: DragDropProvider$1,
    EditingState: EditingState,
    FilteringState: FilteringState,
    Grid: Grid,
    GroupPanelLayout: GroupPanelLayout,
    GroupingPanel: GroupingPanel,
    GroupingState: GroupingState,
    IntegratedFiltering: IntegratedFiltering,
    IntegratedGrouping: IntegratedGrouping,
    IntegratedPaging: IntegratedPaging,
    IntegratedSelection: IntegratedSelection,
    IntegratedSorting: IntegratedSorting,
    IntegratedSummary: IntegratedSummary,
    PagingPanel: PagingPanel,
    PagingState: PagingState,
    RowDetailState: RowDetailState,
    SearchPanel: SearchPanel,
    SearchState: SearchState,
    SelectionState: SelectionState$1,
    SortingState: SortingState,
    StaticTableLayout: StaticTableLayout,
    SummaryState: SummaryState,
    Table: Table,
    TableBandHeader: TableBandHeader,
    TableColumnReordering: TableColumnReordering,
    TableColumnResizing: TableColumnResizing,
    TableColumnVisibility: TableColumnVisibility,
    TableEditColumn: TableEditColumn,
    TableEditRow: TableEditRow,
    TableFilterRow: TableFilterRow,
    TableFixedColumns: TableFixedColumns,
    TableGroupRow: TableGroupRow,
    TableHeaderRow: TableHeaderRow,
    TableLayout: TableLayout,
    TableRowDetail: TableRowDetail,
    TableSelection: TableSelection,
    TableSummaryRow: TableSummaryRow,
    TableTreeColumn: TableTreeColumn,
    Toolbar: Toolbar,
    TreeDataState: TreeDataState,
    VirtualTableLayout: VirtualTableLayout,
    VirtualTableState: VirtualTableState,
    createRowCache: createRowCache,
    makeVirtualTable: makeVirtualTable
  });

  var classnames = createCommonjsModule(function (module) {
  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  /* global define */

  (function () {

  	var hasOwn = {}.hasOwnProperty;

  	function classNames () {
  		var classes = [];

  		for (var i = 0; i < arguments.length; i++) {
  			var arg = arguments[i];
  			if (!arg) continue;

  			var argType = typeof arg;

  			if (argType === 'string' || argType === 'number') {
  				classes.push(arg);
  			} else if (Array.isArray(arg) && arg.length) {
  				var inner = classNames.apply(null, arg);
  				if (inner) {
  					classes.push(inner);
  				}
  			} else if (argType === 'object') {
  				for (var key in arg) {
  					if (hasOwn.call(arg, key) && arg[key]) {
  						classes.push(key);
  					}
  				}
  			}
  		}

  		return classes.join(' ');
  	}

  	if (module.exports) {
  		classNames.default = classNames;
  		module.exports = classNames;
  	} else {
  		window.classNames = classNames;
  	}
  }());
  });

  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose$1;

  var _extends_1 = createCommonjsModule(function (module) {
  function _extends() {
    module.exports = _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  module.exports = _extends;
  });

  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var inheritsLoose = _inheritsLoose$1;

  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  var assertThisInitialized = _assertThisInitialized$1;

  function _defineProperty$3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var defineProperty$1 = _defineProperty$3;

  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.15.0
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }

  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  var supportsMicroTasks = isBrowser && window.Promise;

  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */
  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }

  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    // NOTE: 1 DOM access here
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }

  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }

  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */
  function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body;
    }

    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent(getParentNode(element));
  }

  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

  /**
   * Determines if the browser is Internet Explorer
   * @method
   * @memberof Popper.Utils
   * @param {Number} version to check
   * @returns {Boolean} isIE
   */
  function isIE$1(version) {
    if (version === 11) {
      return isIE11;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11 || isIE10;
  }

  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }

    var noOffsetParent = isIE$1(10) ? document.body : null;

    // NOTE: 1 DOM access here
    var offsetParent = element.offsetParent || null;
    // Skip hidden elements which don't have an offsetParent
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }

    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }

    // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }

  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }

  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */
  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }

  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }

  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }

  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */

  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

    return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
  }

  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE$1(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }

  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE$1(10) && getComputedStyle(html);

    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();





  var defineProperty$2 = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends$a = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */
  function getClientRect(offsets) {
    return _extends$a({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }

  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */
  function getBoundingClientRect(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    try {
      if (isIE$1(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;

    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');

      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var isIE10 = isIE$1(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);

    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

    // In cases where the parent is fixed, we must ignore negative scroll in offset calc
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop, 10);
      var marginLeft = parseFloat(styles.marginLeft, 10);

      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;

      // Attach marginTop and marginLeft because in some circumstances we may need them
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);

    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };

    return getClientRect(offset);
  }

  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
      return false;
    }
    return isFixed(parentNode);
  }

  /**
   * Finds the first parent of an element that has a transformed property defined
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} first transformed parent or documentElement
   */

  function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE$1()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }

  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @param {Boolean} fixedPosition - Is in fixed position mode
   * @returns {Object} Coordinates of the boundaries
   */
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    // NOTE: 1 DOM access here

    var boundaries = { top: 0, left: 0 };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

    // Handle viewport case
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

      // In case of HTML, we need a different computation
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    }

    // Add paddings
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;

    return width * height;
  }

  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
      return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };

    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends$a({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });

    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });

    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

    var variation = placement.split('-')[1];

    return computedPlacement + (variation ? '-' + variation : '');
  }

  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @param {Element} fixedPosition - is in fixed position mode
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */
  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }

  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */
  function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';

    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }

  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
  }

  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }

  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        // eslint-disable-line dot-notation
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);

        data = fn(data, modifier);
      }
    });

    return data;
  }

  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */
  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;

    data.positionFixed = this.options.positionFixed;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }

  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }

  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }

  /**
   * Destroys the popper.
   * @method
   * @memberof Popper
   */
  function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners();

    // remove the popper if user explicity asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }

  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   */
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, { passive: true });

    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }

  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;

    return state;
  }

  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }

  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }

  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger `onUpdate` callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }

  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */
  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      // add unit if the value is numeric and is one of the following
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }

  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */
  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);

    // if arrowElement is defined and arrowStyles has some properties
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }

    return data;
  }

  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper
   * @param {Object} options - Popper.js options
   */
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

    popper.setAttribute('x-placement', placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

    return options;
  }

  /**
   * @function
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Boolean} shouldRound - If the offsets should be rounded at all
   * @returns {Object} The popper's position offsets rounded
   *
   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
   * good as it can be within reason.
   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
   *
   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
   * as well on High DPI screens).
   *
   * Firefox prefers no rounding for positioning and does not have blurriness on
   * high DPI screens.
   *
   * Only horizontal placement and left/right values need to be considered.
   */
  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;

    var noRound = function noRound(v) {
      return v;
    };

    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);

    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;

    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }

  var isFirefox$1 = isBrowser && /Firefox/i.test(navigator.userAgent);

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    var styles = {
      position: popper.position
    };

    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox$1);

    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName('transform');

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
      // and not the bottom of the html element
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    }

    // Attributes
    var attributes = {
      'x-placement': data.placement
    };

    // Update `data` attributes, styles and arrowStyles
    data.attributes = _extends$a({}, attributes, data.attributes);
    data.styles = _extends$a({}, styles, data.styles);
    data.arrowStyles = _extends$a({}, data.offsets.arrow, data.arrowStyles);

    return data;
  }

  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });

    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';
      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function arrow(data, options) {
    var _data$offsets$arrow;

    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }

    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);

      // if arrowElement is not found, don't run the modifier
      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isVertical = ['left', 'right'].indexOf(placement) !== -1;

    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);

    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

    // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$2(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$2(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

    return data;
  }

  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }

  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-end` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

  // Get rid of `auto` `auto-start` and `auto-end`
  var validPlacements = placements.slice(3);

  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';

    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);

      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;

      // using floor because the reference offsets may contain decimals we are not going to consider here
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

      // flip the variation if required
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

      // flips variation if reference element overflows boundaries
      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

      // flips variation if popper content overflows boundaries
      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

      var flippedVariation = flippedVariationByRef || flippedVariationByContent;

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? '-' + variation : '');

        // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future
        data.offsets.popper = _extends$a({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }

  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
      return str;
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }

  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var basePlacement = placement.split('-')[0];

    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }

    // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style; // assignment to help minification
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];

    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

    // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;

    options.boundaries = boundaries;

    var order = options.priority;
    var popper = data.offsets.popper;

    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty$2({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return defineProperty$2({}, mainSide, value);
      }
    };

    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends$a({}, popper, check[side](placement));
    });

    data.offsets.popper = popper;

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;

      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      var shiftOffsets = {
        start: defineProperty$2({}, side, reference[side]),
        end: defineProperty$2({}, side, reference[side] + reference[measurement] - popper[measurement])
      };

      data.offsets.popper = _extends$a({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);

    return data;
  }

  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: offset,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" — or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: preventOverflow,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: arrow,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: flip,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       */
      behavior: 'flip',
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       */
      boundariesElement: 'viewport',
      /**
       * @prop {Boolean} flipVariations=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the reference element overlaps its boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariations: false,
      /**
       * @prop {Boolean} flipVariationsByContent=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the popper element overlaps its reference boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariationsByContent: false
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,
      /** @prop {ModifierFn} */
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: applyStyle,
      /** @prop {Function} */
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: undefined
    }
  };

  /**
   * The `dataObject` is an object containing all the information used by Popper.js.
   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overridden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass an object with the same
   * structure of the `options` object, as the 3rd argument. For example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */
  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,

    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
  };

  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */

  // Utils
  // Methods
  var Popper = function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {Element|referenceObject} reference - The reference element used to position the popper
     * @param {Element} popper - The HTML / XML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };

      // make update() debounced, so that it only runs at most once-per-tick
      this.update = debounce(this.update.bind(this));

      // with {} we create a new object with the options inside it
      this.options = _extends$a({}, Popper.Defaults, options);

      // init state
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };

      // get reference and popper elements (allow jQuery wrappers)
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;

      // Deep merge modifiers options
      this.options.modifiers = {};
      Object.keys(_extends$a({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends$a({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });

      // Refactoring modifiers' list (Object => Array)
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends$a({
          name: name
        }, _this.options.modifiers[name]);
      })
      // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      });

      // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });

      // fire the first update to position the popper in the right place
      this.update();

      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }

      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */


      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */

    }]);
    return Popper;
  }();

  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10.
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */


  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  var key = '__global_unique_id__';

  var gud = function() {
    return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
  };

  /**
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  var warning = emptyFunction_1;

  var warning_1 = warning;

  var implementation = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(react);



  var _propTypes2 = _interopRequireDefault(propTypes);



  var _gud2 = _interopRequireDefault(gud);



  var _warning2 = _interopRequireDefault(warning_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var MAX_SIGNED_31_BIT_INT = 1073741823;

  // Inlined Object.is polyfill.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  function objectIs(x, y) {
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }

  function createEventEmitter(value) {
    var handlers = [];
    return {
      on: function on(handler) {
        handlers.push(handler);
      },
      off: function off(handler) {
        handlers = handlers.filter(function (h) {
          return h !== handler;
        });
      },
      get: function get() {
        return value;
      },
      set: function set(newValue, changedBits) {
        value = newValue;
        handlers.forEach(function (handler) {
          return handler(value, changedBits);
        });
      }
    };
  }

  function onlyChild(children) {
    return Array.isArray(children) ? children[0] : children;
  }

  function createReactContext(defaultValue, calculateChangedBits) {
    var _Provider$childContex, _Consumer$contextType;

    var contextProp = '__create-react-context-' + (0, _gud2.default)() + '__';

    var Provider = function (_Component) {
      _inherits(Provider, _Component);

      function Provider() {
        var _temp, _this, _ret;

        _classCallCheck(this, Provider);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.emitter = createEventEmitter(_this.props.value), _temp), _possibleConstructorReturn(_this, _ret);
      }

      Provider.prototype.getChildContext = function getChildContext() {
        var _ref;

        return _ref = {}, _ref[contextProp] = this.emitter, _ref;
      };

      Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.value !== nextProps.value) {
          var oldValue = this.props.value;
          var newValue = nextProps.value;
          var changedBits = void 0;

          if (objectIs(oldValue, newValue)) {
            changedBits = 0; // No change
          } else {
            changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

            changedBits |= 0;

            if (changedBits !== 0) {
              this.emitter.set(nextProps.value, changedBits);
            }
          }
        }
      };

      Provider.prototype.render = function render() {
        return this.props.children;
      };

      return Provider;
    }(react.Component);

    Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = _propTypes2.default.object.isRequired, _Provider$childContex);

    var Consumer = function (_Component2) {
      _inherits(Consumer, _Component2);

      function Consumer() {
        var _temp2, _this2, _ret2;

        _classCallCheck(this, Consumer);

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, _Component2.call.apply(_Component2, [this].concat(args))), _this2), _this2.state = {
          value: _this2.getValue()
        }, _this2.onUpdate = function (newValue, changedBits) {
          var observedBits = _this2.observedBits | 0;
          if ((observedBits & changedBits) !== 0) {
            _this2.setState({ value: _this2.getValue() });
          }
        }, _temp2), _possibleConstructorReturn(_this2, _ret2);
      }

      Consumer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var observedBits = nextProps.observedBits;

        this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
        : observedBits;
      };

      Consumer.prototype.componentDidMount = function componentDidMount() {
        if (this.context[contextProp]) {
          this.context[contextProp].on(this.onUpdate);
        }
        var observedBits = this.props.observedBits;

        this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
        : observedBits;
      };

      Consumer.prototype.componentWillUnmount = function componentWillUnmount() {
        if (this.context[contextProp]) {
          this.context[contextProp].off(this.onUpdate);
        }
      };

      Consumer.prototype.getValue = function getValue() {
        if (this.context[contextProp]) {
          return this.context[contextProp].get();
        } else {
          return defaultValue;
        }
      };

      Consumer.prototype.render = function render() {
        return onlyChild(this.props.children)(this.state.value);
      };

      return Consumer;
    }(react.Component);

    Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = _propTypes2.default.object, _Consumer$contextType);


    return {
      Provider: Provider,
      Consumer: Consumer
    };
  }

  exports.default = createReactContext;
  module.exports = exports['default'];
  });

  unwrapExports(implementation);

  var lib = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var _react2 = _interopRequireDefault(react);



  var _implementation2 = _interopRequireDefault(implementation);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  exports.default = _react2.default.createContext || _implementation2.default;
  module.exports = exports['default'];
  });

  var createContext = unwrapExports(lib);

  var ManagerContext = createContext({
    setReferenceNode: undefined,
    referenceNode: undefined
  });

  var Manager =
  /*#__PURE__*/
  function (_React$Component) {
    inheritsLoose(Manager, _React$Component);

    function Manager() {
      var _this;

      _this = _React$Component.call(this) || this;

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "setReferenceNode", function (referenceNode) {
        if (!referenceNode || _this.state.context.referenceNode === referenceNode) {
          return;
        }

        _this.setState(function (_ref) {
          var context = _ref.context;
          return {
            context: _extends_1({}, context, {
              referenceNode: referenceNode
            })
          };
        });
      });

      _this.state = {
        context: {
          setReferenceNode: _this.setReferenceNode,
          referenceNode: undefined
        }
      };
      return _this;
    }

    var _proto = Manager.prototype;

    _proto.render = function render() {
      return react_9(ManagerContext.Provider, {
        value: this.state.context
      }, this.props.children);
    };

    return Manager;
  }(react_2);

  /**
   * Takes an argument and if it's an array, returns the first item in the array,
   * otherwise returns the argument. Used for Preact compatibility.
   */
  var unwrapArray = function unwrapArray(arg) {
    return Array.isArray(arg) ? arg[0] : arg;
  };
  /**
   * Takes a maybe-undefined function and arbitrary args and invokes the function
   * only if it is defined.
   */

  var safeInvoke = function safeInvoke(fn) {
    if (typeof fn === "function") {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return fn.apply(void 0, args);
    }
  };

  var initialStyle = {
    position: 'absolute',
    top: 0,
    left: 0,
    opacity: 0,
    pointerEvents: 'none'
  };
  var initialArrowStyle = {};
  var InnerPopper =
  /*#__PURE__*/
  function (_React$Component) {
    inheritsLoose(InnerPopper, _React$Component);

    function InnerPopper() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "state", {
        data: undefined,
        placement: undefined
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "popperInstance", void 0);

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "popperNode", null);

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "arrowNode", null);

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "setPopperNode", function (popperNode) {
        if (!popperNode || _this.popperNode === popperNode) return;
        safeInvoke(_this.props.innerRef, popperNode);
        _this.popperNode = popperNode;

        _this.updatePopperInstance();
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "setArrowNode", function (arrowNode) {
        _this.arrowNode = arrowNode;
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "updateStateModifier", {
        enabled: true,
        order: 900,
        fn: function fn(data) {
          var placement = data.placement;

          _this.setState({
            data: data,
            placement: placement
          });

          return data;
        }
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "getOptions", function () {
        return {
          placement: _this.props.placement,
          eventsEnabled: _this.props.eventsEnabled,
          positionFixed: _this.props.positionFixed,
          modifiers: _extends_1({}, _this.props.modifiers, {
            arrow: _extends_1({}, _this.props.modifiers && _this.props.modifiers.arrow, {
              enabled: !!_this.arrowNode,
              element: _this.arrowNode
            }),
            applyStyle: {
              enabled: false
            },
            updateStateModifier: _this.updateStateModifier
          })
        };
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "getPopperStyle", function () {
        return !_this.popperNode || !_this.state.data ? initialStyle : _extends_1({
          position: _this.state.data.offsets.popper.position
        }, _this.state.data.styles);
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "getPopperPlacement", function () {
        return !_this.state.data ? undefined : _this.state.placement;
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "getArrowStyle", function () {
        return !_this.arrowNode || !_this.state.data ? initialArrowStyle : _this.state.data.arrowStyles;
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "getOutOfBoundariesState", function () {
        return _this.state.data ? _this.state.data.hide : undefined;
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "destroyPopperInstance", function () {
        if (!_this.popperInstance) return;

        _this.popperInstance.destroy();

        _this.popperInstance = null;
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "updatePopperInstance", function () {
        _this.destroyPopperInstance();

        var _assertThisInitialize = assertThisInitialized(assertThisInitialized(_this)),
            popperNode = _assertThisInitialize.popperNode;

        var referenceElement = _this.props.referenceElement;
        if (!referenceElement || !popperNode) return;
        _this.popperInstance = new Popper(referenceElement, popperNode, _this.getOptions());
      });

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "scheduleUpdate", function () {
        if (_this.popperInstance) {
          _this.popperInstance.scheduleUpdate();
        }
      });

      return _this;
    }

    var _proto = InnerPopper.prototype;

    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      // If the Popper.js options have changed, update the instance (destroy + create)
      if (this.props.placement !== prevProps.placement || this.props.referenceElement !== prevProps.referenceElement || this.props.positionFixed !== prevProps.positionFixed) {
        this.updatePopperInstance();
      } else if (this.props.eventsEnabled !== prevProps.eventsEnabled && this.popperInstance) {
        this.props.eventsEnabled ? this.popperInstance.enableEventListeners() : this.popperInstance.disableEventListeners();
      } // A placement difference in state means popper determined a new placement
      // apart from the props value. By the time the popper element is rendered with
      // the new position Popper has already measured it, if the place change triggers
      // a size change it will result in a misaligned popper. So we schedule an update to be sure.


      if (prevState.placement !== this.state.placement) {
        this.scheduleUpdate();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      safeInvoke(this.props.innerRef, null);
      this.destroyPopperInstance();
    };

    _proto.render = function render() {
      return unwrapArray(this.props.children)({
        ref: this.setPopperNode,
        style: this.getPopperStyle(),
        placement: this.getPopperPlacement(),
        outOfBoundaries: this.getOutOfBoundariesState(),
        scheduleUpdate: this.scheduleUpdate,
        arrowProps: {
          ref: this.setArrowNode,
          style: this.getArrowStyle()
        }
      });
    };

    return InnerPopper;
  }(react_2);

  defineProperty$1(InnerPopper, "defaultProps", {
    placement: 'bottom',
    eventsEnabled: true,
    referenceElement: undefined,
    positionFixed: false
  });

  var placements$1 = Popper.placements;
  function Popper$1(_ref) {
    var referenceElement = _ref.referenceElement,
        props = objectWithoutPropertiesLoose(_ref, ["referenceElement"]);

    return react_9(ManagerContext.Consumer, null, function (_ref2) {
      var referenceNode = _ref2.referenceNode;
      return react_9(InnerPopper, _extends_1({
        referenceElement: referenceElement !== undefined ? referenceElement : referenceNode
      }, props));
    });
  }

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var warning$1 = function() {};

  var warning_1$1 = warning$1;

  var InnerReference =
  /*#__PURE__*/
  function (_React$Component) {
    inheritsLoose(InnerReference, _React$Component);

    function InnerReference() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      defineProperty$1(assertThisInitialized(assertThisInitialized(_this)), "refHandler", function (node) {
        safeInvoke(_this.props.innerRef, node);
        safeInvoke(_this.props.setReferenceNode, node);
      });

      return _this;
    }

    var _proto = InnerReference.prototype;

    _proto.render = function render() {
      warning_1$1(Boolean(this.props.setReferenceNode), '`Reference` should not be used outside of a `Manager` component.');
      return unwrapArray(this.props.children)({
        ref: this.refHandler
      });
    };

    return InnerReference;
  }(react_2);

  function Reference(props) {
    return react_9(ManagerContext.Consumer, null, function (_ref) {
      var setReferenceNode = _ref.setReferenceNode;
      return react_9(InnerReference, _extends_1({
        setReferenceNode: setReferenceNode
      }, props));
    });
  }

  // Public components
   // Public types

  var index$3 = /*#__PURE__*/Object.freeze({
    Popper: Popper$1,
    placements: placements$1,
    Manager: Manager,
    Reference: Reference
  });

  /**
   * Bundle of @devexpress/dx-react-grid-bootstrap4
   * Generated: 2019-05-17
   * Version: 1.11.0
   * License: https://js.devexpress.com/Licensing
   */

  function _classCallCheck$i(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty$4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends$b() {
    _extends$b = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$b.apply(this, arguments);
  }

  function _objectSpread$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty$4(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits$d(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf$1(subClass, superClass);
  }

  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$1(o);
  }

  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf$1(o, p);
  }

  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose$2(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized$2(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn$d(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized$2(self);
  }

  var BodyColorContext = react_8();

  var getBodyColor = function getBodyColor() {
    var body = document.getElementsByTagName('body')[0];

    var _window$getComputedSt = window.getComputedStyle(body),
        backgroundColor = _window$getComputedSt.backgroundColor;

    return backgroundColor;
  };

  var Root =
  /*#__PURE__*/
  function (_React$PureComponent) {
    _inherits$d(Root, _React$PureComponent);

    function Root(props) {
      var _this;

      _classCallCheck$i(this, Root);

      _this = _possibleConstructorReturn$d(this, _getPrototypeOf$1(Root).call(this, props));
      _this.state = {
        backgroundColor: undefined
      };
      return _this;
    }

    _createClass$1(Root, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.setState({
          backgroundColor: getBodyColor()
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            children = _this$props.children,
            className = _this$props.className,
            restProps = _objectWithoutProperties(_this$props, ["children", "className"]);

        var backgroundColor = this.state.backgroundColor;
        return react_9("div", _extends$b({
          className: classnames('d-flex flex-column', className)
        }, restProps), react_9(BodyColorContext.Provider, {
          value: backgroundColor
        }, children));
      }
    }]);

    return Root;
  }(react_4);
  Root.defaultProps = {
    className: undefined,
    children: undefined
  };

  var Grid$1 = function Grid$1(_ref) {
    var children = _ref.children,
        props = _objectWithoutProperties(_ref, ["children"]);

    return react_9(Grid, _extends$b({
      rootComponent: Root
    }, props), children);
  };
  Grid$1.Root = Root;

  var Popover =
  /*#__PURE__*/
  function (_React$PureComponent) {
    _inherits$d(Popover, _React$PureComponent);

    function Popover(props) {
      var _this;

      _classCallCheck$i(this, Popover);

      _this = _possibleConstructorReturn$d(this, _getPrototypeOf$1(Popover).call(this, props)); // These two fields should be created only if `isOpen && toggle` condition is true
      // and destroyed when condition turns false.
      // But it would require usage of `this.state` and other code complications.
      // So let's not change it for now. Maybe a better solution would be found.

      _this.contentRef = react_11();
      _this.handleClick = _this.handleClick.bind(_assertThisInitialized$2(_this));
      return _this;
    }

    _createClass$1(Popover, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props = this.props,
            isOpen = _this$props.isOpen,
            toggle = _this$props.toggle;

        if (isOpen && toggle) {
          this.attachDocumentEvents();
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var _this$props2 = this.props,
            isOpen = _this$props2.isOpen,
            toggle = _this$props2.toggle;

        if (isOpen && toggle) {
          this.attachDocumentEvents();
        } else {
          this.detachDocumentEvents();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.detachDocumentEvents();
      }
    }, {
      key: "handleClick",
      value: function handleClick(e) {
        var eventTarget = e.target;
        var contentNode = this.contentRef.current;
        var _this$props3 = this.props,
            toggle = _this$props3.toggle,
            target = _this$props3.target;

        if (contentNode && !contentNode.contains(eventTarget) && !target.contains(eventTarget)) {
          toggle();
        }
      }
    }, {
      key: "attachDocumentEvents",
      value: function attachDocumentEvents() {
        if (!this.listenersAttached) {
          this.toggleDocumentEvents('addEventListener');
          this.listenersAttached = true;
        }
      }
    }, {
      key: "detachDocumentEvents",
      value: function detachDocumentEvents() {
        if (this.listenersAttached) {
          this.toggleDocumentEvents('removeEventListener');
          this.listenersAttached = false;
        }
      }
    }, {
      key: "toggleDocumentEvents",
      value: function toggleDocumentEvents(method) {
        var _this2 = this;

        ['click', 'touchstart'].forEach(function (eventType) {
          document[method](eventType, _this2.handleClick, true);
        });
      }
    }, {
      key: "renderPopper",
      value: function renderPopper() {
        var _this3 = this;

        var _this$props4 = this.props,
            children = _this$props4.children,
            target = _this$props4.target,
            renderInBody = _this$props4.renderInBody,
            restProps = _objectWithoutProperties(_this$props4, ["children", "target", "renderInBody"]);

        return react_9(Popper$1, _extends$b({
          referenceElement: target
        }, restProps), function (_ref) {
          var ref = _ref.ref,
              style = _ref.style,
              arrowProps = _ref.arrowProps,
              placement = _ref.placement;
          return react_9("div", {
            className: "popover show bs-popover-".concat(placement),
            ref: ref,
            style: style
          }, react_9("div", {
            className: "popover-inner",
            ref: _this3.contentRef
          }, children), react_9("div", {
            className: "arrow",
            ref: arrowProps.ref,
            style: arrowProps.style
          }));
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props5 = this.props,
            isOpen = _this$props5.isOpen,
            renderInBody = _this$props5.renderInBody;
        if (!isOpen) return null;
        return renderInBody ? reactDom_1(this.renderPopper(), document.body) : this.renderPopper();
      }
    }]);

    return Popover;
  }(react_4);
  Popover.defaultProps = {
    target: null,
    renderInBody: true,
    isOpen: false,
    placement: 'auto',
    toggle: undefined
  };

  var Overlay = function Overlay(_ref) {
    var visible = _ref.visible,
        children = _ref.children,
        target = _ref.target,
        onHide = _ref.onHide,
        restProps = _objectWithoutProperties(_ref, ["visible", "children", "target", "onHide"]);

    var handleToggle = function handleToggle() {
      if (visible) onHide();
    };

    return target ? react_9(Popover, _extends$b({
      placement: "bottom",
      isOpen: visible,
      target: target,
      renderInBody: false,
      toggle: handleToggle
    }, restProps), children) : null;
  };
  Overlay.defaultProps = {
    visible: false,
    target: null
  };

  var Container = function Container(_ref) {
    var children = _ref.children,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["children", "className"]);

    return react_9("div", _extends$b({
      className: classnames('py-2', className)
    }, restProps), children);
  };
  Container.defaultProps = {
    className: undefined
  };

  var handleMouseDown = function handleMouseDown(e) {
    e.currentTarget.style.outline = 'none';
  };

  var handleBlur = function handleBlur(e) {
    e.currentTarget.style.outline = '';
  };

  var Item = function Item(_ref) {
    var _ref$item = _ref.item,
        column = _ref$item.column,
        hidden = _ref$item.hidden,
        onToggle = _ref.onToggle,
        className = _ref.className,
        disabled = _ref.disabled,
        restProps = _objectWithoutProperties(_ref, ["item", "onToggle", "className", "disabled"]);

    return react_9("button", _extends$b({
      className: classnames({
        'dropdown-item dx-g-bs4-column-chooser-item': true,
        'dx-g-bs4-cursor-pointer': !disabled
      }, className),
      type: "button",
      onClick: onToggle,
      onMouseDown: handleMouseDown,
      onBlur: handleBlur,
      disabled: disabled
    }, restProps), react_9("input", {
      type: "checkbox",
      className: classnames({
        'dx-g-bs4-cursor-pointer': !disabled,
        'dx-g-bs4-column-chooser-checkbox': true
      }),
      tabIndex: -1,
      checked: !hidden,
      disabled: disabled,
      onChange: onToggle,
      onClick: function onClick(e) {
        return e.stopPropagation();
      }
    }), column.title || column.name);
  };
  Item.defaultProps = {
    onToggle: function onToggle() {},
    className: undefined,
    disabled: false
  };

  var ToggleButton = function ToggleButton(_ref) {
    var onToggle = _ref.onToggle,
        className = _ref.className,
        getMessage = _ref.getMessage,
        buttonRef = _ref.buttonRef,
        active = _ref.active,
        restProps = _objectWithoutProperties(_ref, ["onToggle", "className", "getMessage", "buttonRef", "active"]);

    var buttonClasses = classnames({
      btn: true,
      'btn-outline-secondary': true,
      'border-0': true,
      active: active
    }, className);
    return react_9("button", _extends$b({
      type: "button",
      className: buttonClasses,
      onClick: onToggle,
      ref: buttonRef
    }, restProps), react_9("span", {
      className: "oi oi-eye"
    }));
  };
  ToggleButton.defaultProps = {
    className: undefined,
    active: false
  };

  var ColumnChooser$1 = withComponents({
    Container: Container,
    Item: Item,
    Overlay: Overlay,
    ToggleButton: ToggleButton
  })(ColumnChooser);

  var Container$1 = function Container(_ref) {
    var clientOffset = _ref.clientOffset,
        style = _ref.style,
        className = _ref.className,
        children = _ref.children,
        restProps = _objectWithoutProperties(_ref, ["clientOffset", "style", "className", "children"]);

    return react_9("ul", _extends$b({
      className: classnames('list-group d-inline-block position-fixed dx-g-bs4-drag-drop', className),
      style: _objectSpread$1({
        transform: "translate(calc(".concat(clientOffset.x, "px - 50%), calc(").concat(clientOffset.y, "px - 50%))"),
        msTransform: "translateX(".concat(clientOffset.x, "px) translateX(-50%) translateY(").concat(clientOffset.y, "px) translateY(-50%)"),
        zIndex: 1000,
        left: 0,
        top: 0
      }, style)
    }, restProps), children);
  };
  Container$1.defaultProps = {
    style: {},
    className: undefined,
    children: undefined
  };
  var Column = function Column(_ref2) {
    var column = _ref2.column,
        className = _ref2.className,
        restProps = _objectWithoutProperties(_ref2, ["column", "className"]);

    return react_9("li", _extends$b({
      className: classnames('list-group-item', className)
    }, restProps), column.title);
  };
  Column.defaultProps = {
    className: undefined
  };

  var DragDropProvider$2 = withComponents({
    Container: Container$1,
    Column: Column
  })(DragDropProvider$1);

  var PaginationLink = function PaginationLink(_ref) {
    var previous = _ref.previous,
        next = _ref.next,
        children = _ref.children,
        restProps = _objectWithoutProperties(_ref, ["previous", "next", "children"]);

    var ariaLabel = '';
    var content = children;

    if (next || previous) {
      var angleQuote;

      if (next) {
        angleQuote = "\xBB";
        ariaLabel = 'Next';
      }

      if (previous) {
        angleQuote = "\xAB";
        ariaLabel = 'Previous';
      }

      content = [react_9("span", {
        "aria-hidden": "true",
        key: "caret"
      }, children || angleQuote), react_9("span", {
        className: "sr-only",
        key: "sr"
      }, ariaLabel)];
    }

    return react_9("a", _extends$b({
      className: "page-link",
      "aria-label": ariaLabel
    }, restProps), content);
  };
  PaginationLink.defaultProps = {
    previous: false,
    next: false,
    children: undefined
  };

  var PaginationItem = function PaginationItem(_ref) {
    var active = _ref.active,
        disabled = _ref.disabled,
        restProps = _objectWithoutProperties(_ref, ["active", "disabled"]);

    return react_9("li", _extends$b({
      className: classnames('page-item', {
        active: active,
        disabled: disabled
      })
    }, restProps));
  };
  PaginationItem.defaultProps = {
    active: false,
    disabled: false
  };

  var Pagination = function Pagination(_ref) {
    var className = _ref.className,
        listClassName = _ref.listClassName,
        restProps = _objectWithoutProperties(_ref, ["className", "listClassName"]);

    return react_9("nav", {
      className: className
    }, react_9("ul", _extends$b({
      className: classnames('pagination', listClassName)
    }, restProps)));
  };
  Pagination.defaultProps = {
    className: undefined,
    listClassName: undefined
  };

  var PageSizeSelector = function PageSizeSelector(_ref) {
    var pageSize = _ref.pageSize,
        onPageSizeChange = _ref.onPageSizeChange,
        pageSizes = _ref.pageSizes,
        getMessage = _ref.getMessage;
    var showAll = getMessage('showAll');
    return react_9("div", {
      className: "d-inline-block"
    }, react_9("select", {
      className: "form-control d-sm-none",
      value: pageSize,
      onChange: function onChange(e) {
        return onPageSizeChange(parseInt(e.target.value, 10));
      }
    }, pageSizes.map(function (val) {
      return react_9("option", {
        key: val,
        value: val
      }, val || showAll);
    })), react_9(Pagination, {
      className: "d-none d-sm-flex",
      listClassName: "m-0"
    }, pageSizes.map(function (item) {
      return react_9(PaginationItem, {
        key: item,
        active: item === pageSize && true
      }, react_9(PaginationLink, {
        href: "#",
        onClick: function onClick(e) {
          e.preventDefault();
          onPageSizeChange(item);
        }
      }, item || showAll));
    })));
  };

  var renderPageButtons = function renderPageButtons(currentPage, totalPageCount, currentPageChange) {
    var pageButtons = [];
    var maxButtonCount = 3;
    var startPage = 1;
    var endPage = totalPageCount || 1;

    if (maxButtonCount < totalPageCount) {
      startPage = calculateStartPage(currentPage + 1, maxButtonCount, totalPageCount);
      endPage = startPage + maxButtonCount - 1;
    }

    if (startPage > 1) {
      pageButtons.push(react_9(PaginationItem, {
        key: 1
      }, react_9(PaginationLink, {
        href: "#",
        onClick: function onClick(e) {
          return currentPageChange(e, 0);
        }
      }, 1)));

      if (startPage > 2) {
        pageButtons.push(react_9(PaginationItem, {
          key: "ellipsisStart",
          disabled: true
        }, react_9(PaginationLink, null, '...')));
      }
    }

    var _loop = function _loop(page) {
      pageButtons.push(react_9(PaginationItem, {
        key: page,
        active: page === currentPage + 1,
        disabled: startPage === endPage
      }, react_9(PaginationLink, {
        href: "#",
        onClick: function onClick(e) {
          return currentPageChange(e, page - 1);
        }
      }, page)));
    };

    for (var page = startPage; page <= endPage; page += 1) {
      _loop(page);
    }

    if (endPage < totalPageCount) {
      if (endPage < totalPageCount - 1) {
        pageButtons.push(react_9(PaginationItem, {
          key: "ellipsisEnd",
          disabled: true
        }, react_9(PaginationLink, null, '...')));
      }

      pageButtons.push(react_9(PaginationItem, {
        key: totalPageCount
      }, react_9(PaginationLink, {
        href: "#",
        onClick: function onClick(e) {
          return currentPageChange(e, totalPageCount - 1);
        }
      }, totalPageCount)));
    }

    return pageButtons;
  };

  var Pagination$1 = function Pagination$1(_ref) {
    var totalPages = _ref.totalPages,
        currentPage = _ref.currentPage,
        onCurrentPageChange = _ref.onCurrentPageChange,
        totalCount = _ref.totalCount,
        pageSize = _ref.pageSize,
        getMessage = _ref.getMessage;
    var from = firstRowOnPage(currentPage, pageSize, totalCount);
    var to = lastRowOnPage(currentPage, pageSize, totalCount);

    var currentPageChange = function currentPageChange(e, nextPage) {
      e.preventDefault();
      onCurrentPageChange(nextPage);
    };

    return react_9(react_3, null, react_9(Pagination, {
      className: "float-right d-none d-sm-flex",
      listClassName: "m-0"
    }, react_9(PaginationItem, {
      disabled: currentPage === 0
    }, react_9(PaginationLink, {
      previous: true,
      href: "#",
      onClick: function onClick(e) {
        return currentPageChange(e, currentPage - 1);
      }
    })), renderPageButtons(currentPage, totalPages, currentPageChange), react_9(PaginationItem, {
      disabled: currentPage === totalPages - 1 || totalCount === 0
    }, react_9(PaginationLink, {
      next: true,
      href: "#",
      onClick: function onClick(e) {
        return currentPageChange(e, currentPage + 1);
      }
    }))), react_9(Pagination, {
      className: "float-right d-sm-none",
      listClassName: "m-0"
    }, react_9(PaginationItem, {
      disabled: currentPage === 0
    }, react_9(PaginationLink, {
      previous: true,
      href: "#",
      onClick: function onClick(e) {
        return currentPageChange(e, currentPage - 1);
      }
    })), "\xA0", react_9(PaginationItem, {
      disabled: currentPage === totalPages - 1 || totalCount === 0
    }, react_9(PaginationLink, {
      next: true,
      href: "#",
      onClick: function onClick(e) {
        return currentPageChange(e, currentPage + 1);
      }
    }))), react_9("span", {
      className: "float-right d-sm-none mr-4"
    }, react_9("span", {
      className: "d-inline-block align-middle"
    }, getMessage('info', {
      from: from,
      to: to,
      count: totalCount
    }))));
  };

  var Pager = function Pager(_ref) {
    var currentPage = _ref.currentPage,
        _onCurrentPageChange = _ref.onCurrentPageChange,
        totalPages = _ref.totalPages,
        pageSize = _ref.pageSize,
        onPageSizeChange = _ref.onPageSizeChange,
        pageSizes = _ref.pageSizes,
        totalCount = _ref.totalCount,
        getMessage = _ref.getMessage,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["currentPage", "onCurrentPageChange", "totalPages", "pageSize", "onPageSizeChange", "pageSizes", "totalCount", "getMessage", "className"]);

    return react_9("div", _extends$b({
      className: classnames('clearfix card-footer dx-g-bs4-paging-panel', className)
    }, restProps), !!pageSizes.length && react_9(PageSizeSelector, {
      pageSize: pageSize,
      onPageSizeChange: onPageSizeChange,
      pageSizes: pageSizes,
      getMessage: getMessage
    }), react_9(Pagination$1, {
      totalPages: totalPages,
      totalCount: totalCount,
      currentPage: currentPage,
      onCurrentPageChange: function onCurrentPageChange(page) {
        return _onCurrentPageChange(page);
      },
      pageSize: pageSize,
      getMessage: getMessage
    }));
  };
  Pager.defaultProps = {
    className: undefined
  };

  var PagingPanel$1 = withComponents({
    Container: Pager
  })(PagingPanel);

  var GroupPanelContainer = function GroupPanelContainer(_ref) {
    var children = _ref.children,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["children", "className"]);

    return react_9("div", _extends$b({
      className: classnames('w-100 mt-1', className)
    }, restProps), children);
  };
  GroupPanelContainer.defaultProps = {
    children: null,
    className: undefined
  };

  var SortingIndicator = function SortingIndicator(_ref) {
    var direction = _ref.direction,
        className = _ref.className;
    return react_9("span", {
      className: classnames({
        'oi dx-g-bs4-sorting-indicator mx-2': true,
        'oi-arrow-thick-bottom': direction === 'desc',
        'oi-arrow-thick-top': direction !== 'desc',
        invisible: !direction
      }, className)
    });
  };
  SortingIndicator.defaultProps = {
    direction: null,
    className: undefined
  };

  var ENTER_KEY_CODE = 13;
  var SPACE_KEY_CODE = 32;

  var isActionKey = function isActionKey(keyCode) {
    return keyCode === ENTER_KEY_CODE || keyCode === SPACE_KEY_CODE;
  };

  var GroupPanelItem = function GroupPanelItem(_ref) {
    var _ref$item = _ref.item,
        column = _ref$item.column,
        draft = _ref$item.draft,
        onGroup = _ref.onGroup,
        showGroupingControls = _ref.showGroupingControls,
        showSortingControls = _ref.showSortingControls,
        sortingDirection = _ref.sortingDirection,
        onSort = _ref.onSort,
        className = _ref.className,
        groupingEnabled = _ref.groupingEnabled,
        sortingEnabled = _ref.sortingEnabled,
        restProps = _objectWithoutProperties(_ref, ["item", "onGroup", "showGroupingControls", "showSortingControls", "sortingDirection", "onSort", "className", "groupingEnabled", "sortingEnabled"]);

    var handleSortingChange = function handleSortingChange(e) {
      var isActionKeyDown = isActionKey(e.keyCode);
      var isMouseClick = e.keyCode === undefined;
      if (!showSortingControls || !sortingEnabled || !(isActionKeyDown || isMouseClick)) return;
      var cancelSortingRelatedKey = e.metaKey || e.ctrlKey;
      var direction = (isMouseClick || isActionKeyDown) && cancelSortingRelatedKey ? null : undefined;
      e.preventDefault();
      onSort({
        direction: direction,
        keepOther: cancelSortingRelatedKey
      });
    };

    var handleUngroup = function handleUngroup(e) {
      if (!groupingEnabled) return;
      var isActionKeyDown = isActionKey(e.keyCode);
      var isMouseClick = e.keyCode === undefined;
      if (!isActionKeyDown && !isMouseClick) return;
      onGroup();
    };

    return react_9("div", _extends$b({
      className: classnames({
        'btn-group mb-1 mr-1': true,
        'dx-g-bs4-inactive': draft
      }, className)
    }, restProps), react_9("span", _extends$b({
      className: classnames({
        'btn btn-outline-secondary': true,
        disabled: !sortingEnabled && (showSortingControls || !groupingEnabled)
      }),
      onClick: handleSortingChange,
      onKeyDown: handleSortingChange
    }, sortingEnabled ? {
      tabIndex: 0
    } : null), column.title || column.name, showSortingControls && sortingDirection && react_9("span", null, "\xA0", react_9(SortingIndicator, {
      direction: sortingDirection
    }))), showGroupingControls && react_9("span", {
      className: classnames({
        'btn btn-outline-secondary': true,
        disabled: !groupingEnabled
      }),
      onClick: handleUngroup
    }, "\xA0", react_9("span", {
      className: "oi oi-x dx-g-bs4-group-panel-item-icon"
    })));
  };
  GroupPanelItem.defaultProps = {
    showSortingControls: false,
    sortingDirection: undefined,
    className: undefined,
    onSort: undefined,
    onGroup: undefined,
    showGroupingControls: false,
    sortingEnabled: false,
    groupingEnabled: false
  };

  var GroupPanelEmptyMessage = function GroupPanelEmptyMessage(_ref) {
    var getMessage = _ref.getMessage,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["getMessage", "className"]);

    return react_9("div", _extends$b({
      className: classnames('dx-g-bs4-group-panel-empty-message', className)
    }, restProps), getMessage('groupByColumn'));
  };
  GroupPanelEmptyMessage.defaultProps = {
    className: undefined
  };

  var GroupingPanel$1 = withComponents({
    Container: GroupPanelContainer,
    Item: GroupPanelItem,
    EmptyMessage: GroupPanelEmptyMessage
  })(GroupingPanel);

  var ENTER_KEY_CODE$1 = 13;
  var SPACE_KEY_CODE$1 = 32;

  var handleMouseDown$1 = function handleMouseDown(e) {
    e.target.style.outline = 'none';
  };

  var handleBlur$1 = function handleBlur(e) {
    e.target.style.outline = '';
  };

  var ExpandButton = function ExpandButton(_ref) {
    var visible = _ref.visible,
        expanded = _ref.expanded,
        onToggle = _ref.onToggle,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["visible", "expanded", "onToggle", "className"]);

    var fireToggle = function fireToggle() {
      if (!visible) return;
      onToggle(!expanded);
    };

    var handleClick = function handleClick(e) {
      e.stopPropagation();
      fireToggle();
    };

    var handleKeyDown = function handleKeyDown(e) {
      if (e.keyCode === ENTER_KEY_CODE$1 || e.keyCode === SPACE_KEY_CODE$1) {
        e.preventDefault();
        fireToggle();
      }
    };

    return react_9("i", _extends$b({
      className: classnames({
        'oi p-2 text-center dx-g-bs4-toggle-button': true,
        'oi-chevron-bottom': expanded,
        'oi-chevron-right': !expanded,
        'dx-g-bs4-toggle-button-hidden': !visible
      }, className),
      tabIndex: visible ? 0 : undefined // eslint-disable-line jsx-a11y/no-noninteractive-tabindex
      ,
      onKeyDown: handleKeyDown,
      onMouseDown: handleMouseDown$1,
      onBlur: handleBlur$1,
      onClick: handleClick
    }, restProps));
  };
  ExpandButton.defaultProps = {
    visible: true,
    expanded: false,
    onToggle: function onToggle() {},
    className: undefined
  };

  var TableDetailToggleCell = function TableDetailToggleCell(_ref) {
    var expanded = _ref.expanded,
        onToggle = _ref.onToggle,
        tableColumn = _ref.tableColumn,
        tableRow = _ref.tableRow,
        row = _ref.row,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["expanded", "onToggle", "tableColumn", "tableRow", "row", "className"]);

    return react_9("td", _extends$b({
      className: classnames('text-center align-middle', className)
    }, restProps), react_9(ExpandButton, {
      expanded: expanded,
      onToggle: onToggle
    }));
  };
  TableDetailToggleCell.defaultProps = {
    className: undefined,
    expanded: false,
    onToggle: function onToggle() {},
    tableColumn: undefined,
    tableRow: undefined,
    row: undefined
  };

  var TableDetailCell = function TableDetailCell(_ref) {
    var colSpan = _ref.colSpan,
        children = _ref.children,
        className = _ref.className,
        tableColumn = _ref.tableColumn,
        tableRow = _ref.tableRow,
        row = _ref.row,
        restProps = _objectWithoutProperties(_ref, ["colSpan", "children", "className", "tableColumn", "tableRow", "row"]);

    return react_9("td", _extends$b({
      colSpan: colSpan,
      className: classnames('table-active', className)
    }, restProps), children);
  };
  TableDetailCell.defaultProps = {
    style: null,
    colSpan: 1,
    className: undefined,
    tableColumn: undefined,
    tableRow: undefined,
    row: undefined,
    children: undefined
  };

  var TableRow = function TableRow(_ref) {
    var children = _ref.children,
        row = _ref.row,
        tableRow = _ref.tableRow,
        restProps = _objectWithoutProperties(_ref, ["children", "row", "tableRow"]);

    return react_9("tr", restProps, children);
  };
  TableRow.defaultProps = {
    children: null,
    row: undefined,
    tableRow: undefined
  };

  var TableRowDetailWithWidth = function TableRowDetailWithWidth(props) {
    return react_9(TableRowDetail, _extends$b({
      toggleColumnWidth: 40
    }, props));
  };

  TableRowDetailWithWidth.components = TableRowDetail.components;
  var TableRowDetail$1 = withComponents({
    Row: TableRow,
    Cell: TableDetailCell,
    ToggleCell: TableDetailToggleCell
  })(TableRowDetailWithWidth);
  TableRowDetail$1.COLUMN_TYPE = TableRowDetail.COLUMN_TYPE;
  TableRowDetail$1.ROW_TYPE = TableRowDetail.ROW_TYPE;

  var Cell = function Cell(_ref) {
    var className = _ref.className,
        colSpan = _ref.colSpan,
        row = _ref.row,
        column = _ref.column,
        expanded = _ref.expanded,
        onToggle = _ref.onToggle,
        children = _ref.children,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        Icon = _ref.iconComponent,
        Content = _ref.contentComponent,
        restProps = _objectWithoutProperties(_ref, ["className", "colSpan", "row", "column", "expanded", "onToggle", "children", "tableRow", "tableColumn", "iconComponent", "contentComponent"]);

    var handleClick = function handleClick() {
      return onToggle();
    };

    return react_9("td", _extends$b({
      colSpan: colSpan,
      className: classnames('dx-g-bs4-cursor-pointer', className),
      onClick: handleClick
    }, restProps), react_9(Icon, {
      expanded: expanded,
      onToggle: onToggle,
      className: "mr-2"
    }), react_9(Content, {
      column: column,
      row: row
    }, children));
  };
  Cell.defaultProps = {
    className: undefined,
    colSpan: 1,
    row: {},
    column: {},
    expanded: false,
    onToggle: function onToggle() {},
    children: undefined,
    tableRow: undefined,
    tableColumn: undefined
  };

  var Content = function Content(_ref) {
    var column = _ref.column,
        row = _ref.row,
        children = _ref.children,
        restProps = _objectWithoutProperties(_ref, ["column", "row", "children"]);

    return react_9("span", restProps, react_9("strong", null, column.title || column.name, ":", ' '), children || String(row.value));
  };
  Content.defaultProps = {
    row: {},
    column: {},
    children: undefined
  };

  var TableGroupRowWithIndent = function TableGroupRowWithIndent(props) {
    return react_9(TableGroupRow, _extends$b({
      indentColumnWidth: 33
    }, props));
  };

  TableGroupRowWithIndent.components = TableGroupRow.components;
  var TableGroupRow$1 = withComponents({
    Row: TableRow,
    Cell: Cell,
    Content: Content,
    Icon: ExpandButton
  })(TableGroupRowWithIndent);
  TableGroupRow$1.COLUMN_TYPE = TableGroupRow.COLUMN_TYPE;
  TableGroupRow$1.ROW_TYPE = TableGroupRow.ROW_TYPE;

  var SelectionControl = function SelectionControl(_ref) {
    var disabled = _ref.disabled,
        checked = _ref.checked,
        indeterminate = _ref.indeterminate,
        _onChange = _ref.onChange,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["disabled", "checked", "indeterminate", "onChange", "className"]);

    return react_9("input", _extends$b({
      className: classnames({
        'd-inline-block': true,
        'dx-g-bs4-cursor-pointer': !disabled
      }, className),
      type: "checkbox",
      disabled: disabled,
      checked: checked,
      ref: function ref(_ref2) {
        if (_ref2) {
          _ref2.indeterminate = indeterminate; // eslint-disable-line no-param-reassign
        }
      },
      onChange: function onChange() {
        if (disabled) return;

        _onChange();
      },
      onClick: function onClick(e) {
        return e.stopPropagation();
      }
    }, restProps));
  };
  SelectionControl.defaultProps = {
    disabled: false,
    checked: false,
    indeterminate: false,
    onChange: function onChange() {},
    className: undefined
  };

  var TableSelectAllCell = function TableSelectAllCell(_ref) {
    var className = _ref.className,
        allSelected = _ref.allSelected,
        someSelected = _ref.someSelected,
        disabled = _ref.disabled,
        onToggle = _ref.onToggle,
        tableColumn = _ref.tableColumn,
        tableRow = _ref.tableRow,
        rowSpan = _ref.rowSpan,
        restProps = _objectWithoutProperties(_ref, ["className", "allSelected", "someSelected", "disabled", "onToggle", "tableColumn", "tableRow", "rowSpan"]);

    return react_9("th", _extends$b({
      className: classnames({
        'text-center': true,
        'align-middle': !rowSpan,
        'align-bottom': !!rowSpan
      }, className),
      rowSpan: rowSpan
    }, restProps), react_9(SelectionControl, {
      disabled: disabled,
      checked: allSelected,
      indeterminate: someSelected,
      onChange: onToggle
    }));
  };
  TableSelectAllCell.defaultProps = {
    className: undefined,
    allSelected: false,
    someSelected: false,
    disabled: false,
    onToggle: function onToggle() {},
    tableRow: undefined,
    tableColumn: undefined,
    rowSpan: undefined
  };

  var TableSelectCell = function TableSelectCell(_ref) {
    var className = _ref.className,
        selected = _ref.selected,
        onToggle = _ref.onToggle,
        row = _ref.row,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        restProps = _objectWithoutProperties(_ref, ["className", "selected", "onToggle", "row", "tableRow", "tableColumn"]);

    return react_9("td", _extends$b({
      className: classnames('text-center align-middle', className)
    }, restProps), react_9(SelectionControl, {
      checked: selected,
      onChange: onToggle
    }));
  };
  TableSelectCell.defaultProps = {
    className: undefined,
    selected: false,
    onToggle: function onToggle() {},
    row: undefined,
    tableRow: undefined,
    tableColumn: undefined
  };

  var TableSelectRow = function TableSelectRow(_ref) {
    var selected = _ref.selected,
        children = _ref.children,
        style = _ref.style,
        onToggle = _ref.onToggle,
        selectByRowClick = _ref.selectByRowClick;
    return react_9("tr", {
      style: style,
      className: selected ? 'table-active' : '',
      onClick: function onClick(e) {
        if (!selectByRowClick) return;
        e.stopPropagation();
        onToggle();
      }
    }, children);
  };
  TableSelectRow.defaultProps = {
    children: null,
    onToggle: function onToggle() {},
    selected: false,
    selectByRowClick: false,
    style: null
  };

  var TableSelectionWithWidth = function TableSelectionWithWidth(props) {
    return react_9(TableSelection, _extends$b({
      selectionColumnWidth: 40
    }, props));
  };

  TableSelectionWithWidth.components = TableSelection.components;
  var TableSelection$1 = withComponents({
    Row: TableSelectRow,
    Cell: TableSelectCell,
    HeaderCell: TableSelectAllCell
  })(TableSelectionWithWidth);
  TableSelection$1.COLUMN_TYPE = TableSelection.COLUMN_TYPE;

  var MINIMAL_COLUMN_WIDTH = 150;
  var TableLayout$1 = function TableLayout$1(props) {
    return react_9(TableLayout, _extends$b({
      layoutComponent: StaticTableLayout,
      minColumnWidth: MINIMAL_COLUMN_WIDTH
    }, props));
  };

  var TableCell = function TableCell(_ref) {
    var column = _ref.column,
        value = _ref.value,
        children = _ref.children,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        row = _ref.row,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["column", "value", "children", "tableRow", "tableColumn", "row", "className"]);

    return react_9("td", _extends$b({
      className: classnames({
        'dx-g-bs4-table-cell': true,
        'text-nowrap': !(tableColumn && tableColumn.wordWrapEnabled),
        'text-right': tableColumn && tableColumn.align === 'right',
        'text-center': tableColumn && tableColumn.align === 'center'
      }, className)
    }, restProps), children || value);
  };
  TableCell.defaultProps = {
    value: undefined,
    column: undefined,
    row: undefined,
    children: undefined,
    tableRow: undefined,
    tableColumn: undefined,
    className: undefined
  };

  var TableStubCell = function TableStubCell(_ref) {
    var className = _ref.className,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        restProps = _objectWithoutProperties(_ref, ["className", "tableRow", "tableColumn"]);

    return react_9("td", _extends$b({
      className: classnames('p-0', className)
    }, restProps));
  };
  TableStubCell.defaultProps = {
    className: undefined,
    tableRow: undefined,
    tableColumn: undefined
  };

  var TableStubHeaderCell = function TableStubHeaderCell(_ref) {
    var className = _ref.className,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        restProps = _objectWithoutProperties(_ref, ["className", "tableRow", "tableColumn"]);

    return react_9("th", _extends$b({
      className: classnames('p-0', className)
    }, restProps));
  };
  TableStubHeaderCell.defaultProps = {
    className: undefined,
    tableRow: undefined,
    tableColumn: undefined
  };

  var TableNoDataCell = function TableNoDataCell(_ref) {
    var className = _ref.className,
        colSpan = _ref.colSpan,
        getMessage = _ref.getMessage,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        restProps = _objectWithoutProperties(_ref, ["className", "colSpan", "getMessage", "tableRow", "tableColumn"]);

    return react_9("td", _extends$b({
      className: classnames('py-5', className),
      colSpan: colSpan
    }, restProps), react_9("div", {
      className: "dx-g-bs4-fixed-block"
    }, react_9("big", {
      className: "text-muted"
    }, getMessage('noData'))));
  };
  TableNoDataCell.defaultProps = {
    className: undefined,
    colSpan: 1,
    tableRow: undefined,
    tableColumn: undefined
  };

  var Table$1 =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits$d(Table, _React$Component);

    function Table() {
      _classCallCheck$i(this, Table);

      return _possibleConstructorReturn$d(this, _getPrototypeOf$1(Table).apply(this, arguments));
    }

    _createClass$1(Table, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            children = _this$props.children,
            use = _this$props.use,
            style = _this$props.style,
            className = _this$props.className,
            tableRef = _this$props.tableRef,
            restProps = _objectWithoutProperties(_this$props, ["children", "use", "style", "className", "tableRef"]);

        var backgroundColor = this.context;
        return react_9("table", _extends$b({
          ref: tableRef,
          className: classnames({
            'table dx-g-bs4-table': true,
            'dx-g-bs4-table-sticky': !!use,
            'dx-g-bs4-table-head': use === 'head',
            'dx-g-bs4-table-foot': use === 'foot'
          }, className)
        }, restProps, {
          style: _objectSpread$1({}, style, use ? {
            backgroundColor: backgroundColor
          } : null)
        }), children);
      }
    }]);

    return Table;
  }(react_2);
  Table$1.contextType = BodyColorContext;
  Table$1.defaultProps = {
    className: undefined,
    use: undefined,
    style: null
  };

  var TableContainer$1 = function TableContainer(_ref) {
    var children = _ref.children,
        className = _ref.className,
        style = _ref.style,
        restProps = _objectWithoutProperties(_ref, ["children", "className", "style"]);

    return react_9("div", _extends$b({
      className: classnames('table-responsive dx-g-bs4-table-container', className),
      style: _objectSpread$1({
        msOverflowStyle: 'auto'
      }, style)
    }, restProps), children);
  };
  TableContainer$1.defaultProps = {
    className: undefined,
    style: null
  };

  var TableStubRow = function TableStubRow(_ref) {
    var children = _ref.children,
        tableRow = _ref.tableRow,
        restProps = _objectWithoutProperties(_ref, ["children", "tableRow"]);

    return react_9("tr", restProps, children);
  };
  TableStubRow.defaultProps = {
    children: null,
    tableRow: undefined
  };

  var TableHead = function TableHead(props) {
    return react_9("thead", props);
  };

  var TableBody = function TableBody(props) {
    return react_9("tbody", props);
  };

  var TableFooter = function TableFooter(props) {
    return react_9("tfoot", props);
  };

  var Table$1$1 = withComponents({
    Table: Table$1,
    TableHead: TableHead,
    TableBody: TableBody,
    TableFooter: TableFooter,
    Container: TableContainer$1,
    Layout: TableLayout$1,
    Row: TableRow,
    Cell: TableCell,
    NoDataRow: TableRow,
    NoDataCell: TableNoDataCell,
    StubRow: TableStubRow,
    StubCell: TableStubCell,
    StubHeaderCell: TableStubHeaderCell
  })(Table);
  Table$1$1.COLUMN_TYPE = Table.COLUMN_TYPE;
  Table$1$1.ROW_TYPE = Table.ROW_TYPE;
  Table$1$1.NODATA_ROW_TYPE = Table.NODATA_ROW_TYPE;

  var TableSkeletonCell = function TableSkeletonCell(_ref) {
    var className = _ref.className,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        restProps = _objectWithoutProperties(_ref, ["className", "tableRow", "tableColumn"]);

    return react_9("td", _extends$b({
      className: classnames('dx-g-bs4-skeleton-cell', className)
    }, restProps));
  };
  TableSkeletonCell.defaultProps = {
    className: undefined,
    tableRow: undefined,
    tableColumn: undefined
  };

  var MINIMAL_COLUMN_WIDTH$1 = 150;
  var VirtualTableLayout$1 = function VirtualTableLayout$1(props) {
    return react_9(TableLayout, _extends$b({
      layoutComponent: VirtualTableLayout,
      minColumnWidth: MINIMAL_COLUMN_WIDTH$1
    }, props));
  };

  var FixedHeader = function FixedHeader(props) {
    return react_9(Table$1, _extends$b({
      use: "head"
    }, props));
  };

  var FixedFooter = function FixedFooter(props) {
    return react_9(Table$1, _extends$b({
      use: "foot"
    }, props));
  };

  var VirtualTable = makeVirtualTable(Table$1$1, {
    VirtualLayout: VirtualTableLayout$1,
    FixedHeader: FixedHeader,
    FixedFooter: FixedFooter,
    SkeletonCell: TableSkeletonCell,
    defaultEstimatedRowHeight: 49,
    defaultHeight: 530
  });
  VirtualTable.COLUMN_TYPE = Table$1$1.COLUMN_TYPE;
  VirtualTable.ROW_TYPE = Table$1$1.ROW_TYPE;
  VirtualTable.NODATA_ROW_TYPE = Table$1$1.NODATA_ROW_TYPE;

  var TableFilterCell = function TableFilterCell(_ref) {
    var filter = _ref.filter,
        onFilter = _ref.onFilter,
        children = _ref.children,
        column = _ref.column,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        getMessage = _ref.getMessage,
        filteringEnabled = _ref.filteringEnabled,
        restProps = _objectWithoutProperties(_ref, ["filter", "onFilter", "children", "column", "tableRow", "tableColumn", "getMessage", "filteringEnabled"]);

    return react_9("th", restProps, react_9("div", {
      className: "input-group"
    }, children));
  };
  TableFilterCell.defaultProps = {
    filter: null,
    onFilter: function onFilter() {},
    children: undefined,
    column: undefined,
    tableRow: undefined,
    tableColumn: undefined,
    getMessage: undefined,
    filteringEnabled: true
  };

  var Editor = function Editor(_ref) {
    var value = _ref.value,
        disabled = _ref.disabled,
        getMessage = _ref.getMessage,
        _onChange = _ref.onChange,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["value", "disabled", "getMessage", "onChange", "className"]);

    return react_9("input", _extends$b({
      type: "text",
      className: classnames('form-control', className),
      value: value,
      onChange: function onChange(event) {
        return _onChange(event.target.value);
      },
      readOnly: disabled,
      placeholder: getMessage('filterPlaceholder')
    }, restProps));
  };
  Editor.defaultProps = {
    value: '',
    disabled: false,
    onChange: function onChange() {},
    className: undefined
  };

  var FilterSelector =
  /*#__PURE__*/
  function (_React$PureComponent) {
    _inherits$d(FilterSelector, _React$PureComponent);

    function FilterSelector(props) {
      var _this;

      _classCallCheck$i(this, FilterSelector);

      _this = _possibleConstructorReturn$d(this, _getPrototypeOf$1(FilterSelector).call(this, props));
      _this.state = {
        opened: false
      };

      _this.handleButtonClick = function () {
        _this.setState(function (prevState) {
          return {
            opened: !prevState.opened
          };
        });
      };

      _this.handleOverlayToggle = function () {
        var opened = _this.state.opened;
        if (opened) _this.setState({
          opened: false
        });
      };

      _this.handleMenuItemClick = function (nextValue) {
        var onChange = _this.props.onChange;

        _this.setState({
          opened: false
        });

        onChange(nextValue);
      };

      return _this;
    }

    _createClass$1(FilterSelector, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            value = _this$props.value,
            availableValues = _this$props.availableValues,
            disabled = _this$props.disabled,
            getMessage = _this$props.getMessage,
            Icon = _this$props.iconComponent,
            ToggleButton = _this$props.toggleButtonComponent,
            className = _this$props.className,
            restProps = _objectWithoutProperties(_this$props, ["value", "availableValues", "disabled", "getMessage", "iconComponent", "toggleButtonComponent", "className"]);

        var opened = this.state.opened;
        return availableValues.length ? react_9("div", _extends$b({
          className: classnames('input-group-prepend', className)
        }, restProps), react_9(ToggleButton, {
          disabled: disabled || availableValues.length === 1,
          onToggle: this.handleButtonClick,
          buttonRef: function buttonRef(ref) {
            _this2.targetElement = ref;
          }
        }, react_9(Icon, {
          type: value
        })), this.targetElement ? react_9(Popover, {
          placement: "bottom",
          isOpen: opened,
          target: this.targetElement,
          toggle: this.handleOverlayToggle
        }, react_9("div", {
          className: "py-2"
        }, availableValues.map(function (valueItem) {
          return react_9("button", {
            type: "button",
            key: valueItem,
            className: classnames({
              'dropdown-item d-flex align-items-center': true,
              'dx-g-bs4-cursor-pointer dx-g-bs4-filter-selector-item': true,
              active: valueItem === value
            }),
            onClick: function onClick() {
              return _this2.handleMenuItemClick(valueItem);
            }
          }, react_9(Icon, {
            type: valueItem
          }), react_9("span", {
            className: "dx-g-bs4-filter-selector-item-text"
          }, getMessage(valueItem)));
        }))) : null) : null;
      }
    }]);

    return FilterSelector;
  }(react_4);
  FilterSelector.defaultProps = {
    value: undefined,
    availableValues: [],
    onChange: function onChange() {},
    disabled: false,
    className: undefined
  };

  var ToggleButton$1 = function ToggleButton(_ref) {
    var buttonRef = _ref.buttonRef,
        onToggle = _ref.onToggle,
        disabled = _ref.disabled,
        children = _ref.children,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["buttonRef", "onToggle", "disabled", "children", "className"]);

    return react_9("button", _extends$b({
      type: "button",
      className: classnames('btn btn-outline-secondary', className),
      disabled: disabled,
      onClick: onToggle,
      ref: buttonRef
    }, restProps), children);
  };
  ToggleButton$1.defaultProps = {
    children: undefined,
    className: undefined,
    disabled: false
  };

  var AVAILABLE_PATHS = {
    contains: 'M6.094 19.563l-2.031 0.281c-0.646 0.094-1.13 0.266-1.453 0.516-0.302 0.24-0.453 0.646-0.453 1.219 0 0.438 0.138 0.799 0.414 1.086s0.664 0.419 1.164 0.398c0.708 0 1.281-0.24 1.719-0.719 0.427-0.49 0.641-1.125 0.641-1.906v-0.875zM8.234 24.641h-2.172v-1.641c-0.677 1.24-1.661 1.859-2.953 1.859-0.927 0-1.682-0.276-2.266-0.828-0.552-0.552-0.828-1.292-0.828-2.219 0-1.927 1.068-3.052 3.203-3.375l2.875-0.438c0-1.469-0.656-2.203-1.969-2.203-1.177 0-2.224 0.427-3.141 1.281v-2.078c1.010-0.656 2.198-0.984 3.563-0.984 2.458 0 3.687 1.302 3.687 3.906v6.719zM14.734 16.797c0.521-0.583 1.167-0.875 1.938-0.875 0.74 0 1.323 0.281 1.75 0.844 0.448 0.583 0.672 1.38 0.672 2.391 0 1.188-0.24 2.13-0.719 2.828-0.49 0.677-1.13 1.016-1.922 1.016-0.719 0-1.302-0.271-1.75-0.813-0.427-0.51-0.641-1.141-0.641-1.891v-1.266c-0.021-0.906 0.203-1.651 0.672-2.234zM16.969 24.859c1.375 0 2.443-0.521 3.203-1.562 0.781-1.042 1.172-2.427 1.172-4.156 0-1.542-0.354-2.771-1.063-3.688-0.688-0.958-1.651-1.438-2.891-1.438-1.427 0-2.531 0.693-3.313 2.078v-6.781h-2.156v15.328h2.172v-1.5c0.677 1.146 1.635 1.719 2.875 1.719zM22.266 6.125c0.135 0 0.245 0.063 0.328 0.188 0.104 0.073 0.156 0.182 0.156 0.328v22.953c0 0.125-0.052 0.24-0.156 0.344-0.083 0.115-0.193 0.172-0.328 0.172h-12.281c-0.146 0-0.266-0.057-0.359-0.172-0.115-0.115-0.172-0.229-0.172-0.344v-22.953c0-0.135 0.057-0.245 0.172-0.328 0.094-0.125 0.214-0.188 0.359-0.188h12.281zM31.531 24.141c-0.76 0.479-1.693 0.719-2.797 0.719-1.427 0-2.589-0.479-3.484-1.438-0.865-0.958-1.286-2.198-1.266-3.719 0-1.688 0.448-3.052 1.344-4.094 0.917-1.042 2.208-1.573 3.875-1.594 0.854 0 1.63 0.177 2.328 0.531v2.156c-0.677-0.531-1.391-0.792-2.141-0.781-0.938 0-1.714 0.339-2.328 1.016-0.594 0.677-0.891 1.552-0.891 2.625 0 1.042 0.297 1.88 0.891 2.516 0.521 0.615 1.25 0.922 2.188 0.922 0.813 0 1.573-0.297 2.281-0.891v2.031z',
    notContains: 'M5.828 20.469v0.328c0 0.385-0.057 0.667-0.172 0.844-0.052 0.083-0.117 0.177-0.195 0.281s-0.174 0.224-0.289 0.359c-0.458 0.521-1.031 0.771-1.719 0.75-0.521 0-0.927-0.141-1.219-0.422-0.292-0.292-0.438-0.661-0.438-1.109 0-0.156 0.010-0.273 0.031-0.352s0.052-0.141 0.094-0.188 0.094-0.086 0.156-0.117 0.141-0.078 0.234-0.141c0.031-0.031 0.078-0.070 0.141-0.117s0.146-0.086 0.25-0.117h3.125zM14.016 18.328c0.010-0.406 0.070-0.729 0.18-0.969s0.289-0.49 0.539-0.75c0.479-0.604 1.13-0.906 1.953-0.906 0.75 0 1.344 0.292 1.781 0.875 0.198 0.25 0.349 0.495 0.453 0.734s0.172 0.578 0.203 1.016h-5.109zM19.078 20.469c-0.063 0.427-0.146 0.708-0.25 0.844-0.052 0.073-0.109 0.159-0.172 0.258l-0.219 0.352c-0.469 0.688-1.135 1.031-2 1.031-0.708 0-1.297-0.271-1.766-0.813l-0.305-0.359c-0.089-0.104-0.159-0.198-0.211-0.281-0.104-0.167-0.156-0.448-0.156-0.844v-0.188h5.078zM33.344 18.328l-6.875 0c0.031-0.198 0.070-0.372 0.117-0.523s0.107-0.284 0.18-0.398 0.154-0.224 0.242-0.328l0.305-0.344c0.604-0.688 1.391-1.031 2.359-1.031 0.771 0 1.51 0.266 2.219 0.797v-2.234c-0.75-0.333-1.552-0.5-2.406-0.5-1.667 0-2.974 0.531-3.922 1.594-0.396 0.427-0.708 0.859-0.938 1.297s-0.385 0.995-0.469 1.672h-2.719c-0.021-0.719-0.117-1.31-0.289-1.773s-0.424-0.914-0.758-1.352c-0.729-0.938-1.719-1.417-2.969-1.438-1.479 0-2.615 0.708-3.406 2.125v-6.953h-2.266v9.391h-3.75v-0.594c0-2.646-1.25-3.969-3.75-3.969-1.365 0-2.583 0.328-3.656 0.984v2.125c0.99-0.865 2.063-1.297 3.219-1.297 1.344 0 2.016 0.75 2.016 2.25l-2.953 0.125c-0.25 0.021-0.487 0.070-0.711 0.148l-0.633 0.227h-3.328v2.141h1.828l-0.281 0.594c-0.073 0.135-0.109 0.37-0.109 0.703 0 0.938 0.276 1.682 0.828 2.234 0.542 0.573 1.313 0.859 2.313 0.859 1.281 0 2.297-0.635 3.047-1.906v1.656h2.172v-4.141h3.75v4.141h2.297v-1.516c0.677 1.188 1.661 1.776 2.953 1.766 1.385 0 2.464-0.531 3.234-1.594 0.302-0.385 0.557-0.792 0.766-1.219 0.198-0.385 0.339-0.911 0.422-1.578h2.703c0.021 0.708 0.141 1.25 0.359 1.625 0.115 0.198 0.253 0.401 0.414 0.609s0.346 0.427 0.555 0.656c0.906 1 2.099 1.5 3.578 1.5 1.104 0 2.057-0.245 2.859-0.734v-2.109c-0.75 0.604-1.526 0.917-2.328 0.938-0.979 0-1.74-0.318-2.281-0.953l-0.328-0.328c-0.094-0.094-0.177-0.195-0.25-0.305s-0.13-0.234-0.172-0.375-0.073-0.315-0.094-0.523h6.906v-2.141zM33.297 5.688c0.146 0 0.266 0.047 0.359 0.141 0.104 0.104 0.156 0.229 0.156 0.375v23.484c0 0.135-0.052 0.255-0.156 0.359-0.094 0.115-0.214 0.172-0.359 0.172h-35.078c-0.135 0-0.26-0.057-0.375-0.172-0.094-0.115-0.135-0.234-0.125-0.359v-23.484c0-0.104 0.042-0.229 0.125-0.375 0.104-0.094 0.229-0.141 0.375-0.141h35.078z',
    startsWith: 'M6.109 20.688c0 0.813-0.219 1.474-0.656 1.984-0.448 0.531-1.010 0.786-1.688 0.766-0.51 0-0.896-0.141-1.156-0.422-0.302-0.292-0.443-0.667-0.422-1.125 0-0.615 0.151-1.042 0.453-1.281 0.177-0.135 0.378-0.245 0.602-0.328s0.497-0.146 0.82-0.188l2.047-0.313v0.906zM8.203 18.063c0-2.688-1.219-4.031-3.656-4.031-1.333 0-2.51 0.339-3.531 1.016v2.141c0.917-0.885 1.948-1.328 3.094-1.328 1.333 0 2 0.766 2 2.297l-2.891 0.453c-2.115 0.333-3.161 1.516-3.141 3.547 0 0.958 0.266 1.724 0.797 2.297 0.542 0.573 1.292 0.859 2.25 0.859 1.292 0 2.26-0.641 2.906-1.922v1.688h2.172v-7.016zM14.703 16.906c0.479-0.604 1.109-0.906 1.891-0.906 0.76 0 1.344 0.297 1.75 0.891 0.438 0.615 0.656 1.443 0.656 2.484 0 1.219-0.229 2.198-0.688 2.938-0.469 0.719-1.109 1.078-1.922 1.078-0.719 0-1.286-0.281-1.703-0.844-0.448-0.542-0.672-1.208-0.672-2v-1.313c-0.010-0.938 0.219-1.714 0.688-2.328zM16.906 25.313c1.365 0 2.422-0.542 3.172-1.625 0.771-1.115 1.156-2.563 1.156-4.344 0-1.604-0.339-2.885-1.016-3.844-0.698-0.979-1.661-1.469-2.891-1.469-1.438 0-2.531 0.719-3.281 2.156v-7.078h-2.188v15.969h2.172v-1.563c0.667 1.198 1.625 1.797 2.875 1.797zM31.375 24.563c-0.75 0.5-1.672 0.75-2.766 0.75-1.427 0-2.583-0.505-3.469-1.516-0.885-0.969-1.318-2.26-1.297-3.875 0-1.74 0.464-3.161 1.391-4.266 0.927-1.063 2.198-1.604 3.813-1.625 0.844 0 1.62 0.172 2.328 0.516v2.25c-0.688-0.563-1.406-0.828-2.156-0.797-0.927 0-1.688 0.349-2.281 1.047-0.583 0.698-0.875 1.609-0.875 2.734 0 1.094 0.281 1.969 0.844 2.625 0.542 0.656 1.286 0.984 2.234 0.984 0.781 0 1.526-0.323 2.234-0.969v2.141zM22.172 5.844c0.115 0 0.224 0.052 0.328 0.156 0.094 0.125 0.141 0.25 0.141 0.375v23.844c0 0.156-0.047 0.286-0.141 0.391-0.115 0.094-0.224 0.141-0.328 0.141h-23.469c-0.125 0-0.24-0.047-0.344-0.141-0.094-0.104-0.141-0.234-0.141-0.391v-23.844c0-0.125 0.047-0.25 0.141-0.375 0.104-0.104 0.219-0.156 0.344-0.156h23.469z',
    endsWith: 'M6.234 19.344l-2.047 0.313c-0.625 0.083-1.104 0.26-1.438 0.531-0.302 0.24-0.453 0.651-0.453 1.234 0 0.469 0.141 0.852 0.422 1.148s0.672 0.435 1.172 0.414c0.677 0 1.234-0.25 1.672-0.75 0.448-0.51 0.672-1.167 0.672-1.969v-0.922zM8.359 24.578h-2.141v-1.656c-0.667 1.26-1.656 1.891-2.969 1.891-0.938 0-1.698-0.276-2.281-0.828-0.542-0.573-0.813-1.328-0.813-2.266 0-2.021 1.063-3.188 3.188-3.5l2.891-0.484c0-1.51-0.661-2.266-1.984-2.266-1.167 0-2.214 0.443-3.141 1.328v-2.125c1.042-0.677 2.224-1.016 3.547-1.016 2.469 0 3.703 1.333 3.703 4v6.922zM14.906 16.516c0.49-0.615 1.13-0.922 1.922-0.922 0.76 0 1.339 0.297 1.734 0.891 0.438 0.615 0.656 1.438 0.656 2.469 0 1.208-0.229 2.182-0.688 2.922-0.469 0.698-1.115 1.047-1.938 1.047-0.708 0-1.276-0.276-1.703-0.828-0.458-0.552-0.688-1.214-0.688-1.984v-1.281c-0.010-0.948 0.224-1.719 0.703-2.313zM17.125 24.813c1.354 0 2.417-0.531 3.188-1.594 0.781-1.073 1.172-2.505 1.172-4.297 0-1.604-0.349-2.87-1.047-3.797-0.698-0.979-1.661-1.469-2.891-1.469-1.438 0-2.542 0.714-3.313 2.141v-7h-2.203v15.781h2.188v-1.531c0.677 1.177 1.646 1.766 2.906 1.766zM31.688 21.969c-0.698 0.635-1.453 0.953-2.266 0.953-0.958 0-1.703-0.323-2.234-0.969-0.563-0.667-0.849-1.536-0.859-2.609 0-1.115 0.297-2.016 0.891-2.703 0.594-0.698 1.359-1.047 2.297-1.047 0.76 0 1.484 0.266 2.172 0.797v-2.219c-0.708-0.344-1.49-0.516-2.344-0.516-1.625 0-2.906 0.536-3.844 1.609-0.938 1.083-1.406 2.495-1.406 4.234 0 1.594 0.438 2.875 1.313 3.844 0.885 0.979 2.052 1.469 3.5 1.469 1.083 0 2.010-0.245 2.781-0.734v-2.109zM33.188 5.563c0.104 0 0.219 0.047 0.344 0.141 0.094 0.146 0.141 0.276 0.141 0.391v23.578c0 0.146-0.047 0.281-0.141 0.406-0.125 0.094-0.24 0.141-0.344 0.141h-23.625c-0.125 0-0.24-0.047-0.344-0.141-0.094-0.135-0.135-0.271-0.125-0.406v-23.578c0-0.115 0.042-0.245 0.125-0.391 0.094-0.094 0.208-0.141 0.344-0.141h23.625z',
    equal: 'M29.438 11.797v2.75h-26.922v-2.75h26.922zM29.438 17.406v2.75h-26.922v-2.75h26.922z',
    notEqual: 'M16.906 11.797l3.016-6.547 2.094 1-2.547 5.547h9.969v2.75h-11.234l-1.328 2.859h12.563v2.75h-13.828l-2.875 6.281-2.094-0.984 2.438-5.297h-10.563v-2.75h11.828l1.297-2.859h-13.125v-2.75h14.391z',
    greaterThan: 'M24.125 16.047l-14.906 8.625-1.375-2.375 10.781-6.25-10.781-6.234 1.375-2.375z',
    greaterThanOrEqual: 'M23.031 14.328l-14.906 8.625-1.375-2.375 10.797-6.25-10.797-6.234 1.375-2.375zM23.828 15.641l1.375 2.391-14.938 8.609-1.375-2.375z',
    lessThan: 'M22.75 7.438l1.375 2.375-10.781 6.234 10.781 6.25-1.375 2.375-14.906-8.609z',
    lessThanOrEqual: 'M23.828 5.719l1.375 2.375-10.813 6.234 10.813 6.25-1.375 2.375-14.922-8.609zM23.047 24.266l-1.375 2.375-14.922-8.609 1.375-2.391z'
  };
  var Icon = function Icon(_ref) {
    var type = _ref.type,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["type", "className"]);

    var path = AVAILABLE_PATHS[type];
    return path ? react_9("svg", _extends$b({
      className: classnames('d-block dx-g-bs4-filter-selector-icon', className),
      viewBox: "0 0 32 32"
    }, restProps), react_9("path", {
      d: path
    })) : react_9("span", _extends$b({
      className: classnames('d-block', 'oi', 'oi-magnifying-glass', 'dx-g-bs4-filter-selector-icon', className)
    }, restProps));
  };
  Icon.defaultProps = {
    type: undefined,
    className: undefined
  };

  var TableFilterRow$1 = withComponents({
    Row: TableRow,
    Cell: TableFilterCell,
    Editor: Editor,
    FilterSelector: FilterSelector,
    Icon: Icon,
    ToggleButton: ToggleButton$1
  })(TableFilterRow);
  TableFilterRow$1.ROW_TYPE = TableFilterRow.ROW_TYPE;

  var ResizingControl =
  /*#__PURE__*/
  function (_React$PureComponent) {
    _inherits$d(ResizingControl, _React$PureComponent);

    function ResizingControl(props) {
      var _this;

      _classCallCheck$i(this, ResizingControl);

      _this = _possibleConstructorReturn$d(this, _getPrototypeOf$1(ResizingControl).call(this, props));
      _this.state = {
        resizing: false
      };

      _this.onResizeStart = function (_ref) {
        var x = _ref.x;
        _this.resizeStartingX = x;

        _this.setState({
          resizing: true
        });
      };

      _this.onResizeUpdate = function (_ref2) {
        var x = _ref2.x;
        var onWidthDraft = _this.props.onWidthDraft;
        onWidthDraft({
          shift: x - _this.resizeStartingX
        });
      };

      _this.onResizeEnd = function (_ref3) {
        var x = _ref3.x;
        var _this$props = _this.props,
            onWidthChange = _this$props.onWidthChange,
            onWidthDraftCancel = _this$props.onWidthDraftCancel;
        onWidthDraftCancel();
        onWidthChange({
          shift: x - _this.resizeStartingX
        });

        _this.setState({
          resizing: false
        });
      };

      return _this;
    }

    _createClass$1(ResizingControl, [{
      key: "render",
      value: function render() {
        var resizing = this.state.resizing;
        return react_9(Draggable, {
          onStart: this.onResizeStart,
          onUpdate: this.onResizeUpdate,
          onEnd: this.onResizeEnd
        }, react_9("div", {
          className: classnames({
            'dx-g-bs4-resizing-control-wrapper': true,
            'dx-g-bs4-resizing-control-wrapper-active': resizing
          })
        }, react_9("div", {
          className: classnames({
            'dx-g-bs4-resize-control-line dx-g-bs4-resize-control-line-first bg-primary': true,
            'dx-g-bs4-resize-control-line-active': resizing
          })
        }), react_9("div", {
          className: classnames({
            'dx-g-bs4-resize-control-line dx-g-bs4-resize-control-line-second bg-primary': true,
            'dx-g-bs4-resize-control-line-active': resizing
          })
        })));
      }
    }]);

    return ResizingControl;
  }(react_4);

  var TableHeaderCell =
  /*#__PURE__*/
  function (_React$PureComponent) {
    _inherits$d(TableHeaderCell, _React$PureComponent);

    function TableHeaderCell(props) {
      var _this;

      _classCallCheck$i(this, TableHeaderCell);

      _this = _possibleConstructorReturn$d(this, _getPrototypeOf$1(TableHeaderCell).call(this, props));
      _this.state = {
        dragging: false
      };
      _this.cellRef = react_11();

      _this.onDragStart = function () {
        _this.setState({
          dragging: true
        });
      };

      _this.onDragEnd = function () {
        if (_this.cellRef.current) {
          _this.setState({
            dragging: false
          });
        }
      };

      return _this;
    }

    _createClass$1(TableHeaderCell, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            className = _this$props.className,
            column = _this$props.column,
            tableColumn = _this$props.tableColumn,
            showGroupingControls = _this$props.showGroupingControls,
            onGroup = _this$props.onGroup,
            groupingEnabled = _this$props.groupingEnabled,
            draggingEnabled = _this$props.draggingEnabled,
            onWidthDraftCancel = _this$props.onWidthDraftCancel,
            resizingEnabled = _this$props.resizingEnabled,
            onWidthChange = _this$props.onWidthChange,
            onWidthDraft = _this$props.onWidthDraft,
            tableRow = _this$props.tableRow,
            children = _this$props.children,
            showSortingControls = _this$props.showSortingControls,
            sortingDirection = _this$props.sortingDirection,
            sortingEnabled = _this$props.sortingEnabled,
            onSort = _this$props.onSort,
            before = _this$props.before,
            restProps = _objectWithoutProperties(_this$props, ["className", "column", "tableColumn", "showGroupingControls", "onGroup", "groupingEnabled", "draggingEnabled", "onWidthDraftCancel", "resizingEnabled", "onWidthChange", "onWidthDraft", "tableRow", "children", "showSortingControls", "sortingDirection", "sortingEnabled", "onSort", "before"]);

        var dragging = this.state.dragging;
        var cellLayout = react_9("th", _extends$b({
          className: classnames({
            'position-relative dx-g-bs4-header-cell': true,
            'dx-g-bs4-user-select-none': draggingEnabled,
            'dx-g-bs4-cursor-pointer': draggingEnabled,
            'dx-g-bs4-inactive': dragging || tableColumn && tableColumn.draft,
            'text-nowrap': !(tableColumn && tableColumn.wordWrapEnabled)
          }, className),
          scope: "col"
        }, restProps), react_9("div", {
          className: "d-flex flex-direction-row align-items-center"
        }, children), resizingEnabled && react_9(ResizingControl, {
          onWidthChange: onWidthChange,
          onWidthDraft: onWidthDraft,
          onWidthDraftCancel: onWidthDraftCancel
        }));
        return draggingEnabled ? react_9(DragSource, {
          ref: this.cellRef,
          payload: [{
            type: 'column',
            columnName: column.name
          }],
          onStart: this.onDragStart,
          onEnd: this.onDragEnd
        }, cellLayout) : cellLayout;
      }
    }]);

    return TableHeaderCell;
  }(react_4);
  TableHeaderCell.defaultProps = {
    before: undefined,
    column: undefined,
    tableColumn: undefined,
    tableRow: undefined,
    className: undefined,
    showSortingControls: false,
    sortingEnabled: false,
    sortingDirection: undefined,
    onSort: undefined,
    showGroupingControls: false,
    onGroup: undefined,
    groupingEnabled: false,
    draggingEnabled: false,
    resizingEnabled: false,
    onWidthChange: undefined,
    onWidthDraft: undefined,
    onWidthDraftCancel: undefined,
    children: undefined
  };

  var handleMouseDown$2 = function handleMouseDown(e) {
    e.currentTarget.style.outline = 'none';
  };

  var handleBlur$2 = function handleBlur(e) {
    e.currentTarget.style.outline = '';
  };

  var ENTER_KEY_CODE$2 = 13;
  var SPACE_KEY_CODE$2 = 32;

  var _onClick = function onClick(e, onSort) {
    var isActionKeyDown = e.keyCode === ENTER_KEY_CODE$2 || e.keyCode === SPACE_KEY_CODE$2;
    var isMouseClick = e.keyCode === undefined;
    if (!(isActionKeyDown || isMouseClick)) return;
    var cancelSortingRelatedKey = e.metaKey || e.ctrlKey;
    var direction = (isMouseClick || isActionKeyDown) && cancelSortingRelatedKey ? null : undefined;
    var keepOther = e.shiftKey || cancelSortingRelatedKey;
    e.preventDefault();
    onSort({
      direction: direction,
      keepOther: keepOther
    });
  };

  var SortLabel = function SortLabel(_ref) {
    var align = _ref.align,
        direction = _ref.direction,
        disabled = _ref.disabled,
        children = _ref.children,
        onSort = _ref.onSort,
        getMessage = _ref.getMessage,
        className = _ref.className,
        column = _ref.column,
        restProps = _objectWithoutProperties(_ref, ["align", "direction", "disabled", "children", "onSort", "getMessage", "className", "column"]);

    return react_9("span", _extends$b({
      className: classnames({
        'd-inline-flex flex-direction-row align-items-center mw-100 dx-g-bs4-user-select-none': true,
        'dx-g-bs4-cursor-pointer': !disabled,
        'flex-row-reverse': align === 'right',
        'text-primary': direction
      }, className),
      tabIndex: disabled ? -1 : 0,
      onMouseDown: handleMouseDown$2,
      onBlur: handleBlur$2
    }, !disabled ? {
      onKeyDown: function onKeyDown(e) {
        return _onClick(e, onSort);
      },
      onClick: function onClick(e) {
        return _onClick(e, onSort);
      }
    } : null, restProps), children, react_9(SortingIndicator, {
      direction: direction,
      className: direction ? '' : 'dx-g-bs4-sort-indicator-invisible'
    }));
  };
  SortLabel.defaultProps = {
    column: undefined,
    direction: null,
    disabled: false,
    children: undefined,
    className: undefined,
    align: 'left',
    getMessage: function getMessage() {}
  };

  var GroupButton = function GroupButton(_ref) {
    var disabled = _ref.disabled,
        onGroup = _ref.onGroup,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["disabled", "onGroup", "className"]);

    return react_9("div", _extends$b({
      className: classnames({
        'dx-g-bs4-grouping-control': true
      }, className),
      onClick: function onClick(e) {
        if (disabled) return;
        e.stopPropagation();
        onGroup();
      }
    }, restProps), react_9("span", {
      className: classnames({
        'oi oi-list dx-g-bs4-grouping-control-icon': true,
        'dx-g-bs4-cursor-pointer': !disabled,
        'dx-g-bs4-inactive': disabled
      })
    }));
  };
  GroupButton.defaultProps = {
    disabled: false,
    className: undefined
  };

  var Title = function Title(_ref) {
    var children = _ref.children,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["children", "className"]);

    return react_9("span", _extends$b({
      className: classnames('dx-rg-bs4-table-header-title', className)
    }, restProps), children);
  };
  Title.defaultProps = {
    className: null,
    children: undefined
  };

  var Content$1 = function Content(_ref) {
    var column = _ref.column,
        children = _ref.children,
        align = _ref.align,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["column", "children", "align", "className"]);

    return react_9("div", _extends$b({
      className: classnames({
        'dx-g-bs4-header-cell-content w-100 d-flex flex-row align-items-end': true,
        'justify-content-center': align === 'center',
        'justify-content-end': align === 'right'
      }, className)
    }, restProps), children);
  };
  Content$1.defaultProps = {
    column: undefined,
    align: 'left',
    className: null,
    children: undefined
  };

  var TableHeaderRow$1 = withComponents({
    Cell: TableHeaderCell,
    Row: TableRow,
    Content: Content$1,
    SortLabel: SortLabel,
    Title: Title,
    GroupButton: GroupButton
  })(TableHeaderRow);
  TableHeaderRow$1.ROW_TYPE = TableHeaderRow.ROW_TYPE;

  var Cell$1 = function Cell(_ref) {
    var column = _ref.column,
        children = _ref.children,
        beforeBorder = _ref.beforeBorder,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        row = _ref.row,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["column", "children", "beforeBorder", "tableRow", "tableColumn", "row", "className"]);

    return react_9("th", _extends$b({
      className: classnames({
        'dx-g-bs4-banded-cell dx-g-bs4-table-cell text-nowrap border-right': true,
        'border-left': beforeBorder
      }, className)
    }, restProps), children);
  };
  Cell$1.defaultProps = {
    column: undefined,
    row: undefined,
    children: undefined,
    tableRow: undefined,
    tableColumn: undefined,
    className: undefined,
    beforeBorder: false
  };

  var BandedHeaderCell = function BandedHeaderCell(_ref) {
    var HeaderCellComponent = _ref.component,
        className = _ref.className,
        beforeBorder = _ref.beforeBorder,
        restProps = _objectWithoutProperties(_ref, ["component", "className", "beforeBorder"]);

    return react_9(HeaderCellComponent, _extends$b({
      className: classnames({
        'dx-g-bs4-banded-header-cell border-right': true,
        'border-left': beforeBorder
      }, className)
    }, restProps));
  };
  BandedHeaderCell.defaultProps = {
    className: undefined,
    beforeBorder: false
  };

  var InvisibleCell = function InvisibleCell() {
    return react_9("th", {
      className: "d-none"
    });
  };

  var TableBandHeader$1 = withComponents({
    Cell: Cell$1,
    Row: TableRow,
    BandedHeaderCell: BandedHeaderCell,
    InvisibleCell: InvisibleCell
  })(TableBandHeader);
  TableBandHeader$1.ROW_TYPE = TableBandHeader.ROW_TYPE;

  var EditCell = function EditCell(_ref) {
    var column = _ref.column,
        value = _ref.value,
        onValueChange = _ref.onValueChange,
        className = _ref.className,
        children = _ref.children,
        row = _ref.row,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        editingEnabled = _ref.editingEnabled,
        restProps = _objectWithoutProperties(_ref, ["column", "value", "onValueChange", "className", "children", "row", "tableRow", "tableColumn", "editingEnabled"]);

    return react_9("td", _extends$b({
      className: classnames('align-middle dx-g-bs4-table-edit-cell', className)
    }, restProps), children || react_9("input", {
      type: "text",
      className: classnames({
        'form-control w-100': true,
        'text-right': tableColumn && tableColumn.align === 'right',
        'text-center': tableColumn && tableColumn.align === 'center'
      }),
      readOnly: !editingEnabled,
      value: value,
      onChange: function onChange(e) {
        return onValueChange(e.target.value);
      }
    }));
  };
  EditCell.defaultProps = {
    column: undefined,
    row: undefined,
    tableColumn: undefined,
    tableRow: undefined,
    className: undefined,
    children: undefined,
    editingEnabled: true,
    value: ''
  };

  var TableEditRow$1 = withComponents({
    Row: TableRow,
    Cell: EditCell
  })(TableEditRow);
  TableEditRow$1.ADDED_ROW_TYPE = TableEditRow.ADDED_ROW_TYPE;
  TableEditRow$1.EDIT_ROW_TYPE = TableEditRow.EDIT_ROW_TYPE;

  var CommandButton = function CommandButton(_ref) {
    var onExecute = _ref.onExecute,
        text = _ref.text,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["onExecute", "text", "className"]);

    return react_9("button", _extends$b({
      type: "button",
      className: classnames('btn btn-link dx-g-bs4-table-edit-command-cell', className),
      onClick: function onClick(e) {
        e.stopPropagation();
        onExecute();
      }
    }, restProps), text);
  };
  CommandButton.defaultProps = {
    className: undefined
  };
  var EditCommandHeadingCell = function EditCommandHeadingCell(_ref2) {
    var children = _ref2.children,
        className = _ref2.className,
        tableColumn = _ref2.tableColumn,
        tableRow = _ref2.tableRow,
        restProps = _objectWithoutProperties(_ref2, ["children", "className", "tableColumn", "tableRow"]);

    return react_9("th", _extends$b({
      className: classnames('text-center p-0 text-nowrap', className)
    }, restProps), children);
  };
  EditCommandHeadingCell.defaultProps = {
    children: undefined,
    tableColumn: undefined,
    tableRow: undefined,
    className: undefined
  };
  var EditCommandCell = function EditCommandCell(_ref3) {
    var tableColumn = _ref3.tableColumn,
        tableRow = _ref3.tableRow,
        row = _ref3.row,
        children = _ref3.children,
        className = _ref3.className,
        restProps = _objectWithoutProperties(_ref3, ["tableColumn", "tableRow", "row", "children", "className"]);

    return react_9("td", _extends$b({
      className: classnames('text-center p-0 text-nowrap', className)
    }, restProps), children);
  };
  EditCommandCell.defaultProps = {
    children: undefined,
    tableColumn: undefined,
    tableRow: undefined,
    row: undefined,
    className: undefined
  };

  var TableEditColumn$1 = withComponents({
    Cell: EditCommandCell,
    HeaderCell: EditCommandHeadingCell,
    Command: CommandButton
  })(TableEditColumn);
  TableEditColumn$1.COLUMN_TYPE = TableEditColumn.COLUMN_TYPE;

  var EmptyMessage = function EmptyMessage(_ref) {
    var getMessage = _ref.getMessage,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["getMessage", "className"]);

    return react_9("div", _extends$b({
      className: classnames('py-5 text-center', className)
    }, restProps), react_9("big", {
      className: "text-muted"
    }, getMessage('noColumns')));
  };
  EmptyMessage.defaultProps = {
    className: undefined
  };

  var TableColumnVisibility$1 = withComponents({
    EmptyMessage: EmptyMessage
  })(TableColumnVisibility);

  var TableInvisibleRow = function TableInvisibleRow(_ref) {
    var className = _ref.className,
        restParams = _objectWithoutProperties(_ref, ["className"]);

    return react_9(TableRow, _extends$b({
      className: classnames('dx-g-bs4-table-invisible-row', className)
    }, restParams));
  };
  TableInvisibleRow.defaultProps = {
    className: undefined
  };

  var TableReorderingCell = function TableReorderingCell(_ref) {
    var style = _ref.style,
        getCellDimensions = _ref.getCellDimensions;

    var refHandler = function refHandler(node) {
      return node && getCellDimensions(function () {
        var _node$getBoundingClie = node.getBoundingClientRect(),
            left = _node$getBoundingClie.left,
            right = _node$getBoundingClie.right;

        return {
          left: left,
          right: right
        };
      });
    };

    return react_9("td", {
      ref: refHandler,
      className: "p-0 border-0",
      style: style
    });
  };
  TableReorderingCell.defaultProps = {
    style: null
  };

  var TableColumnReordering$1 = withComponents({
    Row: TableInvisibleRow,
    Cell: TableReorderingCell
  })(TableColumnReordering);

  var TableColumnResizing$1 =
  /*#__PURE__*/
  function (_React$PureComponent) {
    _inherits$d(TableColumnResizing$1, _React$PureComponent);

    function TableColumnResizing$1() {
      _classCallCheck$i(this, TableColumnResizing$1);

      return _possibleConstructorReturn$d(this, _getPrototypeOf$1(TableColumnResizing$1).apply(this, arguments));
    }

    _createClass$1(TableColumnResizing$1, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            minColumnWidth = _this$props.minColumnWidth,
            restProps = _objectWithoutProperties(_this$props, ["minColumnWidth"]);

        return react_9(TableColumnResizing, _extends$b({}, restProps, {
          minColumnWidth: minColumnWidth
        }));
      }
    }]);

    return TableColumnResizing$1;
  }(react_4);
  TableColumnResizing$1.defaultProps = {
    minColumnWidth: 55
  };

  var Toolbar$1 = function Toolbar(_ref) {
    var children = _ref.children,
        className = _ref.className,
        style = _ref.style,
        restProps = _objectWithoutProperties(_ref, ["children", "className", "style"]);

    return react_9("div", _extends$b({
      className: classnames('card-header py-2 d-flex position-relative dx-g-bs4-toolbar', className),
      style: style
    }, restProps), children);
  };
  Toolbar$1.defaultProps = {
    className: undefined,
    style: null
  };

  var FlexibleSpace = function FlexibleSpace() {
    return react_9("div", {
      className: "d-flex ml-auto"
    });
  };

  var Toolbar$1$1 = withComponents({
    Root: Toolbar$1,
    FlexibleSpace: FlexibleSpace
  })(Toolbar);

  var TableTreeExpandButton = function TableTreeExpandButton(_ref) {
    var className = _ref.className,
        visible = _ref.visible,
        expanded = _ref.expanded,
        onToggle = _ref.onToggle,
        restProps = _objectWithoutProperties(_ref, ["className", "visible", "expanded", "onToggle"]);

    return react_9(ExpandButton, _extends$b({
      visible: visible,
      expanded: expanded,
      onToggle: onToggle,
      className: classnames('mr-3', className)
    }, restProps));
  };
  TableTreeExpandButton.defaultProps = {
    className: undefined,
    visible: false,
    expanded: false,
    onToggle: function onToggle() {}
  };

  var TableTreeCheckbox = function TableTreeCheckbox(_ref) {
    var className = _ref.className,
        checked = _ref.checked,
        indeterminate = _ref.indeterminate,
        disabled = _ref.disabled,
        onChange = _ref.onChange,
        restProps = _objectWithoutProperties(_ref, ["className", "checked", "indeterminate", "disabled", "onChange"]);

    return react_9(SelectionControl, _extends$b({
      disabled: disabled,
      checked: checked,
      indeterminate: indeterminate,
      onChange: onChange,
      className: classnames('mr-4', className)
    }, restProps));
  };
  TableTreeCheckbox.defaultProps = {
    className: undefined,
    checked: false,
    indeterminate: false,
    disabled: false,
    onChange: function onChange() {}
  };

  var TableTreeIndent = function TableTreeIndent(_ref) {
    var level = _ref.level;
    return Array.from({
      length: level
    }).map(function (value, currentLevel) {
      return react_9("span", {
        // eslint-disable-next-line react/no-array-index-key
        key: currentLevel,
        className: "d-inline-block mr-4"
      });
    });
  };
  TableTreeIndent.defaultProps = {
    level: 0
  };

  var TableTreeCell = function TableTreeCell(_ref) {
    var column = _ref.column,
        children = _ref.children,
        tableRow = _ref.tableRow,
        tableColumn = _ref.tableColumn,
        row = _ref.row,
        restProps = _objectWithoutProperties(_ref, ["column", "children", "tableRow", "tableColumn", "row"]);

    return react_9("td", restProps, react_9("div", {
      className: classnames({
        'd-flex flex-direction-row align-items-center': true,
        'text-nowrap': !(tableColumn && tableColumn.wordWrapEnabled),
        'text-right': tableColumn && tableColumn.align === 'right',
        'text-center': tableColumn && tableColumn.align === 'center'
      })
    }, children));
  };
  TableTreeCell.defaultProps = {
    column: undefined,
    row: undefined,
    children: undefined,
    tableRow: undefined,
    tableColumn: undefined,
    style: null
  };

  var TableTreeContent = function TableTreeContent(_ref) {
    var children = _ref.children,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["children", "className"]);

    return react_9("div", _extends$b({
      className: classnames('w-100 dx-g-bs4-table-tree-content', className)
    }, restProps), children);
  };
  TableTreeContent.defaultProps = {
    className: undefined,
    children: undefined
  };

  var TableTreeColumn$1 = withComponents({
    Cell: TableTreeCell,
    Content: TableTreeContent,
    Indent: TableTreeIndent,
    ExpandButton: TableTreeExpandButton,
    Checkbox: TableTreeCheckbox
  })(TableTreeColumn);

  var SearchPanelInput = function SearchPanelInput(_ref) {
    var onValueChange = _ref.onValueChange,
        value = _ref.value,
        getMessage = _ref.getMessage,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["onValueChange", "value", "getMessage", "className"]);

    return react_9("input", _extends$b({
      type: "text",
      className: classnames('form-control w-25', className),
      onChange: function onChange(e) {
        return onValueChange(e.target.value);
      },
      value: value,
      placeholder: getMessage('searchPlaceholder')
    }, restProps));
  };
  SearchPanelInput.defaultProps = {
    value: null,
    className: undefined
  };

  var SearchPanel$1 = withComponents({
    Input: SearchPanelInput
  })(SearchPanel);

  var FixedCell =
  /*#__PURE__*/
  function (_React$PureComponent) {
    _inherits$d(FixedCell, _React$PureComponent);

    function FixedCell() {
      _classCallCheck$i(this, FixedCell);

      return _possibleConstructorReturn$d(this, _getPrototypeOf$1(FixedCell).apply(this, arguments));
    }

    _createClass$1(FixedCell, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
            CellPlaceholder = _this$props.component,
            side = _this$props.side,
            showLeftDivider = _this$props.showLeftDivider,
            showRightDivider = _this$props.showRightDivider,
            className = _this$props.className,
            style = _this$props.style,
            position = _this$props.position,
            restProps = _objectWithoutProperties(_this$props, ["component", "side", "showLeftDivider", "showRightDivider", "className", "style", "position"]);

        var backgroundColor = this.context;
        return react_9(CellPlaceholder, _extends$b({
          className: classnames({
            'position-sticky': true,
            'dx-g-bs4-fixed-cell': true,
            'border-left': showLeftDivider,
            'border-right': showRightDivider
          }, className),
          style: _objectSpread$1({}, style, _defineProperty$4({
            backgroundColor: backgroundColor
          }, side, position))
        }, restProps));
      }
    }]);

    return FixedCell;
  }(react_4);
  FixedCell.contextType = BodyColorContext;
  FixedCell.defaultProps = {
    className: undefined,
    style: null,
    showLeftDivider: false,
    showRightDivider: false,
    position: undefined
  };

  var TableBorderlessStubCell = function TableBorderlessStubCell(_ref) {
    var className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["className"]);

    return react_9(TableStubCell, _extends$b({
      className: classnames('border-0', className)
    }, restProps));
  };
  TableBorderlessStubCell.defaultProps = {
    className: undefined
  };
  var TableListenerCell = function TableListenerCell(_ref2) {
    var listen = _ref2.listen,
        onSizeChange = _ref2.onSizeChange,
        restProps = _objectWithoutProperties(_ref2, ["listen", "onSizeChange"]);

    return listen ? react_9(Sizer, _extends$b({
      containerComponent: TableBorderlessStubCell,
      onSizeChange: onSizeChange
    }, restProps)) : react_9(TableBorderlessStubCell, restProps);
  };

  var TableFixedColumns$1 = withComponents({
    Cell: FixedCell,
    ListenerRow: TableInvisibleRow,
    ListenerCell: TableListenerCell
  })(TableFixedColumns);

  var TableSummaryItem = function TableSummaryItem(_ref) {
    var children = _ref.children,
        type = _ref.type,
        value = _ref.value,
        getMessage = _ref.getMessage,
        className = _ref.className,
        restProps = _objectWithoutProperties(_ref, ["children", "type", "value", "getMessage", "className"]);

    return react_9("div", _extends$b({
      className: classnames('dx-g-bs4-table-summary-item', className)
    }, restProps), react_9(react_3, null, getMessage(type), ":\xA0\xA0", children));
  };
  TableSummaryItem.defaultProps = {
    value: null,
    className: undefined,
    children: undefined
  };

  var TableSummaryRow$1 = withComponents({
    TotalRow: TableRow,
    GroupRow: TableRow,
    TreeRow: TableRow,
    TotalCell: TableCell,
    GroupCell: TableCell,
    TreeCell: TableCell,
    TableTreeCell: TableTreeCell,
    TableTreeContent: TableTreeContent,
    TableTreeIndent: TableTreeIndent,
    Item: TableSummaryItem
  })(TableSummaryRow);
  TableSummaryRow$1.TREE_ROW_TYPE = TableSummaryRow.TREE_ROW_TYPE;
  TableSummaryRow$1.GROUP_ROW_TYPE = TableSummaryRow.GROUP_ROW_TYPE;
  TableSummaryRow$1.TOTAL_ROW_TYPE = TableSummaryRow.TOTAL_ROW_TYPE;

  var dxReactGridBootstrap4_es = /*#__PURE__*/Object.freeze({
    ColumnChooser: ColumnChooser$1,
    DragDropProvider: DragDropProvider$2,
    Grid: Grid$1,
    GroupingPanel: GroupingPanel$1,
    PagingPanel: PagingPanel$1,
    SearchPanel: SearchPanel$1,
    Table: Table$1$1,
    TableBandHeader: TableBandHeader$1,
    TableColumnReordering: TableColumnReordering$1,
    TableColumnResizing: TableColumnResizing$1,
    TableColumnVisibility: TableColumnVisibility$1,
    TableEditColumn: TableEditColumn$1,
    TableEditRow: TableEditRow$1,
    TableFilterRow: TableFilterRow$1,
    TableFixedColumns: TableFixedColumns$1,
    TableGroupRow: TableGroupRow$1,
    TableHeaderRow: TableHeaderRow$1,
    TableRowDetail: TableRowDetail$1,
    TableSelection: TableSelection$1,
    TableSummaryRow: TableSummaryRow$1,
    TableTreeColumn: TableTreeColumn$1,
    Toolbar: Toolbar$1$1,
    VirtualTable: VirtualTable
  });

  var jquery = createCommonjsModule(function (module) {
  /*!
   * jQuery JavaScript Library v3.4.1
   * https://jquery.com/
   *
   * Includes Sizzle.js
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2019-05-01T21:04Z
   */
  ( function( global, factory ) {

  	{

  		// For CommonJS and CommonJS-like environments where a proper `window`
  		// is present, execute the factory and get jQuery.
  		// For environments that do not have a `window` with a `document`
  		// (such as Node.js), expose a factory as module.exports.
  		// This accentuates the need for the creation of a real `window`.
  		// e.g. var jQuery = require("jquery")(window);
  		// See ticket #14549 for more info.
  		module.exports = global.document ?
  			factory( global, true ) :
  			function( w ) {
  				if ( !w.document ) {
  					throw new Error( "jQuery requires a window with a document" );
  				}
  				return factory( w );
  			};
  	}

  // Pass this if window is not defined yet
  } )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

  var arr = [];

  var document = window.document;

  var getProto = Object.getPrototypeOf;

  var slice = arr.slice;

  var concat = arr.concat;

  var push = arr.push;

  var indexOf = arr.indexOf;

  var class2type = {};

  var toString = class2type.toString;

  var hasOwn = class2type.hasOwnProperty;

  var fnToString = hasOwn.toString;

  var ObjectFunctionString = fnToString.call( Object );

  var support = {};

  var isFunction = function isFunction( obj ) {

        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
    };


  var isWindow = function isWindow( obj ) {
  		return obj != null && obj === obj.window;
  	};




  	var preservedScriptAttributes = {
  		type: true,
  		src: true,
  		nonce: true,
  		noModule: true
  	};

  	function DOMEval( code, node, doc ) {
  		doc = doc || document;

  		var i, val,
  			script = doc.createElement( "script" );

  		script.text = code;
  		if ( node ) {
  			for ( i in preservedScriptAttributes ) {

  				// Support: Firefox 64+, Edge 18+
  				// Some browsers don't support the "nonce" property on scripts.
  				// On the other hand, just using `getAttribute` is not enough as
  				// the `nonce` attribute is reset to an empty string whenever it
  				// becomes browsing-context connected.
  				// See https://github.com/whatwg/html/issues/2369
  				// See https://html.spec.whatwg.org/#nonce-attributes
  				// The `node.getAttribute` check was added for the sake of
  				// `jQuery.globalEval` so that it can fake a nonce-containing node
  				// via an object.
  				val = node[ i ] || node.getAttribute && node.getAttribute( i );
  				if ( val ) {
  					script.setAttribute( i, val );
  				}
  			}
  		}
  		doc.head.appendChild( script ).parentNode.removeChild( script );
  	}


  function toType( obj ) {
  	if ( obj == null ) {
  		return obj + "";
  	}

  	// Support: Android <=2.3 only (functionish RegExp)
  	return typeof obj === "object" || typeof obj === "function" ?
  		class2type[ toString.call( obj ) ] || "object" :
  		typeof obj;
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module



  var
  	version = "3.4.1",

  	// Define a local copy of jQuery
  	jQuery = function( selector, context ) {

  		// The jQuery object is actually just the init constructor 'enhanced'
  		// Need init if jQuery is called (just allow error to be thrown if not included)
  		return new jQuery.fn.init( selector, context );
  	},

  	// Support: Android <=4.0 only
  	// Make sure we trim BOM and NBSP
  	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

  jQuery.fn = jQuery.prototype = {

  	// The current version of jQuery being used
  	jquery: version,

  	constructor: jQuery,

  	// The default length of a jQuery object is 0
  	length: 0,

  	toArray: function() {
  		return slice.call( this );
  	},

  	// Get the Nth element in the matched element set OR
  	// Get the whole matched element set as a clean array
  	get: function( num ) {

  		// Return all the elements in a clean array
  		if ( num == null ) {
  			return slice.call( this );
  		}

  		// Return just the one element from the set
  		return num < 0 ? this[ num + this.length ] : this[ num ];
  	},

  	// Take an array of elements and push it onto the stack
  	// (returning the new matched element set)
  	pushStack: function( elems ) {

  		// Build a new jQuery matched element set
  		var ret = jQuery.merge( this.constructor(), elems );

  		// Add the old object onto the stack (as a reference)
  		ret.prevObject = this;

  		// Return the newly-formed element set
  		return ret;
  	},

  	// Execute a callback for every element in the matched set.
  	each: function( callback ) {
  		return jQuery.each( this, callback );
  	},

  	map: function( callback ) {
  		return this.pushStack( jQuery.map( this, function( elem, i ) {
  			return callback.call( elem, i, elem );
  		} ) );
  	},

  	slice: function() {
  		return this.pushStack( slice.apply( this, arguments ) );
  	},

  	first: function() {
  		return this.eq( 0 );
  	},

  	last: function() {
  		return this.eq( -1 );
  	},

  	eq: function( i ) {
  		var len = this.length,
  			j = +i + ( i < 0 ? len : 0 );
  		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
  	},

  	end: function() {
  		return this.prevObject || this.constructor();
  	},

  	// For internal use only.
  	// Behaves like an Array's method, not like a jQuery method.
  	push: push,
  	sort: arr.sort,
  	splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function() {
  	var options, name, src, copy, copyIsArray, clone,
  		target = arguments[ 0 ] || {},
  		i = 1,
  		length = arguments.length,
  		deep = false;

  	// Handle a deep copy situation
  	if ( typeof target === "boolean" ) {
  		deep = target;

  		// Skip the boolean and the target
  		target = arguments[ i ] || {};
  		i++;
  	}

  	// Handle case when target is a string or something (possible in deep copy)
  	if ( typeof target !== "object" && !isFunction( target ) ) {
  		target = {};
  	}

  	// Extend jQuery itself if only one argument is passed
  	if ( i === length ) {
  		target = this;
  		i--;
  	}

  	for ( ; i < length; i++ ) {

  		// Only deal with non-null/undefined values
  		if ( ( options = arguments[ i ] ) != null ) {

  			// Extend the base object
  			for ( name in options ) {
  				copy = options[ name ];

  				// Prevent Object.prototype pollution
  				// Prevent never-ending loop
  				if ( name === "__proto__" || target === copy ) {
  					continue;
  				}

  				// Recurse if we're merging plain objects or arrays
  				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
  					( copyIsArray = Array.isArray( copy ) ) ) ) {
  					src = target[ name ];

  					// Ensure proper type for the source value
  					if ( copyIsArray && !Array.isArray( src ) ) {
  						clone = [];
  					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
  						clone = {};
  					} else {
  						clone = src;
  					}
  					copyIsArray = false;

  					// Never move original objects, clone them
  					target[ name ] = jQuery.extend( deep, clone, copy );

  				// Don't bring in undefined values
  				} else if ( copy !== undefined ) {
  					target[ name ] = copy;
  				}
  			}
  		}
  	}

  	// Return the modified object
  	return target;
  };

  jQuery.extend( {

  	// Unique for each copy of jQuery on the page
  	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  	// Assume jQuery is ready without the ready module
  	isReady: true,

  	error: function( msg ) {
  		throw new Error( msg );
  	},

  	noop: function() {},

  	isPlainObject: function( obj ) {
  		var proto, Ctor;

  		// Detect obvious negatives
  		// Use toString instead of jQuery.type to catch host objects
  		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
  			return false;
  		}

  		proto = getProto( obj );

  		// Objects with no prototype (e.g., `Object.create( null )`) are plain
  		if ( !proto ) {
  			return true;
  		}

  		// Objects with prototype are plain iff they were constructed by a global Object function
  		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
  		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
  	},

  	isEmptyObject: function( obj ) {
  		var name;

  		for ( name in obj ) {
  			return false;
  		}
  		return true;
  	},

  	// Evaluates a script in a global context
  	globalEval: function( code, options ) {
  		DOMEval( code, { nonce: options && options.nonce } );
  	},

  	each: function( obj, callback ) {
  		var length, i = 0;

  		if ( isArrayLike( obj ) ) {
  			length = obj.length;
  			for ( ; i < length; i++ ) {
  				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  					break;
  				}
  			}
  		} else {
  			for ( i in obj ) {
  				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  					break;
  				}
  			}
  		}

  		return obj;
  	},

  	// Support: Android <=4.0 only
  	trim: function( text ) {
  		return text == null ?
  			"" :
  			( text + "" ).replace( rtrim, "" );
  	},

  	// results is for internal usage only
  	makeArray: function( arr, results ) {
  		var ret = results || [];

  		if ( arr != null ) {
  			if ( isArrayLike( Object( arr ) ) ) {
  				jQuery.merge( ret,
  					typeof arr === "string" ?
  					[ arr ] : arr
  				);
  			} else {
  				push.call( ret, arr );
  			}
  		}

  		return ret;
  	},

  	inArray: function( elem, arr, i ) {
  		return arr == null ? -1 : indexOf.call( arr, elem, i );
  	},

  	// Support: Android <=4.0 only, PhantomJS 1 only
  	// push.apply(_, arraylike) throws on ancient WebKit
  	merge: function( first, second ) {
  		var len = +second.length,
  			j = 0,
  			i = first.length;

  		for ( ; j < len; j++ ) {
  			first[ i++ ] = second[ j ];
  		}

  		first.length = i;

  		return first;
  	},

  	grep: function( elems, callback, invert ) {
  		var callbackInverse,
  			matches = [],
  			i = 0,
  			length = elems.length,
  			callbackExpect = !invert;

  		// Go through the array, only saving the items
  		// that pass the validator function
  		for ( ; i < length; i++ ) {
  			callbackInverse = !callback( elems[ i ], i );
  			if ( callbackInverse !== callbackExpect ) {
  				matches.push( elems[ i ] );
  			}
  		}

  		return matches;
  	},

  	// arg is for internal usage only
  	map: function( elems, callback, arg ) {
  		var length, value,
  			i = 0,
  			ret = [];

  		// Go through the array, translating each of the items to their new values
  		if ( isArrayLike( elems ) ) {
  			length = elems.length;
  			for ( ; i < length; i++ ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}

  		// Go through every key on the object,
  		} else {
  			for ( i in elems ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}
  		}

  		// Flatten any nested arrays
  		return concat.apply( [], ret );
  	},

  	// A global GUID counter for objects
  	guid: 1,

  	// jQuery.support is not used in Core but other projects attach their
  	// properties to it so it needs to exist.
  	support: support
  } );

  if ( typeof Symbol === "function" ) {
  	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
  }

  // Populate the class2type map
  jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
  function( i, name ) {
  	class2type[ "[object " + name + "]" ] = name.toLowerCase();
  } );

  function isArrayLike( obj ) {

  	// Support: real iOS 8.2 only (not reproducible in simulator)
  	// `in` check used to prevent JIT error (gh-2145)
  	// hasOwn isn't used here due to false negatives
  	// regarding Nodelist length in IE
  	var length = !!obj && "length" in obj && obj.length,
  		type = toType( obj );

  	if ( isFunction( obj ) || isWindow( obj ) ) {
  		return false;
  	}

  	return type === "array" || length === 0 ||
  		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  }
  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.4
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2019-04-08
   */
  (function( window ) {

  var i,
  	support,
  	Expr,
  	getText,
  	isXML,
  	tokenize,
  	compile,
  	select,
  	outermostContext,
  	sortInput,
  	hasDuplicate,

  	// Local document vars
  	setDocument,
  	document,
  	docElem,
  	documentIsHTML,
  	rbuggyQSA,
  	rbuggyMatches,
  	matches,
  	contains,

  	// Instance-specific data
  	expando = "sizzle" + 1 * new Date(),
  	preferredDoc = window.document,
  	dirruns = 0,
  	done = 0,
  	classCache = createCache(),
  	tokenCache = createCache(),
  	compilerCache = createCache(),
  	nonnativeSelectorCache = createCache(),
  	sortOrder = function( a, b ) {
  		if ( a === b ) {
  			hasDuplicate = true;
  		}
  		return 0;
  	},

  	// Instance methods
  	hasOwn = ({}).hasOwnProperty,
  	arr = [],
  	pop = arr.pop,
  	push_native = arr.push,
  	push = arr.push,
  	slice = arr.slice,
  	// Use a stripped-down indexOf as it's faster than native
  	// https://jsperf.com/thor-indexof-vs-for/5
  	indexOf = function( list, elem ) {
  		var i = 0,
  			len = list.length;
  		for ( ; i < len; i++ ) {
  			if ( list[i] === elem ) {
  				return i;
  			}
  		}
  		return -1;
  	},

  	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

  	// Regular expressions

  	// http://www.w3.org/TR/css3-selectors/#whitespace
  	whitespace = "[\\x20\\t\\r\\n\\f]",

  	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
  	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

  	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
  		// Operator (capture 2)
  		"*([*^$|!~]?=)" + whitespace +
  		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
  		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
  		"*\\]",

  	pseudos = ":(" + identifier + ")(?:\\((" +
  		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  		// 1. quoted (capture 3; capture 4 or capture 5)
  		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
  		// 2. simple (capture 6)
  		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
  		// 3. anything else (capture 2)
  		".*" +
  		")\\)|)",

  	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  	rwhitespace = new RegExp( whitespace + "+", "g" ),
  	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

  	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
  	rdescend = new RegExp( whitespace + "|>" ),

  	rpseudo = new RegExp( pseudos ),
  	ridentifier = new RegExp( "^" + identifier + "$" ),

  	matchExpr = {
  		"ID": new RegExp( "^#(" + identifier + ")" ),
  		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
  		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
  		"ATTR": new RegExp( "^" + attributes ),
  		"PSEUDO": new RegExp( "^" + pseudos ),
  		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
  			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
  			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
  		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
  		// For use in libraries implementing .is()
  		// We use this for POS matching in `select`
  		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
  			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  	},

  	rhtml = /HTML$/i,
  	rinputs = /^(?:input|select|textarea|button)$/i,
  	rheader = /^h\d$/i,

  	rnative = /^[^{]+\{\s*\[native \w/,

  	// Easily-parseable/retrievable ID or TAG or CLASS selectors
  	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  	rsibling = /[+~]/,

  	// CSS escapes
  	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
  	funescape = function( _, escaped, escapedWhitespace ) {
  		var high = "0x" + escaped - 0x10000;
  		// NaN means non-codepoint
  		// Support: Firefox<24
  		// Workaround erroneous numeric interpretation of +"0x"
  		return high !== high || escapedWhitespace ?
  			escaped :
  			high < 0 ?
  				// BMP codepoint
  				String.fromCharCode( high + 0x10000 ) :
  				// Supplemental Plane codepoint (surrogate pair)
  				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  	},

  	// CSS string/identifier serialization
  	// https://drafts.csswg.org/cssom/#common-serializing-idioms
  	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
  	fcssescape = function( ch, asCodePoint ) {
  		if ( asCodePoint ) {

  			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
  			if ( ch === "\0" ) {
  				return "\uFFFD";
  			}

  			// Control characters and (dependent upon position) numbers get escaped as code points
  			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
  		}

  		// Other potentially-special ASCII characters get backslash-escaped
  		return "\\" + ch;
  	},

  	// Used for iframes
  	// See setDocument()
  	// Removing the function wrapper causes a "Permission Denied"
  	// error in IE
  	unloadHandler = function() {
  		setDocument();
  	},

  	inDisabledFieldset = addCombinator(
  		function( elem ) {
  			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
  		},
  		{ dir: "parentNode", next: "legend" }
  	);

  // Optimize for push.apply( _, NodeList )
  try {
  	push.apply(
  		(arr = slice.call( preferredDoc.childNodes )),
  		preferredDoc.childNodes
  	);
  	// Support: Android<4.0
  	// Detect silently failing push.apply
  	arr[ preferredDoc.childNodes.length ].nodeType;
  } catch ( e ) {
  	push = { apply: arr.length ?

  		// Leverage slice if possible
  		function( target, els ) {
  			push_native.apply( target, slice.call(els) );
  		} :

  		// Support: IE<9
  		// Otherwise append directly
  		function( target, els ) {
  			var j = target.length,
  				i = 0;
  			// Can't trust NodeList.length
  			while ( (target[j++] = els[i++]) ) {}
  			target.length = j - 1;
  		}
  	};
  }

  function Sizzle( selector, context, results, seed ) {
  	var m, i, elem, nid, match, groups, newSelector,
  		newContext = context && context.ownerDocument,

  		// nodeType defaults to 9, since context defaults to document
  		nodeType = context ? context.nodeType : 9;

  	results = results || [];

  	// Return early from calls with invalid selector or context
  	if ( typeof selector !== "string" || !selector ||
  		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

  		return results;
  	}

  	// Try to shortcut find operations (as opposed to filters) in HTML documents
  	if ( !seed ) {

  		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
  			setDocument( context );
  		}
  		context = context || document;

  		if ( documentIsHTML ) {

  			// If the selector is sufficiently simple, try using a "get*By*" DOM method
  			// (excepting DocumentFragment context, where the methods don't exist)
  			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

  				// ID selector
  				if ( (m = match[1]) ) {

  					// Document context
  					if ( nodeType === 9 ) {
  						if ( (elem = context.getElementById( m )) ) {

  							// Support: IE, Opera, Webkit
  							// TODO: identify versions
  							// getElementById can match elements by name instead of ID
  							if ( elem.id === m ) {
  								results.push( elem );
  								return results;
  							}
  						} else {
  							return results;
  						}

  					// Element context
  					} else {

  						// Support: IE, Opera, Webkit
  						// TODO: identify versions
  						// getElementById can match elements by name instead of ID
  						if ( newContext && (elem = newContext.getElementById( m )) &&
  							contains( context, elem ) &&
  							elem.id === m ) {

  							results.push( elem );
  							return results;
  						}
  					}

  				// Type selector
  				} else if ( match[2] ) {
  					push.apply( results, context.getElementsByTagName( selector ) );
  					return results;

  				// Class selector
  				} else if ( (m = match[3]) && support.getElementsByClassName &&
  					context.getElementsByClassName ) {

  					push.apply( results, context.getElementsByClassName( m ) );
  					return results;
  				}
  			}

  			// Take advantage of querySelectorAll
  			if ( support.qsa &&
  				!nonnativeSelectorCache[ selector + " " ] &&
  				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

  				// Support: IE 8 only
  				// Exclude object elements
  				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

  				newSelector = selector;
  				newContext = context;

  				// qSA considers elements outside a scoping root when evaluating child or
  				// descendant combinators, which is not what we want.
  				// In such cases, we work around the behavior by prefixing every selector in the
  				// list with an ID selector referencing the scope context.
  				// Thanks to Andrew Dupont for this technique.
  				if ( nodeType === 1 && rdescend.test( selector ) ) {

  					// Capture the context ID, setting it first if necessary
  					if ( (nid = context.getAttribute( "id" )) ) {
  						nid = nid.replace( rcssescape, fcssescape );
  					} else {
  						context.setAttribute( "id", (nid = expando) );
  					}

  					// Prefix every selector in the list
  					groups = tokenize( selector );
  					i = groups.length;
  					while ( i-- ) {
  						groups[i] = "#" + nid + " " + toSelector( groups[i] );
  					}
  					newSelector = groups.join( "," );

  					// Expand context for sibling selectors
  					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
  						context;
  				}

  				try {
  					push.apply( results,
  						newContext.querySelectorAll( newSelector )
  					);
  					return results;
  				} catch ( qsaError ) {
  					nonnativeSelectorCache( selector, true );
  				} finally {
  					if ( nid === expando ) {
  						context.removeAttribute( "id" );
  					}
  				}
  			}
  		}
  	}

  	// All others
  	return select( selector.replace( rtrim, "$1" ), context, results, seed );
  }

  /**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
  function createCache() {
  	var keys = [];

  	function cache( key, value ) {
  		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
  		if ( keys.push( key + " " ) > Expr.cacheLength ) {
  			// Only keep the most recent entries
  			delete cache[ keys.shift() ];
  		}
  		return (cache[ key + " " ] = value);
  	}
  	return cache;
  }

  /**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
  function markFunction( fn ) {
  	fn[ expando ] = true;
  	return fn;
  }

  /**
   * Support testing using an element
   * @param {Function} fn Passed the created element and returns a boolean result
   */
  function assert( fn ) {
  	var el = document.createElement("fieldset");

  	try {
  		return !!fn( el );
  	} catch (e) {
  		return false;
  	} finally {
  		// Remove from its parent by default
  		if ( el.parentNode ) {
  			el.parentNode.removeChild( el );
  		}
  		// release memory in IE
  		el = null;
  	}
  }

  /**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
  function addHandle( attrs, handler ) {
  	var arr = attrs.split("|"),
  		i = arr.length;

  	while ( i-- ) {
  		Expr.attrHandle[ arr[i] ] = handler;
  	}
  }

  /**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
  function siblingCheck( a, b ) {
  	var cur = b && a,
  		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
  			a.sourceIndex - b.sourceIndex;

  	// Use IE sourceIndex if available on both nodes
  	if ( diff ) {
  		return diff;
  	}

  	// Check if b follows a
  	if ( cur ) {
  		while ( (cur = cur.nextSibling) ) {
  			if ( cur === b ) {
  				return -1;
  			}
  		}
  	}

  	return a ? 1 : -1;
  }

  /**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
  function createInputPseudo( type ) {
  	return function( elem ) {
  		var name = elem.nodeName.toLowerCase();
  		return name === "input" && elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
  function createButtonPseudo( type ) {
  	return function( elem ) {
  		var name = elem.nodeName.toLowerCase();
  		return (name === "input" || name === "button") && elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for :enabled/:disabled
   * @param {Boolean} disabled true for :disabled; false for :enabled
   */
  function createDisabledPseudo( disabled ) {

  	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
  	return function( elem ) {

  		// Only certain elements can match :enabled or :disabled
  		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
  		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
  		if ( "form" in elem ) {

  			// Check for inherited disabledness on relevant non-disabled elements:
  			// * listed form-associated elements in a disabled fieldset
  			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
  			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
  			// * option elements in a disabled optgroup
  			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
  			// All such elements have a "form" property.
  			if ( elem.parentNode && elem.disabled === false ) {

  				// Option elements defer to a parent optgroup if present
  				if ( "label" in elem ) {
  					if ( "label" in elem.parentNode ) {
  						return elem.parentNode.disabled === disabled;
  					} else {
  						return elem.disabled === disabled;
  					}
  				}

  				// Support: IE 6 - 11
  				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
  				return elem.isDisabled === disabled ||

  					// Where there is no isDisabled, check manually
  					/* jshint -W018 */
  					elem.isDisabled !== !disabled &&
  						inDisabledFieldset( elem ) === disabled;
  			}

  			return elem.disabled === disabled;

  		// Try to winnow out elements that can't be disabled before trusting the disabled property.
  		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
  		// even exist on them, let alone have a boolean value.
  		} else if ( "label" in elem ) {
  			return elem.disabled === disabled;
  		}

  		// Remaining elements are neither :enabled nor :disabled
  		return false;
  	};
  }

  /**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
  function createPositionalPseudo( fn ) {
  	return markFunction(function( argument ) {
  		argument = +argument;
  		return markFunction(function( seed, matches ) {
  			var j,
  				matchIndexes = fn( [], seed.length, argument ),
  				i = matchIndexes.length;

  			// Match elements found at the specified indexes
  			while ( i-- ) {
  				if ( seed[ (j = matchIndexes[i]) ] ) {
  					seed[j] = !(matches[j] = seed[j]);
  				}
  			}
  		});
  	});
  }

  /**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
  function testContext( context ) {
  	return context && typeof context.getElementsByTagName !== "undefined" && context;
  }

  // Expose support vars for convenience
  support = Sizzle.support = {};

  /**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
  isXML = Sizzle.isXML = function( elem ) {
  	var namespace = elem.namespaceURI,
  		docElem = (elem.ownerDocument || elem).documentElement;

  	// Support: IE <=8
  	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
  	// https://bugs.jquery.com/ticket/4833
  	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
  };

  /**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
  setDocument = Sizzle.setDocument = function( node ) {
  	var hasCompare, subWindow,
  		doc = node ? node.ownerDocument || node : preferredDoc;

  	// Return early if doc is invalid or already selected
  	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
  		return document;
  	}

  	// Update global variables
  	document = doc;
  	docElem = document.documentElement;
  	documentIsHTML = !isXML( document );

  	// Support: IE 9-11, Edge
  	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
  	if ( preferredDoc !== document &&
  		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

  		// Support: IE 11, Edge
  		if ( subWindow.addEventListener ) {
  			subWindow.addEventListener( "unload", unloadHandler, false );

  		// Support: IE 9 - 10 only
  		} else if ( subWindow.attachEvent ) {
  			subWindow.attachEvent( "onunload", unloadHandler );
  		}
  	}

  	/* Attributes
  	---------------------------------------------------------------------- */

  	// Support: IE<8
  	// Verify that getAttribute really returns attributes and not properties
  	// (excepting IE8 booleans)
  	support.attributes = assert(function( el ) {
  		el.className = "i";
  		return !el.getAttribute("className");
  	});

  	/* getElement(s)By*
  	---------------------------------------------------------------------- */

  	// Check if getElementsByTagName("*") returns only elements
  	support.getElementsByTagName = assert(function( el ) {
  		el.appendChild( document.createComment("") );
  		return !el.getElementsByTagName("*").length;
  	});

  	// Support: IE<9
  	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

  	// Support: IE<10
  	// Check if getElementById returns elements by name
  	// The broken getElementById methods don't pick up programmatically-set names,
  	// so use a roundabout getElementsByName test
  	support.getById = assert(function( el ) {
  		docElem.appendChild( el ).id = expando;
  		return !document.getElementsByName || !document.getElementsByName( expando ).length;
  	});

  	// ID filter and find
  	if ( support.getById ) {
  		Expr.filter["ID"] = function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				return elem.getAttribute("id") === attrId;
  			};
  		};
  		Expr.find["ID"] = function( id, context ) {
  			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  				var elem = context.getElementById( id );
  				return elem ? [ elem ] : [];
  			}
  		};
  	} else {
  		Expr.filter["ID"] =  function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				var node = typeof elem.getAttributeNode !== "undefined" &&
  					elem.getAttributeNode("id");
  				return node && node.value === attrId;
  			};
  		};

  		// Support: IE 6 - 7 only
  		// getElementById is not reliable as a find shortcut
  		Expr.find["ID"] = function( id, context ) {
  			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  				var node, i, elems,
  					elem = context.getElementById( id );

  				if ( elem ) {

  					// Verify the id attribute
  					node = elem.getAttributeNode("id");
  					if ( node && node.value === id ) {
  						return [ elem ];
  					}

  					// Fall back on getElementsByName
  					elems = context.getElementsByName( id );
  					i = 0;
  					while ( (elem = elems[i++]) ) {
  						node = elem.getAttributeNode("id");
  						if ( node && node.value === id ) {
  							return [ elem ];
  						}
  					}
  				}

  				return [];
  			}
  		};
  	}

  	// Tag
  	Expr.find["TAG"] = support.getElementsByTagName ?
  		function( tag, context ) {
  			if ( typeof context.getElementsByTagName !== "undefined" ) {
  				return context.getElementsByTagName( tag );

  			// DocumentFragment nodes don't have gEBTN
  			} else if ( support.qsa ) {
  				return context.querySelectorAll( tag );
  			}
  		} :

  		function( tag, context ) {
  			var elem,
  				tmp = [],
  				i = 0,
  				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
  				results = context.getElementsByTagName( tag );

  			// Filter out possible comments
  			if ( tag === "*" ) {
  				while ( (elem = results[i++]) ) {
  					if ( elem.nodeType === 1 ) {
  						tmp.push( elem );
  					}
  				}

  				return tmp;
  			}
  			return results;
  		};

  	// Class
  	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
  		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
  			return context.getElementsByClassName( className );
  		}
  	};

  	/* QSA/matchesSelector
  	---------------------------------------------------------------------- */

  	// QSA and matchesSelector support

  	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
  	rbuggyMatches = [];

  	// qSa(:focus) reports false when true (Chrome 21)
  	// We allow this because of a bug in IE8/9 that throws an error
  	// whenever `document.activeElement` is accessed on an iframe
  	// So, we allow :focus to pass through QSA all the time to avoid the IE error
  	// See https://bugs.jquery.com/ticket/13378
  	rbuggyQSA = [];

  	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
  		// Build QSA regex
  		// Regex strategy adopted from Diego Perini
  		assert(function( el ) {
  			// Select is set to empty string on purpose
  			// This is to test IE's treatment of not explicitly
  			// setting a boolean content attribute,
  			// since its presence should be enough
  			// https://bugs.jquery.com/ticket/12359
  			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
  				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
  				"<option selected=''></option></select>";

  			// Support: IE8, Opera 11-12.16
  			// Nothing should be selected when empty strings follow ^= or $= or *=
  			// The test attribute must be unknown in Opera but "safe" for WinRT
  			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
  			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
  				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
  			}

  			// Support: IE8
  			// Boolean attributes and "value" are not treated correctly
  			if ( !el.querySelectorAll("[selected]").length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
  			}

  			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
  			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
  				rbuggyQSA.push("~=");
  			}

  			// Webkit/Opera - :checked should return selected option elements
  			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  			// IE8 throws error here and will not see later tests
  			if ( !el.querySelectorAll(":checked").length ) {
  				rbuggyQSA.push(":checked");
  			}

  			// Support: Safari 8+, iOS 8+
  			// https://bugs.webkit.org/show_bug.cgi?id=136851
  			// In-page `selector#id sibling-combinator selector` fails
  			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
  				rbuggyQSA.push(".#.+[+~]");
  			}
  		});

  		assert(function( el ) {
  			el.innerHTML = "<a href='' disabled='disabled'></a>" +
  				"<select disabled='disabled'><option/></select>";

  			// Support: Windows 8 Native Apps
  			// The type and name attributes are restricted during .innerHTML assignment
  			var input = document.createElement("input");
  			input.setAttribute( "type", "hidden" );
  			el.appendChild( input ).setAttribute( "name", "D" );

  			// Support: IE8
  			// Enforce case-sensitivity of name attribute
  			if ( el.querySelectorAll("[name=d]").length ) {
  				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
  			}

  			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
  			// IE8 throws error here and will not see later tests
  			if ( el.querySelectorAll(":enabled").length !== 2 ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Support: IE9-11+
  			// IE's :disabled selector does not pick up the children of disabled fieldsets
  			docElem.appendChild( el ).disabled = true;
  			if ( el.querySelectorAll(":disabled").length !== 2 ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Opera 10-11 does not throw on post-comma invalid pseudos
  			el.querySelectorAll("*,:x");
  			rbuggyQSA.push(",.*:");
  		});
  	}

  	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
  		docElem.webkitMatchesSelector ||
  		docElem.mozMatchesSelector ||
  		docElem.oMatchesSelector ||
  		docElem.msMatchesSelector) )) ) {

  		assert(function( el ) {
  			// Check to see if it's possible to do matchesSelector
  			// on a disconnected node (IE 9)
  			support.disconnectedMatch = matches.call( el, "*" );

  			// This should fail with an exception
  			// Gecko does not error, returns false instead
  			matches.call( el, "[s!='']:x" );
  			rbuggyMatches.push( "!=", pseudos );
  		});
  	}

  	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
  	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

  	/* Contains
  	---------------------------------------------------------------------- */
  	hasCompare = rnative.test( docElem.compareDocumentPosition );

  	// Element contains another
  	// Purposefully self-exclusive
  	// As in, an element does not contain itself
  	contains = hasCompare || rnative.test( docElem.contains ) ?
  		function( a, b ) {
  			var adown = a.nodeType === 9 ? a.documentElement : a,
  				bup = b && b.parentNode;
  			return a === bup || !!( bup && bup.nodeType === 1 && (
  				adown.contains ?
  					adown.contains( bup ) :
  					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
  			));
  		} :
  		function( a, b ) {
  			if ( b ) {
  				while ( (b = b.parentNode) ) {
  					if ( b === a ) {
  						return true;
  					}
  				}
  			}
  			return false;
  		};

  	/* Sorting
  	---------------------------------------------------------------------- */

  	// Document order sorting
  	sortOrder = hasCompare ?
  	function( a, b ) {

  		// Flag for duplicate removal
  		if ( a === b ) {
  			hasDuplicate = true;
  			return 0;
  		}

  		// Sort on method existence if only one input has compareDocumentPosition
  		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
  		if ( compare ) {
  			return compare;
  		}

  		// Calculate position if both inputs belong to the same document
  		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
  			a.compareDocumentPosition( b ) :

  			// Otherwise we know they are disconnected
  			1;

  		// Disconnected nodes
  		if ( compare & 1 ||
  			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

  			// Choose the first element that is related to our preferred document
  			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
  				return -1;
  			}
  			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
  				return 1;
  			}

  			// Maintain original order
  			return sortInput ?
  				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
  				0;
  		}

  		return compare & 4 ? -1 : 1;
  	} :
  	function( a, b ) {
  		// Exit early if the nodes are identical
  		if ( a === b ) {
  			hasDuplicate = true;
  			return 0;
  		}

  		var cur,
  			i = 0,
  			aup = a.parentNode,
  			bup = b.parentNode,
  			ap = [ a ],
  			bp = [ b ];

  		// Parentless nodes are either documents or disconnected
  		if ( !aup || !bup ) {
  			return a === document ? -1 :
  				b === document ? 1 :
  				aup ? -1 :
  				bup ? 1 :
  				sortInput ?
  				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
  				0;

  		// If the nodes are siblings, we can do a quick check
  		} else if ( aup === bup ) {
  			return siblingCheck( a, b );
  		}

  		// Otherwise we need full lists of their ancestors for comparison
  		cur = a;
  		while ( (cur = cur.parentNode) ) {
  			ap.unshift( cur );
  		}
  		cur = b;
  		while ( (cur = cur.parentNode) ) {
  			bp.unshift( cur );
  		}

  		// Walk down the tree looking for a discrepancy
  		while ( ap[i] === bp[i] ) {
  			i++;
  		}

  		return i ?
  			// Do a sibling check if the nodes have a common ancestor
  			siblingCheck( ap[i], bp[i] ) :

  			// Otherwise nodes in our document sort first
  			ap[i] === preferredDoc ? -1 :
  			bp[i] === preferredDoc ? 1 :
  			0;
  	};

  	return document;
  };

  Sizzle.matches = function( expr, elements ) {
  	return Sizzle( expr, null, null, elements );
  };

  Sizzle.matchesSelector = function( elem, expr ) {
  	// Set document vars if needed
  	if ( ( elem.ownerDocument || elem ) !== document ) {
  		setDocument( elem );
  	}

  	if ( support.matchesSelector && documentIsHTML &&
  		!nonnativeSelectorCache[ expr + " " ] &&
  		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
  		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

  		try {
  			var ret = matches.call( elem, expr );

  			// IE 9's matchesSelector returns false on disconnected nodes
  			if ( ret || support.disconnectedMatch ||
  					// As well, disconnected nodes are said to be in a document
  					// fragment in IE 9
  					elem.document && elem.document.nodeType !== 11 ) {
  				return ret;
  			}
  		} catch (e) {
  			nonnativeSelectorCache( expr, true );
  		}
  	}

  	return Sizzle( expr, document, null, [ elem ] ).length > 0;
  };

  Sizzle.contains = function( context, elem ) {
  	// Set document vars if needed
  	if ( ( context.ownerDocument || context ) !== document ) {
  		setDocument( context );
  	}
  	return contains( context, elem );
  };

  Sizzle.attr = function( elem, name ) {
  	// Set document vars if needed
  	if ( ( elem.ownerDocument || elem ) !== document ) {
  		setDocument( elem );
  	}

  	var fn = Expr.attrHandle[ name.toLowerCase() ],
  		// Don't get fooled by Object.prototype properties (jQuery #13807)
  		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
  			fn( elem, name, !documentIsHTML ) :
  			undefined;

  	return val !== undefined ?
  		val :
  		support.attributes || !documentIsHTML ?
  			elem.getAttribute( name ) :
  			(val = elem.getAttributeNode(name)) && val.specified ?
  				val.value :
  				null;
  };

  Sizzle.escape = function( sel ) {
  	return (sel + "").replace( rcssescape, fcssescape );
  };

  Sizzle.error = function( msg ) {
  	throw new Error( "Syntax error, unrecognized expression: " + msg );
  };

  /**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
  Sizzle.uniqueSort = function( results ) {
  	var elem,
  		duplicates = [],
  		j = 0,
  		i = 0;

  	// Unless we *know* we can detect duplicates, assume their presence
  	hasDuplicate = !support.detectDuplicates;
  	sortInput = !support.sortStable && results.slice( 0 );
  	results.sort( sortOrder );

  	if ( hasDuplicate ) {
  		while ( (elem = results[i++]) ) {
  			if ( elem === results[ i ] ) {
  				j = duplicates.push( i );
  			}
  		}
  		while ( j-- ) {
  			results.splice( duplicates[ j ], 1 );
  		}
  	}

  	// Clear input after sorting to release objects
  	// See https://github.com/jquery/sizzle/pull/225
  	sortInput = null;

  	return results;
  };

  /**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
  getText = Sizzle.getText = function( elem ) {
  	var node,
  		ret = "",
  		i = 0,
  		nodeType = elem.nodeType;

  	if ( !nodeType ) {
  		// If no nodeType, this is expected to be an array
  		while ( (node = elem[i++]) ) {
  			// Do not traverse comment nodes
  			ret += getText( node );
  		}
  	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
  		// Use textContent for elements
  		// innerText usage removed for consistency of new lines (jQuery #11153)
  		if ( typeof elem.textContent === "string" ) {
  			return elem.textContent;
  		} else {
  			// Traverse its children
  			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  				ret += getText( elem );
  			}
  		}
  	} else if ( nodeType === 3 || nodeType === 4 ) {
  		return elem.nodeValue;
  	}
  	// Do not include comment or processing instruction nodes

  	return ret;
  };

  Expr = Sizzle.selectors = {

  	// Can be adjusted by the user
  	cacheLength: 50,

  	createPseudo: markFunction,

  	match: matchExpr,

  	attrHandle: {},

  	find: {},

  	relative: {
  		">": { dir: "parentNode", first: true },
  		" ": { dir: "parentNode" },
  		"+": { dir: "previousSibling", first: true },
  		"~": { dir: "previousSibling" }
  	},

  	preFilter: {
  		"ATTR": function( match ) {
  			match[1] = match[1].replace( runescape, funescape );

  			// Move the given value to match[3] whether quoted or unquoted
  			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

  			if ( match[2] === "~=" ) {
  				match[3] = " " + match[3] + " ";
  			}

  			return match.slice( 0, 4 );
  		},

  		"CHILD": function( match ) {
  			/* matches from matchExpr["CHILD"]
  				1 type (only|nth|...)
  				2 what (child|of-type)
  				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
  				4 xn-component of xn+y argument ([+-]?\d*n|)
  				5 sign of xn-component
  				6 x of xn-component
  				7 sign of y-component
  				8 y of y-component
  			*/
  			match[1] = match[1].toLowerCase();

  			if ( match[1].slice( 0, 3 ) === "nth" ) {
  				// nth-* requires argument
  				if ( !match[3] ) {
  					Sizzle.error( match[0] );
  				}

  				// numeric x and y parameters for Expr.filter.CHILD
  				// remember that false/true cast respectively to 0/1
  				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
  				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

  			// other types prohibit arguments
  			} else if ( match[3] ) {
  				Sizzle.error( match[0] );
  			}

  			return match;
  		},

  		"PSEUDO": function( match ) {
  			var excess,
  				unquoted = !match[6] && match[2];

  			if ( matchExpr["CHILD"].test( match[0] ) ) {
  				return null;
  			}

  			// Accept quoted arguments as-is
  			if ( match[3] ) {
  				match[2] = match[4] || match[5] || "";

  			// Strip excess characters from unquoted arguments
  			} else if ( unquoted && rpseudo.test( unquoted ) &&
  				// Get excess from tokenize (recursively)
  				(excess = tokenize( unquoted, true )) &&
  				// advance to the next closing parenthesis
  				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

  				// excess is a negative index
  				match[0] = match[0].slice( 0, excess );
  				match[2] = unquoted.slice( 0, excess );
  			}

  			// Return only captures needed by the pseudo filter method (type and argument)
  			return match.slice( 0, 3 );
  		}
  	},

  	filter: {

  		"TAG": function( nodeNameSelector ) {
  			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
  			return nodeNameSelector === "*" ?
  				function() { return true; } :
  				function( elem ) {
  					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
  				};
  		},

  		"CLASS": function( className ) {
  			var pattern = classCache[ className + " " ];

  			return pattern ||
  				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
  				classCache( className, function( elem ) {
  					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
  				});
  		},

  		"ATTR": function( name, operator, check ) {
  			return function( elem ) {
  				var result = Sizzle.attr( elem, name );

  				if ( result == null ) {
  					return operator === "!=";
  				}
  				if ( !operator ) {
  					return true;
  				}

  				result += "";

  				return operator === "=" ? result === check :
  					operator === "!=" ? result !== check :
  					operator === "^=" ? check && result.indexOf( check ) === 0 :
  					operator === "*=" ? check && result.indexOf( check ) > -1 :
  					operator === "$=" ? check && result.slice( -check.length ) === check :
  					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
  					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
  					false;
  			};
  		},

  		"CHILD": function( type, what, argument, first, last ) {
  			var simple = type.slice( 0, 3 ) !== "nth",
  				forward = type.slice( -4 ) !== "last",
  				ofType = what === "of-type";

  			return first === 1 && last === 0 ?

  				// Shortcut for :nth-*(n)
  				function( elem ) {
  					return !!elem.parentNode;
  				} :

  				function( elem, context, xml ) {
  					var cache, uniqueCache, outerCache, node, nodeIndex, start,
  						dir = simple !== forward ? "nextSibling" : "previousSibling",
  						parent = elem.parentNode,
  						name = ofType && elem.nodeName.toLowerCase(),
  						useCache = !xml && !ofType,
  						diff = false;

  					if ( parent ) {

  						// :(first|last|only)-(child|of-type)
  						if ( simple ) {
  							while ( dir ) {
  								node = elem;
  								while ( (node = node[ dir ]) ) {
  									if ( ofType ?
  										node.nodeName.toLowerCase() === name :
  										node.nodeType === 1 ) {

  										return false;
  									}
  								}
  								// Reverse direction for :only-* (if we haven't yet done so)
  								start = dir = type === "only" && !start && "nextSibling";
  							}
  							return true;
  						}

  						start = [ forward ? parent.firstChild : parent.lastChild ];

  						// non-xml :nth-child(...) stores cache data on `parent`
  						if ( forward && useCache ) {

  							// Seek `elem` from a previously-cached index

  							// ...in a gzip-friendly way
  							node = parent;
  							outerCache = node[ expando ] || (node[ expando ] = {});

  							// Support: IE <9 only
  							// Defend against cloned attroperties (jQuery gh-1709)
  							uniqueCache = outerCache[ node.uniqueID ] ||
  								(outerCache[ node.uniqueID ] = {});

  							cache = uniqueCache[ type ] || [];
  							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  							diff = nodeIndex && cache[ 2 ];
  							node = nodeIndex && parent.childNodes[ nodeIndex ];

  							while ( (node = ++nodeIndex && node && node[ dir ] ||

  								// Fallback to seeking `elem` from the start
  								(diff = nodeIndex = 0) || start.pop()) ) {

  								// When found, cache indexes on `parent` and break
  								if ( node.nodeType === 1 && ++diff && node === elem ) {
  									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
  									break;
  								}
  							}

  						} else {
  							// Use previously-cached element index if available
  							if ( useCache ) {
  								// ...in a gzip-friendly way
  								node = elem;
  								outerCache = node[ expando ] || (node[ expando ] = {});

  								// Support: IE <9 only
  								// Defend against cloned attroperties (jQuery gh-1709)
  								uniqueCache = outerCache[ node.uniqueID ] ||
  									(outerCache[ node.uniqueID ] = {});

  								cache = uniqueCache[ type ] || [];
  								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  								diff = nodeIndex;
  							}

  							// xml :nth-child(...)
  							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
  							if ( diff === false ) {
  								// Use the same loop as above to seek `elem` from the start
  								while ( (node = ++nodeIndex && node && node[ dir ] ||
  									(diff = nodeIndex = 0) || start.pop()) ) {

  									if ( ( ofType ?
  										node.nodeName.toLowerCase() === name :
  										node.nodeType === 1 ) &&
  										++diff ) {

  										// Cache the index of each encountered element
  										if ( useCache ) {
  											outerCache = node[ expando ] || (node[ expando ] = {});

  											// Support: IE <9 only
  											// Defend against cloned attroperties (jQuery gh-1709)
  											uniqueCache = outerCache[ node.uniqueID ] ||
  												(outerCache[ node.uniqueID ] = {});

  											uniqueCache[ type ] = [ dirruns, diff ];
  										}

  										if ( node === elem ) {
  											break;
  										}
  									}
  								}
  							}
  						}

  						// Incorporate the offset, then check against cycle size
  						diff -= last;
  						return diff === first || ( diff % first === 0 && diff / first >= 0 );
  					}
  				};
  		},

  		"PSEUDO": function( pseudo, argument ) {
  			// pseudo-class names are case-insensitive
  			// http://www.w3.org/TR/selectors/#pseudo-classes
  			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
  			// Remember that setFilters inherits from pseudos
  			var args,
  				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
  					Sizzle.error( "unsupported pseudo: " + pseudo );

  			// The user may use createPseudo to indicate that
  			// arguments are needed to create the filter function
  			// just as Sizzle does
  			if ( fn[ expando ] ) {
  				return fn( argument );
  			}

  			// But maintain support for old signatures
  			if ( fn.length > 1 ) {
  				args = [ pseudo, pseudo, "", argument ];
  				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
  					markFunction(function( seed, matches ) {
  						var idx,
  							matched = fn( seed, argument ),
  							i = matched.length;
  						while ( i-- ) {
  							idx = indexOf( seed, matched[i] );
  							seed[ idx ] = !( matches[ idx ] = matched[i] );
  						}
  					}) :
  					function( elem ) {
  						return fn( elem, 0, args );
  					};
  			}

  			return fn;
  		}
  	},

  	pseudos: {
  		// Potentially complex pseudos
  		"not": markFunction(function( selector ) {
  			// Trim the selector passed to compile
  			// to avoid treating leading and trailing
  			// spaces as combinators
  			var input = [],
  				results = [],
  				matcher = compile( selector.replace( rtrim, "$1" ) );

  			return matcher[ expando ] ?
  				markFunction(function( seed, matches, context, xml ) {
  					var elem,
  						unmatched = matcher( seed, null, xml, [] ),
  						i = seed.length;

  					// Match elements unmatched by `matcher`
  					while ( i-- ) {
  						if ( (elem = unmatched[i]) ) {
  							seed[i] = !(matches[i] = elem);
  						}
  					}
  				}) :
  				function( elem, context, xml ) {
  					input[0] = elem;
  					matcher( input, null, xml, results );
  					// Don't keep the element (issue #299)
  					input[0] = null;
  					return !results.pop();
  				};
  		}),

  		"has": markFunction(function( selector ) {
  			return function( elem ) {
  				return Sizzle( selector, elem ).length > 0;
  			};
  		}),

  		"contains": markFunction(function( text ) {
  			text = text.replace( runescape, funescape );
  			return function( elem ) {
  				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
  			};
  		}),

  		// "Whether an element is represented by a :lang() selector
  		// is based solely on the element's language value
  		// being equal to the identifier C,
  		// or beginning with the identifier C immediately followed by "-".
  		// The matching of C against the element's language value is performed case-insensitively.
  		// The identifier C does not have to be a valid language name."
  		// http://www.w3.org/TR/selectors/#lang-pseudo
  		"lang": markFunction( function( lang ) {
  			// lang value must be a valid identifier
  			if ( !ridentifier.test(lang || "") ) {
  				Sizzle.error( "unsupported lang: " + lang );
  			}
  			lang = lang.replace( runescape, funescape ).toLowerCase();
  			return function( elem ) {
  				var elemLang;
  				do {
  					if ( (elemLang = documentIsHTML ?
  						elem.lang :
  						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

  						elemLang = elemLang.toLowerCase();
  						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
  					}
  				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
  				return false;
  			};
  		}),

  		// Miscellaneous
  		"target": function( elem ) {
  			var hash = window.location && window.location.hash;
  			return hash && hash.slice( 1 ) === elem.id;
  		},

  		"root": function( elem ) {
  			return elem === docElem;
  		},

  		"focus": function( elem ) {
  			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
  		},

  		// Boolean properties
  		"enabled": createDisabledPseudo( false ),
  		"disabled": createDisabledPseudo( true ),

  		"checked": function( elem ) {
  			// In CSS3, :checked should return both checked and selected elements
  			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  			var nodeName = elem.nodeName.toLowerCase();
  			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
  		},

  		"selected": function( elem ) {
  			// Accessing this property makes selected-by-default
  			// options in Safari work properly
  			if ( elem.parentNode ) {
  				elem.parentNode.selectedIndex;
  			}

  			return elem.selected === true;
  		},

  		// Contents
  		"empty": function( elem ) {
  			// http://www.w3.org/TR/selectors/#empty-pseudo
  			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  			//   but not by others (comment: 8; processing instruction: 7; etc.)
  			// nodeType < 6 works because attributes (2) do not appear as children
  			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  				if ( elem.nodeType < 6 ) {
  					return false;
  				}
  			}
  			return true;
  		},

  		"parent": function( elem ) {
  			return !Expr.pseudos["empty"]( elem );
  		},

  		// Element/input types
  		"header": function( elem ) {
  			return rheader.test( elem.nodeName );
  		},

  		"input": function( elem ) {
  			return rinputs.test( elem.nodeName );
  		},

  		"button": function( elem ) {
  			var name = elem.nodeName.toLowerCase();
  			return name === "input" && elem.type === "button" || name === "button";
  		},

  		"text": function( elem ) {
  			var attr;
  			return elem.nodeName.toLowerCase() === "input" &&
  				elem.type === "text" &&

  				// Support: IE<8
  				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
  				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
  		},

  		// Position-in-collection
  		"first": createPositionalPseudo(function() {
  			return [ 0 ];
  		}),

  		"last": createPositionalPseudo(function( matchIndexes, length ) {
  			return [ length - 1 ];
  		}),

  		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
  			return [ argument < 0 ? argument + length : argument ];
  		}),

  		"even": createPositionalPseudo(function( matchIndexes, length ) {
  			var i = 0;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		}),

  		"odd": createPositionalPseudo(function( matchIndexes, length ) {
  			var i = 1;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		}),

  		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
  			var i = argument < 0 ?
  				argument + length :
  				argument > length ?
  					length :
  					argument;
  			for ( ; --i >= 0; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		}),

  		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
  			var i = argument < 0 ? argument + length : argument;
  			for ( ; ++i < length; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		})
  	}
  };

  Expr.pseudos["nth"] = Expr.pseudos["eq"];

  // Add button/input type pseudos
  for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  	Expr.pseudos[ i ] = createInputPseudo( i );
  }
  for ( i in { submit: true, reset: true } ) {
  	Expr.pseudos[ i ] = createButtonPseudo( i );
  }

  // Easy API for creating new setFilters
  function setFilters() {}
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();

  tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
  	var matched, match, tokens, type,
  		soFar, groups, preFilters,
  		cached = tokenCache[ selector + " " ];

  	if ( cached ) {
  		return parseOnly ? 0 : cached.slice( 0 );
  	}

  	soFar = selector;
  	groups = [];
  	preFilters = Expr.preFilter;

  	while ( soFar ) {

  		// Comma and first run
  		if ( !matched || (match = rcomma.exec( soFar )) ) {
  			if ( match ) {
  				// Don't consume trailing commas as valid
  				soFar = soFar.slice( match[0].length ) || soFar;
  			}
  			groups.push( (tokens = []) );
  		}

  		matched = false;

  		// Combinators
  		if ( (match = rcombinators.exec( soFar )) ) {
  			matched = match.shift();
  			tokens.push({
  				value: matched,
  				// Cast descendant combinators to space
  				type: match[0].replace( rtrim, " " )
  			});
  			soFar = soFar.slice( matched.length );
  		}

  		// Filters
  		for ( type in Expr.filter ) {
  			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
  				(match = preFilters[ type ]( match ))) ) {
  				matched = match.shift();
  				tokens.push({
  					value: matched,
  					type: type,
  					matches: match
  				});
  				soFar = soFar.slice( matched.length );
  			}
  		}

  		if ( !matched ) {
  			break;
  		}
  	}

  	// Return the length of the invalid excess
  	// if we're just parsing
  	// Otherwise, throw an error or return tokens
  	return parseOnly ?
  		soFar.length :
  		soFar ?
  			Sizzle.error( selector ) :
  			// Cache the tokens
  			tokenCache( selector, groups ).slice( 0 );
  };

  function toSelector( tokens ) {
  	var i = 0,
  		len = tokens.length,
  		selector = "";
  	for ( ; i < len; i++ ) {
  		selector += tokens[i].value;
  	}
  	return selector;
  }

  function addCombinator( matcher, combinator, base ) {
  	var dir = combinator.dir,
  		skip = combinator.next,
  		key = skip || dir,
  		checkNonElements = base && key === "parentNode",
  		doneName = done++;

  	return combinator.first ?
  		// Check against closest ancestor/preceding element
  		function( elem, context, xml ) {
  			while ( (elem = elem[ dir ]) ) {
  				if ( elem.nodeType === 1 || checkNonElements ) {
  					return matcher( elem, context, xml );
  				}
  			}
  			return false;
  		} :

  		// Check against all ancestor/preceding elements
  		function( elem, context, xml ) {
  			var oldCache, uniqueCache, outerCache,
  				newCache = [ dirruns, doneName ];

  			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
  			if ( xml ) {
  				while ( (elem = elem[ dir ]) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						if ( matcher( elem, context, xml ) ) {
  							return true;
  						}
  					}
  				}
  			} else {
  				while ( (elem = elem[ dir ]) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						outerCache = elem[ expando ] || (elem[ expando ] = {});

  						// Support: IE <9 only
  						// Defend against cloned attroperties (jQuery gh-1709)
  						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

  						if ( skip && skip === elem.nodeName.toLowerCase() ) {
  							elem = elem[ dir ] || elem;
  						} else if ( (oldCache = uniqueCache[ key ]) &&
  							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

  							// Assign to newCache so results back-propagate to previous elements
  							return (newCache[ 2 ] = oldCache[ 2 ]);
  						} else {
  							// Reuse newcache so results back-propagate to previous elements
  							uniqueCache[ key ] = newCache;

  							// A match means we're done; a fail means we have to keep checking
  							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
  								return true;
  							}
  						}
  					}
  				}
  			}
  			return false;
  		};
  }

  function elementMatcher( matchers ) {
  	return matchers.length > 1 ?
  		function( elem, context, xml ) {
  			var i = matchers.length;
  			while ( i-- ) {
  				if ( !matchers[i]( elem, context, xml ) ) {
  					return false;
  				}
  			}
  			return true;
  		} :
  		matchers[0];
  }

  function multipleContexts( selector, contexts, results ) {
  	var i = 0,
  		len = contexts.length;
  	for ( ; i < len; i++ ) {
  		Sizzle( selector, contexts[i], results );
  	}
  	return results;
  }

  function condense( unmatched, map, filter, context, xml ) {
  	var elem,
  		newUnmatched = [],
  		i = 0,
  		len = unmatched.length,
  		mapped = map != null;

  	for ( ; i < len; i++ ) {
  		if ( (elem = unmatched[i]) ) {
  			if ( !filter || filter( elem, context, xml ) ) {
  				newUnmatched.push( elem );
  				if ( mapped ) {
  					map.push( i );
  				}
  			}
  		}
  	}

  	return newUnmatched;
  }

  function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  	if ( postFilter && !postFilter[ expando ] ) {
  		postFilter = setMatcher( postFilter );
  	}
  	if ( postFinder && !postFinder[ expando ] ) {
  		postFinder = setMatcher( postFinder, postSelector );
  	}
  	return markFunction(function( seed, results, context, xml ) {
  		var temp, i, elem,
  			preMap = [],
  			postMap = [],
  			preexisting = results.length,

  			// Get initial elements from seed or context
  			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

  			// Prefilter to get matcher input, preserving a map for seed-results synchronization
  			matcherIn = preFilter && ( seed || !selector ) ?
  				condense( elems, preMap, preFilter, context, xml ) :
  				elems,

  			matcherOut = matcher ?
  				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
  				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

  					// ...intermediate processing is necessary
  					[] :

  					// ...otherwise use results directly
  					results :
  				matcherIn;

  		// Find primary matches
  		if ( matcher ) {
  			matcher( matcherIn, matcherOut, context, xml );
  		}

  		// Apply postFilter
  		if ( postFilter ) {
  			temp = condense( matcherOut, postMap );
  			postFilter( temp, [], context, xml );

  			// Un-match failing elements by moving them back to matcherIn
  			i = temp.length;
  			while ( i-- ) {
  				if ( (elem = temp[i]) ) {
  					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
  				}
  			}
  		}

  		if ( seed ) {
  			if ( postFinder || preFilter ) {
  				if ( postFinder ) {
  					// Get the final matcherOut by condensing this intermediate into postFinder contexts
  					temp = [];
  					i = matcherOut.length;
  					while ( i-- ) {
  						if ( (elem = matcherOut[i]) ) {
  							// Restore matcherIn since elem is not yet a final match
  							temp.push( (matcherIn[i] = elem) );
  						}
  					}
  					postFinder( null, (matcherOut = []), temp, xml );
  				}

  				// Move matched elements from seed to results to keep them synchronized
  				i = matcherOut.length;
  				while ( i-- ) {
  					if ( (elem = matcherOut[i]) &&
  						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

  						seed[temp] = !(results[temp] = elem);
  					}
  				}
  			}

  		// Add elements to results, through postFinder if defined
  		} else {
  			matcherOut = condense(
  				matcherOut === results ?
  					matcherOut.splice( preexisting, matcherOut.length ) :
  					matcherOut
  			);
  			if ( postFinder ) {
  				postFinder( null, results, matcherOut, xml );
  			} else {
  				push.apply( results, matcherOut );
  			}
  		}
  	});
  }

  function matcherFromTokens( tokens ) {
  	var checkContext, matcher, j,
  		len = tokens.length,
  		leadingRelative = Expr.relative[ tokens[0].type ],
  		implicitRelative = leadingRelative || Expr.relative[" "],
  		i = leadingRelative ? 1 : 0,

  		// The foundational matcher ensures that elements are reachable from top-level context(s)
  		matchContext = addCombinator( function( elem ) {
  			return elem === checkContext;
  		}, implicitRelative, true ),
  		matchAnyContext = addCombinator( function( elem ) {
  			return indexOf( checkContext, elem ) > -1;
  		}, implicitRelative, true ),
  		matchers = [ function( elem, context, xml ) {
  			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
  				(checkContext = context).nodeType ?
  					matchContext( elem, context, xml ) :
  					matchAnyContext( elem, context, xml ) );
  			// Avoid hanging onto element (issue #299)
  			checkContext = null;
  			return ret;
  		} ];

  	for ( ; i < len; i++ ) {
  		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
  			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
  		} else {
  			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

  			// Return special upon seeing a positional matcher
  			if ( matcher[ expando ] ) {
  				// Find the next relative operator (if any) for proper handling
  				j = ++i;
  				for ( ; j < len; j++ ) {
  					if ( Expr.relative[ tokens[j].type ] ) {
  						break;
  					}
  				}
  				return setMatcher(
  					i > 1 && elementMatcher( matchers ),
  					i > 1 && toSelector(
  						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
  						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
  					).replace( rtrim, "$1" ),
  					matcher,
  					i < j && matcherFromTokens( tokens.slice( i, j ) ),
  					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
  					j < len && toSelector( tokens )
  				);
  			}
  			matchers.push( matcher );
  		}
  	}

  	return elementMatcher( matchers );
  }

  function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  	var bySet = setMatchers.length > 0,
  		byElement = elementMatchers.length > 0,
  		superMatcher = function( seed, context, xml, results, outermost ) {
  			var elem, j, matcher,
  				matchedCount = 0,
  				i = "0",
  				unmatched = seed && [],
  				setMatched = [],
  				contextBackup = outermostContext,
  				// We must always have either seed elements or outermost context
  				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
  				// Use integer dirruns iff this is the outermost matcher
  				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
  				len = elems.length;

  			if ( outermost ) {
  				outermostContext = context === document || context || outermost;
  			}

  			// Add elements passing elementMatchers directly to results
  			// Support: IE<9, Safari
  			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
  			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
  				if ( byElement && elem ) {
  					j = 0;
  					if ( !context && elem.ownerDocument !== document ) {
  						setDocument( elem );
  						xml = !documentIsHTML;
  					}
  					while ( (matcher = elementMatchers[j++]) ) {
  						if ( matcher( elem, context || document, xml) ) {
  							results.push( elem );
  							break;
  						}
  					}
  					if ( outermost ) {
  						dirruns = dirrunsUnique;
  					}
  				}

  				// Track unmatched elements for set filters
  				if ( bySet ) {
  					// They will have gone through all possible matchers
  					if ( (elem = !matcher && elem) ) {
  						matchedCount--;
  					}

  					// Lengthen the array for every element, matched or not
  					if ( seed ) {
  						unmatched.push( elem );
  					}
  				}
  			}

  			// `i` is now the count of elements visited above, and adding it to `matchedCount`
  			// makes the latter nonnegative.
  			matchedCount += i;

  			// Apply set filters to unmatched elements
  			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
  			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
  			// no element matchers and no seed.
  			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
  			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
  			// numerically zero.
  			if ( bySet && i !== matchedCount ) {
  				j = 0;
  				while ( (matcher = setMatchers[j++]) ) {
  					matcher( unmatched, setMatched, context, xml );
  				}

  				if ( seed ) {
  					// Reintegrate element matches to eliminate the need for sorting
  					if ( matchedCount > 0 ) {
  						while ( i-- ) {
  							if ( !(unmatched[i] || setMatched[i]) ) {
  								setMatched[i] = pop.call( results );
  							}
  						}
  					}

  					// Discard index placeholder values to get only actual matches
  					setMatched = condense( setMatched );
  				}

  				// Add matches to results
  				push.apply( results, setMatched );

  				// Seedless set matches succeeding multiple successful matchers stipulate sorting
  				if ( outermost && !seed && setMatched.length > 0 &&
  					( matchedCount + setMatchers.length ) > 1 ) {

  					Sizzle.uniqueSort( results );
  				}
  			}

  			// Override manipulation of globals by nested matchers
  			if ( outermost ) {
  				dirruns = dirrunsUnique;
  				outermostContext = contextBackup;
  			}

  			return unmatched;
  		};

  	return bySet ?
  		markFunction( superMatcher ) :
  		superMatcher;
  }

  compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
  	var i,
  		setMatchers = [],
  		elementMatchers = [],
  		cached = compilerCache[ selector + " " ];

  	if ( !cached ) {
  		// Generate a function of recursive functions that can be used to check each element
  		if ( !match ) {
  			match = tokenize( selector );
  		}
  		i = match.length;
  		while ( i-- ) {
  			cached = matcherFromTokens( match[i] );
  			if ( cached[ expando ] ) {
  				setMatchers.push( cached );
  			} else {
  				elementMatchers.push( cached );
  			}
  		}

  		// Cache the compiled function
  		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

  		// Save selector and tokenization
  		cached.selector = selector;
  	}
  	return cached;
  };

  /**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
  select = Sizzle.select = function( selector, context, results, seed ) {
  	var i, tokens, token, type, find,
  		compiled = typeof selector === "function" && selector,
  		match = !seed && tokenize( (selector = compiled.selector || selector) );

  	results = results || [];

  	// Try to minimize operations if there is only one selector in the list and no seed
  	// (the latter of which guarantees us context)
  	if ( match.length === 1 ) {

  		// Reduce context if the leading compound selector is an ID
  		tokens = match[0] = match[0].slice( 0 );
  		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
  				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

  			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
  			if ( !context ) {
  				return results;

  			// Precompiled matchers will still verify ancestry, so step up a level
  			} else if ( compiled ) {
  				context = context.parentNode;
  			}

  			selector = selector.slice( tokens.shift().value.length );
  		}

  		// Fetch a seed set for right-to-left matching
  		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
  		while ( i-- ) {
  			token = tokens[i];

  			// Abort if we hit a combinator
  			if ( Expr.relative[ (type = token.type) ] ) {
  				break;
  			}
  			if ( (find = Expr.find[ type ]) ) {
  				// Search, expanding context for leading sibling combinators
  				if ( (seed = find(
  					token.matches[0].replace( runescape, funescape ),
  					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
  				)) ) {

  					// If seed is empty or no tokens remain, we can return early
  					tokens.splice( i, 1 );
  					selector = seed.length && toSelector( tokens );
  					if ( !selector ) {
  						push.apply( results, seed );
  						return results;
  					}

  					break;
  				}
  			}
  		}
  	}

  	// Compile and execute a filtering function if one is not provided
  	// Provide `match` to avoid retokenization if we modified the selector above
  	( compiled || compile( selector, match ) )(
  		seed,
  		context,
  		!documentIsHTML,
  		results,
  		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
  	);
  	return results;
  };

  // One-time assignments

  // Sort stability
  support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

  // Support: Chrome 14-35+
  // Always assume duplicates if they aren't passed to the comparison function
  support.detectDuplicates = !!hasDuplicate;

  // Initialize against the default document
  setDocument();

  // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
  // Detached nodes confoundingly follow *each other*
  support.sortDetached = assert(function( el ) {
  	// Should return 1, but returns 4 (following)
  	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
  });

  // Support: IE<8
  // Prevent attribute/property "interpolation"
  // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if ( !assert(function( el ) {
  	el.innerHTML = "<a href='#'></a>";
  	return el.firstChild.getAttribute("href") === "#" ;
  }) ) {
  	addHandle( "type|href|height|width", function( elem, name, isXML ) {
  		if ( !isXML ) {
  			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
  		}
  	});
  }

  // Support: IE<9
  // Use defaultValue in place of getAttribute("value")
  if ( !support.attributes || !assert(function( el ) {
  	el.innerHTML = "<input/>";
  	el.firstChild.setAttribute( "value", "" );
  	return el.firstChild.getAttribute( "value" ) === "";
  }) ) {
  	addHandle( "value", function( elem, name, isXML ) {
  		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
  			return elem.defaultValue;
  		}
  	});
  }

  // Support: IE<9
  // Use getAttributeNode to fetch booleans when getAttribute lies
  if ( !assert(function( el ) {
  	return el.getAttribute("disabled") == null;
  }) ) {
  	addHandle( booleans, function( elem, name, isXML ) {
  		var val;
  		if ( !isXML ) {
  			return elem[ name ] === true ? name.toLowerCase() :
  					(val = elem.getAttributeNode( name )) && val.specified ?
  					val.value :
  				null;
  		}
  	});
  }

  return Sizzle;

  })( window );



  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;

  // Deprecated
  jQuery.expr[ ":" ] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;




  var dir = function( elem, dir, until ) {
  	var matched = [],
  		truncate = until !== undefined;

  	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
  		if ( elem.nodeType === 1 ) {
  			if ( truncate && jQuery( elem ).is( until ) ) {
  				break;
  			}
  			matched.push( elem );
  		}
  	}
  	return matched;
  };


  var siblings = function( n, elem ) {
  	var matched = [];

  	for ( ; n; n = n.nextSibling ) {
  		if ( n.nodeType === 1 && n !== elem ) {
  			matched.push( n );
  		}
  	}

  	return matched;
  };


  var rneedsContext = jQuery.expr.match.needsContext;



  function nodeName( elem, name ) {

    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

  }var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



  // Implement the identical functionality for filter and not
  function winnow( elements, qualifier, not ) {
  	if ( isFunction( qualifier ) ) {
  		return jQuery.grep( elements, function( elem, i ) {
  			return !!qualifier.call( elem, i, elem ) !== not;
  		} );
  	}

  	// Single element
  	if ( qualifier.nodeType ) {
  		return jQuery.grep( elements, function( elem ) {
  			return ( elem === qualifier ) !== not;
  		} );
  	}

  	// Arraylike of elements (jQuery, arguments, Array)
  	if ( typeof qualifier !== "string" ) {
  		return jQuery.grep( elements, function( elem ) {
  			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
  		} );
  	}

  	// Filtered directly for both simple and complex selectors
  	return jQuery.filter( qualifier, elements, not );
  }

  jQuery.filter = function( expr, elems, not ) {
  	var elem = elems[ 0 ];

  	if ( not ) {
  		expr = ":not(" + expr + ")";
  	}

  	if ( elems.length === 1 && elem.nodeType === 1 ) {
  		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
  	}

  	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
  		return elem.nodeType === 1;
  	} ) );
  };

  jQuery.fn.extend( {
  	find: function( selector ) {
  		var i, ret,
  			len = this.length,
  			self = this;

  		if ( typeof selector !== "string" ) {
  			return this.pushStack( jQuery( selector ).filter( function() {
  				for ( i = 0; i < len; i++ ) {
  					if ( jQuery.contains( self[ i ], this ) ) {
  						return true;
  					}
  				}
  			} ) );
  		}

  		ret = this.pushStack( [] );

  		for ( i = 0; i < len; i++ ) {
  			jQuery.find( selector, self[ i ], ret );
  		}

  		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
  	},
  	filter: function( selector ) {
  		return this.pushStack( winnow( this, selector || [], false ) );
  	},
  	not: function( selector ) {
  		return this.pushStack( winnow( this, selector || [], true ) );
  	},
  	is: function( selector ) {
  		return !!winnow(
  			this,

  			// If this is a positional/relative selector, check membership in the returned set
  			// so $("p:first").is("p:last") won't return true for a doc with two "p".
  			typeof selector === "string" && rneedsContext.test( selector ) ?
  				jQuery( selector ) :
  				selector || [],
  			false
  		).length;
  	}
  } );


  // Initialize a jQuery object


  // A central reference to the root jQuery(document)
  var rootjQuery,

  	// A simple way to check for HTML strings
  	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  	// Strict HTML recognition (#11290: must start with <)
  	// Shortcut simple #id case for speed
  	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

  	init = jQuery.fn.init = function( selector, context, root ) {
  		var match, elem;

  		// HANDLE: $(""), $(null), $(undefined), $(false)
  		if ( !selector ) {
  			return this;
  		}

  		// Method init() accepts an alternate rootjQuery
  		// so migrate can support jQuery.sub (gh-2101)
  		root = root || rootjQuery;

  		// Handle HTML strings
  		if ( typeof selector === "string" ) {
  			if ( selector[ 0 ] === "<" &&
  				selector[ selector.length - 1 ] === ">" &&
  				selector.length >= 3 ) {

  				// Assume that strings that start and end with <> are HTML and skip the regex check
  				match = [ null, selector, null ];

  			} else {
  				match = rquickExpr.exec( selector );
  			}

  			// Match html or make sure no context is specified for #id
  			if ( match && ( match[ 1 ] || !context ) ) {

  				// HANDLE: $(html) -> $(array)
  				if ( match[ 1 ] ) {
  					context = context instanceof jQuery ? context[ 0 ] : context;

  					// Option to run scripts is true for back-compat
  					// Intentionally let the error be thrown if parseHTML is not present
  					jQuery.merge( this, jQuery.parseHTML(
  						match[ 1 ],
  						context && context.nodeType ? context.ownerDocument || context : document,
  						true
  					) );

  					// HANDLE: $(html, props)
  					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
  						for ( match in context ) {

  							// Properties of context are called as methods if possible
  							if ( isFunction( this[ match ] ) ) {
  								this[ match ]( context[ match ] );

  							// ...and otherwise set as attributes
  							} else {
  								this.attr( match, context[ match ] );
  							}
  						}
  					}

  					return this;

  				// HANDLE: $(#id)
  				} else {
  					elem = document.getElementById( match[ 2 ] );

  					if ( elem ) {

  						// Inject the element directly into the jQuery object
  						this[ 0 ] = elem;
  						this.length = 1;
  					}
  					return this;
  				}

  			// HANDLE: $(expr, $(...))
  			} else if ( !context || context.jquery ) {
  				return ( context || root ).find( selector );

  			// HANDLE: $(expr, context)
  			// (which is just equivalent to: $(context).find(expr)
  			} else {
  				return this.constructor( context ).find( selector );
  			}

  		// HANDLE: $(DOMElement)
  		} else if ( selector.nodeType ) {
  			this[ 0 ] = selector;
  			this.length = 1;
  			return this;

  		// HANDLE: $(function)
  		// Shortcut for document ready
  		} else if ( isFunction( selector ) ) {
  			return root.ready !== undefined ?
  				root.ready( selector ) :

  				// Execute immediately if ready is not present
  				selector( jQuery );
  		}

  		return jQuery.makeArray( selector, this );
  	};

  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;

  // Initialize central reference
  rootjQuery = jQuery( document );


  var rparentsprev = /^(?:parents|prev(?:Until|All))/,

  	// Methods guaranteed to produce a unique set when starting from a unique set
  	guaranteedUnique = {
  		children: true,
  		contents: true,
  		next: true,
  		prev: true
  	};

  jQuery.fn.extend( {
  	has: function( target ) {
  		var targets = jQuery( target, this ),
  			l = targets.length;

  		return this.filter( function() {
  			var i = 0;
  			for ( ; i < l; i++ ) {
  				if ( jQuery.contains( this, targets[ i ] ) ) {
  					return true;
  				}
  			}
  		} );
  	},

  	closest: function( selectors, context ) {
  		var cur,
  			i = 0,
  			l = this.length,
  			matched = [],
  			targets = typeof selectors !== "string" && jQuery( selectors );

  		// Positional selectors never match, since there's no _selection_ context
  		if ( !rneedsContext.test( selectors ) ) {
  			for ( ; i < l; i++ ) {
  				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

  					// Always skip document fragments
  					if ( cur.nodeType < 11 && ( targets ?
  						targets.index( cur ) > -1 :

  						// Don't pass non-elements to Sizzle
  						cur.nodeType === 1 &&
  							jQuery.find.matchesSelector( cur, selectors ) ) ) {

  						matched.push( cur );
  						break;
  					}
  				}
  			}
  		}

  		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
  	},

  	// Determine the position of an element within the set
  	index: function( elem ) {

  		// No argument, return index in parent
  		if ( !elem ) {
  			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
  		}

  		// Index in selector
  		if ( typeof elem === "string" ) {
  			return indexOf.call( jQuery( elem ), this[ 0 ] );
  		}

  		// Locate the position of the desired element
  		return indexOf.call( this,

  			// If it receives a jQuery object, the first element is used
  			elem.jquery ? elem[ 0 ] : elem
  		);
  	},

  	add: function( selector, context ) {
  		return this.pushStack(
  			jQuery.uniqueSort(
  				jQuery.merge( this.get(), jQuery( selector, context ) )
  			)
  		);
  	},

  	addBack: function( selector ) {
  		return this.add( selector == null ?
  			this.prevObject : this.prevObject.filter( selector )
  		);
  	}
  } );

  function sibling( cur, dir ) {
  	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
  	return cur;
  }

  jQuery.each( {
  	parent: function( elem ) {
  		var parent = elem.parentNode;
  		return parent && parent.nodeType !== 11 ? parent : null;
  	},
  	parents: function( elem ) {
  		return dir( elem, "parentNode" );
  	},
  	parentsUntil: function( elem, i, until ) {
  		return dir( elem, "parentNode", until );
  	},
  	next: function( elem ) {
  		return sibling( elem, "nextSibling" );
  	},
  	prev: function( elem ) {
  		return sibling( elem, "previousSibling" );
  	},
  	nextAll: function( elem ) {
  		return dir( elem, "nextSibling" );
  	},
  	prevAll: function( elem ) {
  		return dir( elem, "previousSibling" );
  	},
  	nextUntil: function( elem, i, until ) {
  		return dir( elem, "nextSibling", until );
  	},
  	prevUntil: function( elem, i, until ) {
  		return dir( elem, "previousSibling", until );
  	},
  	siblings: function( elem ) {
  		return siblings( ( elem.parentNode || {} ).firstChild, elem );
  	},
  	children: function( elem ) {
  		return siblings( elem.firstChild );
  	},
  	contents: function( elem ) {
  		if ( typeof elem.contentDocument !== "undefined" ) {
  			return elem.contentDocument;
  		}

  		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
  		// Treat the template element as a regular one in browsers that
  		// don't support it.
  		if ( nodeName( elem, "template" ) ) {
  			elem = elem.content || elem;
  		}

  		return jQuery.merge( [], elem.childNodes );
  	}
  }, function( name, fn ) {
  	jQuery.fn[ name ] = function( until, selector ) {
  		var matched = jQuery.map( this, fn, until );

  		if ( name.slice( -5 ) !== "Until" ) {
  			selector = until;
  		}

  		if ( selector && typeof selector === "string" ) {
  			matched = jQuery.filter( selector, matched );
  		}

  		if ( this.length > 1 ) {

  			// Remove duplicates
  			if ( !guaranteedUnique[ name ] ) {
  				jQuery.uniqueSort( matched );
  			}

  			// Reverse order for parents* and prev-derivatives
  			if ( rparentsprev.test( name ) ) {
  				matched.reverse();
  			}
  		}

  		return this.pushStack( matched );
  	};
  } );
  var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



  // Convert String-formatted options into Object-formatted ones
  function createOptions( options ) {
  	var object = {};
  	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
  		object[ flag ] = true;
  	} );
  	return object;
  }

  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function( options ) {

  	// Convert options from String-formatted to Object-formatted if needed
  	// (we check in cache first)
  	options = typeof options === "string" ?
  		createOptions( options ) :
  		jQuery.extend( {}, options );

  	var // Flag to know if list is currently firing
  		firing,

  		// Last fire value for non-forgettable lists
  		memory,

  		// Flag to know if list was already fired
  		fired,

  		// Flag to prevent firing
  		locked,

  		// Actual callback list
  		list = [],

  		// Queue of execution data for repeatable lists
  		queue = [],

  		// Index of currently firing callback (modified by add/remove as needed)
  		firingIndex = -1,

  		// Fire callbacks
  		fire = function() {

  			// Enforce single-firing
  			locked = locked || options.once;

  			// Execute callbacks for all pending executions,
  			// respecting firingIndex overrides and runtime changes
  			fired = firing = true;
  			for ( ; queue.length; firingIndex = -1 ) {
  				memory = queue.shift();
  				while ( ++firingIndex < list.length ) {

  					// Run callback and check for early termination
  					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
  						options.stopOnFalse ) {

  						// Jump to end and forget the data so .add doesn't re-fire
  						firingIndex = list.length;
  						memory = false;
  					}
  				}
  			}

  			// Forget the data if we're done with it
  			if ( !options.memory ) {
  				memory = false;
  			}

  			firing = false;

  			// Clean up if we're done firing for good
  			if ( locked ) {

  				// Keep an empty list if we have data for future add calls
  				if ( memory ) {
  					list = [];

  				// Otherwise, this object is spent
  				} else {
  					list = "";
  				}
  			}
  		},

  		// Actual Callbacks object
  		self = {

  			// Add a callback or a collection of callbacks to the list
  			add: function() {
  				if ( list ) {

  					// If we have memory from a past run, we should fire after adding
  					if ( memory && !firing ) {
  						firingIndex = list.length - 1;
  						queue.push( memory );
  					}

  					( function add( args ) {
  						jQuery.each( args, function( _, arg ) {
  							if ( isFunction( arg ) ) {
  								if ( !options.unique || !self.has( arg ) ) {
  									list.push( arg );
  								}
  							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

  								// Inspect recursively
  								add( arg );
  							}
  						} );
  					} )( arguments );

  					if ( memory && !firing ) {
  						fire();
  					}
  				}
  				return this;
  			},

  			// Remove a callback from the list
  			remove: function() {
  				jQuery.each( arguments, function( _, arg ) {
  					var index;
  					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
  						list.splice( index, 1 );

  						// Handle firing indexes
  						if ( index <= firingIndex ) {
  							firingIndex--;
  						}
  					}
  				} );
  				return this;
  			},

  			// Check if a given callback is in the list.
  			// If no argument is given, return whether or not list has callbacks attached.
  			has: function( fn ) {
  				return fn ?
  					jQuery.inArray( fn, list ) > -1 :
  					list.length > 0;
  			},

  			// Remove all callbacks from the list
  			empty: function() {
  				if ( list ) {
  					list = [];
  				}
  				return this;
  			},

  			// Disable .fire and .add
  			// Abort any current/pending executions
  			// Clear all callbacks and values
  			disable: function() {
  				locked = queue = [];
  				list = memory = "";
  				return this;
  			},
  			disabled: function() {
  				return !list;
  			},

  			// Disable .fire
  			// Also disable .add unless we have memory (since it would have no effect)
  			// Abort any pending executions
  			lock: function() {
  				locked = queue = [];
  				if ( !memory && !firing ) {
  					list = memory = "";
  				}
  				return this;
  			},
  			locked: function() {
  				return !!locked;
  			},

  			// Call all callbacks with the given context and arguments
  			fireWith: function( context, args ) {
  				if ( !locked ) {
  					args = args || [];
  					args = [ context, args.slice ? args.slice() : args ];
  					queue.push( args );
  					if ( !firing ) {
  						fire();
  					}
  				}
  				return this;
  			},

  			// Call all the callbacks with the given arguments
  			fire: function() {
  				self.fireWith( this, arguments );
  				return this;
  			},

  			// To know if the callbacks have already been called at least once
  			fired: function() {
  				return !!fired;
  			}
  		};

  	return self;
  };


  function Identity( v ) {
  	return v;
  }
  function Thrower( ex ) {
  	throw ex;
  }

  function adoptValue( value, resolve, reject, noValue ) {
  	var method;

  	try {

  		// Check for promise aspect first to privilege synchronous behavior
  		if ( value && isFunction( ( method = value.promise ) ) ) {
  			method.call( value ).done( resolve ).fail( reject );

  		// Other thenables
  		} else if ( value && isFunction( ( method = value.then ) ) ) {
  			method.call( value, resolve, reject );

  		// Other non-thenables
  		} else {

  			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
  			// * false: [ value ].slice( 0 ) => resolve( value )
  			// * true: [ value ].slice( 1 ) => resolve()
  			resolve.apply( undefined, [ value ].slice( noValue ) );
  		}

  	// For Promises/A+, convert exceptions into rejections
  	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
  	// Deferred#then to conditionally suppress rejection.
  	} catch ( value ) {

  		// Support: Android 4.0 only
  		// Strict mode functions invoked without .call/.apply get global-object context
  		reject.apply( undefined, [ value ] );
  	}
  }

  jQuery.extend( {

  	Deferred: function( func ) {
  		var tuples = [

  				// action, add listener, callbacks,
  				// ... .then handlers, argument index, [final state]
  				[ "notify", "progress", jQuery.Callbacks( "memory" ),
  					jQuery.Callbacks( "memory" ), 2 ],
  				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
  					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
  				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
  					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
  			],
  			state = "pending",
  			promise = {
  				state: function() {
  					return state;
  				},
  				always: function() {
  					deferred.done( arguments ).fail( arguments );
  					return this;
  				},
  				"catch": function( fn ) {
  					return promise.then( null, fn );
  				},

  				// Keep pipe for back-compat
  				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
  					var fns = arguments;

  					return jQuery.Deferred( function( newDefer ) {
  						jQuery.each( tuples, function( i, tuple ) {

  							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
  							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

  							// deferred.progress(function() { bind to newDefer or newDefer.notify })
  							// deferred.done(function() { bind to newDefer or newDefer.resolve })
  							// deferred.fail(function() { bind to newDefer or newDefer.reject })
  							deferred[ tuple[ 1 ] ]( function() {
  								var returned = fn && fn.apply( this, arguments );
  								if ( returned && isFunction( returned.promise ) ) {
  									returned.promise()
  										.progress( newDefer.notify )
  										.done( newDefer.resolve )
  										.fail( newDefer.reject );
  								} else {
  									newDefer[ tuple[ 0 ] + "With" ](
  										this,
  										fn ? [ returned ] : arguments
  									);
  								}
  							} );
  						} );
  						fns = null;
  					} ).promise();
  				},
  				then: function( onFulfilled, onRejected, onProgress ) {
  					var maxDepth = 0;
  					function resolve( depth, deferred, handler, special ) {
  						return function() {
  							var that = this,
  								args = arguments,
  								mightThrow = function() {
  									var returned, then;

  									// Support: Promises/A+ section 2.3.3.3.3
  									// https://promisesaplus.com/#point-59
  									// Ignore double-resolution attempts
  									if ( depth < maxDepth ) {
  										return;
  									}

  									returned = handler.apply( that, args );

  									// Support: Promises/A+ section 2.3.1
  									// https://promisesaplus.com/#point-48
  									if ( returned === deferred.promise() ) {
  										throw new TypeError( "Thenable self-resolution" );
  									}

  									// Support: Promises/A+ sections 2.3.3.1, 3.5
  									// https://promisesaplus.com/#point-54
  									// https://promisesaplus.com/#point-75
  									// Retrieve `then` only once
  									then = returned &&

  										// Support: Promises/A+ section 2.3.4
  										// https://promisesaplus.com/#point-64
  										// Only check objects and functions for thenability
  										( typeof returned === "object" ||
  											typeof returned === "function" ) &&
  										returned.then;

  									// Handle a returned thenable
  									if ( isFunction( then ) ) {

  										// Special processors (notify) just wait for resolution
  										if ( special ) {
  											then.call(
  												returned,
  												resolve( maxDepth, deferred, Identity, special ),
  												resolve( maxDepth, deferred, Thrower, special )
  											);

  										// Normal processors (resolve) also hook into progress
  										} else {

  											// ...and disregard older resolution values
  											maxDepth++;

  											then.call(
  												returned,
  												resolve( maxDepth, deferred, Identity, special ),
  												resolve( maxDepth, deferred, Thrower, special ),
  												resolve( maxDepth, deferred, Identity,
  													deferred.notifyWith )
  											);
  										}

  									// Handle all other returned values
  									} else {

  										// Only substitute handlers pass on context
  										// and multiple values (non-spec behavior)
  										if ( handler !== Identity ) {
  											that = undefined;
  											args = [ returned ];
  										}

  										// Process the value(s)
  										// Default process is resolve
  										( special || deferred.resolveWith )( that, args );
  									}
  								},

  								// Only normal processors (resolve) catch and reject exceptions
  								process = special ?
  									mightThrow :
  									function() {
  										try {
  											mightThrow();
  										} catch ( e ) {

  											if ( jQuery.Deferred.exceptionHook ) {
  												jQuery.Deferred.exceptionHook( e,
  													process.stackTrace );
  											}

  											// Support: Promises/A+ section 2.3.3.3.4.1
  											// https://promisesaplus.com/#point-61
  											// Ignore post-resolution exceptions
  											if ( depth + 1 >= maxDepth ) {

  												// Only substitute handlers pass on context
  												// and multiple values (non-spec behavior)
  												if ( handler !== Thrower ) {
  													that = undefined;
  													args = [ e ];
  												}

  												deferred.rejectWith( that, args );
  											}
  										}
  									};

  							// Support: Promises/A+ section 2.3.3.3.1
  							// https://promisesaplus.com/#point-57
  							// Re-resolve promises immediately to dodge false rejection from
  							// subsequent errors
  							if ( depth ) {
  								process();
  							} else {

  								// Call an optional hook to record the stack, in case of exception
  								// since it's otherwise lost when execution goes async
  								if ( jQuery.Deferred.getStackHook ) {
  									process.stackTrace = jQuery.Deferred.getStackHook();
  								}
  								window.setTimeout( process );
  							}
  						};
  					}

  					return jQuery.Deferred( function( newDefer ) {

  						// progress_handlers.add( ... )
  						tuples[ 0 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onProgress ) ?
  									onProgress :
  									Identity,
  								newDefer.notifyWith
  							)
  						);

  						// fulfilled_handlers.add( ... )
  						tuples[ 1 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onFulfilled ) ?
  									onFulfilled :
  									Identity
  							)
  						);

  						// rejected_handlers.add( ... )
  						tuples[ 2 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onRejected ) ?
  									onRejected :
  									Thrower
  							)
  						);
  					} ).promise();
  				},

  				// Get a promise for this deferred
  				// If obj is provided, the promise aspect is added to the object
  				promise: function( obj ) {
  					return obj != null ? jQuery.extend( obj, promise ) : promise;
  				}
  			},
  			deferred = {};

  		// Add list-specific methods
  		jQuery.each( tuples, function( i, tuple ) {
  			var list = tuple[ 2 ],
  				stateString = tuple[ 5 ];

  			// promise.progress = list.add
  			// promise.done = list.add
  			// promise.fail = list.add
  			promise[ tuple[ 1 ] ] = list.add;

  			// Handle state
  			if ( stateString ) {
  				list.add(
  					function() {

  						// state = "resolved" (i.e., fulfilled)
  						// state = "rejected"
  						state = stateString;
  					},

  					// rejected_callbacks.disable
  					// fulfilled_callbacks.disable
  					tuples[ 3 - i ][ 2 ].disable,

  					// rejected_handlers.disable
  					// fulfilled_handlers.disable
  					tuples[ 3 - i ][ 3 ].disable,

  					// progress_callbacks.lock
  					tuples[ 0 ][ 2 ].lock,

  					// progress_handlers.lock
  					tuples[ 0 ][ 3 ].lock
  				);
  			}

  			// progress_handlers.fire
  			// fulfilled_handlers.fire
  			// rejected_handlers.fire
  			list.add( tuple[ 3 ].fire );

  			// deferred.notify = function() { deferred.notifyWith(...) }
  			// deferred.resolve = function() { deferred.resolveWith(...) }
  			// deferred.reject = function() { deferred.rejectWith(...) }
  			deferred[ tuple[ 0 ] ] = function() {
  				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
  				return this;
  			};

  			// deferred.notifyWith = list.fireWith
  			// deferred.resolveWith = list.fireWith
  			// deferred.rejectWith = list.fireWith
  			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
  		} );

  		// Make the deferred a promise
  		promise.promise( deferred );

  		// Call given func if any
  		if ( func ) {
  			func.call( deferred, deferred );
  		}

  		// All done!
  		return deferred;
  	},

  	// Deferred helper
  	when: function( singleValue ) {
  		var

  			// count of uncompleted subordinates
  			remaining = arguments.length,

  			// count of unprocessed arguments
  			i = remaining,

  			// subordinate fulfillment data
  			resolveContexts = Array( i ),
  			resolveValues = slice.call( arguments ),

  			// the master Deferred
  			master = jQuery.Deferred(),

  			// subordinate callback factory
  			updateFunc = function( i ) {
  				return function( value ) {
  					resolveContexts[ i ] = this;
  					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
  					if ( !( --remaining ) ) {
  						master.resolveWith( resolveContexts, resolveValues );
  					}
  				};
  			};

  		// Single- and empty arguments are adopted like Promise.resolve
  		if ( remaining <= 1 ) {
  			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
  				!remaining );

  			// Use .then() to unwrap secondary thenables (cf. gh-3000)
  			if ( master.state() === "pending" ||
  				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

  				return master.then();
  			}
  		}

  		// Multiple arguments are aggregated like Promise.all array elements
  		while ( i-- ) {
  			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
  		}

  		return master.promise();
  	}
  } );


  // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function( error, stack ) {

  	// Support: IE 8 - 9 only
  	// Console exists when dev tools are open, which can happen at any time
  	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
  		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
  	}
  };




  jQuery.readyException = function( error ) {
  	window.setTimeout( function() {
  		throw error;
  	} );
  };




  // The deferred used on DOM ready
  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function( fn ) {

  	readyList
  		.then( fn )

  		// Wrap jQuery.readyException in a function so that the lookup
  		// happens at the time of error handling instead of callback
  		// registration.
  		.catch( function( error ) {
  			jQuery.readyException( error );
  		} );

  	return this;
  };

  jQuery.extend( {

  	// Is the DOM ready to be used? Set to true once it occurs.
  	isReady: false,

  	// A counter to track how many items to wait for before
  	// the ready event fires. See #6781
  	readyWait: 1,

  	// Handle when the DOM is ready
  	ready: function( wait ) {

  		// Abort if there are pending holds or we're already ready
  		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
  			return;
  		}

  		// Remember that the DOM is ready
  		jQuery.isReady = true;

  		// If a normal DOM Ready event fired, decrement, and wait if need be
  		if ( wait !== true && --jQuery.readyWait > 0 ) {
  			return;
  		}

  		// If there are functions bound, to execute
  		readyList.resolveWith( document, [ jQuery ] );
  	}
  } );

  jQuery.ready.then = readyList.then;

  // The ready event handler and self cleanup method
  function completed() {
  	document.removeEventListener( "DOMContentLoaded", completed );
  	window.removeEventListener( "load", completed );
  	jQuery.ready();
  }

  // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon
  if ( document.readyState === "complete" ||
  	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

  	// Handle it asynchronously to allow scripts the opportunity to delay ready
  	window.setTimeout( jQuery.ready );

  } else {

  	// Use the handy event callback
  	document.addEventListener( "DOMContentLoaded", completed );

  	// A fallback to window.onload, that will always work
  	window.addEventListener( "load", completed );
  }




  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  	var i = 0,
  		len = elems.length,
  		bulk = key == null;

  	// Sets many values
  	if ( toType( key ) === "object" ) {
  		chainable = true;
  		for ( i in key ) {
  			access( elems, fn, i, key[ i ], true, emptyGet, raw );
  		}

  	// Sets one value
  	} else if ( value !== undefined ) {
  		chainable = true;

  		if ( !isFunction( value ) ) {
  			raw = true;
  		}

  		if ( bulk ) {

  			// Bulk operations run against the entire set
  			if ( raw ) {
  				fn.call( elems, value );
  				fn = null;

  			// ...except when executing function values
  			} else {
  				bulk = fn;
  				fn = function( elem, key, value ) {
  					return bulk.call( jQuery( elem ), value );
  				};
  			}
  		}

  		if ( fn ) {
  			for ( ; i < len; i++ ) {
  				fn(
  					elems[ i ], key, raw ?
  					value :
  					value.call( elems[ i ], i, fn( elems[ i ], key ) )
  				);
  			}
  		}
  	}

  	if ( chainable ) {
  		return elems;
  	}

  	// Gets
  	if ( bulk ) {
  		return fn.call( elems );
  	}

  	return len ? fn( elems[ 0 ], key ) : emptyGet;
  };


  // Matches dashed string for camelizing
  var rmsPrefix = /^-ms-/,
  	rdashAlpha = /-([a-z])/g;

  // Used by camelCase as callback to replace()
  function fcamelCase( all, letter ) {
  	return letter.toUpperCase();
  }

  // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)
  function camelCase( string ) {
  	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  }
  var acceptData = function( owner ) {

  	// Accepts only:
  	//  - Node
  	//    - Node.ELEMENT_NODE
  	//    - Node.DOCUMENT_NODE
  	//  - Object
  	//    - Any
  	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
  };




  function Data() {
  	this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;

  Data.prototype = {

  	cache: function( owner ) {

  		// Check if the owner object already has a cache
  		var value = owner[ this.expando ];

  		// If not, create one
  		if ( !value ) {
  			value = {};

  			// We can accept data for non-element nodes in modern browsers,
  			// but we should not, see #8335.
  			// Always return an empty object.
  			if ( acceptData( owner ) ) {

  				// If it is a node unlikely to be stringify-ed or looped over
  				// use plain assignment
  				if ( owner.nodeType ) {
  					owner[ this.expando ] = value;

  				// Otherwise secure it in a non-enumerable property
  				// configurable must be true to allow the property to be
  				// deleted when data is removed
  				} else {
  					Object.defineProperty( owner, this.expando, {
  						value: value,
  						configurable: true
  					} );
  				}
  			}
  		}

  		return value;
  	},
  	set: function( owner, data, value ) {
  		var prop,
  			cache = this.cache( owner );

  		// Handle: [ owner, key, value ] args
  		// Always use camelCase key (gh-2257)
  		if ( typeof data === "string" ) {
  			cache[ camelCase( data ) ] = value;

  		// Handle: [ owner, { properties } ] args
  		} else {

  			// Copy the properties one-by-one to the cache object
  			for ( prop in data ) {
  				cache[ camelCase( prop ) ] = data[ prop ];
  			}
  		}
  		return cache;
  	},
  	get: function( owner, key ) {
  		return key === undefined ?
  			this.cache( owner ) :

  			// Always use camelCase key (gh-2257)
  			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
  	},
  	access: function( owner, key, value ) {

  		// In cases where either:
  		//
  		//   1. No key was specified
  		//   2. A string key was specified, but no value provided
  		//
  		// Take the "read" path and allow the get method to determine
  		// which value to return, respectively either:
  		//
  		//   1. The entire cache object
  		//   2. The data stored at the key
  		//
  		if ( key === undefined ||
  				( ( key && typeof key === "string" ) && value === undefined ) ) {

  			return this.get( owner, key );
  		}

  		// When the key is not a string, or both a key and value
  		// are specified, set or extend (existing objects) with either:
  		//
  		//   1. An object of properties
  		//   2. A key and value
  		//
  		this.set( owner, key, value );

  		// Since the "set" path can have two possible entry points
  		// return the expected data based on which path was taken[*]
  		return value !== undefined ? value : key;
  	},
  	remove: function( owner, key ) {
  		var i,
  			cache = owner[ this.expando ];

  		if ( cache === undefined ) {
  			return;
  		}

  		if ( key !== undefined ) {

  			// Support array or space separated string of keys
  			if ( Array.isArray( key ) ) {

  				// If key is an array of keys...
  				// We always set camelCase keys, so remove that.
  				key = key.map( camelCase );
  			} else {
  				key = camelCase( key );

  				// If a key with the spaces exists, use it.
  				// Otherwise, create an array by matching non-whitespace
  				key = key in cache ?
  					[ key ] :
  					( key.match( rnothtmlwhite ) || [] );
  			}

  			i = key.length;

  			while ( i-- ) {
  				delete cache[ key[ i ] ];
  			}
  		}

  		// Remove the expando if there's no more data
  		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

  			// Support: Chrome <=35 - 45
  			// Webkit & Blink performance suffers when deleting properties
  			// from DOM nodes, so set to undefined instead
  			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
  			if ( owner.nodeType ) {
  				owner[ this.expando ] = undefined;
  			} else {
  				delete owner[ this.expando ];
  			}
  		}
  	},
  	hasData: function( owner ) {
  		var cache = owner[ this.expando ];
  		return cache !== undefined && !jQuery.isEmptyObject( cache );
  	}
  };
  var dataPriv = new Data();

  var dataUser = new Data();



  //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  	rmultiDash = /[A-Z]/g;

  function getData( data ) {
  	if ( data === "true" ) {
  		return true;
  	}

  	if ( data === "false" ) {
  		return false;
  	}

  	if ( data === "null" ) {
  		return null;
  	}

  	// Only convert to a number if it doesn't change the string
  	if ( data === +data + "" ) {
  		return +data;
  	}

  	if ( rbrace.test( data ) ) {
  		return JSON.parse( data );
  	}

  	return data;
  }

  function dataAttr( elem, key, data ) {
  	var name;

  	// If nothing was found internally, try to fetch any
  	// data from the HTML5 data-* attribute
  	if ( data === undefined && elem.nodeType === 1 ) {
  		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
  		data = elem.getAttribute( name );

  		if ( typeof data === "string" ) {
  			try {
  				data = getData( data );
  			} catch ( e ) {}

  			// Make sure we set the data so it isn't changed later
  			dataUser.set( elem, key, data );
  		} else {
  			data = undefined;
  		}
  	}
  	return data;
  }

  jQuery.extend( {
  	hasData: function( elem ) {
  		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
  	},

  	data: function( elem, name, data ) {
  		return dataUser.access( elem, name, data );
  	},

  	removeData: function( elem, name ) {
  		dataUser.remove( elem, name );
  	},

  	// TODO: Now that all calls to _data and _removeData have been replaced
  	// with direct calls to dataPriv methods, these can be deprecated.
  	_data: function( elem, name, data ) {
  		return dataPriv.access( elem, name, data );
  	},

  	_removeData: function( elem, name ) {
  		dataPriv.remove( elem, name );
  	}
  } );

  jQuery.fn.extend( {
  	data: function( key, value ) {
  		var i, name, data,
  			elem = this[ 0 ],
  			attrs = elem && elem.attributes;

  		// Gets all values
  		if ( key === undefined ) {
  			if ( this.length ) {
  				data = dataUser.get( elem );

  				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
  					i = attrs.length;
  					while ( i-- ) {

  						// Support: IE 11 only
  						// The attrs elements can be null (#14894)
  						if ( attrs[ i ] ) {
  							name = attrs[ i ].name;
  							if ( name.indexOf( "data-" ) === 0 ) {
  								name = camelCase( name.slice( 5 ) );
  								dataAttr( elem, name, data[ name ] );
  							}
  						}
  					}
  					dataPriv.set( elem, "hasDataAttrs", true );
  				}
  			}

  			return data;
  		}

  		// Sets multiple values
  		if ( typeof key === "object" ) {
  			return this.each( function() {
  				dataUser.set( this, key );
  			} );
  		}

  		return access( this, function( value ) {
  			var data;

  			// The calling jQuery object (element matches) is not empty
  			// (and therefore has an element appears at this[ 0 ]) and the
  			// `value` parameter was not undefined. An empty jQuery object
  			// will result in `undefined` for elem = this[ 0 ] which will
  			// throw an exception if an attempt to read a data cache is made.
  			if ( elem && value === undefined ) {

  				// Attempt to get data from the cache
  				// The key will always be camelCased in Data
  				data = dataUser.get( elem, key );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// Attempt to "discover" the data in
  				// HTML5 custom data-* attrs
  				data = dataAttr( elem, key );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// We tried really hard, but the data doesn't exist.
  				return;
  			}

  			// Set the data...
  			this.each( function() {

  				// We always store the camelCased key
  				dataUser.set( this, key, value );
  			} );
  		}, null, value, arguments.length > 1, null, true );
  	},

  	removeData: function( key ) {
  		return this.each( function() {
  			dataUser.remove( this, key );
  		} );
  	}
  } );


  jQuery.extend( {
  	queue: function( elem, type, data ) {
  		var queue;

  		if ( elem ) {
  			type = ( type || "fx" ) + "queue";
  			queue = dataPriv.get( elem, type );

  			// Speed up dequeue by getting out quickly if this is just a lookup
  			if ( data ) {
  				if ( !queue || Array.isArray( data ) ) {
  					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
  				} else {
  					queue.push( data );
  				}
  			}
  			return queue || [];
  		}
  	},

  	dequeue: function( elem, type ) {
  		type = type || "fx";

  		var queue = jQuery.queue( elem, type ),
  			startLength = queue.length,
  			fn = queue.shift(),
  			hooks = jQuery._queueHooks( elem, type ),
  			next = function() {
  				jQuery.dequeue( elem, type );
  			};

  		// If the fx queue is dequeued, always remove the progress sentinel
  		if ( fn === "inprogress" ) {
  			fn = queue.shift();
  			startLength--;
  		}

  		if ( fn ) {

  			// Add a progress sentinel to prevent the fx queue from being
  			// automatically dequeued
  			if ( type === "fx" ) {
  				queue.unshift( "inprogress" );
  			}

  			// Clear up the last queue stop function
  			delete hooks.stop;
  			fn.call( elem, next, hooks );
  		}

  		if ( !startLength && hooks ) {
  			hooks.empty.fire();
  		}
  	},

  	// Not public - generate a queueHooks object, or return the current one
  	_queueHooks: function( elem, type ) {
  		var key = type + "queueHooks";
  		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
  			empty: jQuery.Callbacks( "once memory" ).add( function() {
  				dataPriv.remove( elem, [ type + "queue", key ] );
  			} )
  		} );
  	}
  } );

  jQuery.fn.extend( {
  	queue: function( type, data ) {
  		var setter = 2;

  		if ( typeof type !== "string" ) {
  			data = type;
  			type = "fx";
  			setter--;
  		}

  		if ( arguments.length < setter ) {
  			return jQuery.queue( this[ 0 ], type );
  		}

  		return data === undefined ?
  			this :
  			this.each( function() {
  				var queue = jQuery.queue( this, type, data );

  				// Ensure a hooks for this queue
  				jQuery._queueHooks( this, type );

  				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
  					jQuery.dequeue( this, type );
  				}
  			} );
  	},
  	dequeue: function( type ) {
  		return this.each( function() {
  			jQuery.dequeue( this, type );
  		} );
  	},
  	clearQueue: function( type ) {
  		return this.queue( type || "fx", [] );
  	},

  	// Get a promise resolved when queues of a certain type
  	// are emptied (fx is the type by default)
  	promise: function( type, obj ) {
  		var tmp,
  			count = 1,
  			defer = jQuery.Deferred(),
  			elements = this,
  			i = this.length,
  			resolve = function() {
  				if ( !( --count ) ) {
  					defer.resolveWith( elements, [ elements ] );
  				}
  			};

  		if ( typeof type !== "string" ) {
  			obj = type;
  			type = undefined;
  		}
  		type = type || "fx";

  		while ( i-- ) {
  			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
  			if ( tmp && tmp.empty ) {
  				count++;
  				tmp.empty.add( resolve );
  			}
  		}
  		resolve();
  		return defer.promise( obj );
  	}
  } );
  var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

  var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


  var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

  var documentElement = document.documentElement;



  	var isAttached = function( elem ) {
  			return jQuery.contains( elem.ownerDocument, elem );
  		},
  		composed = { composed: true };

  	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  	// Check attachment across shadow DOM boundaries when possible (gh-3504)
  	// Support: iOS 10.0-10.2 only
  	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  	// leading to errors. We need to check for `getRootNode`.
  	if ( documentElement.getRootNode ) {
  		isAttached = function( elem ) {
  			return jQuery.contains( elem.ownerDocument, elem ) ||
  				elem.getRootNode( composed ) === elem.ownerDocument;
  		};
  	}
  var isHiddenWithinTree = function( elem, el ) {

  		// isHiddenWithinTree might be called from jQuery#filter function;
  		// in that case, element will be second argument
  		elem = el || elem;

  		// Inline style trumps all
  		return elem.style.display === "none" ||
  			elem.style.display === "" &&

  			// Otherwise, check computed style
  			// Support: Firefox <=43 - 45
  			// Disconnected elements can have computed display: none, so first confirm that elem is
  			// in the document.
  			isAttached( elem ) &&

  			jQuery.css( elem, "display" ) === "none";
  	};

  var swap = function( elem, options, callback, args ) {
  	var ret, name,
  		old = {};

  	// Remember the old values, and insert the new ones
  	for ( name in options ) {
  		old[ name ] = elem.style[ name ];
  		elem.style[ name ] = options[ name ];
  	}

  	ret = callback.apply( elem, args || [] );

  	// Revert the old values
  	for ( name in options ) {
  		elem.style[ name ] = old[ name ];
  	}

  	return ret;
  };




  function adjustCSS( elem, prop, valueParts, tween ) {
  	var adjusted, scale,
  		maxIterations = 20,
  		currentValue = tween ?
  			function() {
  				return tween.cur();
  			} :
  			function() {
  				return jQuery.css( elem, prop, "" );
  			},
  		initial = currentValue(),
  		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

  		// Starting value computation is required for potential unit mismatches
  		initialInUnit = elem.nodeType &&
  			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
  			rcssNum.exec( jQuery.css( elem, prop ) );

  	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

  		// Support: Firefox <=54
  		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
  		initial = initial / 2;

  		// Trust units reported by jQuery.css
  		unit = unit || initialInUnit[ 3 ];

  		// Iteratively approximate from a nonzero starting point
  		initialInUnit = +initial || 1;

  		while ( maxIterations-- ) {

  			// Evaluate and update our best guess (doubling guesses that zero out).
  			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
  			jQuery.style( elem, prop, initialInUnit + unit );
  			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
  				maxIterations = 0;
  			}
  			initialInUnit = initialInUnit / scale;

  		}

  		initialInUnit = initialInUnit * 2;
  		jQuery.style( elem, prop, initialInUnit + unit );

  		// Make sure we update the tween properties later on
  		valueParts = valueParts || [];
  	}

  	if ( valueParts ) {
  		initialInUnit = +initialInUnit || +initial || 0;

  		// Apply relative offset (+=/-=) if specified
  		adjusted = valueParts[ 1 ] ?
  			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
  			+valueParts[ 2 ];
  		if ( tween ) {
  			tween.unit = unit;
  			tween.start = initialInUnit;
  			tween.end = adjusted;
  		}
  	}
  	return adjusted;
  }


  var defaultDisplayMap = {};

  function getDefaultDisplay( elem ) {
  	var temp,
  		doc = elem.ownerDocument,
  		nodeName = elem.nodeName,
  		display = defaultDisplayMap[ nodeName ];

  	if ( display ) {
  		return display;
  	}

  	temp = doc.body.appendChild( doc.createElement( nodeName ) );
  	display = jQuery.css( temp, "display" );

  	temp.parentNode.removeChild( temp );

  	if ( display === "none" ) {
  		display = "block";
  	}
  	defaultDisplayMap[ nodeName ] = display;

  	return display;
  }

  function showHide( elements, show ) {
  	var display, elem,
  		values = [],
  		index = 0,
  		length = elements.length;

  	// Determine new display value for elements that need to change
  	for ( ; index < length; index++ ) {
  		elem = elements[ index ];
  		if ( !elem.style ) {
  			continue;
  		}

  		display = elem.style.display;
  		if ( show ) {

  			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
  			// check is required in this first loop unless we have a nonempty display value (either
  			// inline or about-to-be-restored)
  			if ( display === "none" ) {
  				values[ index ] = dataPriv.get( elem, "display" ) || null;
  				if ( !values[ index ] ) {
  					elem.style.display = "";
  				}
  			}
  			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
  				values[ index ] = getDefaultDisplay( elem );
  			}
  		} else {
  			if ( display !== "none" ) {
  				values[ index ] = "none";

  				// Remember what we're overwriting
  				dataPriv.set( elem, "display", display );
  			}
  		}
  	}

  	// Set the display of the elements in a second loop to avoid constant reflow
  	for ( index = 0; index < length; index++ ) {
  		if ( values[ index ] != null ) {
  			elements[ index ].style.display = values[ index ];
  		}
  	}

  	return elements;
  }

  jQuery.fn.extend( {
  	show: function() {
  		return showHide( this, true );
  	},
  	hide: function() {
  		return showHide( this );
  	},
  	toggle: function( state ) {
  		if ( typeof state === "boolean" ) {
  			return state ? this.show() : this.hide();
  		}

  		return this.each( function() {
  			if ( isHiddenWithinTree( this ) ) {
  				jQuery( this ).show();
  			} else {
  				jQuery( this ).hide();
  			}
  		} );
  	}
  } );
  var rcheckableType = ( /^(?:checkbox|radio)$/i );

  var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

  var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



  // We have to close these tags to support XHTML (#13200)
  var wrapMap = {

  	// Support: IE <=9 only
  	option: [ 1, "<select multiple='multiple'>", "</select>" ],

  	// XHTML parsers do not magically insert elements in the
  	// same way that tag soup parsers do. So we cannot shorten
  	// this by omitting <tbody> or other required elements.
  	thead: [ 1, "<table>", "</table>" ],
  	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
  	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
  	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

  	_default: [ 0, "", "" ]
  };

  // Support: IE <=9 only
  wrapMap.optgroup = wrapMap.option;

  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;


  function getAll( context, tag ) {

  	// Support: IE <=9 - 11 only
  	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
  	var ret;

  	if ( typeof context.getElementsByTagName !== "undefined" ) {
  		ret = context.getElementsByTagName( tag || "*" );

  	} else if ( typeof context.querySelectorAll !== "undefined" ) {
  		ret = context.querySelectorAll( tag || "*" );

  	} else {
  		ret = [];
  	}

  	if ( tag === undefined || tag && nodeName( context, tag ) ) {
  		return jQuery.merge( [ context ], ret );
  	}

  	return ret;
  }


  // Mark scripts as having already been evaluated
  function setGlobalEval( elems, refElements ) {
  	var i = 0,
  		l = elems.length;

  	for ( ; i < l; i++ ) {
  		dataPriv.set(
  			elems[ i ],
  			"globalEval",
  			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
  		);
  	}
  }


  var rhtml = /<|&#?\w+;/;

  function buildFragment( elems, context, scripts, selection, ignored ) {
  	var elem, tmp, tag, wrap, attached, j,
  		fragment = context.createDocumentFragment(),
  		nodes = [],
  		i = 0,
  		l = elems.length;

  	for ( ; i < l; i++ ) {
  		elem = elems[ i ];

  		if ( elem || elem === 0 ) {

  			// Add nodes directly
  			if ( toType( elem ) === "object" ) {

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// push.apply(_, arraylike) throws on ancient WebKit
  				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

  			// Convert non-html into a text node
  			} else if ( !rhtml.test( elem ) ) {
  				nodes.push( context.createTextNode( elem ) );

  			// Convert html into DOM nodes
  			} else {
  				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

  				// Deserialize a standard representation
  				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
  				wrap = wrapMap[ tag ] || wrapMap._default;
  				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

  				// Descend through wrappers to the right content
  				j = wrap[ 0 ];
  				while ( j-- ) {
  					tmp = tmp.lastChild;
  				}

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// push.apply(_, arraylike) throws on ancient WebKit
  				jQuery.merge( nodes, tmp.childNodes );

  				// Remember the top-level container
  				tmp = fragment.firstChild;

  				// Ensure the created nodes are orphaned (#12392)
  				tmp.textContent = "";
  			}
  		}
  	}

  	// Remove wrapper from fragment
  	fragment.textContent = "";

  	i = 0;
  	while ( ( elem = nodes[ i++ ] ) ) {

  		// Skip elements already in the context collection (trac-4087)
  		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
  			if ( ignored ) {
  				ignored.push( elem );
  			}
  			continue;
  		}

  		attached = isAttached( elem );

  		// Append to fragment
  		tmp = getAll( fragment.appendChild( elem ), "script" );

  		// Preserve script evaluation history
  		if ( attached ) {
  			setGlobalEval( tmp );
  		}

  		// Capture executables
  		if ( scripts ) {
  			j = 0;
  			while ( ( elem = tmp[ j++ ] ) ) {
  				if ( rscriptType.test( elem.type || "" ) ) {
  					scripts.push( elem );
  				}
  			}
  		}
  	}

  	return fragment;
  }


  ( function() {
  	var fragment = document.createDocumentFragment(),
  		div = fragment.appendChild( document.createElement( "div" ) ),
  		input = document.createElement( "input" );

  	// Support: Android 4.0 - 4.3 only
  	// Check state lost if the name is set (#11217)
  	// Support: Windows Web Apps (WWA)
  	// `name` and `type` must use .setAttribute for WWA (#14901)
  	input.setAttribute( "type", "radio" );
  	input.setAttribute( "checked", "checked" );
  	input.setAttribute( "name", "t" );

  	div.appendChild( input );

  	// Support: Android <=4.1 only
  	// Older WebKit doesn't clone checked state correctly in fragments
  	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  	// Support: IE <=11 only
  	// Make sure textarea (and checkbox) defaultValue is properly cloned
  	div.innerHTML = "<textarea>x</textarea>";
  	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
  } )();


  var
  	rkeyEvent = /^key/,
  	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
  	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
  	return true;
  }

  function returnFalse() {
  	return false;
  }

  // Support: IE <=9 - 11+
  // focus() and blur() are asynchronous, except when they are no-op.
  // So expect focus to be synchronous when the element is already active,
  // and blur to be synchronous when the element is not already active.
  // (focus and blur are always synchronous in other supported browsers,
  // this just defines when we can count on it).
  function expectSync( elem, type ) {
  	return ( elem === safeActiveElement() ) === ( type === "focus" );
  }

  // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393
  function safeActiveElement() {
  	try {
  		return document.activeElement;
  	} catch ( err ) { }
  }

  function on( elem, types, selector, data, fn, one ) {
  	var origFn, type;

  	// Types can be a map of types/handlers
  	if ( typeof types === "object" ) {

  		// ( types-Object, selector, data )
  		if ( typeof selector !== "string" ) {

  			// ( types-Object, data )
  			data = data || selector;
  			selector = undefined;
  		}
  		for ( type in types ) {
  			on( elem, type, selector, data, types[ type ], one );
  		}
  		return elem;
  	}

  	if ( data == null && fn == null ) {

  		// ( types, fn )
  		fn = selector;
  		data = selector = undefined;
  	} else if ( fn == null ) {
  		if ( typeof selector === "string" ) {

  			// ( types, selector, fn )
  			fn = data;
  			data = undefined;
  		} else {

  			// ( types, data, fn )
  			fn = data;
  			data = selector;
  			selector = undefined;
  		}
  	}
  	if ( fn === false ) {
  		fn = returnFalse;
  	} else if ( !fn ) {
  		return elem;
  	}

  	if ( one === 1 ) {
  		origFn = fn;
  		fn = function( event ) {

  			// Can use an empty set, since event contains the info
  			jQuery().off( event );
  			return origFn.apply( this, arguments );
  		};

  		// Use same guid so caller can remove using origFn
  		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
  	}
  	return elem.each( function() {
  		jQuery.event.add( this, types, fn, data, selector );
  	} );
  }

  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {

  	global: {},

  	add: function( elem, types, handler, data, selector ) {

  		var handleObjIn, eventHandle, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = dataPriv.get( elem );

  		// Don't attach events to noData or text/comment nodes (but allow plain objects)
  		if ( !elemData ) {
  			return;
  		}

  		// Caller can pass in an object of custom data in lieu of the handler
  		if ( handler.handler ) {
  			handleObjIn = handler;
  			handler = handleObjIn.handler;
  			selector = handleObjIn.selector;
  		}

  		// Ensure that invalid selectors throw exceptions at attach time
  		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
  		if ( selector ) {
  			jQuery.find.matchesSelector( documentElement, selector );
  		}

  		// Make sure that the handler has a unique ID, used to find/remove it later
  		if ( !handler.guid ) {
  			handler.guid = jQuery.guid++;
  		}

  		// Init the element's event structure and main handler, if this is the first
  		if ( !( events = elemData.events ) ) {
  			events = elemData.events = {};
  		}
  		if ( !( eventHandle = elemData.handle ) ) {
  			eventHandle = elemData.handle = function( e ) {

  				// Discard the second event of a jQuery.event.trigger() and
  				// when an event is called after a page has unloaded
  				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
  					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
  			};
  		}

  		// Handle multiple events separated by a space
  		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[ t ] ) || [];
  			type = origType = tmp[ 1 ];
  			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  			// There *must* be a type, no attaching namespace-only handlers
  			if ( !type ) {
  				continue;
  			}

  			// If event changes its type, use the special event handlers for the changed type
  			special = jQuery.event.special[ type ] || {};

  			// If selector defined, determine special event api type, otherwise given type
  			type = ( selector ? special.delegateType : special.bindType ) || type;

  			// Update special based on newly reset type
  			special = jQuery.event.special[ type ] || {};

  			// handleObj is passed to all event handlers
  			handleObj = jQuery.extend( {
  				type: type,
  				origType: origType,
  				data: data,
  				handler: handler,
  				guid: handler.guid,
  				selector: selector,
  				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
  				namespace: namespaces.join( "." )
  			}, handleObjIn );

  			// Init the event handler queue if we're the first
  			if ( !( handlers = events[ type ] ) ) {
  				handlers = events[ type ] = [];
  				handlers.delegateCount = 0;

  				// Only use addEventListener if the special events handler returns false
  				if ( !special.setup ||
  					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

  					if ( elem.addEventListener ) {
  						elem.addEventListener( type, eventHandle );
  					}
  				}
  			}

  			if ( special.add ) {
  				special.add.call( elem, handleObj );

  				if ( !handleObj.handler.guid ) {
  					handleObj.handler.guid = handler.guid;
  				}
  			}

  			// Add to the element's handler list, delegates in front
  			if ( selector ) {
  				handlers.splice( handlers.delegateCount++, 0, handleObj );
  			} else {
  				handlers.push( handleObj );
  			}

  			// Keep track of which events have ever been used, for event optimization
  			jQuery.event.global[ type ] = true;
  		}

  	},

  	// Detach an event or set of events from an element
  	remove: function( elem, types, handler, selector, mappedTypes ) {

  		var j, origCount, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

  		if ( !elemData || !( events = elemData.events ) ) {
  			return;
  		}

  		// Once for each type.namespace in types; type may be omitted
  		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[ t ] ) || [];
  			type = origType = tmp[ 1 ];
  			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  			// Unbind all events (on this namespace, if provided) for the element
  			if ( !type ) {
  				for ( type in events ) {
  					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
  				}
  				continue;
  			}

  			special = jQuery.event.special[ type ] || {};
  			type = ( selector ? special.delegateType : special.bindType ) || type;
  			handlers = events[ type ] || [];
  			tmp = tmp[ 2 ] &&
  				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

  			// Remove matching events
  			origCount = j = handlers.length;
  			while ( j-- ) {
  				handleObj = handlers[ j ];

  				if ( ( mappedTypes || origType === handleObj.origType ) &&
  					( !handler || handler.guid === handleObj.guid ) &&
  					( !tmp || tmp.test( handleObj.namespace ) ) &&
  					( !selector || selector === handleObj.selector ||
  						selector === "**" && handleObj.selector ) ) {
  					handlers.splice( j, 1 );

  					if ( handleObj.selector ) {
  						handlers.delegateCount--;
  					}
  					if ( special.remove ) {
  						special.remove.call( elem, handleObj );
  					}
  				}
  			}

  			// Remove generic event handler if we removed something and no more handlers exist
  			// (avoids potential for endless recursion during removal of special event handlers)
  			if ( origCount && !handlers.length ) {
  				if ( !special.teardown ||
  					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

  					jQuery.removeEvent( elem, type, elemData.handle );
  				}

  				delete events[ type ];
  			}
  		}

  		// Remove data and the expando if it's no longer used
  		if ( jQuery.isEmptyObject( events ) ) {
  			dataPriv.remove( elem, "handle events" );
  		}
  	},

  	dispatch: function( nativeEvent ) {

  		// Make a writable jQuery.Event from the native event object
  		var event = jQuery.event.fix( nativeEvent );

  		var i, j, ret, matched, handleObj, handlerQueue,
  			args = new Array( arguments.length ),
  			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
  			special = jQuery.event.special[ event.type ] || {};

  		// Use the fix-ed jQuery.Event rather than the (read-only) native event
  		args[ 0 ] = event;

  		for ( i = 1; i < arguments.length; i++ ) {
  			args[ i ] = arguments[ i ];
  		}

  		event.delegateTarget = this;

  		// Call the preDispatch hook for the mapped type, and let it bail if desired
  		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
  			return;
  		}

  		// Determine handlers
  		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

  		// Run delegates first; they may want to stop propagation beneath us
  		i = 0;
  		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
  			event.currentTarget = matched.elem;

  			j = 0;
  			while ( ( handleObj = matched.handlers[ j++ ] ) &&
  				!event.isImmediatePropagationStopped() ) {

  				// If the event is namespaced, then each handler is only invoked if it is
  				// specially universal or its namespaces are a superset of the event's.
  				if ( !event.rnamespace || handleObj.namespace === false ||
  					event.rnamespace.test( handleObj.namespace ) ) {

  					event.handleObj = handleObj;
  					event.data = handleObj.data;

  					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
  						handleObj.handler ).apply( matched.elem, args );

  					if ( ret !== undefined ) {
  						if ( ( event.result = ret ) === false ) {
  							event.preventDefault();
  							event.stopPropagation();
  						}
  					}
  				}
  			}
  		}

  		// Call the postDispatch hook for the mapped type
  		if ( special.postDispatch ) {
  			special.postDispatch.call( this, event );
  		}

  		return event.result;
  	},

  	handlers: function( event, handlers ) {
  		var i, handleObj, sel, matchedHandlers, matchedSelectors,
  			handlerQueue = [],
  			delegateCount = handlers.delegateCount,
  			cur = event.target;

  		// Find delegate handlers
  		if ( delegateCount &&

  			// Support: IE <=9
  			// Black-hole SVG <use> instance trees (trac-13180)
  			cur.nodeType &&

  			// Support: Firefox <=42
  			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
  			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
  			// Support: IE 11 only
  			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
  			!( event.type === "click" && event.button >= 1 ) ) {

  			for ( ; cur !== this; cur = cur.parentNode || this ) {

  				// Don't check non-elements (#13208)
  				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
  				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
  					matchedHandlers = [];
  					matchedSelectors = {};
  					for ( i = 0; i < delegateCount; i++ ) {
  						handleObj = handlers[ i ];

  						// Don't conflict with Object.prototype properties (#13203)
  						sel = handleObj.selector + " ";

  						if ( matchedSelectors[ sel ] === undefined ) {
  							matchedSelectors[ sel ] = handleObj.needsContext ?
  								jQuery( sel, this ).index( cur ) > -1 :
  								jQuery.find( sel, this, null, [ cur ] ).length;
  						}
  						if ( matchedSelectors[ sel ] ) {
  							matchedHandlers.push( handleObj );
  						}
  					}
  					if ( matchedHandlers.length ) {
  						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
  					}
  				}
  			}
  		}

  		// Add the remaining (directly-bound) handlers
  		cur = this;
  		if ( delegateCount < handlers.length ) {
  			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
  		}

  		return handlerQueue;
  	},

  	addProp: function( name, hook ) {
  		Object.defineProperty( jQuery.Event.prototype, name, {
  			enumerable: true,
  			configurable: true,

  			get: isFunction( hook ) ?
  				function() {
  					if ( this.originalEvent ) {
  							return hook( this.originalEvent );
  					}
  				} :
  				function() {
  					if ( this.originalEvent ) {
  							return this.originalEvent[ name ];
  					}
  				},

  			set: function( value ) {
  				Object.defineProperty( this, name, {
  					enumerable: true,
  					configurable: true,
  					writable: true,
  					value: value
  				} );
  			}
  		} );
  	},

  	fix: function( originalEvent ) {
  		return originalEvent[ jQuery.expando ] ?
  			originalEvent :
  			new jQuery.Event( originalEvent );
  	},

  	special: {
  		load: {

  			// Prevent triggered image.load events from bubbling to window.load
  			noBubble: true
  		},
  		click: {

  			// Utilize native event to ensure correct state for checkable inputs
  			setup: function( data ) {

  				// For mutual compressibility with _default, replace `this` access with a local var.
  				// `|| data` is dead code meant only to preserve the variable through minification.
  				var el = this || data;

  				// Claim the first handler
  				if ( rcheckableType.test( el.type ) &&
  					el.click && nodeName( el, "input" ) ) {

  					// dataPriv.set( el, "click", ... )
  					leverageNative( el, "click", returnTrue );
  				}

  				// Return false to allow normal processing in the caller
  				return false;
  			},
  			trigger: function( data ) {

  				// For mutual compressibility with _default, replace `this` access with a local var.
  				// `|| data` is dead code meant only to preserve the variable through minification.
  				var el = this || data;

  				// Force setup before triggering a click
  				if ( rcheckableType.test( el.type ) &&
  					el.click && nodeName( el, "input" ) ) {

  					leverageNative( el, "click" );
  				}

  				// Return non-false to allow normal event-path propagation
  				return true;
  			},

  			// For cross-browser consistency, suppress native .click() on links
  			// Also prevent it if we're currently inside a leveraged native-event stack
  			_default: function( event ) {
  				var target = event.target;
  				return rcheckableType.test( target.type ) &&
  					target.click && nodeName( target, "input" ) &&
  					dataPriv.get( target, "click" ) ||
  					nodeName( target, "a" );
  			}
  		},

  		beforeunload: {
  			postDispatch: function( event ) {

  				// Support: Firefox 20+
  				// Firefox doesn't alert if the returnValue field is not set.
  				if ( event.result !== undefined && event.originalEvent ) {
  					event.originalEvent.returnValue = event.result;
  				}
  			}
  		}
  	}
  };

  // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.
  function leverageNative( el, type, expectSync ) {

  	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
  	if ( !expectSync ) {
  		if ( dataPriv.get( el, type ) === undefined ) {
  			jQuery.event.add( el, type, returnTrue );
  		}
  		return;
  	}

  	// Register the controller as a special universal handler for all event namespaces
  	dataPriv.set( el, type, false );
  	jQuery.event.add( el, type, {
  		namespace: false,
  		handler: function( event ) {
  			var notAsync, result,
  				saved = dataPriv.get( this, type );

  			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

  				// Interrupt processing of the outer synthetic .trigger()ed event
  				// Saved data should be false in such cases, but might be a leftover capture object
  				// from an async native handler (gh-4350)
  				if ( !saved.length ) {

  					// Store arguments for use when handling the inner native event
  					// There will always be at least one argument (an event object), so this array
  					// will not be confused with a leftover capture object.
  					saved = slice.call( arguments );
  					dataPriv.set( this, type, saved );

  					// Trigger the native event and capture its result
  					// Support: IE <=9 - 11+
  					// focus() and blur() are asynchronous
  					notAsync = expectSync( this, type );
  					this[ type ]();
  					result = dataPriv.get( this, type );
  					if ( saved !== result || notAsync ) {
  						dataPriv.set( this, type, false );
  					} else {
  						result = {};
  					}
  					if ( saved !== result ) {

  						// Cancel the outer synthetic event
  						event.stopImmediatePropagation();
  						event.preventDefault();
  						return result.value;
  					}

  				// If this is an inner synthetic event for an event with a bubbling surrogate
  				// (focus or blur), assume that the surrogate already propagated from triggering the
  				// native event and prevent that from happening again here.
  				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
  				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
  				// less bad than duplication.
  				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
  					event.stopPropagation();
  				}

  			// If this is a native event triggered above, everything is now in order
  			// Fire an inner synthetic event with the original arguments
  			} else if ( saved.length ) {

  				// ...and capture the result
  				dataPriv.set( this, type, {
  					value: jQuery.event.trigger(

  						// Support: IE <=9 - 11+
  						// Extend with the prototype to reset the above stopImmediatePropagation()
  						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
  						saved.slice( 1 ),
  						this
  					)
  				} );

  				// Abort handling of the native event
  				event.stopImmediatePropagation();
  			}
  		}
  	} );
  }

  jQuery.removeEvent = function( elem, type, handle ) {

  	// This "if" is needed for plain objects
  	if ( elem.removeEventListener ) {
  		elem.removeEventListener( type, handle );
  	}
  };

  jQuery.Event = function( src, props ) {

  	// Allow instantiation without the 'new' keyword
  	if ( !( this instanceof jQuery.Event ) ) {
  		return new jQuery.Event( src, props );
  	}

  	// Event object
  	if ( src && src.type ) {
  		this.originalEvent = src;
  		this.type = src.type;

  		// Events bubbling up the document may have been marked as prevented
  		// by a handler lower down the tree; reflect the correct value.
  		this.isDefaultPrevented = src.defaultPrevented ||
  				src.defaultPrevented === undefined &&

  				// Support: Android <=2.3 only
  				src.returnValue === false ?
  			returnTrue :
  			returnFalse;

  		// Create target properties
  		// Support: Safari <=6 - 7 only
  		// Target should not be a text node (#504, #13143)
  		this.target = ( src.target && src.target.nodeType === 3 ) ?
  			src.target.parentNode :
  			src.target;

  		this.currentTarget = src.currentTarget;
  		this.relatedTarget = src.relatedTarget;

  	// Event type
  	} else {
  		this.type = src;
  	}

  	// Put explicitly provided properties onto the event object
  	if ( props ) {
  		jQuery.extend( this, props );
  	}

  	// Create a timestamp if incoming event doesn't have one
  	this.timeStamp = src && src.timeStamp || Date.now();

  	// Mark it as fixed
  	this[ jQuery.expando ] = true;
  };

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
  	constructor: jQuery.Event,
  	isDefaultPrevented: returnFalse,
  	isPropagationStopped: returnFalse,
  	isImmediatePropagationStopped: returnFalse,
  	isSimulated: false,

  	preventDefault: function() {
  		var e = this.originalEvent;

  		this.isDefaultPrevented = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.preventDefault();
  		}
  	},
  	stopPropagation: function() {
  		var e = this.originalEvent;

  		this.isPropagationStopped = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.stopPropagation();
  		}
  	},
  	stopImmediatePropagation: function() {
  		var e = this.originalEvent;

  		this.isImmediatePropagationStopped = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.stopImmediatePropagation();
  		}

  		this.stopPropagation();
  	}
  };

  // Includes all common event props including KeyEvent and MouseEvent specific props
  jQuery.each( {
  	altKey: true,
  	bubbles: true,
  	cancelable: true,
  	changedTouches: true,
  	ctrlKey: true,
  	detail: true,
  	eventPhase: true,
  	metaKey: true,
  	pageX: true,
  	pageY: true,
  	shiftKey: true,
  	view: true,
  	"char": true,
  	code: true,
  	charCode: true,
  	key: true,
  	keyCode: true,
  	button: true,
  	buttons: true,
  	clientX: true,
  	clientY: true,
  	offsetX: true,
  	offsetY: true,
  	pointerId: true,
  	pointerType: true,
  	screenX: true,
  	screenY: true,
  	targetTouches: true,
  	toElement: true,
  	touches: true,

  	which: function( event ) {
  		var button = event.button;

  		// Add which for key events
  		if ( event.which == null && rkeyEvent.test( event.type ) ) {
  			return event.charCode != null ? event.charCode : event.keyCode;
  		}

  		// Add which for click: 1 === left; 2 === middle; 3 === right
  		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
  			if ( button & 1 ) {
  				return 1;
  			}

  			if ( button & 2 ) {
  				return 3;
  			}

  			if ( button & 4 ) {
  				return 2;
  			}

  			return 0;
  		}

  		return event.which;
  	}
  }, jQuery.event.addProp );

  jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
  	jQuery.event.special[ type ] = {

  		// Utilize native event if possible so blur/focus sequence is correct
  		setup: function() {

  			// Claim the first handler
  			// dataPriv.set( this, "focus", ... )
  			// dataPriv.set( this, "blur", ... )
  			leverageNative( this, type, expectSync );

  			// Return false to allow normal processing in the caller
  			return false;
  		},
  		trigger: function() {

  			// Force setup before trigger
  			leverageNative( this, type );

  			// Return non-false to allow normal event-path propagation
  			return true;
  		},

  		delegateType: delegateType
  	};
  } );

  // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).
  jQuery.each( {
  	mouseenter: "mouseover",
  	mouseleave: "mouseout",
  	pointerenter: "pointerover",
  	pointerleave: "pointerout"
  }, function( orig, fix ) {
  	jQuery.event.special[ orig ] = {
  		delegateType: fix,
  		bindType: fix,

  		handle: function( event ) {
  			var ret,
  				target = this,
  				related = event.relatedTarget,
  				handleObj = event.handleObj;

  			// For mouseenter/leave call the handler if related is outside the target.
  			// NB: No relatedTarget if the mouse left/entered the browser window
  			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
  				event.type = handleObj.origType;
  				ret = handleObj.handler.apply( this, arguments );
  				event.type = fix;
  			}
  			return ret;
  		}
  	};
  } );

  jQuery.fn.extend( {

  	on: function( types, selector, data, fn ) {
  		return on( this, types, selector, data, fn );
  	},
  	one: function( types, selector, data, fn ) {
  		return on( this, types, selector, data, fn, 1 );
  	},
  	off: function( types, selector, fn ) {
  		var handleObj, type;
  		if ( types && types.preventDefault && types.handleObj ) {

  			// ( event )  dispatched jQuery.Event
  			handleObj = types.handleObj;
  			jQuery( types.delegateTarget ).off(
  				handleObj.namespace ?
  					handleObj.origType + "." + handleObj.namespace :
  					handleObj.origType,
  				handleObj.selector,
  				handleObj.handler
  			);
  			return this;
  		}
  		if ( typeof types === "object" ) {

  			// ( types-object [, selector] )
  			for ( type in types ) {
  				this.off( type, selector, types[ type ] );
  			}
  			return this;
  		}
  		if ( selector === false || typeof selector === "function" ) {

  			// ( types [, fn] )
  			fn = selector;
  			selector = undefined;
  		}
  		if ( fn === false ) {
  			fn = returnFalse;
  		}
  		return this.each( function() {
  			jQuery.event.remove( this, types, fn, selector );
  		} );
  	}
  } );


  var

  	/* eslint-disable max-len */

  	// See https://github.com/eslint/eslint/issues/3229
  	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

  	/* eslint-enable */

  	// Support: IE <=10 - 11, Edge 12 - 13 only
  	// In IE/Edge using regex groups here causes severe slowdowns.
  	// See https://connect.microsoft.com/IE/feedback/details/1736512/
  	rnoInnerhtml = /<script|<style|<link/i,

  	// checked="checked" or checked
  	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  // Prefer a tbody over its parent table for containing new rows
  function manipulationTarget( elem, content ) {
  	if ( nodeName( elem, "table" ) &&
  		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

  		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
  	}

  	return elem;
  }

  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript( elem ) {
  	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
  	return elem;
  }
  function restoreScript( elem ) {
  	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
  		elem.type = elem.type.slice( 5 );
  	} else {
  		elem.removeAttribute( "type" );
  	}

  	return elem;
  }

  function cloneCopyEvent( src, dest ) {
  	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

  	if ( dest.nodeType !== 1 ) {
  		return;
  	}

  	// 1. Copy private data: events, handlers, etc.
  	if ( dataPriv.hasData( src ) ) {
  		pdataOld = dataPriv.access( src );
  		pdataCur = dataPriv.set( dest, pdataOld );
  		events = pdataOld.events;

  		if ( events ) {
  			delete pdataCur.handle;
  			pdataCur.events = {};

  			for ( type in events ) {
  				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
  					jQuery.event.add( dest, type, events[ type ][ i ] );
  				}
  			}
  		}
  	}

  	// 2. Copy user data
  	if ( dataUser.hasData( src ) ) {
  		udataOld = dataUser.access( src );
  		udataCur = jQuery.extend( {}, udataOld );

  		dataUser.set( dest, udataCur );
  	}
  }

  // Fix IE bugs, see support tests
  function fixInput( src, dest ) {
  	var nodeName = dest.nodeName.toLowerCase();

  	// Fails to persist the checked state of a cloned checkbox or radio button.
  	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
  		dest.checked = src.checked;

  	// Fails to return the selected option to the default selected state when cloning options
  	} else if ( nodeName === "input" || nodeName === "textarea" ) {
  		dest.defaultValue = src.defaultValue;
  	}
  }

  function domManip( collection, args, callback, ignored ) {

  	// Flatten any nested arrays
  	args = concat.apply( [], args );

  	var fragment, first, scripts, hasScripts, node, doc,
  		i = 0,
  		l = collection.length,
  		iNoClone = l - 1,
  		value = args[ 0 ],
  		valueIsFunction = isFunction( value );

  	// We can't cloneNode fragments that contain checked, in WebKit
  	if ( valueIsFunction ||
  			( l > 1 && typeof value === "string" &&
  				!support.checkClone && rchecked.test( value ) ) ) {
  		return collection.each( function( index ) {
  			var self = collection.eq( index );
  			if ( valueIsFunction ) {
  				args[ 0 ] = value.call( this, index, self.html() );
  			}
  			domManip( self, args, callback, ignored );
  		} );
  	}

  	if ( l ) {
  		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
  		first = fragment.firstChild;

  		if ( fragment.childNodes.length === 1 ) {
  			fragment = first;
  		}

  		// Require either new content or an interest in ignored elements to invoke the callback
  		if ( first || ignored ) {
  			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
  			hasScripts = scripts.length;

  			// Use the original fragment for the last item
  			// instead of the first because it can end up
  			// being emptied incorrectly in certain situations (#8070).
  			for ( ; i < l; i++ ) {
  				node = fragment;

  				if ( i !== iNoClone ) {
  					node = jQuery.clone( node, true, true );

  					// Keep references to cloned scripts for later restoration
  					if ( hasScripts ) {

  						// Support: Android <=4.0 only, PhantomJS 1 only
  						// push.apply(_, arraylike) throws on ancient WebKit
  						jQuery.merge( scripts, getAll( node, "script" ) );
  					}
  				}

  				callback.call( collection[ i ], node, i );
  			}

  			if ( hasScripts ) {
  				doc = scripts[ scripts.length - 1 ].ownerDocument;

  				// Reenable scripts
  				jQuery.map( scripts, restoreScript );

  				// Evaluate executable scripts on first document insertion
  				for ( i = 0; i < hasScripts; i++ ) {
  					node = scripts[ i ];
  					if ( rscriptType.test( node.type || "" ) &&
  						!dataPriv.access( node, "globalEval" ) &&
  						jQuery.contains( doc, node ) ) {

  						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

  							// Optional AJAX dependency, but won't run scripts if not present
  							if ( jQuery._evalUrl && !node.noModule ) {
  								jQuery._evalUrl( node.src, {
  									nonce: node.nonce || node.getAttribute( "nonce" )
  								} );
  							}
  						} else {
  							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
  						}
  					}
  				}
  			}
  		}
  	}

  	return collection;
  }

  function remove( elem, selector, keepData ) {
  	var node,
  		nodes = selector ? jQuery.filter( selector, elem ) : elem,
  		i = 0;

  	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
  		if ( !keepData && node.nodeType === 1 ) {
  			jQuery.cleanData( getAll( node ) );
  		}

  		if ( node.parentNode ) {
  			if ( keepData && isAttached( node ) ) {
  				setGlobalEval( getAll( node, "script" ) );
  			}
  			node.parentNode.removeChild( node );
  		}
  	}

  	return elem;
  }

  jQuery.extend( {
  	htmlPrefilter: function( html ) {
  		return html.replace( rxhtmlTag, "<$1></$2>" );
  	},

  	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
  		var i, l, srcElements, destElements,
  			clone = elem.cloneNode( true ),
  			inPage = isAttached( elem );

  		// Fix IE cloning issues
  		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
  				!jQuery.isXMLDoc( elem ) ) {

  			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
  			destElements = getAll( clone );
  			srcElements = getAll( elem );

  			for ( i = 0, l = srcElements.length; i < l; i++ ) {
  				fixInput( srcElements[ i ], destElements[ i ] );
  			}
  		}

  		// Copy the events from the original to the clone
  		if ( dataAndEvents ) {
  			if ( deepDataAndEvents ) {
  				srcElements = srcElements || getAll( elem );
  				destElements = destElements || getAll( clone );

  				for ( i = 0, l = srcElements.length; i < l; i++ ) {
  					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
  				}
  			} else {
  				cloneCopyEvent( elem, clone );
  			}
  		}

  		// Preserve script evaluation history
  		destElements = getAll( clone, "script" );
  		if ( destElements.length > 0 ) {
  			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
  		}

  		// Return the cloned set
  		return clone;
  	},

  	cleanData: function( elems ) {
  		var data, elem, type,
  			special = jQuery.event.special,
  			i = 0;

  		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
  			if ( acceptData( elem ) ) {
  				if ( ( data = elem[ dataPriv.expando ] ) ) {
  					if ( data.events ) {
  						for ( type in data.events ) {
  							if ( special[ type ] ) {
  								jQuery.event.remove( elem, type );

  							// This is a shortcut to avoid jQuery.event.remove's overhead
  							} else {
  								jQuery.removeEvent( elem, type, data.handle );
  							}
  						}
  					}

  					// Support: Chrome <=35 - 45+
  					// Assign undefined instead of using delete, see Data#remove
  					elem[ dataPriv.expando ] = undefined;
  				}
  				if ( elem[ dataUser.expando ] ) {

  					// Support: Chrome <=35 - 45+
  					// Assign undefined instead of using delete, see Data#remove
  					elem[ dataUser.expando ] = undefined;
  				}
  			}
  		}
  	}
  } );

  jQuery.fn.extend( {
  	detach: function( selector ) {
  		return remove( this, selector, true );
  	},

  	remove: function( selector ) {
  		return remove( this, selector );
  	},

  	text: function( value ) {
  		return access( this, function( value ) {
  			return value === undefined ?
  				jQuery.text( this ) :
  				this.empty().each( function() {
  					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  						this.textContent = value;
  					}
  				} );
  		}, null, value, arguments.length );
  	},

  	append: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.appendChild( elem );
  			}
  		} );
  	},

  	prepend: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.insertBefore( elem, target.firstChild );
  			}
  		} );
  	},

  	before: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this );
  			}
  		} );
  	},

  	after: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this.nextSibling );
  			}
  		} );
  	},

  	empty: function() {
  		var elem,
  			i = 0;

  		for ( ; ( elem = this[ i ] ) != null; i++ ) {
  			if ( elem.nodeType === 1 ) {

  				// Prevent memory leaks
  				jQuery.cleanData( getAll( elem, false ) );

  				// Remove any remaining nodes
  				elem.textContent = "";
  			}
  		}

  		return this;
  	},

  	clone: function( dataAndEvents, deepDataAndEvents ) {
  		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
  		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

  		return this.map( function() {
  			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
  		} );
  	},

  	html: function( value ) {
  		return access( this, function( value ) {
  			var elem = this[ 0 ] || {},
  				i = 0,
  				l = this.length;

  			if ( value === undefined && elem.nodeType === 1 ) {
  				return elem.innerHTML;
  			}

  			// See if we can take a shortcut and just use innerHTML
  			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
  				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

  				value = jQuery.htmlPrefilter( value );

  				try {
  					for ( ; i < l; i++ ) {
  						elem = this[ i ] || {};

  						// Remove element nodes and prevent memory leaks
  						if ( elem.nodeType === 1 ) {
  							jQuery.cleanData( getAll( elem, false ) );
  							elem.innerHTML = value;
  						}
  					}

  					elem = 0;

  				// If using innerHTML throws an exception, use the fallback method
  				} catch ( e ) {}
  			}

  			if ( elem ) {
  				this.empty().append( value );
  			}
  		}, null, value, arguments.length );
  	},

  	replaceWith: function() {
  		var ignored = [];

  		// Make the changes, replacing each non-ignored context element with the new content
  		return domManip( this, arguments, function( elem ) {
  			var parent = this.parentNode;

  			if ( jQuery.inArray( this, ignored ) < 0 ) {
  				jQuery.cleanData( getAll( this ) );
  				if ( parent ) {
  					parent.replaceChild( elem, this );
  				}
  			}

  		// Force callback invocation
  		}, ignored );
  	}
  } );

  jQuery.each( {
  	appendTo: "append",
  	prependTo: "prepend",
  	insertBefore: "before",
  	insertAfter: "after",
  	replaceAll: "replaceWith"
  }, function( name, original ) {
  	jQuery.fn[ name ] = function( selector ) {
  		var elems,
  			ret = [],
  			insert = jQuery( selector ),
  			last = insert.length - 1,
  			i = 0;

  		for ( ; i <= last; i++ ) {
  			elems = i === last ? this : this.clone( true );
  			jQuery( insert[ i ] )[ original ]( elems );

  			// Support: Android <=4.0 only, PhantomJS 1 only
  			// .get() because push.apply(_, arraylike) throws on ancient WebKit
  			push.apply( ret, elems.get() );
  		}

  		return this.pushStack( ret );
  	};
  } );
  var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

  var getStyles = function( elem ) {

  		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
  		// IE throws on elements created in popups
  		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
  		var view = elem.ownerDocument.defaultView;

  		if ( !view || !view.opener ) {
  			view = window;
  		}

  		return view.getComputedStyle( elem );
  	};

  var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



  ( function() {

  	// Executing both pixelPosition & boxSizingReliable tests require only one layout
  	// so they're executed at the same time to save the second computation.
  	function computeStyleTests() {

  		// This is a singleton, we need to execute it only once
  		if ( !div ) {
  			return;
  		}

  		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
  			"margin-top:1px;padding:0;border:0";
  		div.style.cssText =
  			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
  			"margin:auto;border:1px;padding:1px;" +
  			"width:60%;top:1%";
  		documentElement.appendChild( container ).appendChild( div );

  		var divStyle = window.getComputedStyle( div );
  		pixelPositionVal = divStyle.top !== "1%";

  		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
  		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

  		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
  		// Some styles come back with percentage values, even though they shouldn't
  		div.style.right = "60%";
  		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

  		// Support: IE 9 - 11 only
  		// Detect misreporting of content dimensions for box-sizing:border-box elements
  		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

  		// Support: IE 9 only
  		// Detect overflow:scroll screwiness (gh-3699)
  		// Support: Chrome <=64
  		// Don't get tricked when zoom affects offsetWidth (gh-4029)
  		div.style.position = "absolute";
  		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

  		documentElement.removeChild( container );

  		// Nullify the div so it wouldn't be stored in the memory and
  		// it will also be a sign that checks already performed
  		div = null;
  	}

  	function roundPixelMeasures( measure ) {
  		return Math.round( parseFloat( measure ) );
  	}

  	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
  		reliableMarginLeftVal,
  		container = document.createElement( "div" ),
  		div = document.createElement( "div" );

  	// Finish early in limited (non-browser) environments
  	if ( !div.style ) {
  		return;
  	}

  	// Support: IE <=9 - 11 only
  	// Style of cloned element affects source element cloned (#8908)
  	div.style.backgroundClip = "content-box";
  	div.cloneNode( true ).style.backgroundClip = "";
  	support.clearCloneStyle = div.style.backgroundClip === "content-box";

  	jQuery.extend( support, {
  		boxSizingReliable: function() {
  			computeStyleTests();
  			return boxSizingReliableVal;
  		},
  		pixelBoxStyles: function() {
  			computeStyleTests();
  			return pixelBoxStylesVal;
  		},
  		pixelPosition: function() {
  			computeStyleTests();
  			return pixelPositionVal;
  		},
  		reliableMarginLeft: function() {
  			computeStyleTests();
  			return reliableMarginLeftVal;
  		},
  		scrollboxSize: function() {
  			computeStyleTests();
  			return scrollboxSizeVal;
  		}
  	} );
  } )();


  function curCSS( elem, name, computed ) {
  	var width, minWidth, maxWidth, ret,

  		// Support: Firefox 51+
  		// Retrieving style before computed somehow
  		// fixes an issue with getting wrong values
  		// on detached elements
  		style = elem.style;

  	computed = computed || getStyles( elem );

  	// getPropertyValue is needed for:
  	//   .css('filter') (IE 9 only, #12537)
  	//   .css('--customProperty) (#3144)
  	if ( computed ) {
  		ret = computed.getPropertyValue( name ) || computed[ name ];

  		if ( ret === "" && !isAttached( elem ) ) {
  			ret = jQuery.style( elem, name );
  		}

  		// A tribute to the "awesome hack by Dean Edwards"
  		// Android Browser returns percentage for some values,
  		// but width seems to be reliably pixels.
  		// This is against the CSSOM draft spec:
  		// https://drafts.csswg.org/cssom/#resolved-values
  		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

  			// Remember the original values
  			width = style.width;
  			minWidth = style.minWidth;
  			maxWidth = style.maxWidth;

  			// Put in the new values to get a computed value out
  			style.minWidth = style.maxWidth = style.width = ret;
  			ret = computed.width;

  			// Revert the changed values
  			style.width = width;
  			style.minWidth = minWidth;
  			style.maxWidth = maxWidth;
  		}
  	}

  	return ret !== undefined ?

  		// Support: IE <=9 - 11 only
  		// IE returns zIndex value as an integer.
  		ret + "" :
  		ret;
  }


  function addGetHookIf( conditionFn, hookFn ) {

  	// Define the hook, we'll check on the first run if it's really needed.
  	return {
  		get: function() {
  			if ( conditionFn() ) {

  				// Hook not needed (or it's not possible to use it due
  				// to missing dependency), remove it.
  				delete this.get;
  				return;
  			}

  			// Hook needed; redefine it so that the support test is not executed again.
  			return ( this.get = hookFn ).apply( this, arguments );
  		}
  	};
  }


  var cssPrefixes = [ "Webkit", "Moz", "ms" ],
  	emptyStyle = document.createElement( "div" ).style,
  	vendorProps = {};

  // Return a vendor-prefixed property or undefined
  function vendorPropName( name ) {

  	// Check for vendor prefixed names
  	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
  		i = cssPrefixes.length;

  	while ( i-- ) {
  		name = cssPrefixes[ i ] + capName;
  		if ( name in emptyStyle ) {
  			return name;
  		}
  	}
  }

  // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
  function finalPropName( name ) {
  	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

  	if ( final ) {
  		return final;
  	}
  	if ( name in emptyStyle ) {
  		return name;
  	}
  	return vendorProps[ name ] = vendorPropName( name ) || name;
  }


  var

  	// Swappable if display is none or starts with table
  	// except "table", "table-cell", or "table-caption"
  	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  	rcustomProp = /^--/,
  	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  	cssNormalTransform = {
  		letterSpacing: "0",
  		fontWeight: "400"
  	};

  function setPositiveNumber( elem, value, subtract ) {

  	// Any relative (+/-) values have already been
  	// normalized at this point
  	var matches = rcssNum.exec( value );
  	return matches ?

  		// Guard against undefined "subtract", e.g., when used as in cssHooks
  		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
  		value;
  }

  function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
  	var i = dimension === "width" ? 1 : 0,
  		extra = 0,
  		delta = 0;

  	// Adjustment may not be necessary
  	if ( box === ( isBorderBox ? "border" : "content" ) ) {
  		return 0;
  	}

  	for ( ; i < 4; i += 2 ) {

  		// Both box models exclude margin
  		if ( box === "margin" ) {
  			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
  		}

  		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
  		if ( !isBorderBox ) {

  			// Add padding
  			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

  			// For "border" or "margin", add border
  			if ( box !== "padding" ) {
  				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

  			// But still keep track of it otherwise
  			} else {
  				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}

  		// If we get here with a border-box (content + padding + border), we're seeking "content" or
  		// "padding" or "margin"
  		} else {

  			// For "content", subtract padding
  			if ( box === "content" ) {
  				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  			}

  			// For "content" or "padding", subtract border
  			if ( box !== "margin" ) {
  				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}
  		}
  	}

  	// Account for positive content-box scroll gutter when requested by providing computedVal
  	if ( !isBorderBox && computedVal >= 0 ) {

  		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
  		// Assuming integer scroll gutter, subtract the rest and round down
  		delta += Math.max( 0, Math.ceil(
  			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  			computedVal -
  			delta -
  			extra -
  			0.5

  		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
  		// Use an explicit zero to avoid NaN (gh-3964)
  		) ) || 0;
  	}

  	return delta;
  }

  function getWidthOrHeight( elem, dimension, extra ) {

  	// Start with computed style
  	var styles = getStyles( elem ),

  		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
  		// Fake content-box until we know it's needed to know the true value.
  		boxSizingNeeded = !support.boxSizingReliable() || extra,
  		isBorderBox = boxSizingNeeded &&
  			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  		valueIsBorderBox = isBorderBox,

  		val = curCSS( elem, dimension, styles ),
  		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

  	// Support: Firefox <=54
  	// Return a confounding non-pixel value or feign ignorance, as appropriate.
  	if ( rnumnonpx.test( val ) ) {
  		if ( !extra ) {
  			return val;
  		}
  		val = "auto";
  	}


  	// Fall back to offsetWidth/offsetHeight when value is "auto"
  	// This happens for inline elements with no explicit setting (gh-3571)
  	// Support: Android <=4.1 - 4.3 only
  	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
  	// Support: IE 9-11 only
  	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
  	// We use getClientRects() to check for hidden/disconnected.
  	// In those cases, the computed value can be trusted to be border-box
  	if ( ( !support.boxSizingReliable() && isBorderBox ||
  		val === "auto" ||
  		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
  		elem.getClientRects().length ) {

  		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

  		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
  		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
  		// retrieved value as a content box dimension.
  		valueIsBorderBox = offsetProp in elem;
  		if ( valueIsBorderBox ) {
  			val = elem[ offsetProp ];
  		}
  	}

  	// Normalize "" and auto
  	val = parseFloat( val ) || 0;

  	// Adjust for the element's box model
  	return ( val +
  		boxModelAdjustment(
  			elem,
  			dimension,
  			extra || ( isBorderBox ? "border" : "content" ),
  			valueIsBorderBox,
  			styles,

  			// Provide the current computed size to request scroll gutter calculation (gh-3589)
  			val
  		)
  	) + "px";
  }

  jQuery.extend( {

  	// Add in style property hooks for overriding the default
  	// behavior of getting and setting a style property
  	cssHooks: {
  		opacity: {
  			get: function( elem, computed ) {
  				if ( computed ) {

  					// We should always get a number back from opacity
  					var ret = curCSS( elem, "opacity" );
  					return ret === "" ? "1" : ret;
  				}
  			}
  		}
  	},

  	// Don't automatically add "px" to these possibly-unitless properties
  	cssNumber: {
  		"animationIterationCount": true,
  		"columnCount": true,
  		"fillOpacity": true,
  		"flexGrow": true,
  		"flexShrink": true,
  		"fontWeight": true,
  		"gridArea": true,
  		"gridColumn": true,
  		"gridColumnEnd": true,
  		"gridColumnStart": true,
  		"gridRow": true,
  		"gridRowEnd": true,
  		"gridRowStart": true,
  		"lineHeight": true,
  		"opacity": true,
  		"order": true,
  		"orphans": true,
  		"widows": true,
  		"zIndex": true,
  		"zoom": true
  	},

  	// Add in properties whose names you wish to fix before
  	// setting or getting the value
  	cssProps: {},

  	// Get and set the style property on a DOM Node
  	style: function( elem, name, value, extra ) {

  		// Don't set styles on text and comment nodes
  		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
  			return;
  		}

  		// Make sure that we're working with the right name
  		var ret, type, hooks,
  			origName = camelCase( name ),
  			isCustomProp = rcustomProp.test( name ),
  			style = elem.style;

  		// Make sure that we're working with the right name. We don't
  		// want to query the value if it is a CSS custom property
  		// since they are user-defined.
  		if ( !isCustomProp ) {
  			name = finalPropName( origName );
  		}

  		// Gets hook for the prefixed version, then unprefixed version
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// Check if we're setting a value
  		if ( value !== undefined ) {
  			type = typeof value;

  			// Convert "+=" or "-=" to relative numbers (#7345)
  			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
  				value = adjustCSS( elem, name, ret );

  				// Fixes bug #9237
  				type = "number";
  			}

  			// Make sure that null and NaN values aren't set (#7116)
  			if ( value == null || value !== value ) {
  				return;
  			}

  			// If a number was passed in, add the unit (except for certain CSS properties)
  			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
  			// "px" to a few hardcoded values.
  			if ( type === "number" && !isCustomProp ) {
  				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
  			}

  			// background-* props affect original clone's values
  			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
  				style[ name ] = "inherit";
  			}

  			// If a hook was provided, use that value, otherwise just set the specified value
  			if ( !hooks || !( "set" in hooks ) ||
  				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

  				if ( isCustomProp ) {
  					style.setProperty( name, value );
  				} else {
  					style[ name ] = value;
  				}
  			}

  		} else {

  			// If a hook was provided get the non-computed value from there
  			if ( hooks && "get" in hooks &&
  				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

  				return ret;
  			}

  			// Otherwise just get the value from the style object
  			return style[ name ];
  		}
  	},

  	css: function( elem, name, extra, styles ) {
  		var val, num, hooks,
  			origName = camelCase( name ),
  			isCustomProp = rcustomProp.test( name );

  		// Make sure that we're working with the right name. We don't
  		// want to modify the value if it is a CSS custom property
  		// since they are user-defined.
  		if ( !isCustomProp ) {
  			name = finalPropName( origName );
  		}

  		// Try prefixed name followed by the unprefixed name
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// If a hook was provided get the computed value from there
  		if ( hooks && "get" in hooks ) {
  			val = hooks.get( elem, true, extra );
  		}

  		// Otherwise, if a way to get the computed value exists, use that
  		if ( val === undefined ) {
  			val = curCSS( elem, name, styles );
  		}

  		// Convert "normal" to computed value
  		if ( val === "normal" && name in cssNormalTransform ) {
  			val = cssNormalTransform[ name ];
  		}

  		// Make numeric if forced or a qualifier was provided and val looks numeric
  		if ( extra === "" || extra ) {
  			num = parseFloat( val );
  			return extra === true || isFinite( num ) ? num || 0 : val;
  		}

  		return val;
  	}
  } );

  jQuery.each( [ "height", "width" ], function( i, dimension ) {
  	jQuery.cssHooks[ dimension ] = {
  		get: function( elem, computed, extra ) {
  			if ( computed ) {

  				// Certain elements can have dimension info if we invisibly show them
  				// but it must have a current display style that would benefit
  				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

  					// Support: Safari 8+
  					// Table columns in Safari have non-zero offsetWidth & zero
  					// getBoundingClientRect().width unless display is changed.
  					// Support: IE <=11 only
  					// Running getBoundingClientRect on a disconnected node
  					// in IE throws an error.
  					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
  						swap( elem, cssShow, function() {
  							return getWidthOrHeight( elem, dimension, extra );
  						} ) :
  						getWidthOrHeight( elem, dimension, extra );
  			}
  		},

  		set: function( elem, value, extra ) {
  			var matches,
  				styles = getStyles( elem ),

  				// Only read styles.position if the test has a chance to fail
  				// to avoid forcing a reflow.
  				scrollboxSizeBuggy = !support.scrollboxSize() &&
  					styles.position === "absolute",

  				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
  				boxSizingNeeded = scrollboxSizeBuggy || extra,
  				isBorderBox = boxSizingNeeded &&
  					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  				subtract = extra ?
  					boxModelAdjustment(
  						elem,
  						dimension,
  						extra,
  						isBorderBox,
  						styles
  					) :
  					0;

  			// Account for unreliable border-box dimensions by comparing offset* to computed and
  			// faking a content-box to get border and padding (gh-3699)
  			if ( isBorderBox && scrollboxSizeBuggy ) {
  				subtract -= Math.ceil(
  					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  					parseFloat( styles[ dimension ] ) -
  					boxModelAdjustment( elem, dimension, "border", false, styles ) -
  					0.5
  				);
  			}

  			// Convert to pixels if value adjustment is needed
  			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
  				( matches[ 3 ] || "px" ) !== "px" ) {

  				elem.style[ dimension ] = value;
  				value = jQuery.css( elem, dimension );
  			}

  			return setPositiveNumber( elem, value, subtract );
  		}
  	};
  } );

  jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
  	function( elem, computed ) {
  		if ( computed ) {
  			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
  				elem.getBoundingClientRect().left -
  					swap( elem, { marginLeft: 0 }, function() {
  						return elem.getBoundingClientRect().left;
  					} )
  				) + "px";
  		}
  	}
  );

  // These hooks are used by animate to expand properties
  jQuery.each( {
  	margin: "",
  	padding: "",
  	border: "Width"
  }, function( prefix, suffix ) {
  	jQuery.cssHooks[ prefix + suffix ] = {
  		expand: function( value ) {
  			var i = 0,
  				expanded = {},

  				// Assumes a single number if not a string
  				parts = typeof value === "string" ? value.split( " " ) : [ value ];

  			for ( ; i < 4; i++ ) {
  				expanded[ prefix + cssExpand[ i ] + suffix ] =
  					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
  			}

  			return expanded;
  		}
  	};

  	if ( prefix !== "margin" ) {
  		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  	}
  } );

  jQuery.fn.extend( {
  	css: function( name, value ) {
  		return access( this, function( elem, name, value ) {
  			var styles, len,
  				map = {},
  				i = 0;

  			if ( Array.isArray( name ) ) {
  				styles = getStyles( elem );
  				len = name.length;

  				for ( ; i < len; i++ ) {
  					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
  				}

  				return map;
  			}

  			return value !== undefined ?
  				jQuery.style( elem, name, value ) :
  				jQuery.css( elem, name );
  		}, name, value, arguments.length > 1 );
  	}
  } );


  function Tween( elem, options, prop, end, easing ) {
  	return new Tween.prototype.init( elem, options, prop, end, easing );
  }
  jQuery.Tween = Tween;

  Tween.prototype = {
  	constructor: Tween,
  	init: function( elem, options, prop, end, easing, unit ) {
  		this.elem = elem;
  		this.prop = prop;
  		this.easing = easing || jQuery.easing._default;
  		this.options = options;
  		this.start = this.now = this.cur();
  		this.end = end;
  		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  	},
  	cur: function() {
  		var hooks = Tween.propHooks[ this.prop ];

  		return hooks && hooks.get ?
  			hooks.get( this ) :
  			Tween.propHooks._default.get( this );
  	},
  	run: function( percent ) {
  		var eased,
  			hooks = Tween.propHooks[ this.prop ];

  		if ( this.options.duration ) {
  			this.pos = eased = jQuery.easing[ this.easing ](
  				percent, this.options.duration * percent, 0, 1, this.options.duration
  			);
  		} else {
  			this.pos = eased = percent;
  		}
  		this.now = ( this.end - this.start ) * eased + this.start;

  		if ( this.options.step ) {
  			this.options.step.call( this.elem, this.now, this );
  		}

  		if ( hooks && hooks.set ) {
  			hooks.set( this );
  		} else {
  			Tween.propHooks._default.set( this );
  		}
  		return this;
  	}
  };

  Tween.prototype.init.prototype = Tween.prototype;

  Tween.propHooks = {
  	_default: {
  		get: function( tween ) {
  			var result;

  			// Use a property on the element directly when it is not a DOM element,
  			// or when there is no matching style property that exists.
  			if ( tween.elem.nodeType !== 1 ||
  				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
  				return tween.elem[ tween.prop ];
  			}

  			// Passing an empty string as a 3rd parameter to .css will automatically
  			// attempt a parseFloat and fallback to a string if the parse fails.
  			// Simple values such as "10px" are parsed to Float;
  			// complex values such as "rotate(1rad)" are returned as-is.
  			result = jQuery.css( tween.elem, tween.prop, "" );

  			// Empty strings, null, undefined and "auto" are converted to 0.
  			return !result || result === "auto" ? 0 : result;
  		},
  		set: function( tween ) {

  			// Use step hook for back compat.
  			// Use cssHook if its there.
  			// Use .style if available and use plain properties where available.
  			if ( jQuery.fx.step[ tween.prop ] ) {
  				jQuery.fx.step[ tween.prop ]( tween );
  			} else if ( tween.elem.nodeType === 1 && (
  					jQuery.cssHooks[ tween.prop ] ||
  					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
  				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
  			} else {
  				tween.elem[ tween.prop ] = tween.now;
  			}
  		}
  	}
  };

  // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  	set: function( tween ) {
  		if ( tween.elem.nodeType && tween.elem.parentNode ) {
  			tween.elem[ tween.prop ] = tween.now;
  		}
  	}
  };

  jQuery.easing = {
  	linear: function( p ) {
  		return p;
  	},
  	swing: function( p ) {
  		return 0.5 - Math.cos( p * Math.PI ) / 2;
  	},
  	_default: "swing"
  };

  jQuery.fx = Tween.prototype.init;

  // Back compat <1.8 extension point
  jQuery.fx.step = {};




  var
  	fxNow, inProgress,
  	rfxtypes = /^(?:toggle|show|hide)$/,
  	rrun = /queueHooks$/;

  function schedule() {
  	if ( inProgress ) {
  		if ( document.hidden === false && window.requestAnimationFrame ) {
  			window.requestAnimationFrame( schedule );
  		} else {
  			window.setTimeout( schedule, jQuery.fx.interval );
  		}

  		jQuery.fx.tick();
  	}
  }

  // Animations created synchronously will run synchronously
  function createFxNow() {
  	window.setTimeout( function() {
  		fxNow = undefined;
  	} );
  	return ( fxNow = Date.now() );
  }

  // Generate parameters to create a standard animation
  function genFx( type, includeWidth ) {
  	var which,
  		i = 0,
  		attrs = { height: type };

  	// If we include width, step value is 1 to do all cssExpand values,
  	// otherwise step value is 2 to skip over Left and Right
  	includeWidth = includeWidth ? 1 : 0;
  	for ( ; i < 4; i += 2 - includeWidth ) {
  		which = cssExpand[ i ];
  		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  	}

  	if ( includeWidth ) {
  		attrs.opacity = attrs.width = type;
  	}

  	return attrs;
  }

  function createTween( value, prop, animation ) {
  	var tween,
  		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
  		index = 0,
  		length = collection.length;
  	for ( ; index < length; index++ ) {
  		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

  			// We're done with this property
  			return tween;
  		}
  	}
  }

  function defaultPrefilter( elem, props, opts ) {
  	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
  		isBox = "width" in props || "height" in props,
  		anim = this,
  		orig = {},
  		style = elem.style,
  		hidden = elem.nodeType && isHiddenWithinTree( elem ),
  		dataShow = dataPriv.get( elem, "fxshow" );

  	// Queue-skipping animations hijack the fx hooks
  	if ( !opts.queue ) {
  		hooks = jQuery._queueHooks( elem, "fx" );
  		if ( hooks.unqueued == null ) {
  			hooks.unqueued = 0;
  			oldfire = hooks.empty.fire;
  			hooks.empty.fire = function() {
  				if ( !hooks.unqueued ) {
  					oldfire();
  				}
  			};
  		}
  		hooks.unqueued++;

  		anim.always( function() {

  			// Ensure the complete handler is called before this completes
  			anim.always( function() {
  				hooks.unqueued--;
  				if ( !jQuery.queue( elem, "fx" ).length ) {
  					hooks.empty.fire();
  				}
  			} );
  		} );
  	}

  	// Detect show/hide animations
  	for ( prop in props ) {
  		value = props[ prop ];
  		if ( rfxtypes.test( value ) ) {
  			delete props[ prop ];
  			toggle = toggle || value === "toggle";
  			if ( value === ( hidden ? "hide" : "show" ) ) {

  				// Pretend to be hidden if this is a "show" and
  				// there is still data from a stopped show/hide
  				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
  					hidden = true;

  				// Ignore all other no-op show/hide data
  				} else {
  					continue;
  				}
  			}
  			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
  		}
  	}

  	// Bail out if this is a no-op like .hide().hide()
  	propTween = !jQuery.isEmptyObject( props );
  	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
  		return;
  	}

  	// Restrict "overflow" and "display" styles during box animations
  	if ( isBox && elem.nodeType === 1 ) {

  		// Support: IE <=9 - 11, Edge 12 - 15
  		// Record all 3 overflow attributes because IE does not infer the shorthand
  		// from identically-valued overflowX and overflowY and Edge just mirrors
  		// the overflowX value there.
  		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

  		// Identify a display type, preferring old show/hide data over the CSS cascade
  		restoreDisplay = dataShow && dataShow.display;
  		if ( restoreDisplay == null ) {
  			restoreDisplay = dataPriv.get( elem, "display" );
  		}
  		display = jQuery.css( elem, "display" );
  		if ( display === "none" ) {
  			if ( restoreDisplay ) {
  				display = restoreDisplay;
  			} else {

  				// Get nonempty value(s) by temporarily forcing visibility
  				showHide( [ elem ], true );
  				restoreDisplay = elem.style.display || restoreDisplay;
  				display = jQuery.css( elem, "display" );
  				showHide( [ elem ] );
  			}
  		}

  		// Animate inline elements as inline-block
  		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
  			if ( jQuery.css( elem, "float" ) === "none" ) {

  				// Restore the original display value at the end of pure show/hide animations
  				if ( !propTween ) {
  					anim.done( function() {
  						style.display = restoreDisplay;
  					} );
  					if ( restoreDisplay == null ) {
  						display = style.display;
  						restoreDisplay = display === "none" ? "" : display;
  					}
  				}
  				style.display = "inline-block";
  			}
  		}
  	}

  	if ( opts.overflow ) {
  		style.overflow = "hidden";
  		anim.always( function() {
  			style.overflow = opts.overflow[ 0 ];
  			style.overflowX = opts.overflow[ 1 ];
  			style.overflowY = opts.overflow[ 2 ];
  		} );
  	}

  	// Implement show/hide animations
  	propTween = false;
  	for ( prop in orig ) {

  		// General show/hide setup for this element animation
  		if ( !propTween ) {
  			if ( dataShow ) {
  				if ( "hidden" in dataShow ) {
  					hidden = dataShow.hidden;
  				}
  			} else {
  				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
  			}

  			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
  			if ( toggle ) {
  				dataShow.hidden = !hidden;
  			}

  			// Show elements before animating them
  			if ( hidden ) {
  				showHide( [ elem ], true );
  			}

  			/* eslint-disable no-loop-func */

  			anim.done( function() {

  			/* eslint-enable no-loop-func */

  				// The final step of a "hide" animation is actually hiding the element
  				if ( !hidden ) {
  					showHide( [ elem ] );
  				}
  				dataPriv.remove( elem, "fxshow" );
  				for ( prop in orig ) {
  					jQuery.style( elem, prop, orig[ prop ] );
  				}
  			} );
  		}

  		// Per-property setup
  		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
  		if ( !( prop in dataShow ) ) {
  			dataShow[ prop ] = propTween.start;
  			if ( hidden ) {
  				propTween.end = propTween.start;
  				propTween.start = 0;
  			}
  		}
  	}
  }

  function propFilter( props, specialEasing ) {
  	var index, name, easing, value, hooks;

  	// camelCase, specialEasing and expand cssHook pass
  	for ( index in props ) {
  		name = camelCase( index );
  		easing = specialEasing[ name ];
  		value = props[ index ];
  		if ( Array.isArray( value ) ) {
  			easing = value[ 1 ];
  			value = props[ index ] = value[ 0 ];
  		}

  		if ( index !== name ) {
  			props[ name ] = value;
  			delete props[ index ];
  		}

  		hooks = jQuery.cssHooks[ name ];
  		if ( hooks && "expand" in hooks ) {
  			value = hooks.expand( value );
  			delete props[ name ];

  			// Not quite $.extend, this won't overwrite existing keys.
  			// Reusing 'index' because we have the correct "name"
  			for ( index in value ) {
  				if ( !( index in props ) ) {
  					props[ index ] = value[ index ];
  					specialEasing[ index ] = easing;
  				}
  			}
  		} else {
  			specialEasing[ name ] = easing;
  		}
  	}
  }

  function Animation( elem, properties, options ) {
  	var result,
  		stopped,
  		index = 0,
  		length = Animation.prefilters.length,
  		deferred = jQuery.Deferred().always( function() {

  			// Don't match elem in the :animated selector
  			delete tick.elem;
  		} ),
  		tick = function() {
  			if ( stopped ) {
  				return false;
  			}
  			var currentTime = fxNow || createFxNow(),
  				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

  				// Support: Android 2.3 only
  				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
  				temp = remaining / animation.duration || 0,
  				percent = 1 - temp,
  				index = 0,
  				length = animation.tweens.length;

  			for ( ; index < length; index++ ) {
  				animation.tweens[ index ].run( percent );
  			}

  			deferred.notifyWith( elem, [ animation, percent, remaining ] );

  			// If there's more to do, yield
  			if ( percent < 1 && length ) {
  				return remaining;
  			}

  			// If this was an empty animation, synthesize a final progress notification
  			if ( !length ) {
  				deferred.notifyWith( elem, [ animation, 1, 0 ] );
  			}

  			// Resolve the animation and report its conclusion
  			deferred.resolveWith( elem, [ animation ] );
  			return false;
  		},
  		animation = deferred.promise( {
  			elem: elem,
  			props: jQuery.extend( {}, properties ),
  			opts: jQuery.extend( true, {
  				specialEasing: {},
  				easing: jQuery.easing._default
  			}, options ),
  			originalProperties: properties,
  			originalOptions: options,
  			startTime: fxNow || createFxNow(),
  			duration: options.duration,
  			tweens: [],
  			createTween: function( prop, end ) {
  				var tween = jQuery.Tween( elem, animation.opts, prop, end,
  						animation.opts.specialEasing[ prop ] || animation.opts.easing );
  				animation.tweens.push( tween );
  				return tween;
  			},
  			stop: function( gotoEnd ) {
  				var index = 0,

  					// If we are going to the end, we want to run all the tweens
  					// otherwise we skip this part
  					length = gotoEnd ? animation.tweens.length : 0;
  				if ( stopped ) {
  					return this;
  				}
  				stopped = true;
  				for ( ; index < length; index++ ) {
  					animation.tweens[ index ].run( 1 );
  				}

  				// Resolve when we played the last frame; otherwise, reject
  				if ( gotoEnd ) {
  					deferred.notifyWith( elem, [ animation, 1, 0 ] );
  					deferred.resolveWith( elem, [ animation, gotoEnd ] );
  				} else {
  					deferred.rejectWith( elem, [ animation, gotoEnd ] );
  				}
  				return this;
  			}
  		} ),
  		props = animation.props;

  	propFilter( props, animation.opts.specialEasing );

  	for ( ; index < length; index++ ) {
  		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
  		if ( result ) {
  			if ( isFunction( result.stop ) ) {
  				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
  					result.stop.bind( result );
  			}
  			return result;
  		}
  	}

  	jQuery.map( props, createTween, animation );

  	if ( isFunction( animation.opts.start ) ) {
  		animation.opts.start.call( elem, animation );
  	}

  	// Attach callbacks from options
  	animation
  		.progress( animation.opts.progress )
  		.done( animation.opts.done, animation.opts.complete )
  		.fail( animation.opts.fail )
  		.always( animation.opts.always );

  	jQuery.fx.timer(
  		jQuery.extend( tick, {
  			elem: elem,
  			anim: animation,
  			queue: animation.opts.queue
  		} )
  	);

  	return animation;
  }

  jQuery.Animation = jQuery.extend( Animation, {

  	tweeners: {
  		"*": [ function( prop, value ) {
  			var tween = this.createTween( prop, value );
  			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
  			return tween;
  		} ]
  	},

  	tweener: function( props, callback ) {
  		if ( isFunction( props ) ) {
  			callback = props;
  			props = [ "*" ];
  		} else {
  			props = props.match( rnothtmlwhite );
  		}

  		var prop,
  			index = 0,
  			length = props.length;

  		for ( ; index < length; index++ ) {
  			prop = props[ index ];
  			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
  			Animation.tweeners[ prop ].unshift( callback );
  		}
  	},

  	prefilters: [ defaultPrefilter ],

  	prefilter: function( callback, prepend ) {
  		if ( prepend ) {
  			Animation.prefilters.unshift( callback );
  		} else {
  			Animation.prefilters.push( callback );
  		}
  	}
  } );

  jQuery.speed = function( speed, easing, fn ) {
  	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
  		complete: fn || !fn && easing ||
  			isFunction( speed ) && speed,
  		duration: speed,
  		easing: fn && easing || easing && !isFunction( easing ) && easing
  	};

  	// Go to the end state if fx are off
  	if ( jQuery.fx.off ) {
  		opt.duration = 0;

  	} else {
  		if ( typeof opt.duration !== "number" ) {
  			if ( opt.duration in jQuery.fx.speeds ) {
  				opt.duration = jQuery.fx.speeds[ opt.duration ];

  			} else {
  				opt.duration = jQuery.fx.speeds._default;
  			}
  		}
  	}

  	// Normalize opt.queue - true/undefined/null -> "fx"
  	if ( opt.queue == null || opt.queue === true ) {
  		opt.queue = "fx";
  	}

  	// Queueing
  	opt.old = opt.complete;

  	opt.complete = function() {
  		if ( isFunction( opt.old ) ) {
  			opt.old.call( this );
  		}

  		if ( opt.queue ) {
  			jQuery.dequeue( this, opt.queue );
  		}
  	};

  	return opt;
  };

  jQuery.fn.extend( {
  	fadeTo: function( speed, to, easing, callback ) {

  		// Show any hidden elements after setting opacity to 0
  		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

  			// Animate to the value specified
  			.end().animate( { opacity: to }, speed, easing, callback );
  	},
  	animate: function( prop, speed, easing, callback ) {
  		var empty = jQuery.isEmptyObject( prop ),
  			optall = jQuery.speed( speed, easing, callback ),
  			doAnimation = function() {

  				// Operate on a copy of prop so per-property easing won't be lost
  				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

  				// Empty animations, or finishing resolves immediately
  				if ( empty || dataPriv.get( this, "finish" ) ) {
  					anim.stop( true );
  				}
  			};
  			doAnimation.finish = doAnimation;

  		return empty || optall.queue === false ?
  			this.each( doAnimation ) :
  			this.queue( optall.queue, doAnimation );
  	},
  	stop: function( type, clearQueue, gotoEnd ) {
  		var stopQueue = function( hooks ) {
  			var stop = hooks.stop;
  			delete hooks.stop;
  			stop( gotoEnd );
  		};

  		if ( typeof type !== "string" ) {
  			gotoEnd = clearQueue;
  			clearQueue = type;
  			type = undefined;
  		}
  		if ( clearQueue && type !== false ) {
  			this.queue( type || "fx", [] );
  		}

  		return this.each( function() {
  			var dequeue = true,
  				index = type != null && type + "queueHooks",
  				timers = jQuery.timers,
  				data = dataPriv.get( this );

  			if ( index ) {
  				if ( data[ index ] && data[ index ].stop ) {
  					stopQueue( data[ index ] );
  				}
  			} else {
  				for ( index in data ) {
  					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
  						stopQueue( data[ index ] );
  					}
  				}
  			}

  			for ( index = timers.length; index--; ) {
  				if ( timers[ index ].elem === this &&
  					( type == null || timers[ index ].queue === type ) ) {

  					timers[ index ].anim.stop( gotoEnd );
  					dequeue = false;
  					timers.splice( index, 1 );
  				}
  			}

  			// Start the next in the queue if the last step wasn't forced.
  			// Timers currently will call their complete callbacks, which
  			// will dequeue but only if they were gotoEnd.
  			if ( dequeue || !gotoEnd ) {
  				jQuery.dequeue( this, type );
  			}
  		} );
  	},
  	finish: function( type ) {
  		if ( type !== false ) {
  			type = type || "fx";
  		}
  		return this.each( function() {
  			var index,
  				data = dataPriv.get( this ),
  				queue = data[ type + "queue" ],
  				hooks = data[ type + "queueHooks" ],
  				timers = jQuery.timers,
  				length = queue ? queue.length : 0;

  			// Enable finishing flag on private data
  			data.finish = true;

  			// Empty the queue first
  			jQuery.queue( this, type, [] );

  			if ( hooks && hooks.stop ) {
  				hooks.stop.call( this, true );
  			}

  			// Look for any active animations, and finish them
  			for ( index = timers.length; index--; ) {
  				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
  					timers[ index ].anim.stop( true );
  					timers.splice( index, 1 );
  				}
  			}

  			// Look for any animations in the old queue and finish them
  			for ( index = 0; index < length; index++ ) {
  				if ( queue[ index ] && queue[ index ].finish ) {
  					queue[ index ].finish.call( this );
  				}
  			}

  			// Turn off finishing flag
  			delete data.finish;
  		} );
  	}
  } );

  jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
  	var cssFn = jQuery.fn[ name ];
  	jQuery.fn[ name ] = function( speed, easing, callback ) {
  		return speed == null || typeof speed === "boolean" ?
  			cssFn.apply( this, arguments ) :
  			this.animate( genFx( name, true ), speed, easing, callback );
  	};
  } );

  // Generate shortcuts for custom animations
  jQuery.each( {
  	slideDown: genFx( "show" ),
  	slideUp: genFx( "hide" ),
  	slideToggle: genFx( "toggle" ),
  	fadeIn: { opacity: "show" },
  	fadeOut: { opacity: "hide" },
  	fadeToggle: { opacity: "toggle" }
  }, function( name, props ) {
  	jQuery.fn[ name ] = function( speed, easing, callback ) {
  		return this.animate( props, speed, easing, callback );
  	};
  } );

  jQuery.timers = [];
  jQuery.fx.tick = function() {
  	var timer,
  		i = 0,
  		timers = jQuery.timers;

  	fxNow = Date.now();

  	for ( ; i < timers.length; i++ ) {
  		timer = timers[ i ];

  		// Run the timer and safely remove it when done (allowing for external removal)
  		if ( !timer() && timers[ i ] === timer ) {
  			timers.splice( i--, 1 );
  		}
  	}

  	if ( !timers.length ) {
  		jQuery.fx.stop();
  	}
  	fxNow = undefined;
  };

  jQuery.fx.timer = function( timer ) {
  	jQuery.timers.push( timer );
  	jQuery.fx.start();
  };

  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
  	if ( inProgress ) {
  		return;
  	}

  	inProgress = true;
  	schedule();
  };

  jQuery.fx.stop = function() {
  	inProgress = null;
  };

  jQuery.fx.speeds = {
  	slow: 600,
  	fast: 200,

  	// Default speed
  	_default: 400
  };


  // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function( time, type ) {
  	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  	type = type || "fx";

  	return this.queue( type, function( next, hooks ) {
  		var timeout = window.setTimeout( next, time );
  		hooks.stop = function() {
  			window.clearTimeout( timeout );
  		};
  	} );
  };


  ( function() {
  	var input = document.createElement( "input" ),
  		select = document.createElement( "select" ),
  		opt = select.appendChild( document.createElement( "option" ) );

  	input.type = "checkbox";

  	// Support: Android <=4.3 only
  	// Default value for a checkbox should be "on"
  	support.checkOn = input.value !== "";

  	// Support: IE <=11 only
  	// Must access selectedIndex to make default options select
  	support.optSelected = opt.selected;

  	// Support: IE <=11 only
  	// An input loses its value after becoming a radio
  	input = document.createElement( "input" );
  	input.value = "t";
  	input.type = "radio";
  	support.radioValue = input.value === "t";
  } )();


  var boolHook,
  	attrHandle = jQuery.expr.attrHandle;

  jQuery.fn.extend( {
  	attr: function( name, value ) {
  		return access( this, jQuery.attr, name, value, arguments.length > 1 );
  	},

  	removeAttr: function( name ) {
  		return this.each( function() {
  			jQuery.removeAttr( this, name );
  		} );
  	}
  } );

  jQuery.extend( {
  	attr: function( elem, name, value ) {
  		var ret, hooks,
  			nType = elem.nodeType;

  		// Don't get/set attributes on text, comment and attribute nodes
  		if ( nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		// Fallback to prop when attributes are not supported
  		if ( typeof elem.getAttribute === "undefined" ) {
  			return jQuery.prop( elem, name, value );
  		}

  		// Attribute hooks are determined by the lowercase version
  		// Grab necessary hook if one is defined
  		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
  				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
  		}

  		if ( value !== undefined ) {
  			if ( value === null ) {
  				jQuery.removeAttr( elem, name );
  				return;
  			}

  			if ( hooks && "set" in hooks &&
  				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  				return ret;
  			}

  			elem.setAttribute( name, value + "" );
  			return value;
  		}

  		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  			return ret;
  		}

  		ret = jQuery.find.attr( elem, name );

  		// Non-existent attributes return null, we normalize to undefined
  		return ret == null ? undefined : ret;
  	},

  	attrHooks: {
  		type: {
  			set: function( elem, value ) {
  				if ( !support.radioValue && value === "radio" &&
  					nodeName( elem, "input" ) ) {
  					var val = elem.value;
  					elem.setAttribute( "type", value );
  					if ( val ) {
  						elem.value = val;
  					}
  					return value;
  				}
  			}
  		}
  	},

  	removeAttr: function( elem, value ) {
  		var name,
  			i = 0,

  			// Attribute names can contain non-HTML whitespace characters
  			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
  			attrNames = value && value.match( rnothtmlwhite );

  		if ( attrNames && elem.nodeType === 1 ) {
  			while ( ( name = attrNames[ i++ ] ) ) {
  				elem.removeAttribute( name );
  			}
  		}
  	}
  } );

  // Hooks for boolean attributes
  boolHook = {
  	set: function( elem, value, name ) {
  		if ( value === false ) {

  			// Remove boolean attributes when set to false
  			jQuery.removeAttr( elem, name );
  		} else {
  			elem.setAttribute( name, name );
  		}
  		return name;
  	}
  };

  jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
  	var getter = attrHandle[ name ] || jQuery.find.attr;

  	attrHandle[ name ] = function( elem, name, isXML ) {
  		var ret, handle,
  			lowercaseName = name.toLowerCase();

  		if ( !isXML ) {

  			// Avoid an infinite loop by temporarily removing this function from the getter
  			handle = attrHandle[ lowercaseName ];
  			attrHandle[ lowercaseName ] = ret;
  			ret = getter( elem, name, isXML ) != null ?
  				lowercaseName :
  				null;
  			attrHandle[ lowercaseName ] = handle;
  		}
  		return ret;
  	};
  } );




  var rfocusable = /^(?:input|select|textarea|button)$/i,
  	rclickable = /^(?:a|area)$/i;

  jQuery.fn.extend( {
  	prop: function( name, value ) {
  		return access( this, jQuery.prop, name, value, arguments.length > 1 );
  	},

  	removeProp: function( name ) {
  		return this.each( function() {
  			delete this[ jQuery.propFix[ name ] || name ];
  		} );
  	}
  } );

  jQuery.extend( {
  	prop: function( elem, name, value ) {
  		var ret, hooks,
  			nType = elem.nodeType;

  		// Don't get/set properties on text, comment and attribute nodes
  		if ( nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

  			// Fix name and attach hooks
  			name = jQuery.propFix[ name ] || name;
  			hooks = jQuery.propHooks[ name ];
  		}

  		if ( value !== undefined ) {
  			if ( hooks && "set" in hooks &&
  				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  				return ret;
  			}

  			return ( elem[ name ] = value );
  		}

  		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  			return ret;
  		}

  		return elem[ name ];
  	},

  	propHooks: {
  		tabIndex: {
  			get: function( elem ) {

  				// Support: IE <=9 - 11 only
  				// elem.tabIndex doesn't always return the
  				// correct value when it hasn't been explicitly set
  				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
  				// Use proper attribute retrieval(#12072)
  				var tabindex = jQuery.find.attr( elem, "tabindex" );

  				if ( tabindex ) {
  					return parseInt( tabindex, 10 );
  				}

  				if (
  					rfocusable.test( elem.nodeName ) ||
  					rclickable.test( elem.nodeName ) &&
  					elem.href
  				) {
  					return 0;
  				}

  				return -1;
  			}
  		}
  	},

  	propFix: {
  		"for": "htmlFor",
  		"class": "className"
  	}
  } );

  // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop
  if ( !support.optSelected ) {
  	jQuery.propHooks.selected = {
  		get: function( elem ) {

  			/* eslint no-unused-expressions: "off" */

  			var parent = elem.parentNode;
  			if ( parent && parent.parentNode ) {
  				parent.parentNode.selectedIndex;
  			}
  			return null;
  		},
  		set: function( elem ) {

  			/* eslint no-unused-expressions: "off" */

  			var parent = elem.parentNode;
  			if ( parent ) {
  				parent.selectedIndex;

  				if ( parent.parentNode ) {
  					parent.parentNode.selectedIndex;
  				}
  			}
  		}
  	};
  }

  jQuery.each( [
  	"tabIndex",
  	"readOnly",
  	"maxLength",
  	"cellSpacing",
  	"cellPadding",
  	"rowSpan",
  	"colSpan",
  	"useMap",
  	"frameBorder",
  	"contentEditable"
  ], function() {
  	jQuery.propFix[ this.toLowerCase() ] = this;
  } );




  	// Strip and collapse whitespace according to HTML spec
  	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
  	function stripAndCollapse( value ) {
  		var tokens = value.match( rnothtmlwhite ) || [];
  		return tokens.join( " " );
  	}


  function getClass( elem ) {
  	return elem.getAttribute && elem.getAttribute( "class" ) || "";
  }

  function classesToArray( value ) {
  	if ( Array.isArray( value ) ) {
  		return value;
  	}
  	if ( typeof value === "string" ) {
  		return value.match( rnothtmlwhite ) || [];
  	}
  	return [];
  }

  jQuery.fn.extend( {
  	addClass: function( value ) {
  		var classes, elem, cur, curValue, clazz, j, finalValue,
  			i = 0;

  		if ( isFunction( value ) ) {
  			return this.each( function( j ) {
  				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
  			} );
  		}

  		classes = classesToArray( value );

  		if ( classes.length ) {
  			while ( ( elem = this[ i++ ] ) ) {
  				curValue = getClass( elem );
  				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  				if ( cur ) {
  					j = 0;
  					while ( ( clazz = classes[ j++ ] ) ) {
  						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
  							cur += clazz + " ";
  						}
  					}

  					// Only assign if different to avoid unneeded rendering.
  					finalValue = stripAndCollapse( cur );
  					if ( curValue !== finalValue ) {
  						elem.setAttribute( "class", finalValue );
  					}
  				}
  			}
  		}

  		return this;
  	},

  	removeClass: function( value ) {
  		var classes, elem, cur, curValue, clazz, j, finalValue,
  			i = 0;

  		if ( isFunction( value ) ) {
  			return this.each( function( j ) {
  				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
  			} );
  		}

  		if ( !arguments.length ) {
  			return this.attr( "class", "" );
  		}

  		classes = classesToArray( value );

  		if ( classes.length ) {
  			while ( ( elem = this[ i++ ] ) ) {
  				curValue = getClass( elem );

  				// This expression is here for better compressibility (see addClass)
  				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  				if ( cur ) {
  					j = 0;
  					while ( ( clazz = classes[ j++ ] ) ) {

  						// Remove *all* instances
  						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
  							cur = cur.replace( " " + clazz + " ", " " );
  						}
  					}

  					// Only assign if different to avoid unneeded rendering.
  					finalValue = stripAndCollapse( cur );
  					if ( curValue !== finalValue ) {
  						elem.setAttribute( "class", finalValue );
  					}
  				}
  			}
  		}

  		return this;
  	},

  	toggleClass: function( value, stateVal ) {
  		var type = typeof value,
  			isValidValue = type === "string" || Array.isArray( value );

  		if ( typeof stateVal === "boolean" && isValidValue ) {
  			return stateVal ? this.addClass( value ) : this.removeClass( value );
  		}

  		if ( isFunction( value ) ) {
  			return this.each( function( i ) {
  				jQuery( this ).toggleClass(
  					value.call( this, i, getClass( this ), stateVal ),
  					stateVal
  				);
  			} );
  		}

  		return this.each( function() {
  			var className, i, self, classNames;

  			if ( isValidValue ) {

  				// Toggle individual class names
  				i = 0;
  				self = jQuery( this );
  				classNames = classesToArray( value );

  				while ( ( className = classNames[ i++ ] ) ) {

  					// Check each className given, space separated list
  					if ( self.hasClass( className ) ) {
  						self.removeClass( className );
  					} else {
  						self.addClass( className );
  					}
  				}

  			// Toggle whole class name
  			} else if ( value === undefined || type === "boolean" ) {
  				className = getClass( this );
  				if ( className ) {

  					// Store className if set
  					dataPriv.set( this, "__className__", className );
  				}

  				// If the element has a class name or if we're passed `false`,
  				// then remove the whole classname (if there was one, the above saved it).
  				// Otherwise bring back whatever was previously saved (if anything),
  				// falling back to the empty string if nothing was stored.
  				if ( this.setAttribute ) {
  					this.setAttribute( "class",
  						className || value === false ?
  						"" :
  						dataPriv.get( this, "__className__" ) || ""
  					);
  				}
  			}
  		} );
  	},

  	hasClass: function( selector ) {
  		var className, elem,
  			i = 0;

  		className = " " + selector + " ";
  		while ( ( elem = this[ i++ ] ) ) {
  			if ( elem.nodeType === 1 &&
  				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
  					return true;
  			}
  		}

  		return false;
  	}
  } );




  var rreturn = /\r/g;

  jQuery.fn.extend( {
  	val: function( value ) {
  		var hooks, ret, valueIsFunction,
  			elem = this[ 0 ];

  		if ( !arguments.length ) {
  			if ( elem ) {
  				hooks = jQuery.valHooks[ elem.type ] ||
  					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

  				if ( hooks &&
  					"get" in hooks &&
  					( ret = hooks.get( elem, "value" ) ) !== undefined
  				) {
  					return ret;
  				}

  				ret = elem.value;

  				// Handle most common string cases
  				if ( typeof ret === "string" ) {
  					return ret.replace( rreturn, "" );
  				}

  				// Handle cases where value is null/undef or number
  				return ret == null ? "" : ret;
  			}

  			return;
  		}

  		valueIsFunction = isFunction( value );

  		return this.each( function( i ) {
  			var val;

  			if ( this.nodeType !== 1 ) {
  				return;
  			}

  			if ( valueIsFunction ) {
  				val = value.call( this, i, jQuery( this ).val() );
  			} else {
  				val = value;
  			}

  			// Treat null/undefined as ""; convert numbers to string
  			if ( val == null ) {
  				val = "";

  			} else if ( typeof val === "number" ) {
  				val += "";

  			} else if ( Array.isArray( val ) ) {
  				val = jQuery.map( val, function( value ) {
  					return value == null ? "" : value + "";
  				} );
  			}

  			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

  			// If set returns undefined, fall back to normal setting
  			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
  				this.value = val;
  			}
  		} );
  	}
  } );

  jQuery.extend( {
  	valHooks: {
  		option: {
  			get: function( elem ) {

  				var val = jQuery.find.attr( elem, "value" );
  				return val != null ?
  					val :

  					// Support: IE <=10 - 11 only
  					// option.text throws exceptions (#14686, #14858)
  					// Strip and collapse whitespace
  					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
  					stripAndCollapse( jQuery.text( elem ) );
  			}
  		},
  		select: {
  			get: function( elem ) {
  				var value, option, i,
  					options = elem.options,
  					index = elem.selectedIndex,
  					one = elem.type === "select-one",
  					values = one ? null : [],
  					max = one ? index + 1 : options.length;

  				if ( index < 0 ) {
  					i = max;

  				} else {
  					i = one ? index : 0;
  				}

  				// Loop through all the selected options
  				for ( ; i < max; i++ ) {
  					option = options[ i ];

  					// Support: IE <=9 only
  					// IE8-9 doesn't update selected after form reset (#2551)
  					if ( ( option.selected || i === index ) &&

  							// Don't return options that are disabled or in a disabled optgroup
  							!option.disabled &&
  							( !option.parentNode.disabled ||
  								!nodeName( option.parentNode, "optgroup" ) ) ) {

  						// Get the specific value for the option
  						value = jQuery( option ).val();

  						// We don't need an array for one selects
  						if ( one ) {
  							return value;
  						}

  						// Multi-Selects return an array
  						values.push( value );
  					}
  				}

  				return values;
  			},

  			set: function( elem, value ) {
  				var optionSet, option,
  					options = elem.options,
  					values = jQuery.makeArray( value ),
  					i = options.length;

  				while ( i-- ) {
  					option = options[ i ];

  					/* eslint-disable no-cond-assign */

  					if ( option.selected =
  						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
  					) {
  						optionSet = true;
  					}

  					/* eslint-enable no-cond-assign */
  				}

  				// Force browsers to behave consistently when non-matching value is set
  				if ( !optionSet ) {
  					elem.selectedIndex = -1;
  				}
  				return values;
  			}
  		}
  	}
  } );

  // Radios and checkboxes getter/setter
  jQuery.each( [ "radio", "checkbox" ], function() {
  	jQuery.valHooks[ this ] = {
  		set: function( elem, value ) {
  			if ( Array.isArray( value ) ) {
  				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
  			}
  		}
  	};
  	if ( !support.checkOn ) {
  		jQuery.valHooks[ this ].get = function( elem ) {
  			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
  		};
  	}
  } );




  // Return jQuery for attributes-only inclusion


  support.focusin = "onfocusin" in window;


  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  	stopPropagationCallback = function( e ) {
  		e.stopPropagation();
  	};

  jQuery.extend( jQuery.event, {

  	trigger: function( event, data, elem, onlyHandlers ) {

  		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
  			eventPath = [ elem || document ],
  			type = hasOwn.call( event, "type" ) ? event.type : event,
  			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

  		cur = lastElement = tmp = elem = elem || document;

  		// Don't do events on text and comment nodes
  		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
  			return;
  		}

  		// focus/blur morphs to focusin/out; ensure we're not firing them right now
  		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
  			return;
  		}

  		if ( type.indexOf( "." ) > -1 ) {

  			// Namespaced trigger; create a regexp to match event type in handle()
  			namespaces = type.split( "." );
  			type = namespaces.shift();
  			namespaces.sort();
  		}
  		ontype = type.indexOf( ":" ) < 0 && "on" + type;

  		// Caller can pass in a jQuery.Event object, Object, or just an event type string
  		event = event[ jQuery.expando ] ?
  			event :
  			new jQuery.Event( type, typeof event === "object" && event );

  		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
  		event.isTrigger = onlyHandlers ? 2 : 3;
  		event.namespace = namespaces.join( "." );
  		event.rnamespace = event.namespace ?
  			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
  			null;

  		// Clean up the event in case it is being reused
  		event.result = undefined;
  		if ( !event.target ) {
  			event.target = elem;
  		}

  		// Clone any incoming data and prepend the event, creating the handler arg list
  		data = data == null ?
  			[ event ] :
  			jQuery.makeArray( data, [ event ] );

  		// Allow special events to draw outside the lines
  		special = jQuery.event.special[ type ] || {};
  		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
  			return;
  		}

  		// Determine event propagation path in advance, per W3C events spec (#9951)
  		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
  		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

  			bubbleType = special.delegateType || type;
  			if ( !rfocusMorph.test( bubbleType + type ) ) {
  				cur = cur.parentNode;
  			}
  			for ( ; cur; cur = cur.parentNode ) {
  				eventPath.push( cur );
  				tmp = cur;
  			}

  			// Only add window if we got to document (e.g., not plain obj or detached DOM)
  			if ( tmp === ( elem.ownerDocument || document ) ) {
  				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
  			}
  		}

  		// Fire handlers on the event path
  		i = 0;
  		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
  			lastElement = cur;
  			event.type = i > 1 ?
  				bubbleType :
  				special.bindType || type;

  			// jQuery handler
  			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
  				dataPriv.get( cur, "handle" );
  			if ( handle ) {
  				handle.apply( cur, data );
  			}

  			// Native handler
  			handle = ontype && cur[ ontype ];
  			if ( handle && handle.apply && acceptData( cur ) ) {
  				event.result = handle.apply( cur, data );
  				if ( event.result === false ) {
  					event.preventDefault();
  				}
  			}
  		}
  		event.type = type;

  		// If nobody prevented the default action, do it now
  		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

  			if ( ( !special._default ||
  				special._default.apply( eventPath.pop(), data ) === false ) &&
  				acceptData( elem ) ) {

  				// Call a native DOM method on the target with the same name as the event.
  				// Don't do default actions on window, that's where global variables be (#6170)
  				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

  					// Don't re-trigger an onFOO event when we call its FOO() method
  					tmp = elem[ ontype ];

  					if ( tmp ) {
  						elem[ ontype ] = null;
  					}

  					// Prevent re-triggering of the same event, since we already bubbled it above
  					jQuery.event.triggered = type;

  					if ( event.isPropagationStopped() ) {
  						lastElement.addEventListener( type, stopPropagationCallback );
  					}

  					elem[ type ]();

  					if ( event.isPropagationStopped() ) {
  						lastElement.removeEventListener( type, stopPropagationCallback );
  					}

  					jQuery.event.triggered = undefined;

  					if ( tmp ) {
  						elem[ ontype ] = tmp;
  					}
  				}
  			}
  		}

  		return event.result;
  	},

  	// Piggyback on a donor event to simulate a different one
  	// Used only for `focus(in | out)` events
  	simulate: function( type, elem, event ) {
  		var e = jQuery.extend(
  			new jQuery.Event(),
  			event,
  			{
  				type: type,
  				isSimulated: true
  			}
  		);

  		jQuery.event.trigger( e, null, elem );
  	}

  } );

  jQuery.fn.extend( {

  	trigger: function( type, data ) {
  		return this.each( function() {
  			jQuery.event.trigger( type, data, this );
  		} );
  	},
  	triggerHandler: function( type, data ) {
  		var elem = this[ 0 ];
  		if ( elem ) {
  			return jQuery.event.trigger( type, data, elem, true );
  		}
  	}
  } );


  // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  if ( !support.focusin ) {
  	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

  		// Attach a single capturing handler on the document while someone wants focusin/focusout
  		var handler = function( event ) {
  			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
  		};

  		jQuery.event.special[ fix ] = {
  			setup: function() {
  				var doc = this.ownerDocument || this,
  					attaches = dataPriv.access( doc, fix );

  				if ( !attaches ) {
  					doc.addEventListener( orig, handler, true );
  				}
  				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
  			},
  			teardown: function() {
  				var doc = this.ownerDocument || this,
  					attaches = dataPriv.access( doc, fix ) - 1;

  				if ( !attaches ) {
  					doc.removeEventListener( orig, handler, true );
  					dataPriv.remove( doc, fix );

  				} else {
  					dataPriv.access( doc, fix, attaches );
  				}
  			}
  		};
  	} );
  }
  var location = window.location;

  var nonce = Date.now();

  var rquery = ( /\?/ );



  // Cross-browser xml parsing
  jQuery.parseXML = function( data ) {
  	var xml;
  	if ( !data || typeof data !== "string" ) {
  		return null;
  	}

  	// Support: IE 9 - 11 only
  	// IE throws on parseFromString with invalid input.
  	try {
  		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
  	} catch ( e ) {
  		xml = undefined;
  	}

  	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
  		jQuery.error( "Invalid XML: " + data );
  	}
  	return xml;
  };


  var
  	rbracket = /\[\]$/,
  	rCRLF = /\r?\n/g,
  	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  	rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams( prefix, obj, traditional, add ) {
  	var name;

  	if ( Array.isArray( obj ) ) {

  		// Serialize array item.
  		jQuery.each( obj, function( i, v ) {
  			if ( traditional || rbracket.test( prefix ) ) {

  				// Treat each array item as a scalar.
  				add( prefix, v );

  			} else {

  				// Item is non-scalar (array or object), encode its numeric index.
  				buildParams(
  					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
  					v,
  					traditional,
  					add
  				);
  			}
  		} );

  	} else if ( !traditional && toType( obj ) === "object" ) {

  		// Serialize object item.
  		for ( name in obj ) {
  			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
  		}

  	} else {

  		// Serialize scalar item.
  		add( prefix, obj );
  	}
  }

  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function( a, traditional ) {
  	var prefix,
  		s = [],
  		add = function( key, valueOrFunction ) {

  			// If value is a function, invoke it and use its return value
  			var value = isFunction( valueOrFunction ) ?
  				valueOrFunction() :
  				valueOrFunction;

  			s[ s.length ] = encodeURIComponent( key ) + "=" +
  				encodeURIComponent( value == null ? "" : value );
  		};

  	if ( a == null ) {
  		return "";
  	}

  	// If an array was passed in, assume that it is an array of form elements.
  	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

  		// Serialize the form elements
  		jQuery.each( a, function() {
  			add( this.name, this.value );
  		} );

  	} else {

  		// If traditional, encode the "old" way (the way 1.3.2 or older
  		// did it), otherwise encode params recursively.
  		for ( prefix in a ) {
  			buildParams( prefix, a[ prefix ], traditional, add );
  		}
  	}

  	// Return the resulting serialization
  	return s.join( "&" );
  };

  jQuery.fn.extend( {
  	serialize: function() {
  		return jQuery.param( this.serializeArray() );
  	},
  	serializeArray: function() {
  		return this.map( function() {

  			// Can add propHook for "elements" to filter or add form elements
  			var elements = jQuery.prop( this, "elements" );
  			return elements ? jQuery.makeArray( elements ) : this;
  		} )
  		.filter( function() {
  			var type = this.type;

  			// Use .is( ":disabled" ) so that fieldset[disabled] works
  			return this.name && !jQuery( this ).is( ":disabled" ) &&
  				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
  				( this.checked || !rcheckableType.test( type ) );
  		} )
  		.map( function( i, elem ) {
  			var val = jQuery( this ).val();

  			if ( val == null ) {
  				return null;
  			}

  			if ( Array.isArray( val ) ) {
  				return jQuery.map( val, function( val ) {
  					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  				} );
  			}

  			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  		} ).get();
  	}
  } );


  var
  	r20 = /%20/g,
  	rhash = /#.*$/,
  	rantiCache = /([?&])_=[^&]*/,
  	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

  	// #7653, #8125, #8152: local protocol detection
  	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  	rnoContent = /^(?:GET|HEAD)$/,
  	rprotocol = /^\/\//,

  	/* Prefilters
  	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  	 * 2) These are called:
  	 *    - BEFORE asking for a transport
  	 *    - AFTER param serialization (s.data is a string if s.processData is true)
  	 * 3) key is the dataType
  	 * 4) the catchall symbol "*" can be used
  	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  	 */
  	prefilters = {},

  	/* Transports bindings
  	 * 1) key is the dataType
  	 * 2) the catchall symbol "*" can be used
  	 * 3) selection will start with transport dataType and THEN go to "*" if needed
  	 */
  	transports = {},

  	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  	allTypes = "*/".concat( "*" ),

  	// Anchor tag for parsing the document origin
  	originAnchor = document.createElement( "a" );
  	originAnchor.href = location.href;

  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports( structure ) {

  	// dataTypeExpression is optional and defaults to "*"
  	return function( dataTypeExpression, func ) {

  		if ( typeof dataTypeExpression !== "string" ) {
  			func = dataTypeExpression;
  			dataTypeExpression = "*";
  		}

  		var dataType,
  			i = 0,
  			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

  		if ( isFunction( func ) ) {

  			// For each dataType in the dataTypeExpression
  			while ( ( dataType = dataTypes[ i++ ] ) ) {

  				// Prepend if requested
  				if ( dataType[ 0 ] === "+" ) {
  					dataType = dataType.slice( 1 ) || "*";
  					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

  				// Otherwise append
  				} else {
  					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
  				}
  			}
  		}
  	};
  }

  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  	var inspected = {},
  		seekingTransport = ( structure === transports );

  	function inspect( dataType ) {
  		var selected;
  		inspected[ dataType ] = true;
  		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
  			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
  			if ( typeof dataTypeOrTransport === "string" &&
  				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

  				options.dataTypes.unshift( dataTypeOrTransport );
  				inspect( dataTypeOrTransport );
  				return false;
  			} else if ( seekingTransport ) {
  				return !( selected = dataTypeOrTransport );
  			}
  		} );
  		return selected;
  	}

  	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
  }

  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend( target, src ) {
  	var key, deep,
  		flatOptions = jQuery.ajaxSettings.flatOptions || {};

  	for ( key in src ) {
  		if ( src[ key ] !== undefined ) {
  			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
  		}
  	}
  	if ( deep ) {
  		jQuery.extend( true, target, deep );
  	}

  	return target;
  }

  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */
  function ajaxHandleResponses( s, jqXHR, responses ) {

  	var ct, type, finalDataType, firstDataType,
  		contents = s.contents,
  		dataTypes = s.dataTypes;

  	// Remove auto dataType and get content-type in the process
  	while ( dataTypes[ 0 ] === "*" ) {
  		dataTypes.shift();
  		if ( ct === undefined ) {
  			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
  		}
  	}

  	// Check if we're dealing with a known content-type
  	if ( ct ) {
  		for ( type in contents ) {
  			if ( contents[ type ] && contents[ type ].test( ct ) ) {
  				dataTypes.unshift( type );
  				break;
  			}
  		}
  	}

  	// Check to see if we have a response for the expected dataType
  	if ( dataTypes[ 0 ] in responses ) {
  		finalDataType = dataTypes[ 0 ];
  	} else {

  		// Try convertible dataTypes
  		for ( type in responses ) {
  			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
  				finalDataType = type;
  				break;
  			}
  			if ( !firstDataType ) {
  				firstDataType = type;
  			}
  		}

  		// Or just use first one
  		finalDataType = finalDataType || firstDataType;
  	}

  	// If we found a dataType
  	// We add the dataType to the list if needed
  	// and return the corresponding response
  	if ( finalDataType ) {
  		if ( finalDataType !== dataTypes[ 0 ] ) {
  			dataTypes.unshift( finalDataType );
  		}
  		return responses[ finalDataType ];
  	}
  }

  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */
  function ajaxConvert( s, response, jqXHR, isSuccess ) {
  	var conv2, current, conv, tmp, prev,
  		converters = {},

  		// Work with a copy of dataTypes in case we need to modify it for conversion
  		dataTypes = s.dataTypes.slice();

  	// Create converters map with lowercased keys
  	if ( dataTypes[ 1 ] ) {
  		for ( conv in s.converters ) {
  			converters[ conv.toLowerCase() ] = s.converters[ conv ];
  		}
  	}

  	current = dataTypes.shift();

  	// Convert to each sequential dataType
  	while ( current ) {

  		if ( s.responseFields[ current ] ) {
  			jqXHR[ s.responseFields[ current ] ] = response;
  		}

  		// Apply the dataFilter if provided
  		if ( !prev && isSuccess && s.dataFilter ) {
  			response = s.dataFilter( response, s.dataType );
  		}

  		prev = current;
  		current = dataTypes.shift();

  		if ( current ) {

  			// There's only work to do if current dataType is non-auto
  			if ( current === "*" ) {

  				current = prev;

  			// Convert response if prev dataType is non-auto and differs from current
  			} else if ( prev !== "*" && prev !== current ) {

  				// Seek a direct converter
  				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

  				// If none found, seek a pair
  				if ( !conv ) {
  					for ( conv2 in converters ) {

  						// If conv2 outputs current
  						tmp = conv2.split( " " );
  						if ( tmp[ 1 ] === current ) {

  							// If prev can be converted to accepted input
  							conv = converters[ prev + " " + tmp[ 0 ] ] ||
  								converters[ "* " + tmp[ 0 ] ];
  							if ( conv ) {

  								// Condense equivalence converters
  								if ( conv === true ) {
  									conv = converters[ conv2 ];

  								// Otherwise, insert the intermediate dataType
  								} else if ( converters[ conv2 ] !== true ) {
  									current = tmp[ 0 ];
  									dataTypes.unshift( tmp[ 1 ] );
  								}
  								break;
  							}
  						}
  					}
  				}

  				// Apply converter (if not an equivalence)
  				if ( conv !== true ) {

  					// Unless errors are allowed to bubble, catch and return them
  					if ( conv && s.throws ) {
  						response = conv( response );
  					} else {
  						try {
  							response = conv( response );
  						} catch ( e ) {
  							return {
  								state: "parsererror",
  								error: conv ? e : "No conversion from " + prev + " to " + current
  							};
  						}
  					}
  				}
  			}
  		}
  	}

  	return { state: "success", data: response };
  }

  jQuery.extend( {

  	// Counter for holding the number of active queries
  	active: 0,

  	// Last-Modified header cache for next request
  	lastModified: {},
  	etag: {},

  	ajaxSettings: {
  		url: location.href,
  		type: "GET",
  		isLocal: rlocalProtocol.test( location.protocol ),
  		global: true,
  		processData: true,
  		async: true,
  		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

  		/*
  		timeout: 0,
  		data: null,
  		dataType: null,
  		username: null,
  		password: null,
  		cache: null,
  		throws: false,
  		traditional: false,
  		headers: {},
  		*/

  		accepts: {
  			"*": allTypes,
  			text: "text/plain",
  			html: "text/html",
  			xml: "application/xml, text/xml",
  			json: "application/json, text/javascript"
  		},

  		contents: {
  			xml: /\bxml\b/,
  			html: /\bhtml/,
  			json: /\bjson\b/
  		},

  		responseFields: {
  			xml: "responseXML",
  			text: "responseText",
  			json: "responseJSON"
  		},

  		// Data converters
  		// Keys separate source (or catchall "*") and destination types with a single space
  		converters: {

  			// Convert anything to text
  			"* text": String,

  			// Text to html (true = no transformation)
  			"text html": true,

  			// Evaluate text as a json expression
  			"text json": JSON.parse,

  			// Parse text as xml
  			"text xml": jQuery.parseXML
  		},

  		// For options that shouldn't be deep extended:
  		// you can add your own custom options here if
  		// and when you create one that shouldn't be
  		// deep extended (see ajaxExtend)
  		flatOptions: {
  			url: true,
  			context: true
  		}
  	},

  	// Creates a full fledged settings object into target
  	// with both ajaxSettings and settings fields.
  	// If target is omitted, writes into ajaxSettings.
  	ajaxSetup: function( target, settings ) {
  		return settings ?

  			// Building a settings object
  			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

  			// Extending ajaxSettings
  			ajaxExtend( jQuery.ajaxSettings, target );
  	},

  	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  	ajaxTransport: addToPrefiltersOrTransports( transports ),

  	// Main method
  	ajax: function( url, options ) {

  		// If url is an object, simulate pre-1.5 signature
  		if ( typeof url === "object" ) {
  			options = url;
  			url = undefined;
  		}

  		// Force options to be an object
  		options = options || {};

  		var transport,

  			// URL without anti-cache param
  			cacheURL,

  			// Response headers
  			responseHeadersString,
  			responseHeaders,

  			// timeout handle
  			timeoutTimer,

  			// Url cleanup var
  			urlAnchor,

  			// Request state (becomes false upon send and true upon completion)
  			completed,

  			// To know if global events are to be dispatched
  			fireGlobals,

  			// Loop variable
  			i,

  			// uncached part of the url
  			uncached,

  			// Create the final options object
  			s = jQuery.ajaxSetup( {}, options ),

  			// Callbacks context
  			callbackContext = s.context || s,

  			// Context for global events is callbackContext if it is a DOM node or jQuery collection
  			globalEventContext = s.context &&
  				( callbackContext.nodeType || callbackContext.jquery ) ?
  					jQuery( callbackContext ) :
  					jQuery.event,

  			// Deferreds
  			deferred = jQuery.Deferred(),
  			completeDeferred = jQuery.Callbacks( "once memory" ),

  			// Status-dependent callbacks
  			statusCode = s.statusCode || {},

  			// Headers (they are sent all at once)
  			requestHeaders = {},
  			requestHeadersNames = {},

  			// Default abort message
  			strAbort = "canceled",

  			// Fake xhr
  			jqXHR = {
  				readyState: 0,

  				// Builds headers hashtable if needed
  				getResponseHeader: function( key ) {
  					var match;
  					if ( completed ) {
  						if ( !responseHeaders ) {
  							responseHeaders = {};
  							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
  								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
  									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
  										.concat( match[ 2 ] );
  							}
  						}
  						match = responseHeaders[ key.toLowerCase() + " " ];
  					}
  					return match == null ? null : match.join( ", " );
  				},

  				// Raw string
  				getAllResponseHeaders: function() {
  					return completed ? responseHeadersString : null;
  				},

  				// Caches the header
  				setRequestHeader: function( name, value ) {
  					if ( completed == null ) {
  						name = requestHeadersNames[ name.toLowerCase() ] =
  							requestHeadersNames[ name.toLowerCase() ] || name;
  						requestHeaders[ name ] = value;
  					}
  					return this;
  				},

  				// Overrides response content-type header
  				overrideMimeType: function( type ) {
  					if ( completed == null ) {
  						s.mimeType = type;
  					}
  					return this;
  				},

  				// Status-dependent callbacks
  				statusCode: function( map ) {
  					var code;
  					if ( map ) {
  						if ( completed ) {

  							// Execute the appropriate callbacks
  							jqXHR.always( map[ jqXHR.status ] );
  						} else {

  							// Lazy-add the new callbacks in a way that preserves old ones
  							for ( code in map ) {
  								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
  							}
  						}
  					}
  					return this;
  				},

  				// Cancel the request
  				abort: function( statusText ) {
  					var finalText = statusText || strAbort;
  					if ( transport ) {
  						transport.abort( finalText );
  					}
  					done( 0, finalText );
  					return this;
  				}
  			};

  		// Attach deferreds
  		deferred.promise( jqXHR );

  		// Add protocol if not provided (prefilters might expect it)
  		// Handle falsy url in the settings object (#10093: consistency with old signature)
  		// We also use the url parameter if available
  		s.url = ( ( url || s.url || location.href ) + "" )
  			.replace( rprotocol, location.protocol + "//" );

  		// Alias method option to type as per ticket #12004
  		s.type = options.method || options.type || s.method || s.type;

  		// Extract dataTypes list
  		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

  		// A cross-domain request is in order when the origin doesn't match the current origin.
  		if ( s.crossDomain == null ) {
  			urlAnchor = document.createElement( "a" );

  			// Support: IE <=8 - 11, Edge 12 - 15
  			// IE throws exception on accessing the href property if url is malformed,
  			// e.g. http://example.com:80x/
  			try {
  				urlAnchor.href = s.url;

  				// Support: IE <=8 - 11 only
  				// Anchor's host property isn't correctly set when s.url is relative
  				urlAnchor.href = urlAnchor.href;
  				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
  					urlAnchor.protocol + "//" + urlAnchor.host;
  			} catch ( e ) {

  				// If there is an error parsing the URL, assume it is crossDomain,
  				// it can be rejected by the transport if it is invalid
  				s.crossDomain = true;
  			}
  		}

  		// Convert data if not already a string
  		if ( s.data && s.processData && typeof s.data !== "string" ) {
  			s.data = jQuery.param( s.data, s.traditional );
  		}

  		// Apply prefilters
  		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

  		// If request was aborted inside a prefilter, stop there
  		if ( completed ) {
  			return jqXHR;
  		}

  		// We can fire global events as of now if asked to
  		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
  		fireGlobals = jQuery.event && s.global;

  		// Watch for a new set of requests
  		if ( fireGlobals && jQuery.active++ === 0 ) {
  			jQuery.event.trigger( "ajaxStart" );
  		}

  		// Uppercase the type
  		s.type = s.type.toUpperCase();

  		// Determine if request has content
  		s.hasContent = !rnoContent.test( s.type );

  		// Save the URL in case we're toying with the If-Modified-Since
  		// and/or If-None-Match header later on
  		// Remove hash to simplify url manipulation
  		cacheURL = s.url.replace( rhash, "" );

  		// More options handling for requests with no content
  		if ( !s.hasContent ) {

  			// Remember the hash so we can put it back
  			uncached = s.url.slice( cacheURL.length );

  			// If data is available and should be processed, append data to url
  			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
  				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

  				// #9682: remove data so that it's not used in an eventual retry
  				delete s.data;
  			}

  			// Add or update anti-cache param if needed
  			if ( s.cache === false ) {
  				cacheURL = cacheURL.replace( rantiCache, "$1" );
  				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
  			}

  			// Put hash and anti-cache on the URL that will be requested (gh-1732)
  			s.url = cacheURL + uncached;

  		// Change '%20' to '+' if this is encoded form body content (gh-2658)
  		} else if ( s.data && s.processData &&
  			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
  			s.data = s.data.replace( r20, "+" );
  		}

  		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  		if ( s.ifModified ) {
  			if ( jQuery.lastModified[ cacheURL ] ) {
  				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
  			}
  			if ( jQuery.etag[ cacheURL ] ) {
  				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
  			}
  		}

  		// Set the correct header, if data is being sent
  		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
  			jqXHR.setRequestHeader( "Content-Type", s.contentType );
  		}

  		// Set the Accepts header for the server, depending on the dataType
  		jqXHR.setRequestHeader(
  			"Accept",
  			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
  				s.accepts[ s.dataTypes[ 0 ] ] +
  					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
  				s.accepts[ "*" ]
  		);

  		// Check for headers option
  		for ( i in s.headers ) {
  			jqXHR.setRequestHeader( i, s.headers[ i ] );
  		}

  		// Allow custom headers/mimetypes and early abort
  		if ( s.beforeSend &&
  			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

  			// Abort if not done already and return
  			return jqXHR.abort();
  		}

  		// Aborting is no longer a cancellation
  		strAbort = "abort";

  		// Install callbacks on deferreds
  		completeDeferred.add( s.complete );
  		jqXHR.done( s.success );
  		jqXHR.fail( s.error );

  		// Get transport
  		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

  		// If no transport, we auto-abort
  		if ( !transport ) {
  			done( -1, "No Transport" );
  		} else {
  			jqXHR.readyState = 1;

  			// Send global event
  			if ( fireGlobals ) {
  				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
  			}

  			// If request was aborted inside ajaxSend, stop there
  			if ( completed ) {
  				return jqXHR;
  			}

  			// Timeout
  			if ( s.async && s.timeout > 0 ) {
  				timeoutTimer = window.setTimeout( function() {
  					jqXHR.abort( "timeout" );
  				}, s.timeout );
  			}

  			try {
  				completed = false;
  				transport.send( requestHeaders, done );
  			} catch ( e ) {

  				// Rethrow post-completion exceptions
  				if ( completed ) {
  					throw e;
  				}

  				// Propagate others as results
  				done( -1, e );
  			}
  		}

  		// Callback for when everything is done
  		function done( status, nativeStatusText, responses, headers ) {
  			var isSuccess, success, error, response, modified,
  				statusText = nativeStatusText;

  			// Ignore repeat invocations
  			if ( completed ) {
  				return;
  			}

  			completed = true;

  			// Clear timeout if it exists
  			if ( timeoutTimer ) {
  				window.clearTimeout( timeoutTimer );
  			}

  			// Dereference transport for early garbage collection
  			// (no matter how long the jqXHR object will be used)
  			transport = undefined;

  			// Cache response headers
  			responseHeadersString = headers || "";

  			// Set readyState
  			jqXHR.readyState = status > 0 ? 4 : 0;

  			// Determine if successful
  			isSuccess = status >= 200 && status < 300 || status === 304;

  			// Get response data
  			if ( responses ) {
  				response = ajaxHandleResponses( s, jqXHR, responses );
  			}

  			// Convert no matter what (that way responseXXX fields are always set)
  			response = ajaxConvert( s, response, jqXHR, isSuccess );

  			// If successful, handle type chaining
  			if ( isSuccess ) {

  				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  				if ( s.ifModified ) {
  					modified = jqXHR.getResponseHeader( "Last-Modified" );
  					if ( modified ) {
  						jQuery.lastModified[ cacheURL ] = modified;
  					}
  					modified = jqXHR.getResponseHeader( "etag" );
  					if ( modified ) {
  						jQuery.etag[ cacheURL ] = modified;
  					}
  				}

  				// if no content
  				if ( status === 204 || s.type === "HEAD" ) {
  					statusText = "nocontent";

  				// if not modified
  				} else if ( status === 304 ) {
  					statusText = "notmodified";

  				// If we have data, let's convert it
  				} else {
  					statusText = response.state;
  					success = response.data;
  					error = response.error;
  					isSuccess = !error;
  				}
  			} else {

  				// Extract error from statusText and normalize for non-aborts
  				error = statusText;
  				if ( status || !statusText ) {
  					statusText = "error";
  					if ( status < 0 ) {
  						status = 0;
  					}
  				}
  			}

  			// Set data for the fake xhr object
  			jqXHR.status = status;
  			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

  			// Success/Error
  			if ( isSuccess ) {
  				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
  			} else {
  				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
  			}

  			// Status-dependent callbacks
  			jqXHR.statusCode( statusCode );
  			statusCode = undefined;

  			if ( fireGlobals ) {
  				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
  					[ jqXHR, s, isSuccess ? success : error ] );
  			}

  			// Complete
  			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

  			if ( fireGlobals ) {
  				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

  				// Handle the global AJAX counter
  				if ( !( --jQuery.active ) ) {
  					jQuery.event.trigger( "ajaxStop" );
  				}
  			}
  		}

  		return jqXHR;
  	},

  	getJSON: function( url, data, callback ) {
  		return jQuery.get( url, data, callback, "json" );
  	},

  	getScript: function( url, callback ) {
  		return jQuery.get( url, undefined, callback, "script" );
  	}
  } );

  jQuery.each( [ "get", "post" ], function( i, method ) {
  	jQuery[ method ] = function( url, data, callback, type ) {

  		// Shift arguments if data argument was omitted
  		if ( isFunction( data ) ) {
  			type = type || callback;
  			callback = data;
  			data = undefined;
  		}

  		// The url can be an options object (which then must have .url)
  		return jQuery.ajax( jQuery.extend( {
  			url: url,
  			type: method,
  			dataType: type,
  			data: data,
  			success: callback
  		}, jQuery.isPlainObject( url ) && url ) );
  	};
  } );


  jQuery._evalUrl = function( url, options ) {
  	return jQuery.ajax( {
  		url: url,

  		// Make this explicit, since user can override this through ajaxSetup (#11264)
  		type: "GET",
  		dataType: "script",
  		cache: true,
  		async: false,
  		global: false,

  		// Only evaluate the response if it is successful (gh-4126)
  		// dataFilter is not invoked for failure responses, so using it instead
  		// of the default converter is kludgy but it works.
  		converters: {
  			"text script": function() {}
  		},
  		dataFilter: function( response ) {
  			jQuery.globalEval( response, options );
  		}
  	} );
  };


  jQuery.fn.extend( {
  	wrapAll: function( html ) {
  		var wrap;

  		if ( this[ 0 ] ) {
  			if ( isFunction( html ) ) {
  				html = html.call( this[ 0 ] );
  			}

  			// The elements to wrap the target around
  			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

  			if ( this[ 0 ].parentNode ) {
  				wrap.insertBefore( this[ 0 ] );
  			}

  			wrap.map( function() {
  				var elem = this;

  				while ( elem.firstElementChild ) {
  					elem = elem.firstElementChild;
  				}

  				return elem;
  			} ).append( this );
  		}

  		return this;
  	},

  	wrapInner: function( html ) {
  		if ( isFunction( html ) ) {
  			return this.each( function( i ) {
  				jQuery( this ).wrapInner( html.call( this, i ) );
  			} );
  		}

  		return this.each( function() {
  			var self = jQuery( this ),
  				contents = self.contents();

  			if ( contents.length ) {
  				contents.wrapAll( html );

  			} else {
  				self.append( html );
  			}
  		} );
  	},

  	wrap: function( html ) {
  		var htmlIsFunction = isFunction( html );

  		return this.each( function( i ) {
  			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
  		} );
  	},

  	unwrap: function( selector ) {
  		this.parent( selector ).not( "body" ).each( function() {
  			jQuery( this ).replaceWith( this.childNodes );
  		} );
  		return this;
  	}
  } );


  jQuery.expr.pseudos.hidden = function( elem ) {
  	return !jQuery.expr.pseudos.visible( elem );
  };
  jQuery.expr.pseudos.visible = function( elem ) {
  	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
  };




  jQuery.ajaxSettings.xhr = function() {
  	try {
  		return new window.XMLHttpRequest();
  	} catch ( e ) {}
  };

  var xhrSuccessStatus = {

  		// File protocol always yields status code 0, assume 200
  		0: 200,

  		// Support: IE <=9 only
  		// #1450: sometimes IE returns 1223 when it should be 204
  		1223: 204
  	},
  	xhrSupported = jQuery.ajaxSettings.xhr();

  support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
  support.ajax = xhrSupported = !!xhrSupported;

  jQuery.ajaxTransport( function( options ) {
  	var callback, errorCallback;

  	// Cross domain only allowed if supported through XMLHttpRequest
  	if ( support.cors || xhrSupported && !options.crossDomain ) {
  		return {
  			send: function( headers, complete ) {
  				var i,
  					xhr = options.xhr();

  				xhr.open(
  					options.type,
  					options.url,
  					options.async,
  					options.username,
  					options.password
  				);

  				// Apply custom fields if provided
  				if ( options.xhrFields ) {
  					for ( i in options.xhrFields ) {
  						xhr[ i ] = options.xhrFields[ i ];
  					}
  				}

  				// Override mime type if needed
  				if ( options.mimeType && xhr.overrideMimeType ) {
  					xhr.overrideMimeType( options.mimeType );
  				}

  				// X-Requested-With header
  				// For cross-domain requests, seeing as conditions for a preflight are
  				// akin to a jigsaw puzzle, we simply never set it to be sure.
  				// (it can always be set on a per-request basis or even using ajaxSetup)
  				// For same-domain requests, won't change header if already provided.
  				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
  					headers[ "X-Requested-With" ] = "XMLHttpRequest";
  				}

  				// Set headers
  				for ( i in headers ) {
  					xhr.setRequestHeader( i, headers[ i ] );
  				}

  				// Callback
  				callback = function( type ) {
  					return function() {
  						if ( callback ) {
  							callback = errorCallback = xhr.onload =
  								xhr.onerror = xhr.onabort = xhr.ontimeout =
  									xhr.onreadystatechange = null;

  							if ( type === "abort" ) {
  								xhr.abort();
  							} else if ( type === "error" ) {

  								// Support: IE <=9 only
  								// On a manual native abort, IE9 throws
  								// errors on any property access that is not readyState
  								if ( typeof xhr.status !== "number" ) {
  									complete( 0, "error" );
  								} else {
  									complete(

  										// File: protocol always yields status 0; see #8605, #14207
  										xhr.status,
  										xhr.statusText
  									);
  								}
  							} else {
  								complete(
  									xhrSuccessStatus[ xhr.status ] || xhr.status,
  									xhr.statusText,

  									// Support: IE <=9 only
  									// IE9 has no XHR2 but throws on binary (trac-11426)
  									// For XHR2 non-text, let the caller handle it (gh-2498)
  									( xhr.responseType || "text" ) !== "text"  ||
  									typeof xhr.responseText !== "string" ?
  										{ binary: xhr.response } :
  										{ text: xhr.responseText },
  									xhr.getAllResponseHeaders()
  								);
  							}
  						}
  					};
  				};

  				// Listen to events
  				xhr.onload = callback();
  				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

  				// Support: IE 9 only
  				// Use onreadystatechange to replace onabort
  				// to handle uncaught aborts
  				if ( xhr.onabort !== undefined ) {
  					xhr.onabort = errorCallback;
  				} else {
  					xhr.onreadystatechange = function() {

  						// Check readyState before timeout as it changes
  						if ( xhr.readyState === 4 ) {

  							// Allow onerror to be called first,
  							// but that will not handle a native abort
  							// Also, save errorCallback to a variable
  							// as xhr.onerror cannot be accessed
  							window.setTimeout( function() {
  								if ( callback ) {
  									errorCallback();
  								}
  							} );
  						}
  					};
  				}

  				// Create the abort callback
  				callback = callback( "abort" );

  				try {

  					// Do send the request (this may raise an exception)
  					xhr.send( options.hasContent && options.data || null );
  				} catch ( e ) {

  					// #14683: Only rethrow if this hasn't been notified as an error yet
  					if ( callback ) {
  						throw e;
  					}
  				}
  			},

  			abort: function() {
  				if ( callback ) {
  					callback();
  				}
  			}
  		};
  	}
  } );




  // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
  jQuery.ajaxPrefilter( function( s ) {
  	if ( s.crossDomain ) {
  		s.contents.script = false;
  	}
  } );

  // Install script dataType
  jQuery.ajaxSetup( {
  	accepts: {
  		script: "text/javascript, application/javascript, " +
  			"application/ecmascript, application/x-ecmascript"
  	},
  	contents: {
  		script: /\b(?:java|ecma)script\b/
  	},
  	converters: {
  		"text script": function( text ) {
  			jQuery.globalEval( text );
  			return text;
  		}
  	}
  } );

  // Handle cache's special case and crossDomain
  jQuery.ajaxPrefilter( "script", function( s ) {
  	if ( s.cache === undefined ) {
  		s.cache = false;
  	}
  	if ( s.crossDomain ) {
  		s.type = "GET";
  	}
  } );

  // Bind script tag hack transport
  jQuery.ajaxTransport( "script", function( s ) {

  	// This transport only deals with cross domain or forced-by-attrs requests
  	if ( s.crossDomain || s.scriptAttrs ) {
  		var script, callback;
  		return {
  			send: function( _, complete ) {
  				script = jQuery( "<script>" )
  					.attr( s.scriptAttrs || {} )
  					.prop( { charset: s.scriptCharset, src: s.url } )
  					.on( "load error", callback = function( evt ) {
  						script.remove();
  						callback = null;
  						if ( evt ) {
  							complete( evt.type === "error" ? 404 : 200, evt.type );
  						}
  					} );

  				// Use native DOM manipulation to avoid our domManip AJAX trickery
  				document.head.appendChild( script[ 0 ] );
  			},
  			abort: function() {
  				if ( callback ) {
  					callback();
  				}
  			}
  		};
  	}
  } );




  var oldCallbacks = [],
  	rjsonp = /(=)\?(?=&|$)|\?\?/;

  // Default jsonp settings
  jQuery.ajaxSetup( {
  	jsonp: "callback",
  	jsonpCallback: function() {
  		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
  		this[ callback ] = true;
  		return callback;
  	}
  } );

  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  	var callbackName, overwritten, responseContainer,
  		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
  			"url" :
  			typeof s.data === "string" &&
  				( s.contentType || "" )
  					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
  				rjsonp.test( s.data ) && "data"
  		);

  	// Handle iff the expected data type is "jsonp" or we have a parameter to set
  	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

  		// Get callback name, remembering preexisting value associated with it
  		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
  			s.jsonpCallback() :
  			s.jsonpCallback;

  		// Insert callback into url or form data
  		if ( jsonProp ) {
  			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
  		} else if ( s.jsonp !== false ) {
  			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
  		}

  		// Use data converter to retrieve json after script execution
  		s.converters[ "script json" ] = function() {
  			if ( !responseContainer ) {
  				jQuery.error( callbackName + " was not called" );
  			}
  			return responseContainer[ 0 ];
  		};

  		// Force json dataType
  		s.dataTypes[ 0 ] = "json";

  		// Install callback
  		overwritten = window[ callbackName ];
  		window[ callbackName ] = function() {
  			responseContainer = arguments;
  		};

  		// Clean-up function (fires after converters)
  		jqXHR.always( function() {

  			// If previous value didn't exist - remove it
  			if ( overwritten === undefined ) {
  				jQuery( window ).removeProp( callbackName );

  			// Otherwise restore preexisting value
  			} else {
  				window[ callbackName ] = overwritten;
  			}

  			// Save back as free
  			if ( s[ callbackName ] ) {

  				// Make sure that re-using the options doesn't screw things around
  				s.jsonpCallback = originalSettings.jsonpCallback;

  				// Save the callback name for future use
  				oldCallbacks.push( callbackName );
  			}

  			// Call if it was a function and we have a response
  			if ( responseContainer && isFunction( overwritten ) ) {
  				overwritten( responseContainer[ 0 ] );
  			}

  			responseContainer = overwritten = undefined;
  		} );

  		// Delegate to script
  		return "script";
  	}
  } );




  // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337
  support.createHTMLDocument = ( function() {
  	var body = document.implementation.createHTMLDocument( "" ).body;
  	body.innerHTML = "<form></form><form></form>";
  	return body.childNodes.length === 2;
  } )();


  // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function( data, context, keepScripts ) {
  	if ( typeof data !== "string" ) {
  		return [];
  	}
  	if ( typeof context === "boolean" ) {
  		keepScripts = context;
  		context = false;
  	}

  	var base, parsed, scripts;

  	if ( !context ) {

  		// Stop scripts or inline event handlers from being executed immediately
  		// by using document.implementation
  		if ( support.createHTMLDocument ) {
  			context = document.implementation.createHTMLDocument( "" );

  			// Set the base href for the created document
  			// so any parsed elements with URLs
  			// are based on the document's URL (gh-2965)
  			base = context.createElement( "base" );
  			base.href = document.location.href;
  			context.head.appendChild( base );
  		} else {
  			context = document;
  		}
  	}

  	parsed = rsingleTag.exec( data );
  	scripts = !keepScripts && [];

  	// Single tag
  	if ( parsed ) {
  		return [ context.createElement( parsed[ 1 ] ) ];
  	}

  	parsed = buildFragment( [ data ], context, scripts );

  	if ( scripts && scripts.length ) {
  		jQuery( scripts ).remove();
  	}

  	return jQuery.merge( [], parsed.childNodes );
  };


  /**
   * Load a url into a page
   */
  jQuery.fn.load = function( url, params, callback ) {
  	var selector, type, response,
  		self = this,
  		off = url.indexOf( " " );

  	if ( off > -1 ) {
  		selector = stripAndCollapse( url.slice( off ) );
  		url = url.slice( 0, off );
  	}

  	// If it's a function
  	if ( isFunction( params ) ) {

  		// We assume that it's the callback
  		callback = params;
  		params = undefined;

  	// Otherwise, build a param string
  	} else if ( params && typeof params === "object" ) {
  		type = "POST";
  	}

  	// If we have elements to modify, make the request
  	if ( self.length > 0 ) {
  		jQuery.ajax( {
  			url: url,

  			// If "type" variable is undefined, then "GET" method will be used.
  			// Make value of this field explicit since
  			// user can override it through ajaxSetup method
  			type: type || "GET",
  			dataType: "html",
  			data: params
  		} ).done( function( responseText ) {

  			// Save response for use in complete callback
  			response = arguments;

  			self.html( selector ?

  				// If a selector was specified, locate the right elements in a dummy div
  				// Exclude scripts to avoid IE 'Permission Denied' errors
  				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

  				// Otherwise use the full result
  				responseText );

  		// If the request succeeds, this function gets "data", "status", "jqXHR"
  		// but they are ignored because response was set above.
  		// If it fails, this function gets "jqXHR", "status", "error"
  		} ).always( callback && function( jqXHR, status ) {
  			self.each( function() {
  				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
  			} );
  		} );
  	}

  	return this;
  };




  // Attach a bunch of functions for handling common AJAX events
  jQuery.each( [
  	"ajaxStart",
  	"ajaxStop",
  	"ajaxComplete",
  	"ajaxError",
  	"ajaxSuccess",
  	"ajaxSend"
  ], function( i, type ) {
  	jQuery.fn[ type ] = function( fn ) {
  		return this.on( type, fn );
  	};
  } );




  jQuery.expr.pseudos.animated = function( elem ) {
  	return jQuery.grep( jQuery.timers, function( fn ) {
  		return elem === fn.elem;
  	} ).length;
  };




  jQuery.offset = {
  	setOffset: function( elem, options, i ) {
  		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
  			position = jQuery.css( elem, "position" ),
  			curElem = jQuery( elem ),
  			props = {};

  		// Set position first, in-case top/left are set even on static elem
  		if ( position === "static" ) {
  			elem.style.position = "relative";
  		}

  		curOffset = curElem.offset();
  		curCSSTop = jQuery.css( elem, "top" );
  		curCSSLeft = jQuery.css( elem, "left" );
  		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
  			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

  		// Need to be able to calculate position if either
  		// top or left is auto and position is either absolute or fixed
  		if ( calculatePosition ) {
  			curPosition = curElem.position();
  			curTop = curPosition.top;
  			curLeft = curPosition.left;

  		} else {
  			curTop = parseFloat( curCSSTop ) || 0;
  			curLeft = parseFloat( curCSSLeft ) || 0;
  		}

  		if ( isFunction( options ) ) {

  			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
  			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
  		}

  		if ( options.top != null ) {
  			props.top = ( options.top - curOffset.top ) + curTop;
  		}
  		if ( options.left != null ) {
  			props.left = ( options.left - curOffset.left ) + curLeft;
  		}

  		if ( "using" in options ) {
  			options.using.call( elem, props );

  		} else {
  			curElem.css( props );
  		}
  	}
  };

  jQuery.fn.extend( {

  	// offset() relates an element's border box to the document origin
  	offset: function( options ) {

  		// Preserve chaining for setter
  		if ( arguments.length ) {
  			return options === undefined ?
  				this :
  				this.each( function( i ) {
  					jQuery.offset.setOffset( this, options, i );
  				} );
  		}

  		var rect, win,
  			elem = this[ 0 ];

  		if ( !elem ) {
  			return;
  		}

  		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  		// Support: IE <=11 only
  		// Running getBoundingClientRect on a
  		// disconnected node in IE throws an error
  		if ( !elem.getClientRects().length ) {
  			return { top: 0, left: 0 };
  		}

  		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
  		rect = elem.getBoundingClientRect();
  		win = elem.ownerDocument.defaultView;
  		return {
  			top: rect.top + win.pageYOffset,
  			left: rect.left + win.pageXOffset
  		};
  	},

  	// position() relates an element's margin box to its offset parent's padding box
  	// This corresponds to the behavior of CSS absolute positioning
  	position: function() {
  		if ( !this[ 0 ] ) {
  			return;
  		}

  		var offsetParent, offset, doc,
  			elem = this[ 0 ],
  			parentOffset = { top: 0, left: 0 };

  		// position:fixed elements are offset from the viewport, which itself always has zero offset
  		if ( jQuery.css( elem, "position" ) === "fixed" ) {

  			// Assume position:fixed implies availability of getBoundingClientRect
  			offset = elem.getBoundingClientRect();

  		} else {
  			offset = this.offset();

  			// Account for the *real* offset parent, which can be the document or its root element
  			// when a statically positioned element is identified
  			doc = elem.ownerDocument;
  			offsetParent = elem.offsetParent || doc.documentElement;
  			while ( offsetParent &&
  				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
  				jQuery.css( offsetParent, "position" ) === "static" ) {

  				offsetParent = offsetParent.parentNode;
  			}
  			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

  				// Incorporate borders into its offset, since they are outside its content origin
  				parentOffset = jQuery( offsetParent ).offset();
  				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
  				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
  			}
  		}

  		// Subtract parent offsets and element margins
  		return {
  			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
  			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
  		};
  	},

  	// This method will return documentElement in the following cases:
  	// 1) For the element inside the iframe without offsetParent, this method will return
  	//    documentElement of the parent window
  	// 2) For the hidden or detached element
  	// 3) For body or html element, i.e. in case of the html node - it will return itself
  	//
  	// but those exceptions were never presented as a real life use-cases
  	// and might be considered as more preferable results.
  	//
  	// This logic, however, is not guaranteed and can change at any point in the future
  	offsetParent: function() {
  		return this.map( function() {
  			var offsetParent = this.offsetParent;

  			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
  				offsetParent = offsetParent.offsetParent;
  			}

  			return offsetParent || documentElement;
  		} );
  	}
  } );

  // Create scrollLeft and scrollTop methods
  jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  	var top = "pageYOffset" === prop;

  	jQuery.fn[ method ] = function( val ) {
  		return access( this, function( elem, method, val ) {

  			// Coalesce documents and windows
  			var win;
  			if ( isWindow( elem ) ) {
  				win = elem;
  			} else if ( elem.nodeType === 9 ) {
  				win = elem.defaultView;
  			}

  			if ( val === undefined ) {
  				return win ? win[ prop ] : elem[ method ];
  			}

  			if ( win ) {
  				win.scrollTo(
  					!top ? val : win.pageXOffset,
  					top ? val : win.pageYOffset
  				);

  			} else {
  				elem[ method ] = val;
  			}
  		}, method, val, arguments.length );
  	};
  } );

  // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each( [ "top", "left" ], function( i, prop ) {
  	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
  		function( elem, computed ) {
  			if ( computed ) {
  				computed = curCSS( elem, prop );

  				// If curCSS returns percentage, fallback to offset
  				return rnumnonpx.test( computed ) ?
  					jQuery( elem ).position()[ prop ] + "px" :
  					computed;
  			}
  		}
  	);
  } );


  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
  		function( defaultExtra, funcName ) {

  		// Margin is only for outerHeight, outerWidth
  		jQuery.fn[ funcName ] = function( margin, value ) {
  			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
  				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

  			return access( this, function( elem, type, value ) {
  				var doc;

  				if ( isWindow( elem ) ) {

  					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
  					return funcName.indexOf( "outer" ) === 0 ?
  						elem[ "inner" + name ] :
  						elem.document.documentElement[ "client" + name ];
  				}

  				// Get document width or height
  				if ( elem.nodeType === 9 ) {
  					doc = elem.documentElement;

  					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
  					// whichever is greatest
  					return Math.max(
  						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
  						elem.body[ "offset" + name ], doc[ "offset" + name ],
  						doc[ "client" + name ]
  					);
  				}

  				return value === undefined ?

  					// Get width or height on the element, requesting but not forcing parseFloat
  					jQuery.css( elem, type, extra ) :

  					// Set width or height on the element
  					jQuery.style( elem, type, value, extra );
  			}, type, chainable ? margin : undefined, chainable );
  		};
  	} );
  } );


  jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
  	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
  	function( i, name ) {

  	// Handle event binding
  	jQuery.fn[ name ] = function( data, fn ) {
  		return arguments.length > 0 ?
  			this.on( name, null, data, fn ) :
  			this.trigger( name );
  	};
  } );

  jQuery.fn.extend( {
  	hover: function( fnOver, fnOut ) {
  		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  	}
  } );




  jQuery.fn.extend( {

  	bind: function( types, data, fn ) {
  		return this.on( types, null, data, fn );
  	},
  	unbind: function( types, fn ) {
  		return this.off( types, null, fn );
  	},

  	delegate: function( selector, types, data, fn ) {
  		return this.on( types, selector, data, fn );
  	},
  	undelegate: function( selector, types, fn ) {

  		// ( namespace ) or ( selector, types [, fn] )
  		return arguments.length === 1 ?
  			this.off( selector, "**" ) :
  			this.off( types, selector || "**", fn );
  	}
  } );

  // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon
  jQuery.proxy = function( fn, context ) {
  	var tmp, args, proxy;

  	if ( typeof context === "string" ) {
  		tmp = fn[ context ];
  		context = fn;
  		fn = tmp;
  	}

  	// Quick check to determine if target is callable, in the spec
  	// this throws a TypeError, but we will just return undefined.
  	if ( !isFunction( fn ) ) {
  		return undefined;
  	}

  	// Simulated bind
  	args = slice.call( arguments, 2 );
  	proxy = function() {
  		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
  	};

  	// Set the guid of unique handler to the same of original handler, so it can be removed
  	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  	return proxy;
  };

  jQuery.holdReady = function( hold ) {
  	if ( hold ) {
  		jQuery.readyWait++;
  	} else {
  		jQuery.ready( true );
  	}
  };
  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;

  jQuery.now = Date.now;

  jQuery.isNumeric = function( obj ) {

  	// As of jQuery 3.0, isNumeric is limited to
  	// strings and numbers (primitives or objects)
  	// that can be coerced to finite numbers (gh-2662)
  	var type = jQuery.type( obj );
  	return ( type === "number" || type === "string" ) &&

  		// parseFloat NaNs numeric-cast false positives ("")
  		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
  		// subtraction forces infinities to NaN
  		!isNaN( obj - parseFloat( obj ) );
  };




  var

  	// Map over jQuery in case of overwrite
  	_jQuery = window.jQuery,

  	// Map over the $ in case of overwrite
  	_$ = window.$;

  jQuery.noConflict = function( deep ) {
  	if ( window.$ === jQuery ) {
  		window.$ = _$;
  	}

  	if ( deep && window.jQuery === jQuery ) {
  		window.jQuery = _jQuery;
  	}

  	return jQuery;
  };

  // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if ( !noGlobal ) {
  	window.jQuery = window.$ = jQuery;
  }




  return jQuery;
  } );
  });
  var jquery_1 = jquery.$;
  var jquery_2 = jquery.jquery;
  var jquery_3 = jquery.jQuery;

  var bootstrap = createCommonjsModule(function (module, exports) {
  /*!
    * Bootstrap v4.3.1 (https://getbootstrap.com/)
    * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
    */
  (function (global, factory) {
    factory(exports, jquery, Popper);
  }(commonjsGlobal, function (exports, $, Popper) {
    $ = $ && $.hasOwnProperty('default') ? $['default'] : $;
    Popper = Popper && Popper.hasOwnProperty('default') ? Popper['default'] : Popper;

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);

        if (typeof Object.getOwnPropertySymbols === 'function') {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }

        ownKeys.forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      }

      return target;
    }

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    /**
     * --------------------------------------------------------------------------
     * Bootstrap (v4.3.1): util.js
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * --------------------------------------------------------------------------
     */
    /**
     * ------------------------------------------------------------------------
     * Private TransitionEnd Helpers
     * ------------------------------------------------------------------------
     */

    var TRANSITION_END = 'transitionend';
    var MAX_UID = 1000000;
    var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

    function toType(obj) {
      return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
    }

    function getSpecialTransitionEndEvent() {
      return {
        bindType: TRANSITION_END,
        delegateType: TRANSITION_END,
        handle: function handle(event) {
          if ($(event.target).is(this)) {
            return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
          }

          return undefined; // eslint-disable-line no-undefined
        }
      };
    }

    function transitionEndEmulator(duration) {
      var _this = this;

      var called = false;
      $(this).one(Util.TRANSITION_END, function () {
        called = true;
      });
      setTimeout(function () {
        if (!called) {
          Util.triggerTransitionEnd(_this);
        }
      }, duration);
      return this;
    }

    function setTransitionEndSupport() {
      $.fn.emulateTransitionEnd = transitionEndEmulator;
      $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
    }
    /**
     * --------------------------------------------------------------------------
     * Public Util Api
     * --------------------------------------------------------------------------
     */


    var Util = {
      TRANSITION_END: 'bsTransitionEnd',
      getUID: function getUID(prefix) {
        do {
          // eslint-disable-next-line no-bitwise
          prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
        } while (document.getElementById(prefix));

        return prefix;
      },
      getSelectorFromElement: function getSelectorFromElement(element) {
        var selector = element.getAttribute('data-target');

        if (!selector || selector === '#') {
          var hrefAttr = element.getAttribute('href');
          selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
        }

        try {
          return document.querySelector(selector) ? selector : null;
        } catch (err) {
          return null;
        }
      },
      getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
        if (!element) {
          return 0;
        } // Get transition-duration of the element


        var transitionDuration = $(element).css('transition-duration');
        var transitionDelay = $(element).css('transition-delay');
        var floatTransitionDuration = parseFloat(transitionDuration);
        var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

        if (!floatTransitionDuration && !floatTransitionDelay) {
          return 0;
        } // If multiple durations are defined, take the first


        transitionDuration = transitionDuration.split(',')[0];
        transitionDelay = transitionDelay.split(',')[0];
        return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
      },
      reflow: function reflow(element) {
        return element.offsetHeight;
      },
      triggerTransitionEnd: function triggerTransitionEnd(element) {
        $(element).trigger(TRANSITION_END);
      },
      // TODO: Remove in v5
      supportsTransitionEnd: function supportsTransitionEnd() {
        return Boolean(TRANSITION_END);
      },
      isElement: function isElement(obj) {
        return (obj[0] || obj).nodeType;
      },
      typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
        for (var property in configTypes) {
          if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
            var expectedTypes = configTypes[property];
            var value = config[property];
            var valueType = value && Util.isElement(value) ? 'element' : toType(value);

            if (!new RegExp(expectedTypes).test(valueType)) {
              throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
            }
          }
        }
      },
      findShadowRoot: function findShadowRoot(element) {
        if (!document.documentElement.attachShadow) {
          return null;
        } // Can find the shadow root otherwise it'll return the document


        if (typeof element.getRootNode === 'function') {
          var root = element.getRootNode();
          return root instanceof ShadowRoot ? root : null;
        }

        if (element instanceof ShadowRoot) {
          return element;
        } // when we don't find a shadow root


        if (!element.parentNode) {
          return null;
        }

        return Util.findShadowRoot(element.parentNode);
      }
    };
    setTransitionEndSupport();

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME = 'alert';
    var VERSION = '4.3.1';
    var DATA_KEY = 'bs.alert';
    var EVENT_KEY = "." + DATA_KEY;
    var DATA_API_KEY = '.data-api';
    var JQUERY_NO_CONFLICT = $.fn[NAME];
    var Selector = {
      DISMISS: '[data-dismiss="alert"]'
    };
    var Event = {
      CLOSE: "close" + EVENT_KEY,
      CLOSED: "closed" + EVENT_KEY,
      CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
    };
    var ClassName = {
      ALERT: 'alert',
      FADE: 'fade',
      SHOW: 'show'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Alert =
    /*#__PURE__*/
    function () {
      function Alert(element) {
        this._element = element;
      } // Getters


      var _proto = Alert.prototype;

      // Public
      _proto.close = function close(element) {
        var rootElement = this._element;

        if (element) {
          rootElement = this._getRootElement(element);
        }

        var customEvent = this._triggerCloseEvent(rootElement);

        if (customEvent.isDefaultPrevented()) {
          return;
        }

        this._removeElement(rootElement);
      };

      _proto.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY);
        this._element = null;
      } // Private
      ;

      _proto._getRootElement = function _getRootElement(element) {
        var selector = Util.getSelectorFromElement(element);
        var parent = false;

        if (selector) {
          parent = document.querySelector(selector);
        }

        if (!parent) {
          parent = $(element).closest("." + ClassName.ALERT)[0];
        }

        return parent;
      };

      _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
        var closeEvent = $.Event(Event.CLOSE);
        $(element).trigger(closeEvent);
        return closeEvent;
      };

      _proto._removeElement = function _removeElement(element) {
        var _this = this;

        $(element).removeClass(ClassName.SHOW);

        if (!$(element).hasClass(ClassName.FADE)) {
          this._destroyElement(element);

          return;
        }

        var transitionDuration = Util.getTransitionDurationFromElement(element);
        $(element).one(Util.TRANSITION_END, function (event) {
          return _this._destroyElement(element, event);
        }).emulateTransitionEnd(transitionDuration);
      };

      _proto._destroyElement = function _destroyElement(element) {
        $(element).detach().trigger(Event.CLOSED).remove();
      } // Static
      ;

      Alert._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $element = $(this);
          var data = $element.data(DATA_KEY);

          if (!data) {
            data = new Alert(this);
            $element.data(DATA_KEY, data);
          }

          if (config === 'close') {
            data[config](this);
          }
        });
      };

      Alert._handleDismiss = function _handleDismiss(alertInstance) {
        return function (event) {
          if (event) {
            event.preventDefault();
          }

          alertInstance.close(this);
        };
      };

      _createClass(Alert, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION;
        }
      }]);

      return Alert;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME] = Alert._jQueryInterface;
    $.fn[NAME].Constructor = Alert;

    $.fn[NAME].noConflict = function () {
      $.fn[NAME] = JQUERY_NO_CONFLICT;
      return Alert._jQueryInterface;
    };

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$1 = 'button';
    var VERSION$1 = '4.3.1';
    var DATA_KEY$1 = 'bs.button';
    var EVENT_KEY$1 = "." + DATA_KEY$1;
    var DATA_API_KEY$1 = '.data-api';
    var JQUERY_NO_CONFLICT$1 = $.fn[NAME$1];
    var ClassName$1 = {
      ACTIVE: 'active',
      BUTTON: 'btn',
      FOCUS: 'focus'
    };
    var Selector$1 = {
      DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
      DATA_TOGGLE: '[data-toggle="buttons"]',
      INPUT: 'input:not([type="hidden"])',
      ACTIVE: '.active',
      BUTTON: '.btn'
    };
    var Event$1 = {
      CLICK_DATA_API: "click" + EVENT_KEY$1 + DATA_API_KEY$1,
      FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY$1 + DATA_API_KEY$1 + " " + ("blur" + EVENT_KEY$1 + DATA_API_KEY$1)
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Button =
    /*#__PURE__*/
    function () {
      function Button(element) {
        this._element = element;
      } // Getters


      var _proto = Button.prototype;

      // Public
      _proto.toggle = function toggle() {
        var triggerChangeEvent = true;
        var addAriaPressed = true;
        var rootElement = $(this._element).closest(Selector$1.DATA_TOGGLE)[0];

        if (rootElement) {
          var input = this._element.querySelector(Selector$1.INPUT);

          if (input) {
            if (input.type === 'radio') {
              if (input.checked && this._element.classList.contains(ClassName$1.ACTIVE)) {
                triggerChangeEvent = false;
              } else {
                var activeElement = rootElement.querySelector(Selector$1.ACTIVE);

                if (activeElement) {
                  $(activeElement).removeClass(ClassName$1.ACTIVE);
                }
              }
            }

            if (triggerChangeEvent) {
              if (input.hasAttribute('disabled') || rootElement.hasAttribute('disabled') || input.classList.contains('disabled') || rootElement.classList.contains('disabled')) {
                return;
              }

              input.checked = !this._element.classList.contains(ClassName$1.ACTIVE);
              $(input).trigger('change');
            }

            input.focus();
            addAriaPressed = false;
          }
        }

        if (addAriaPressed) {
          this._element.setAttribute('aria-pressed', !this._element.classList.contains(ClassName$1.ACTIVE));
        }

        if (triggerChangeEvent) {
          $(this._element).toggleClass(ClassName$1.ACTIVE);
        }
      };

      _proto.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY$1);
        this._element = null;
      } // Static
      ;

      Button._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY$1);

          if (!data) {
            data = new Button(this);
            $(this).data(DATA_KEY$1, data);
          }

          if (config === 'toggle') {
            data[config]();
          }
        });
      };

      _createClass(Button, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION$1;
        }
      }]);

      return Button;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $(document).on(Event$1.CLICK_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
      event.preventDefault();
      var button = event.target;

      if (!$(button).hasClass(ClassName$1.BUTTON)) {
        button = $(button).closest(Selector$1.BUTTON);
      }

      Button._jQueryInterface.call($(button), 'toggle');
    }).on(Event$1.FOCUS_BLUR_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
      var button = $(event.target).closest(Selector$1.BUTTON)[0];
      $(button).toggleClass(ClassName$1.FOCUS, /^focus(in)?$/.test(event.type));
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME$1] = Button._jQueryInterface;
    $.fn[NAME$1].Constructor = Button;

    $.fn[NAME$1].noConflict = function () {
      $.fn[NAME$1] = JQUERY_NO_CONFLICT$1;
      return Button._jQueryInterface;
    };

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$2 = 'carousel';
    var VERSION$2 = '4.3.1';
    var DATA_KEY$2 = 'bs.carousel';
    var EVENT_KEY$2 = "." + DATA_KEY$2;
    var DATA_API_KEY$2 = '.data-api';
    var JQUERY_NO_CONFLICT$2 = $.fn[NAME$2];
    var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

    var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

    var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

    var SWIPE_THRESHOLD = 40;
    var Default = {
      interval: 5000,
      keyboard: true,
      slide: false,
      pause: 'hover',
      wrap: true,
      touch: true
    };
    var DefaultType = {
      interval: '(number|boolean)',
      keyboard: 'boolean',
      slide: '(boolean|string)',
      pause: '(string|boolean)',
      wrap: 'boolean',
      touch: 'boolean'
    };
    var Direction = {
      NEXT: 'next',
      PREV: 'prev',
      LEFT: 'left',
      RIGHT: 'right'
    };
    var Event$2 = {
      SLIDE: "slide" + EVENT_KEY$2,
      SLID: "slid" + EVENT_KEY$2,
      KEYDOWN: "keydown" + EVENT_KEY$2,
      MOUSEENTER: "mouseenter" + EVENT_KEY$2,
      MOUSELEAVE: "mouseleave" + EVENT_KEY$2,
      TOUCHSTART: "touchstart" + EVENT_KEY$2,
      TOUCHMOVE: "touchmove" + EVENT_KEY$2,
      TOUCHEND: "touchend" + EVENT_KEY$2,
      POINTERDOWN: "pointerdown" + EVENT_KEY$2,
      POINTERUP: "pointerup" + EVENT_KEY$2,
      DRAG_START: "dragstart" + EVENT_KEY$2,
      LOAD_DATA_API: "load" + EVENT_KEY$2 + DATA_API_KEY$2,
      CLICK_DATA_API: "click" + EVENT_KEY$2 + DATA_API_KEY$2
    };
    var ClassName$2 = {
      CAROUSEL: 'carousel',
      ACTIVE: 'active',
      SLIDE: 'slide',
      RIGHT: 'carousel-item-right',
      LEFT: 'carousel-item-left',
      NEXT: 'carousel-item-next',
      PREV: 'carousel-item-prev',
      ITEM: 'carousel-item',
      POINTER_EVENT: 'pointer-event'
    };
    var Selector$2 = {
      ACTIVE: '.active',
      ACTIVE_ITEM: '.active.carousel-item',
      ITEM: '.carousel-item',
      ITEM_IMG: '.carousel-item img',
      NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
      INDICATORS: '.carousel-indicators',
      DATA_SLIDE: '[data-slide], [data-slide-to]',
      DATA_RIDE: '[data-ride="carousel"]'
    };
    var PointerType = {
      TOUCH: 'touch',
      PEN: 'pen'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Carousel =
    /*#__PURE__*/
    function () {
      function Carousel(element, config) {
        this._items = null;
        this._interval = null;
        this._activeElement = null;
        this._isPaused = false;
        this._isSliding = false;
        this.touchTimeout = null;
        this.touchStartX = 0;
        this.touchDeltaX = 0;
        this._config = this._getConfig(config);
        this._element = element;
        this._indicatorsElement = this._element.querySelector(Selector$2.INDICATORS);
        this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
        this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);

        this._addEventListeners();
      } // Getters


      var _proto = Carousel.prototype;

      // Public
      _proto.next = function next() {
        if (!this._isSliding) {
          this._slide(Direction.NEXT);
        }
      };

      _proto.nextWhenVisible = function nextWhenVisible() {
        // Don't call next when the page isn't visible
        // or the carousel or its parent isn't visible
        if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {
          this.next();
        }
      };

      _proto.prev = function prev() {
        if (!this._isSliding) {
          this._slide(Direction.PREV);
        }
      };

      _proto.pause = function pause(event) {
        if (!event) {
          this._isPaused = true;
        }

        if (this._element.querySelector(Selector$2.NEXT_PREV)) {
          Util.triggerTransitionEnd(this._element);
          this.cycle(true);
        }

        clearInterval(this._interval);
        this._interval = null;
      };

      _proto.cycle = function cycle(event) {
        if (!event) {
          this._isPaused = false;
        }

        if (this._interval) {
          clearInterval(this._interval);
          this._interval = null;
        }

        if (this._config.interval && !this._isPaused) {
          this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
        }
      };

      _proto.to = function to(index) {
        var _this = this;

        this._activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

        var activeIndex = this._getItemIndex(this._activeElement);

        if (index > this._items.length - 1 || index < 0) {
          return;
        }

        if (this._isSliding) {
          $(this._element).one(Event$2.SLID, function () {
            return _this.to(index);
          });
          return;
        }

        if (activeIndex === index) {
          this.pause();
          this.cycle();
          return;
        }

        var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

        this._slide(direction, this._items[index]);
      };

      _proto.dispose = function dispose() {
        $(this._element).off(EVENT_KEY$2);
        $.removeData(this._element, DATA_KEY$2);
        this._items = null;
        this._config = null;
        this._element = null;
        this._interval = null;
        this._isPaused = null;
        this._isSliding = null;
        this._activeElement = null;
        this._indicatorsElement = null;
      } // Private
      ;

      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, Default, config);
        Util.typeCheckConfig(NAME$2, config, DefaultType);
        return config;
      };

      _proto._handleSwipe = function _handleSwipe() {
        var absDeltax = Math.abs(this.touchDeltaX);

        if (absDeltax <= SWIPE_THRESHOLD) {
          return;
        }

        var direction = absDeltax / this.touchDeltaX; // swipe left

        if (direction > 0) {
          this.prev();
        } // swipe right


        if (direction < 0) {
          this.next();
        }
      };

      _proto._addEventListeners = function _addEventListeners() {
        var _this2 = this;

        if (this._config.keyboard) {
          $(this._element).on(Event$2.KEYDOWN, function (event) {
            return _this2._keydown(event);
          });
        }

        if (this._config.pause === 'hover') {
          $(this._element).on(Event$2.MOUSEENTER, function (event) {
            return _this2.pause(event);
          }).on(Event$2.MOUSELEAVE, function (event) {
            return _this2.cycle(event);
          });
        }

        if (this._config.touch) {
          this._addTouchEventListeners();
        }
      };

      _proto._addTouchEventListeners = function _addTouchEventListeners() {
        var _this3 = this;

        if (!this._touchSupported) {
          return;
        }

        var start = function start(event) {
          if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
            _this3.touchStartX = event.originalEvent.clientX;
          } else if (!_this3._pointerEvent) {
            _this3.touchStartX = event.originalEvent.touches[0].clientX;
          }
        };

        var move = function move(event) {
          // ensure swiping with one touch and not pinching
          if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {
            _this3.touchDeltaX = 0;
          } else {
            _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;
          }
        };

        var end = function end(event) {
          if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
            _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
          }

          _this3._handleSwipe();

          if (_this3._config.pause === 'hover') {
            // If it's a touch-enabled device, mouseenter/leave are fired as
            // part of the mouse compatibility events on first tap - the carousel
            // would stop cycling until user tapped out of it;
            // here, we listen for touchend, explicitly pause the carousel
            // (as if it's the second time we tap on it, mouseenter compat event
            // is NOT fired) and after a timeout (to allow for mouse compatibility
            // events to fire) we explicitly restart cycling
            _this3.pause();

            if (_this3.touchTimeout) {
              clearTimeout(_this3.touchTimeout);
            }

            _this3.touchTimeout = setTimeout(function (event) {
              return _this3.cycle(event);
            }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
          }
        };

        $(this._element.querySelectorAll(Selector$2.ITEM_IMG)).on(Event$2.DRAG_START, function (e) {
          return e.preventDefault();
        });

        if (this._pointerEvent) {
          $(this._element).on(Event$2.POINTERDOWN, function (event) {
            return start(event);
          });
          $(this._element).on(Event$2.POINTERUP, function (event) {
            return end(event);
          });

          this._element.classList.add(ClassName$2.POINTER_EVENT);
        } else {
          $(this._element).on(Event$2.TOUCHSTART, function (event) {
            return start(event);
          });
          $(this._element).on(Event$2.TOUCHMOVE, function (event) {
            return move(event);
          });
          $(this._element).on(Event$2.TOUCHEND, function (event) {
            return end(event);
          });
        }
      };

      _proto._keydown = function _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) {
          return;
        }

        switch (event.which) {
          case ARROW_LEFT_KEYCODE:
            event.preventDefault();
            this.prev();
            break;

          case ARROW_RIGHT_KEYCODE:
            event.preventDefault();
            this.next();
            break;

          default:
        }
      };

      _proto._getItemIndex = function _getItemIndex(element) {
        this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector$2.ITEM)) : [];
        return this._items.indexOf(element);
      };

      _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
        var isNextDirection = direction === Direction.NEXT;
        var isPrevDirection = direction === Direction.PREV;

        var activeIndex = this._getItemIndex(activeElement);

        var lastItemIndex = this._items.length - 1;
        var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

        if (isGoingToWrap && !this._config.wrap) {
          return activeElement;
        }

        var delta = direction === Direction.PREV ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this._items.length;
        return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
      };

      _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
        var targetIndex = this._getItemIndex(relatedTarget);

        var fromIndex = this._getItemIndex(this._element.querySelector(Selector$2.ACTIVE_ITEM));

        var slideEvent = $.Event(Event$2.SLIDE, {
          relatedTarget: relatedTarget,
          direction: eventDirectionName,
          from: fromIndex,
          to: targetIndex
        });
        $(this._element).trigger(slideEvent);
        return slideEvent;
      };

      _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
        if (this._indicatorsElement) {
          var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector$2.ACTIVE));
          $(indicators).removeClass(ClassName$2.ACTIVE);

          var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

          if (nextIndicator) {
            $(nextIndicator).addClass(ClassName$2.ACTIVE);
          }
        }
      };

      _proto._slide = function _slide(direction, element) {
        var _this4 = this;

        var activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

        var activeElementIndex = this._getItemIndex(activeElement);

        var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

        var nextElementIndex = this._getItemIndex(nextElement);

        var isCycling = Boolean(this._interval);
        var directionalClassName;
        var orderClassName;
        var eventDirectionName;

        if (direction === Direction.NEXT) {
          directionalClassName = ClassName$2.LEFT;
          orderClassName = ClassName$2.NEXT;
          eventDirectionName = Direction.LEFT;
        } else {
          directionalClassName = ClassName$2.RIGHT;
          orderClassName = ClassName$2.PREV;
          eventDirectionName = Direction.RIGHT;
        }

        if (nextElement && $(nextElement).hasClass(ClassName$2.ACTIVE)) {
          this._isSliding = false;
          return;
        }

        var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

        if (slideEvent.isDefaultPrevented()) {
          return;
        }

        if (!activeElement || !nextElement) {
          // Some weirdness is happening, so we bail
          return;
        }

        this._isSliding = true;

        if (isCycling) {
          this.pause();
        }

        this._setActiveIndicatorElement(nextElement);

        var slidEvent = $.Event(Event$2.SLID, {
          relatedTarget: nextElement,
          direction: eventDirectionName,
          from: activeElementIndex,
          to: nextElementIndex
        });

        if ($(this._element).hasClass(ClassName$2.SLIDE)) {
          $(nextElement).addClass(orderClassName);
          Util.reflow(nextElement);
          $(activeElement).addClass(directionalClassName);
          $(nextElement).addClass(directionalClassName);
          var nextElementInterval = parseInt(nextElement.getAttribute('data-interval'), 10);

          if (nextElementInterval) {
            this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
            this._config.interval = nextElementInterval;
          } else {
            this._config.interval = this._config.defaultInterval || this._config.interval;
          }

          var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
          $(activeElement).one(Util.TRANSITION_END, function () {
            $(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName$2.ACTIVE);
            $(activeElement).removeClass(ClassName$2.ACTIVE + " " + orderClassName + " " + directionalClassName);
            _this4._isSliding = false;
            setTimeout(function () {
              return $(_this4._element).trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(transitionDuration);
        } else {
          $(activeElement).removeClass(ClassName$2.ACTIVE);
          $(nextElement).addClass(ClassName$2.ACTIVE);
          this._isSliding = false;
          $(this._element).trigger(slidEvent);
        }

        if (isCycling) {
          this.cycle();
        }
      } // Static
      ;

      Carousel._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY$2);

          var _config = _objectSpread({}, Default, $(this).data());

          if (typeof config === 'object') {
            _config = _objectSpread({}, _config, config);
          }

          var action = typeof config === 'string' ? config : _config.slide;

          if (!data) {
            data = new Carousel(this, _config);
            $(this).data(DATA_KEY$2, data);
          }

          if (typeof config === 'number') {
            data.to(config);
          } else if (typeof action === 'string') {
            if (typeof data[action] === 'undefined') {
              throw new TypeError("No method named \"" + action + "\"");
            }

            data[action]();
          } else if (_config.interval && _config.ride) {
            data.pause();
            data.cycle();
          }
        });
      };

      Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
        var selector = Util.getSelectorFromElement(this);

        if (!selector) {
          return;
        }

        var target = $(selector)[0];

        if (!target || !$(target).hasClass(ClassName$2.CAROUSEL)) {
          return;
        }

        var config = _objectSpread({}, $(target).data(), $(this).data());

        var slideIndex = this.getAttribute('data-slide-to');

        if (slideIndex) {
          config.interval = false;
        }

        Carousel._jQueryInterface.call($(target), config);

        if (slideIndex) {
          $(target).data(DATA_KEY$2).to(slideIndex);
        }

        event.preventDefault();
      };

      _createClass(Carousel, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION$2;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default;
        }
      }]);

      return Carousel;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $(document).on(Event$2.CLICK_DATA_API, Selector$2.DATA_SLIDE, Carousel._dataApiClickHandler);
    $(window).on(Event$2.LOAD_DATA_API, function () {
      var carousels = [].slice.call(document.querySelectorAll(Selector$2.DATA_RIDE));

      for (var i = 0, len = carousels.length; i < len; i++) {
        var $carousel = $(carousels[i]);

        Carousel._jQueryInterface.call($carousel, $carousel.data());
      }
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME$2] = Carousel._jQueryInterface;
    $.fn[NAME$2].Constructor = Carousel;

    $.fn[NAME$2].noConflict = function () {
      $.fn[NAME$2] = JQUERY_NO_CONFLICT$2;
      return Carousel._jQueryInterface;
    };

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$3 = 'collapse';
    var VERSION$3 = '4.3.1';
    var DATA_KEY$3 = 'bs.collapse';
    var EVENT_KEY$3 = "." + DATA_KEY$3;
    var DATA_API_KEY$3 = '.data-api';
    var JQUERY_NO_CONFLICT$3 = $.fn[NAME$3];
    var Default$1 = {
      toggle: true,
      parent: ''
    };
    var DefaultType$1 = {
      toggle: 'boolean',
      parent: '(string|element)'
    };
    var Event$3 = {
      SHOW: "show" + EVENT_KEY$3,
      SHOWN: "shown" + EVENT_KEY$3,
      HIDE: "hide" + EVENT_KEY$3,
      HIDDEN: "hidden" + EVENT_KEY$3,
      CLICK_DATA_API: "click" + EVENT_KEY$3 + DATA_API_KEY$3
    };
    var ClassName$3 = {
      SHOW: 'show',
      COLLAPSE: 'collapse',
      COLLAPSING: 'collapsing',
      COLLAPSED: 'collapsed'
    };
    var Dimension = {
      WIDTH: 'width',
      HEIGHT: 'height'
    };
    var Selector$3 = {
      ACTIVES: '.show, .collapsing',
      DATA_TOGGLE: '[data-toggle="collapse"]'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Collapse =
    /*#__PURE__*/
    function () {
      function Collapse(element, config) {
        this._isTransitioning = false;
        this._element = element;
        this._config = this._getConfig(config);
        this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
        var toggleList = [].slice.call(document.querySelectorAll(Selector$3.DATA_TOGGLE));

        for (var i = 0, len = toggleList.length; i < len; i++) {
          var elem = toggleList[i];
          var selector = Util.getSelectorFromElement(elem);
          var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
            return foundElem === element;
          });

          if (selector !== null && filterElement.length > 0) {
            this._selector = selector;

            this._triggerArray.push(elem);
          }
        }

        this._parent = this._config.parent ? this._getParent() : null;

        if (!this._config.parent) {
          this._addAriaAndCollapsedClass(this._element, this._triggerArray);
        }

        if (this._config.toggle) {
          this.toggle();
        }
      } // Getters


      var _proto = Collapse.prototype;

      // Public
      _proto.toggle = function toggle() {
        if ($(this._element).hasClass(ClassName$3.SHOW)) {
          this.hide();
        } else {
          this.show();
        }
      };

      _proto.show = function show() {
        var _this = this;

        if (this._isTransitioning || $(this._element).hasClass(ClassName$3.SHOW)) {
          return;
        }

        var actives;
        var activesData;

        if (this._parent) {
          actives = [].slice.call(this._parent.querySelectorAll(Selector$3.ACTIVES)).filter(function (elem) {
            if (typeof _this._config.parent === 'string') {
              return elem.getAttribute('data-parent') === _this._config.parent;
            }

            return elem.classList.contains(ClassName$3.COLLAPSE);
          });

          if (actives.length === 0) {
            actives = null;
          }
        }

        if (actives) {
          activesData = $(actives).not(this._selector).data(DATA_KEY$3);

          if (activesData && activesData._isTransitioning) {
            return;
          }
        }

        var startEvent = $.Event(Event$3.SHOW);
        $(this._element).trigger(startEvent);

        if (startEvent.isDefaultPrevented()) {
          return;
        }

        if (actives) {
          Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');

          if (!activesData) {
            $(actives).data(DATA_KEY$3, null);
          }
        }

        var dimension = this._getDimension();

        $(this._element).removeClass(ClassName$3.COLLAPSE).addClass(ClassName$3.COLLAPSING);
        this._element.style[dimension] = 0;

        if (this._triggerArray.length) {
          $(this._triggerArray).removeClass(ClassName$3.COLLAPSED).attr('aria-expanded', true);
        }

        this.setTransitioning(true);

        var complete = function complete() {
          $(_this._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).addClass(ClassName$3.SHOW);
          _this._element.style[dimension] = '';

          _this.setTransitioning(false);

          $(_this._element).trigger(Event$3.SHOWN);
        };

        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        var scrollSize = "scroll" + capitalizedDimension;
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        this._element.style[dimension] = this._element[scrollSize] + "px";
      };

      _proto.hide = function hide() {
        var _this2 = this;

        if (this._isTransitioning || !$(this._element).hasClass(ClassName$3.SHOW)) {
          return;
        }

        var startEvent = $.Event(Event$3.HIDE);
        $(this._element).trigger(startEvent);

        if (startEvent.isDefaultPrevented()) {
          return;
        }

        var dimension = this._getDimension();

        this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
        Util.reflow(this._element);
        $(this._element).addClass(ClassName$3.COLLAPSING).removeClass(ClassName$3.COLLAPSE).removeClass(ClassName$3.SHOW);
        var triggerArrayLength = this._triggerArray.length;

        if (triggerArrayLength > 0) {
          for (var i = 0; i < triggerArrayLength; i++) {
            var trigger = this._triggerArray[i];
            var selector = Util.getSelectorFromElement(trigger);

            if (selector !== null) {
              var $elem = $([].slice.call(document.querySelectorAll(selector)));

              if (!$elem.hasClass(ClassName$3.SHOW)) {
                $(trigger).addClass(ClassName$3.COLLAPSED).attr('aria-expanded', false);
              }
            }
          }
        }

        this.setTransitioning(true);

        var complete = function complete() {
          _this2.setTransitioning(false);

          $(_this2._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).trigger(Event$3.HIDDEN);
        };

        this._element.style[dimension] = '';
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      };

      _proto.setTransitioning = function setTransitioning(isTransitioning) {
        this._isTransitioning = isTransitioning;
      };

      _proto.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY$3);
        this._config = null;
        this._parent = null;
        this._element = null;
        this._triggerArray = null;
        this._isTransitioning = null;
      } // Private
      ;

      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, Default$1, config);
        config.toggle = Boolean(config.toggle); // Coerce string values

        Util.typeCheckConfig(NAME$3, config, DefaultType$1);
        return config;
      };

      _proto._getDimension = function _getDimension() {
        var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
        return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
      };

      _proto._getParent = function _getParent() {
        var _this3 = this;

        var parent;

        if (Util.isElement(this._config.parent)) {
          parent = this._config.parent; // It's a jQuery object

          if (typeof this._config.parent.jquery !== 'undefined') {
            parent = this._config.parent[0];
          }
        } else {
          parent = document.querySelector(this._config.parent);
        }

        var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
        var children = [].slice.call(parent.querySelectorAll(selector));
        $(children).each(function (i, element) {
          _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
        });
        return parent;
      };

      _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
        var isOpen = $(element).hasClass(ClassName$3.SHOW);

        if (triggerArray.length) {
          $(triggerArray).toggleClass(ClassName$3.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
        }
      } // Static
      ;

      Collapse._getTargetFromElement = function _getTargetFromElement(element) {
        var selector = Util.getSelectorFromElement(element);
        return selector ? document.querySelector(selector) : null;
      };

      Collapse._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data(DATA_KEY$3);

          var _config = _objectSpread({}, Default$1, $this.data(), typeof config === 'object' && config ? config : {});

          if (!data && _config.toggle && /show|hide/.test(config)) {
            _config.toggle = false;
          }

          if (!data) {
            data = new Collapse(this, _config);
            $this.data(DATA_KEY$3, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(Collapse, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION$3;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default$1;
        }
      }]);

      return Collapse;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $(document).on(Event$3.CLICK_DATA_API, Selector$3.DATA_TOGGLE, function (event) {
      // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
      if (event.currentTarget.tagName === 'A') {
        event.preventDefault();
      }

      var $trigger = $(this);
      var selector = Util.getSelectorFromElement(this);
      var selectors = [].slice.call(document.querySelectorAll(selector));
      $(selectors).each(function () {
        var $target = $(this);
        var data = $target.data(DATA_KEY$3);
        var config = data ? 'toggle' : $trigger.data();

        Collapse._jQueryInterface.call($target, config);
      });
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME$3] = Collapse._jQueryInterface;
    $.fn[NAME$3].Constructor = Collapse;

    $.fn[NAME$3].noConflict = function () {
      $.fn[NAME$3] = JQUERY_NO_CONFLICT$3;
      return Collapse._jQueryInterface;
    };

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$4 = 'dropdown';
    var VERSION$4 = '4.3.1';
    var DATA_KEY$4 = 'bs.dropdown';
    var EVENT_KEY$4 = "." + DATA_KEY$4;
    var DATA_API_KEY$4 = '.data-api';
    var JQUERY_NO_CONFLICT$4 = $.fn[NAME$4];
    var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

    var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

    var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

    var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

    var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

    var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

    var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
    var Event$4 = {
      HIDE: "hide" + EVENT_KEY$4,
      HIDDEN: "hidden" + EVENT_KEY$4,
      SHOW: "show" + EVENT_KEY$4,
      SHOWN: "shown" + EVENT_KEY$4,
      CLICK: "click" + EVENT_KEY$4,
      CLICK_DATA_API: "click" + EVENT_KEY$4 + DATA_API_KEY$4,
      KEYDOWN_DATA_API: "keydown" + EVENT_KEY$4 + DATA_API_KEY$4,
      KEYUP_DATA_API: "keyup" + EVENT_KEY$4 + DATA_API_KEY$4
    };
    var ClassName$4 = {
      DISABLED: 'disabled',
      SHOW: 'show',
      DROPUP: 'dropup',
      DROPRIGHT: 'dropright',
      DROPLEFT: 'dropleft',
      MENURIGHT: 'dropdown-menu-right',
      MENULEFT: 'dropdown-menu-left',
      POSITION_STATIC: 'position-static'
    };
    var Selector$4 = {
      DATA_TOGGLE: '[data-toggle="dropdown"]',
      FORM_CHILD: '.dropdown form',
      MENU: '.dropdown-menu',
      NAVBAR_NAV: '.navbar-nav',
      VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'
    };
    var AttachmentMap = {
      TOP: 'top-start',
      TOPEND: 'top-end',
      BOTTOM: 'bottom-start',
      BOTTOMEND: 'bottom-end',
      RIGHT: 'right-start',
      RIGHTEND: 'right-end',
      LEFT: 'left-start',
      LEFTEND: 'left-end'
    };
    var Default$2 = {
      offset: 0,
      flip: true,
      boundary: 'scrollParent',
      reference: 'toggle',
      display: 'dynamic'
    };
    var DefaultType$2 = {
      offset: '(number|string|function)',
      flip: 'boolean',
      boundary: '(string|element)',
      reference: '(string|element)',
      display: 'string'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Dropdown =
    /*#__PURE__*/
    function () {
      function Dropdown(element, config) {
        this._element = element;
        this._popper = null;
        this._config = this._getConfig(config);
        this._menu = this._getMenuElement();
        this._inNavbar = this._detectNavbar();

        this._addEventListeners();
      } // Getters


      var _proto = Dropdown.prototype;

      // Public
      _proto.toggle = function toggle() {
        if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED)) {
          return;
        }

        var parent = Dropdown._getParentFromElement(this._element);

        var isActive = $(this._menu).hasClass(ClassName$4.SHOW);

        Dropdown._clearMenus();

        if (isActive) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };
        var showEvent = $.Event(Event$4.SHOW, relatedTarget);
        $(parent).trigger(showEvent);

        if (showEvent.isDefaultPrevented()) {
          return;
        } // Disable totally Popper.js for Dropdown in Navbar


        if (!this._inNavbar) {
          /**
           * Check for Popper dependency
           * Popper - https://popper.js.org
           */
          if (typeof Popper === 'undefined') {
            throw new TypeError('Bootstrap\'s dropdowns require Popper.js (https://popper.js.org/)');
          }

          var referenceElement = this._element;

          if (this._config.reference === 'parent') {
            referenceElement = parent;
          } else if (Util.isElement(this._config.reference)) {
            referenceElement = this._config.reference; // Check if it's jQuery element

            if (typeof this._config.reference.jquery !== 'undefined') {
              referenceElement = this._config.reference[0];
            }
          } // If boundary is not `scrollParent`, then set position to `static`
          // to allow the menu to "escape" the scroll parent's boundaries
          // https://github.com/twbs/bootstrap/issues/24251


          if (this._config.boundary !== 'scrollParent') {
            $(parent).addClass(ClassName$4.POSITION_STATIC);
          }

          this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());
        } // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


        if ('ontouchstart' in document.documentElement && $(parent).closest(Selector$4.NAVBAR_NAV).length === 0) {
          $(document.body).children().on('mouseover', null, $.noop);
        }

        this._element.focus();

        this._element.setAttribute('aria-expanded', true);

        $(this._menu).toggleClass(ClassName$4.SHOW);
        $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
      };

      _proto.show = function show() {
        if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || $(this._menu).hasClass(ClassName$4.SHOW)) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };
        var showEvent = $.Event(Event$4.SHOW, relatedTarget);

        var parent = Dropdown._getParentFromElement(this._element);

        $(parent).trigger(showEvent);

        if (showEvent.isDefaultPrevented()) {
          return;
        }

        $(this._menu).toggleClass(ClassName$4.SHOW);
        $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
      };

      _proto.hide = function hide() {
        if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || !$(this._menu).hasClass(ClassName$4.SHOW)) {
          return;
        }

        var relatedTarget = {
          relatedTarget: this._element
        };
        var hideEvent = $.Event(Event$4.HIDE, relatedTarget);

        var parent = Dropdown._getParentFromElement(this._element);

        $(parent).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          return;
        }

        $(this._menu).toggleClass(ClassName$4.SHOW);
        $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
      };

      _proto.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY$4);
        $(this._element).off(EVENT_KEY$4);
        this._element = null;
        this._menu = null;

        if (this._popper !== null) {
          this._popper.destroy();

          this._popper = null;
        }
      };

      _proto.update = function update() {
        this._inNavbar = this._detectNavbar();

        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      } // Private
      ;

      _proto._addEventListeners = function _addEventListeners() {
        var _this = this;

        $(this._element).on(Event$4.CLICK, function (event) {
          event.preventDefault();
          event.stopPropagation();

          _this.toggle();
        });
      };

      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, this.constructor.Default, $(this._element).data(), config);
        Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
        return config;
      };

      _proto._getMenuElement = function _getMenuElement() {
        if (!this._menu) {
          var parent = Dropdown._getParentFromElement(this._element);

          if (parent) {
            this._menu = parent.querySelector(Selector$4.MENU);
          }
        }

        return this._menu;
      };

      _proto._getPlacement = function _getPlacement() {
        var $parentDropdown = $(this._element.parentNode);
        var placement = AttachmentMap.BOTTOM; // Handle dropup

        if ($parentDropdown.hasClass(ClassName$4.DROPUP)) {
          placement = AttachmentMap.TOP;

          if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
            placement = AttachmentMap.TOPEND;
          }
        } else if ($parentDropdown.hasClass(ClassName$4.DROPRIGHT)) {
          placement = AttachmentMap.RIGHT;
        } else if ($parentDropdown.hasClass(ClassName$4.DROPLEFT)) {
          placement = AttachmentMap.LEFT;
        } else if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
          placement = AttachmentMap.BOTTOMEND;
        }

        return placement;
      };

      _proto._detectNavbar = function _detectNavbar() {
        return $(this._element).closest('.navbar').length > 0;
      };

      _proto._getOffset = function _getOffset() {
        var _this2 = this;

        var offset = {};

        if (typeof this._config.offset === 'function') {
          offset.fn = function (data) {
            data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets, _this2._element) || {});
            return data;
          };
        } else {
          offset.offset = this._config.offset;
        }

        return offset;
      };

      _proto._getPopperConfig = function _getPopperConfig() {
        var popperConfig = {
          placement: this._getPlacement(),
          modifiers: {
            offset: this._getOffset(),
            flip: {
              enabled: this._config.flip
            },
            preventOverflow: {
              boundariesElement: this._config.boundary
            }
          } // Disable Popper.js if we have a static display

        };

        if (this._config.display === 'static') {
          popperConfig.modifiers.applyStyle = {
            enabled: false
          };
        }

        return popperConfig;
      } // Static
      ;

      Dropdown._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY$4);

          var _config = typeof config === 'object' ? config : null;

          if (!data) {
            data = new Dropdown(this, _config);
            $(this).data(DATA_KEY$4, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      Dropdown._clearMenus = function _clearMenus(event) {
        if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
          return;
        }

        var toggles = [].slice.call(document.querySelectorAll(Selector$4.DATA_TOGGLE));

        for (var i = 0, len = toggles.length; i < len; i++) {
          var parent = Dropdown._getParentFromElement(toggles[i]);

          var context = $(toggles[i]).data(DATA_KEY$4);
          var relatedTarget = {
            relatedTarget: toggles[i]
          };

          if (event && event.type === 'click') {
            relatedTarget.clickEvent = event;
          }

          if (!context) {
            continue;
          }

          var dropdownMenu = context._menu;

          if (!$(parent).hasClass(ClassName$4.SHOW)) {
            continue;
          }

          if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
            continue;
          }

          var hideEvent = $.Event(Event$4.HIDE, relatedTarget);
          $(parent).trigger(hideEvent);

          if (hideEvent.isDefaultPrevented()) {
            continue;
          } // If this is a touch-enabled device we remove the extra
          // empty mouseover listeners we added for iOS support


          if ('ontouchstart' in document.documentElement) {
            $(document.body).children().off('mouseover', null, $.noop);
          }

          toggles[i].setAttribute('aria-expanded', 'false');
          $(dropdownMenu).removeClass(ClassName$4.SHOW);
          $(parent).removeClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
        }
      };

      Dropdown._getParentFromElement = function _getParentFromElement(element) {
        var parent;
        var selector = Util.getSelectorFromElement(element);

        if (selector) {
          parent = document.querySelector(selector);
        }

        return parent || element.parentNode;
      } // eslint-disable-next-line complexity
      ;

      Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
        // If not input/textarea:
        //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
        // If input/textarea:
        //  - If space key => not a dropdown command
        //  - If key is other than escape
        //    - If key is not up or down => not a dropdown command
        //    - If trigger inside the menu => not a dropdown command
        if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $(event.target).closest(Selector$4.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();

        if (this.disabled || $(this).hasClass(ClassName$4.DISABLED)) {
          return;
        }

        var parent = Dropdown._getParentFromElement(this);

        var isActive = $(parent).hasClass(ClassName$4.SHOW);

        if (!isActive || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
          if (event.which === ESCAPE_KEYCODE) {
            var toggle = parent.querySelector(Selector$4.DATA_TOGGLE);
            $(toggle).trigger('focus');
          }

          $(this).trigger('click');
          return;
        }

        var items = [].slice.call(parent.querySelectorAll(Selector$4.VISIBLE_ITEMS));

        if (items.length === 0) {
          return;
        }

        var index = items.indexOf(event.target);

        if (event.which === ARROW_UP_KEYCODE && index > 0) {
          // Up
          index--;
        }

        if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
          // Down
          index++;
        }

        if (index < 0) {
          index = 0;
        }

        items[index].focus();
      };

      _createClass(Dropdown, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION$4;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default$2;
        }
      }, {
        key: "DefaultType",
        get: function get() {
          return DefaultType$2;
        }
      }]);

      return Dropdown;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $(document).on(Event$4.KEYDOWN_DATA_API, Selector$4.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event$4.KEYDOWN_DATA_API, Selector$4.MENU, Dropdown._dataApiKeydownHandler).on(Event$4.CLICK_DATA_API + " " + Event$4.KEYUP_DATA_API, Dropdown._clearMenus).on(Event$4.CLICK_DATA_API, Selector$4.DATA_TOGGLE, function (event) {
      event.preventDefault();
      event.stopPropagation();

      Dropdown._jQueryInterface.call($(this), 'toggle');
    }).on(Event$4.CLICK_DATA_API, Selector$4.FORM_CHILD, function (e) {
      e.stopPropagation();
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME$4] = Dropdown._jQueryInterface;
    $.fn[NAME$4].Constructor = Dropdown;

    $.fn[NAME$4].noConflict = function () {
      $.fn[NAME$4] = JQUERY_NO_CONFLICT$4;
      return Dropdown._jQueryInterface;
    };

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$5 = 'modal';
    var VERSION$5 = '4.3.1';
    var DATA_KEY$5 = 'bs.modal';
    var EVENT_KEY$5 = "." + DATA_KEY$5;
    var DATA_API_KEY$5 = '.data-api';
    var JQUERY_NO_CONFLICT$5 = $.fn[NAME$5];
    var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key

    var Default$3 = {
      backdrop: true,
      keyboard: true,
      focus: true,
      show: true
    };
    var DefaultType$3 = {
      backdrop: '(boolean|string)',
      keyboard: 'boolean',
      focus: 'boolean',
      show: 'boolean'
    };
    var Event$5 = {
      HIDE: "hide" + EVENT_KEY$5,
      HIDDEN: "hidden" + EVENT_KEY$5,
      SHOW: "show" + EVENT_KEY$5,
      SHOWN: "shown" + EVENT_KEY$5,
      FOCUSIN: "focusin" + EVENT_KEY$5,
      RESIZE: "resize" + EVENT_KEY$5,
      CLICK_DISMISS: "click.dismiss" + EVENT_KEY$5,
      KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY$5,
      MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY$5,
      MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY$5,
      CLICK_DATA_API: "click" + EVENT_KEY$5 + DATA_API_KEY$5
    };
    var ClassName$5 = {
      SCROLLABLE: 'modal-dialog-scrollable',
      SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
      BACKDROP: 'modal-backdrop',
      OPEN: 'modal-open',
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector$5 = {
      DIALOG: '.modal-dialog',
      MODAL_BODY: '.modal-body',
      DATA_TOGGLE: '[data-toggle="modal"]',
      DATA_DISMISS: '[data-dismiss="modal"]',
      FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
      STICKY_CONTENT: '.sticky-top'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Modal =
    /*#__PURE__*/
    function () {
      function Modal(element, config) {
        this._config = this._getConfig(config);
        this._element = element;
        this._dialog = element.querySelector(Selector$5.DIALOG);
        this._backdrop = null;
        this._isShown = false;
        this._isBodyOverflowing = false;
        this._ignoreBackdropClick = false;
        this._isTransitioning = false;
        this._scrollbarWidth = 0;
      } // Getters


      var _proto = Modal.prototype;

      // Public
      _proto.toggle = function toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      };

      _proto.show = function show(relatedTarget) {
        var _this = this;

        if (this._isShown || this._isTransitioning) {
          return;
        }

        if ($(this._element).hasClass(ClassName$5.FADE)) {
          this._isTransitioning = true;
        }

        var showEvent = $.Event(Event$5.SHOW, {
          relatedTarget: relatedTarget
        });
        $(this._element).trigger(showEvent);

        if (this._isShown || showEvent.isDefaultPrevented()) {
          return;
        }

        this._isShown = true;

        this._checkScrollbar();

        this._setScrollbar();

        this._adjustDialog();

        this._setEscapeEvent();

        this._setResizeEvent();

        $(this._element).on(Event$5.CLICK_DISMISS, Selector$5.DATA_DISMISS, function (event) {
          return _this.hide(event);
        });
        $(this._dialog).on(Event$5.MOUSEDOWN_DISMISS, function () {
          $(_this._element).one(Event$5.MOUSEUP_DISMISS, function (event) {
            if ($(event.target).is(_this._element)) {
              _this._ignoreBackdropClick = true;
            }
          });
        });

        this._showBackdrop(function () {
          return _this._showElement(relatedTarget);
        });
      };

      _proto.hide = function hide(event) {
        var _this2 = this;

        if (event) {
          event.preventDefault();
        }

        if (!this._isShown || this._isTransitioning) {
          return;
        }

        var hideEvent = $.Event(Event$5.HIDE);
        $(this._element).trigger(hideEvent);

        if (!this._isShown || hideEvent.isDefaultPrevented()) {
          return;
        }

        this._isShown = false;
        var transition = $(this._element).hasClass(ClassName$5.FADE);

        if (transition) {
          this._isTransitioning = true;
        }

        this._setEscapeEvent();

        this._setResizeEvent();

        $(document).off(Event$5.FOCUSIN);
        $(this._element).removeClass(ClassName$5.SHOW);
        $(this._element).off(Event$5.CLICK_DISMISS);
        $(this._dialog).off(Event$5.MOUSEDOWN_DISMISS);

        if (transition) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $(this._element).one(Util.TRANSITION_END, function (event) {
            return _this2._hideModal(event);
          }).emulateTransitionEnd(transitionDuration);
        } else {
          this._hideModal();
        }
      };

      _proto.dispose = function dispose() {
        [window, this._element, this._dialog].forEach(function (htmlElement) {
          return $(htmlElement).off(EVENT_KEY$5);
        });
        /**
         * `document` has 2 events `Event.FOCUSIN` and `Event.CLICK_DATA_API`
         * Do not move `document` in `htmlElements` array
         * It will remove `Event.CLICK_DATA_API` event that should remain
         */

        $(document).off(Event$5.FOCUSIN);
        $.removeData(this._element, DATA_KEY$5);
        this._config = null;
        this._element = null;
        this._dialog = null;
        this._backdrop = null;
        this._isShown = null;
        this._isBodyOverflowing = null;
        this._ignoreBackdropClick = null;
        this._isTransitioning = null;
        this._scrollbarWidth = null;
      };

      _proto.handleUpdate = function handleUpdate() {
        this._adjustDialog();
      } // Private
      ;

      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, Default$3, config);
        Util.typeCheckConfig(NAME$5, config, DefaultType$3);
        return config;
      };

      _proto._showElement = function _showElement(relatedTarget) {
        var _this3 = this;

        var transition = $(this._element).hasClass(ClassName$5.FADE);

        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
          // Don't move modal's DOM position
          document.body.appendChild(this._element);
        }

        this._element.style.display = 'block';

        this._element.removeAttribute('aria-hidden');

        this._element.setAttribute('aria-modal', true);

        if ($(this._dialog).hasClass(ClassName$5.SCROLLABLE)) {
          this._dialog.querySelector(Selector$5.MODAL_BODY).scrollTop = 0;
        } else {
          this._element.scrollTop = 0;
        }

        if (transition) {
          Util.reflow(this._element);
        }

        $(this._element).addClass(ClassName$5.SHOW);

        if (this._config.focus) {
          this._enforceFocus();
        }

        var shownEvent = $.Event(Event$5.SHOWN, {
          relatedTarget: relatedTarget
        });

        var transitionComplete = function transitionComplete() {
          if (_this3._config.focus) {
            _this3._element.focus();
          }

          _this3._isTransitioning = false;
          $(_this3._element).trigger(shownEvent);
        };

        if (transition) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
          $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
        } else {
          transitionComplete();
        }
      };

      _proto._enforceFocus = function _enforceFocus() {
        var _this4 = this;

        $(document).off(Event$5.FOCUSIN) // Guard against infinite focus loop
        .on(Event$5.FOCUSIN, function (event) {
          if (document !== event.target && _this4._element !== event.target && $(_this4._element).has(event.target).length === 0) {
            _this4._element.focus();
          }
        });
      };

      _proto._setEscapeEvent = function _setEscapeEvent() {
        var _this5 = this;

        if (this._isShown && this._config.keyboard) {
          $(this._element).on(Event$5.KEYDOWN_DISMISS, function (event) {
            if (event.which === ESCAPE_KEYCODE$1) {
              event.preventDefault();

              _this5.hide();
            }
          });
        } else if (!this._isShown) {
          $(this._element).off(Event$5.KEYDOWN_DISMISS);
        }
      };

      _proto._setResizeEvent = function _setResizeEvent() {
        var _this6 = this;

        if (this._isShown) {
          $(window).on(Event$5.RESIZE, function (event) {
            return _this6.handleUpdate(event);
          });
        } else {
          $(window).off(Event$5.RESIZE);
        }
      };

      _proto._hideModal = function _hideModal() {
        var _this7 = this;

        this._element.style.display = 'none';

        this._element.setAttribute('aria-hidden', true);

        this._element.removeAttribute('aria-modal');

        this._isTransitioning = false;

        this._showBackdrop(function () {
          $(document.body).removeClass(ClassName$5.OPEN);

          _this7._resetAdjustments();

          _this7._resetScrollbar();

          $(_this7._element).trigger(Event$5.HIDDEN);
        });
      };

      _proto._removeBackdrop = function _removeBackdrop() {
        if (this._backdrop) {
          $(this._backdrop).remove();
          this._backdrop = null;
        }
      };

      _proto._showBackdrop = function _showBackdrop(callback) {
        var _this8 = this;

        var animate = $(this._element).hasClass(ClassName$5.FADE) ? ClassName$5.FADE : '';

        if (this._isShown && this._config.backdrop) {
          this._backdrop = document.createElement('div');
          this._backdrop.className = ClassName$5.BACKDROP;

          if (animate) {
            this._backdrop.classList.add(animate);
          }

          $(this._backdrop).appendTo(document.body);
          $(this._element).on(Event$5.CLICK_DISMISS, function (event) {
            if (_this8._ignoreBackdropClick) {
              _this8._ignoreBackdropClick = false;
              return;
            }

            if (event.target !== event.currentTarget) {
              return;
            }

            if (_this8._config.backdrop === 'static') {
              _this8._element.focus();
            } else {
              _this8.hide();
            }
          });

          if (animate) {
            Util.reflow(this._backdrop);
          }

          $(this._backdrop).addClass(ClassName$5.SHOW);

          if (!callback) {
            return;
          }

          if (!animate) {
            callback();
            return;
          }

          var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
          $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
        } else if (!this._isShown && this._backdrop) {
          $(this._backdrop).removeClass(ClassName$5.SHOW);

          var callbackRemove = function callbackRemove() {
            _this8._removeBackdrop();

            if (callback) {
              callback();
            }
          };

          if ($(this._element).hasClass(ClassName$5.FADE)) {
            var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);

            $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
          } else {
            callbackRemove();
          }
        } else if (callback) {
          callback();
        }
      } // ----------------------------------------------------------------------
      // the following methods are used to handle overflowing modals
      // todo (fat): these should probably be refactored out of modal.js
      // ----------------------------------------------------------------------
      ;

      _proto._adjustDialog = function _adjustDialog() {
        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

        if (!this._isBodyOverflowing && isModalOverflowing) {
          this._element.style.paddingLeft = this._scrollbarWidth + "px";
        }

        if (this._isBodyOverflowing && !isModalOverflowing) {
          this._element.style.paddingRight = this._scrollbarWidth + "px";
        }
      };

      _proto._resetAdjustments = function _resetAdjustments() {
        this._element.style.paddingLeft = '';
        this._element.style.paddingRight = '';
      };

      _proto._checkScrollbar = function _checkScrollbar() {
        var rect = document.body.getBoundingClientRect();
        this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
        this._scrollbarWidth = this._getScrollbarWidth();
      };

      _proto._setScrollbar = function _setScrollbar() {
        var _this9 = this;

        if (this._isBodyOverflowing) {
          // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
          //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
          var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
          var stickyContent = [].slice.call(document.querySelectorAll(Selector$5.STICKY_CONTENT)); // Adjust fixed content padding

          $(fixedContent).each(function (index, element) {
            var actualPadding = element.style.paddingRight;
            var calculatedPadding = $(element).css('padding-right');
            $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px");
          }); // Adjust sticky content margin

          $(stickyContent).each(function (index, element) {
            var actualMargin = element.style.marginRight;
            var calculatedMargin = $(element).css('margin-right');
            $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");
          }); // Adjust body padding

          var actualPadding = document.body.style.paddingRight;
          var calculatedPadding = $(document.body).css('padding-right');
          $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
        }

        $(document.body).addClass(ClassName$5.OPEN);
      };

      _proto._resetScrollbar = function _resetScrollbar() {
        // Restore fixed content padding
        var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
        $(fixedContent).each(function (index, element) {
          var padding = $(element).data('padding-right');
          $(element).removeData('padding-right');
          element.style.paddingRight = padding ? padding : '';
        }); // Restore sticky content

        var elements = [].slice.call(document.querySelectorAll("" + Selector$5.STICKY_CONTENT));
        $(elements).each(function (index, element) {
          var margin = $(element).data('margin-right');

          if (typeof margin !== 'undefined') {
            $(element).css('margin-right', margin).removeData('margin-right');
          }
        }); // Restore body padding

        var padding = $(document.body).data('padding-right');
        $(document.body).removeData('padding-right');
        document.body.style.paddingRight = padding ? padding : '';
      };

      _proto._getScrollbarWidth = function _getScrollbarWidth() {
        // thx d.walsh
        var scrollDiv = document.createElement('div');
        scrollDiv.className = ClassName$5.SCROLLBAR_MEASURER;
        document.body.appendChild(scrollDiv);
        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        return scrollbarWidth;
      } // Static
      ;

      Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY$5);

          var _config = _objectSpread({}, Default$3, $(this).data(), typeof config === 'object' && config ? config : {});

          if (!data) {
            data = new Modal(this, _config);
            $(this).data(DATA_KEY$5, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config](relatedTarget);
          } else if (_config.show) {
            data.show(relatedTarget);
          }
        });
      };

      _createClass(Modal, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION$5;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default$3;
        }
      }]);

      return Modal;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $(document).on(Event$5.CLICK_DATA_API, Selector$5.DATA_TOGGLE, function (event) {
      var _this10 = this;

      var target;
      var selector = Util.getSelectorFromElement(this);

      if (selector) {
        target = document.querySelector(selector);
      }

      var config = $(target).data(DATA_KEY$5) ? 'toggle' : _objectSpread({}, $(target).data(), $(this).data());

      if (this.tagName === 'A' || this.tagName === 'AREA') {
        event.preventDefault();
      }

      var $target = $(target).one(Event$5.SHOW, function (showEvent) {
        if (showEvent.isDefaultPrevented()) {
          // Only register focus restorer if modal will actually get shown
          return;
        }

        $target.one(Event$5.HIDDEN, function () {
          if ($(_this10).is(':visible')) {
            _this10.focus();
          }
        });
      });

      Modal._jQueryInterface.call($(target), config, this);
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME$5] = Modal._jQueryInterface;
    $.fn[NAME$5].Constructor = Modal;

    $.fn[NAME$5].noConflict = function () {
      $.fn[NAME$5] = JQUERY_NO_CONFLICT$5;
      return Modal._jQueryInterface;
    };

    /**
     * --------------------------------------------------------------------------
     * Bootstrap (v4.3.1): tools/sanitizer.js
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * --------------------------------------------------------------------------
     */
    var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
    var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
    var DefaultWhitelist = {
      // Global attributes allowed on any supplied element below.
      '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
      a: ['target', 'href', 'title', 'rel'],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      div: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ['src', 'alt', 'title', 'width', 'height'],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: []
      /**
       * A pattern that recognizes a commonly useful subset of URLs that are safe.
       *
       * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
       */

    };
    var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
    /**
     * A pattern that matches safe data URLs. Only matches image, video and audio types.
     *
     * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
     */

    var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

    function allowedAttribute(attr, allowedAttributeList) {
      var attrName = attr.nodeName.toLowerCase();

      if (allowedAttributeList.indexOf(attrName) !== -1) {
        if (uriAttrs.indexOf(attrName) !== -1) {
          return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
        }

        return true;
      }

      var regExp = allowedAttributeList.filter(function (attrRegex) {
        return attrRegex instanceof RegExp;
      }); // Check if a regular expression validates the attribute.

      for (var i = 0, l = regExp.length; i < l; i++) {
        if (attrName.match(regExp[i])) {
          return true;
        }
      }

      return false;
    }

    function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
      if (unsafeHtml.length === 0) {
        return unsafeHtml;
      }

      if (sanitizeFn && typeof sanitizeFn === 'function') {
        return sanitizeFn(unsafeHtml);
      }

      var domParser = new window.DOMParser();
      var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
      var whitelistKeys = Object.keys(whiteList);
      var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));

      var _loop = function _loop(i, len) {
        var el = elements[i];
        var elName = el.nodeName.toLowerCase();

        if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
          el.parentNode.removeChild(el);
          return "continue";
        }

        var attributeList = [].slice.call(el.attributes);
        var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
        attributeList.forEach(function (attr) {
          if (!allowedAttribute(attr, whitelistedAttributes)) {
            el.removeAttribute(attr.nodeName);
          }
        });
      };

      for (var i = 0, len = elements.length; i < len; i++) {
        var _ret = _loop(i, len);

        if (_ret === "continue") continue;
      }

      return createdDocument.body.innerHTML;
    }

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$6 = 'tooltip';
    var VERSION$6 = '4.3.1';
    var DATA_KEY$6 = 'bs.tooltip';
    var EVENT_KEY$6 = "." + DATA_KEY$6;
    var JQUERY_NO_CONFLICT$6 = $.fn[NAME$6];
    var CLASS_PREFIX = 'bs-tooltip';
    var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
    var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
    var DefaultType$4 = {
      animation: 'boolean',
      template: 'string',
      title: '(string|element|function)',
      trigger: 'string',
      delay: '(number|object)',
      html: 'boolean',
      selector: '(string|boolean)',
      placement: '(string|function)',
      offset: '(number|string|function)',
      container: '(string|element|boolean)',
      fallbackPlacement: '(string|array)',
      boundary: '(string|element)',
      sanitize: 'boolean',
      sanitizeFn: '(null|function)',
      whiteList: 'object'
    };
    var AttachmentMap$1 = {
      AUTO: 'auto',
      TOP: 'top',
      RIGHT: 'right',
      BOTTOM: 'bottom',
      LEFT: 'left'
    };
    var Default$4 = {
      animation: true,
      template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
      trigger: 'hover focus',
      title: '',
      delay: 0,
      html: false,
      selector: false,
      placement: 'top',
      offset: 0,
      container: false,
      fallbackPlacement: 'flip',
      boundary: 'scrollParent',
      sanitize: true,
      sanitizeFn: null,
      whiteList: DefaultWhitelist
    };
    var HoverState = {
      SHOW: 'show',
      OUT: 'out'
    };
    var Event$6 = {
      HIDE: "hide" + EVENT_KEY$6,
      HIDDEN: "hidden" + EVENT_KEY$6,
      SHOW: "show" + EVENT_KEY$6,
      SHOWN: "shown" + EVENT_KEY$6,
      INSERTED: "inserted" + EVENT_KEY$6,
      CLICK: "click" + EVENT_KEY$6,
      FOCUSIN: "focusin" + EVENT_KEY$6,
      FOCUSOUT: "focusout" + EVENT_KEY$6,
      MOUSEENTER: "mouseenter" + EVENT_KEY$6,
      MOUSELEAVE: "mouseleave" + EVENT_KEY$6
    };
    var ClassName$6 = {
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector$6 = {
      TOOLTIP: '.tooltip',
      TOOLTIP_INNER: '.tooltip-inner',
      ARROW: '.arrow'
    };
    var Trigger = {
      HOVER: 'hover',
      FOCUS: 'focus',
      CLICK: 'click',
      MANUAL: 'manual'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Tooltip =
    /*#__PURE__*/
    function () {
      function Tooltip(element, config) {
        /**
         * Check for Popper dependency
         * Popper - https://popper.js.org
         */
        if (typeof Popper === 'undefined') {
          throw new TypeError('Bootstrap\'s tooltips require Popper.js (https://popper.js.org/)');
        } // private


        this._isEnabled = true;
        this._timeout = 0;
        this._hoverState = '';
        this._activeTrigger = {};
        this._popper = null; // Protected

        this.element = element;
        this.config = this._getConfig(config);
        this.tip = null;

        this._setListeners();
      } // Getters


      var _proto = Tooltip.prototype;

      // Public
      _proto.enable = function enable() {
        this._isEnabled = true;
      };

      _proto.disable = function disable() {
        this._isEnabled = false;
      };

      _proto.toggleEnabled = function toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      };

      _proto.toggle = function toggle(event) {
        if (!this._isEnabled) {
          return;
        }

        if (event) {
          var dataKey = this.constructor.DATA_KEY;
          var context = $(event.currentTarget).data(dataKey);

          if (!context) {
            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
            $(event.currentTarget).data(dataKey, context);
          }

          context._activeTrigger.click = !context._activeTrigger.click;

          if (context._isWithActiveTrigger()) {
            context._enter(null, context);
          } else {
            context._leave(null, context);
          }
        } else {
          if ($(this.getTipElement()).hasClass(ClassName$6.SHOW)) {
            this._leave(null, this);

            return;
          }

          this._enter(null, this);
        }
      };

      _proto.dispose = function dispose() {
        clearTimeout(this._timeout);
        $.removeData(this.element, this.constructor.DATA_KEY);
        $(this.element).off(this.constructor.EVENT_KEY);
        $(this.element).closest('.modal').off('hide.bs.modal');

        if (this.tip) {
          $(this.tip).remove();
        }

        this._isEnabled = null;
        this._timeout = null;
        this._hoverState = null;
        this._activeTrigger = null;

        if (this._popper !== null) {
          this._popper.destroy();
        }

        this._popper = null;
        this.element = null;
        this.config = null;
        this.tip = null;
      };

      _proto.show = function show() {
        var _this = this;

        if ($(this.element).css('display') === 'none') {
          throw new Error('Please use show on visible elements');
        }

        var showEvent = $.Event(this.constructor.Event.SHOW);

        if (this.isWithContent() && this._isEnabled) {
          $(this.element).trigger(showEvent);
          var shadowRoot = Util.findShadowRoot(this.element);
          var isInTheDom = $.contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);

          if (showEvent.isDefaultPrevented() || !isInTheDom) {
            return;
          }

          var tip = this.getTipElement();
          var tipId = Util.getUID(this.constructor.NAME);
          tip.setAttribute('id', tipId);
          this.element.setAttribute('aria-describedby', tipId);
          this.setContent();

          if (this.config.animation) {
            $(tip).addClass(ClassName$6.FADE);
          }

          var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

          var attachment = this._getAttachment(placement);

          this.addAttachmentClass(attachment);

          var container = this._getContainer();

          $(tip).data(this.constructor.DATA_KEY, this);

          if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
            $(tip).appendTo(container);
          }

          $(this.element).trigger(this.constructor.Event.INSERTED);
          this._popper = new Popper(this.element, tip, {
            placement: attachment,
            modifiers: {
              offset: this._getOffset(),
              flip: {
                behavior: this.config.fallbackPlacement
              },
              arrow: {
                element: Selector$6.ARROW
              },
              preventOverflow: {
                boundariesElement: this.config.boundary
              }
            },
            onCreate: function onCreate(data) {
              if (data.originalPlacement !== data.placement) {
                _this._handlePopperPlacementChange(data);
              }
            },
            onUpdate: function onUpdate(data) {
              return _this._handlePopperPlacementChange(data);
            }
          });
          $(tip).addClass(ClassName$6.SHOW); // If this is a touch-enabled device we add extra
          // empty mouseover listeners to the body's immediate children;
          // only needed because of broken event delegation on iOS
          // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

          if ('ontouchstart' in document.documentElement) {
            $(document.body).children().on('mouseover', null, $.noop);
          }

          var complete = function complete() {
            if (_this.config.animation) {
              _this._fixTransition();
            }

            var prevHoverState = _this._hoverState;
            _this._hoverState = null;
            $(_this.element).trigger(_this.constructor.Event.SHOWN);

            if (prevHoverState === HoverState.OUT) {
              _this._leave(null, _this);
            }
          };

          if ($(this.tip).hasClass(ClassName$6.FADE)) {
            var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
            $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          } else {
            complete();
          }
        }
      };

      _proto.hide = function hide(callback) {
        var _this2 = this;

        var tip = this.getTipElement();
        var hideEvent = $.Event(this.constructor.Event.HIDE);

        var complete = function complete() {
          if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
            tip.parentNode.removeChild(tip);
          }

          _this2._cleanTipClass();

          _this2.element.removeAttribute('aria-describedby');

          $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

          if (_this2._popper !== null) {
            _this2._popper.destroy();
          }

          if (callback) {
            callback();
          }
        };

        $(this.element).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          return;
        }

        $(tip).removeClass(ClassName$6.SHOW); // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support

        if ('ontouchstart' in document.documentElement) {
          $(document.body).children().off('mouseover', null, $.noop);
        }

        this._activeTrigger[Trigger.CLICK] = false;
        this._activeTrigger[Trigger.FOCUS] = false;
        this._activeTrigger[Trigger.HOVER] = false;

        if ($(this.tip).hasClass(ClassName$6.FADE)) {
          var transitionDuration = Util.getTransitionDurationFromElement(tip);
          $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }

        this._hoverState = '';
      };

      _proto.update = function update() {
        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      } // Protected
      ;

      _proto.isWithContent = function isWithContent() {
        return Boolean(this.getTitle());
      };

      _proto.addAttachmentClass = function addAttachmentClass(attachment) {
        $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
      };

      _proto.getTipElement = function getTipElement() {
        this.tip = this.tip || $(this.config.template)[0];
        return this.tip;
      };

      _proto.setContent = function setContent() {
        var tip = this.getTipElement();
        this.setElementContent($(tip.querySelectorAll(Selector$6.TOOLTIP_INNER)), this.getTitle());
        $(tip).removeClass(ClassName$6.FADE + " " + ClassName$6.SHOW);
      };

      _proto.setElementContent = function setElementContent($element, content) {
        if (typeof content === 'object' && (content.nodeType || content.jquery)) {
          // Content is a DOM node or a jQuery
          if (this.config.html) {
            if (!$(content).parent().is($element)) {
              $element.empty().append(content);
            }
          } else {
            $element.text($(content).text());
          }

          return;
        }

        if (this.config.html) {
          if (this.config.sanitize) {
            content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
          }

          $element.html(content);
        } else {
          $element.text(content);
        }
      };

      _proto.getTitle = function getTitle() {
        var title = this.element.getAttribute('data-original-title');

        if (!title) {
          title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
        }

        return title;
      } // Private
      ;

      _proto._getOffset = function _getOffset() {
        var _this3 = this;

        var offset = {};

        if (typeof this.config.offset === 'function') {
          offset.fn = function (data) {
            data.offsets = _objectSpread({}, data.offsets, _this3.config.offset(data.offsets, _this3.element) || {});
            return data;
          };
        } else {
          offset.offset = this.config.offset;
        }

        return offset;
      };

      _proto._getContainer = function _getContainer() {
        if (this.config.container === false) {
          return document.body;
        }

        if (Util.isElement(this.config.container)) {
          return $(this.config.container);
        }

        return $(document).find(this.config.container);
      };

      _proto._getAttachment = function _getAttachment(placement) {
        return AttachmentMap$1[placement.toUpperCase()];
      };

      _proto._setListeners = function _setListeners() {
        var _this4 = this;

        var triggers = this.config.trigger.split(' ');
        triggers.forEach(function (trigger) {
          if (trigger === 'click') {
            $(_this4.element).on(_this4.constructor.Event.CLICK, _this4.config.selector, function (event) {
              return _this4.toggle(event);
            });
          } else if (trigger !== Trigger.MANUAL) {
            var eventIn = trigger === Trigger.HOVER ? _this4.constructor.Event.MOUSEENTER : _this4.constructor.Event.FOCUSIN;
            var eventOut = trigger === Trigger.HOVER ? _this4.constructor.Event.MOUSELEAVE : _this4.constructor.Event.FOCUSOUT;
            $(_this4.element).on(eventIn, _this4.config.selector, function (event) {
              return _this4._enter(event);
            }).on(eventOut, _this4.config.selector, function (event) {
              return _this4._leave(event);
            });
          }
        });
        $(this.element).closest('.modal').on('hide.bs.modal', function () {
          if (_this4.element) {
            _this4.hide();
          }
        });

        if (this.config.selector) {
          this.config = _objectSpread({}, this.config, {
            trigger: 'manual',
            selector: ''
          });
        } else {
          this._fixTitle();
        }
      };

      _proto._fixTitle = function _fixTitle() {
        var titleType = typeof this.element.getAttribute('data-original-title');

        if (this.element.getAttribute('title') || titleType !== 'string') {
          this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
          this.element.setAttribute('title', '');
        }
      };

      _proto._enter = function _enter(event, context) {
        var dataKey = this.constructor.DATA_KEY;
        context = context || $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
        }

        if ($(context.getTipElement()).hasClass(ClassName$6.SHOW) || context._hoverState === HoverState.SHOW) {
          context._hoverState = HoverState.SHOW;
          return;
        }

        clearTimeout(context._timeout);
        context._hoverState = HoverState.SHOW;

        if (!context.config.delay || !context.config.delay.show) {
          context.show();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.SHOW) {
            context.show();
          }
        }, context.config.delay.show);
      };

      _proto._leave = function _leave(event, context) {
        var dataKey = this.constructor.DATA_KEY;
        context = context || $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
        }

        if (context._isWithActiveTrigger()) {
          return;
        }

        clearTimeout(context._timeout);
        context._hoverState = HoverState.OUT;

        if (!context.config.delay || !context.config.delay.hide) {
          context.hide();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.OUT) {
            context.hide();
          }
        }, context.config.delay.hide);
      };

      _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
        for (var trigger in this._activeTrigger) {
          if (this._activeTrigger[trigger]) {
            return true;
          }
        }

        return false;
      };

      _proto._getConfig = function _getConfig(config) {
        var dataAttributes = $(this.element).data();
        Object.keys(dataAttributes).forEach(function (dataAttr) {
          if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
            delete dataAttributes[dataAttr];
          }
        });
        config = _objectSpread({}, this.constructor.Default, dataAttributes, typeof config === 'object' && config ? config : {});

        if (typeof config.delay === 'number') {
          config.delay = {
            show: config.delay,
            hide: config.delay
          };
        }

        if (typeof config.title === 'number') {
          config.title = config.title.toString();
        }

        if (typeof config.content === 'number') {
          config.content = config.content.toString();
        }

        Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);

        if (config.sanitize) {
          config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);
        }

        return config;
      };

      _proto._getDelegateConfig = function _getDelegateConfig() {
        var config = {};

        if (this.config) {
          for (var key in this.config) {
            if (this.constructor.Default[key] !== this.config[key]) {
              config[key] = this.config[key];
            }
          }
        }

        return config;
      };

      _proto._cleanTipClass = function _cleanTipClass() {
        var $tip = $(this.getTipElement());
        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

        if (tabClass !== null && tabClass.length) {
          $tip.removeClass(tabClass.join(''));
        }
      };

      _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
        var popperInstance = popperData.instance;
        this.tip = popperInstance.popper;

        this._cleanTipClass();

        this.addAttachmentClass(this._getAttachment(popperData.placement));
      };

      _proto._fixTransition = function _fixTransition() {
        var tip = this.getTipElement();
        var initConfigAnimation = this.config.animation;

        if (tip.getAttribute('x-placement') !== null) {
          return;
        }

        $(tip).removeClass(ClassName$6.FADE);
        this.config.animation = false;
        this.hide();
        this.show();
        this.config.animation = initConfigAnimation;
      } // Static
      ;

      Tooltip._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY$6);

          var _config = typeof config === 'object' && config;

          if (!data && /dispose|hide/.test(config)) {
            return;
          }

          if (!data) {
            data = new Tooltip(this, _config);
            $(this).data(DATA_KEY$6, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(Tooltip, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION$6;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default$4;
        }
      }, {
        key: "NAME",
        get: function get() {
          return NAME$6;
        }
      }, {
        key: "DATA_KEY",
        get: function get() {
          return DATA_KEY$6;
        }
      }, {
        key: "Event",
        get: function get() {
          return Event$6;
        }
      }, {
        key: "EVENT_KEY",
        get: function get() {
          return EVENT_KEY$6;
        }
      }, {
        key: "DefaultType",
        get: function get() {
          return DefaultType$4;
        }
      }]);

      return Tooltip;
    }();
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */


    $.fn[NAME$6] = Tooltip._jQueryInterface;
    $.fn[NAME$6].Constructor = Tooltip;

    $.fn[NAME$6].noConflict = function () {
      $.fn[NAME$6] = JQUERY_NO_CONFLICT$6;
      return Tooltip._jQueryInterface;
    };

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$7 = 'popover';
    var VERSION$7 = '4.3.1';
    var DATA_KEY$7 = 'bs.popover';
    var EVENT_KEY$7 = "." + DATA_KEY$7;
    var JQUERY_NO_CONFLICT$7 = $.fn[NAME$7];
    var CLASS_PREFIX$1 = 'bs-popover';
    var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", 'g');

    var Default$5 = _objectSpread({}, Tooltip.Default, {
      placement: 'right',
      trigger: 'click',
      content: '',
      template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
    });

    var DefaultType$5 = _objectSpread({}, Tooltip.DefaultType, {
      content: '(string|element|function)'
    });

    var ClassName$7 = {
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector$7 = {
      TITLE: '.popover-header',
      CONTENT: '.popover-body'
    };
    var Event$7 = {
      HIDE: "hide" + EVENT_KEY$7,
      HIDDEN: "hidden" + EVENT_KEY$7,
      SHOW: "show" + EVENT_KEY$7,
      SHOWN: "shown" + EVENT_KEY$7,
      INSERTED: "inserted" + EVENT_KEY$7,
      CLICK: "click" + EVENT_KEY$7,
      FOCUSIN: "focusin" + EVENT_KEY$7,
      FOCUSOUT: "focusout" + EVENT_KEY$7,
      MOUSEENTER: "mouseenter" + EVENT_KEY$7,
      MOUSELEAVE: "mouseleave" + EVENT_KEY$7
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Popover =
    /*#__PURE__*/
    function (_Tooltip) {
      _inheritsLoose(Popover, _Tooltip);

      function Popover() {
        return _Tooltip.apply(this, arguments) || this;
      }

      var _proto = Popover.prototype;

      // Overrides
      _proto.isWithContent = function isWithContent() {
        return this.getTitle() || this._getContent();
      };

      _proto.addAttachmentClass = function addAttachmentClass(attachment) {
        $(this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
      };

      _proto.getTipElement = function getTipElement() {
        this.tip = this.tip || $(this.config.template)[0];
        return this.tip;
      };

      _proto.setContent = function setContent() {
        var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events

        this.setElementContent($tip.find(Selector$7.TITLE), this.getTitle());

        var content = this._getContent();

        if (typeof content === 'function') {
          content = content.call(this.element);
        }

        this.setElementContent($tip.find(Selector$7.CONTENT), content);
        $tip.removeClass(ClassName$7.FADE + " " + ClassName$7.SHOW);
      } // Private
      ;

      _proto._getContent = function _getContent() {
        return this.element.getAttribute('data-content') || this.config.content;
      };

      _proto._cleanTipClass = function _cleanTipClass() {
        var $tip = $(this.getTipElement());
        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);

        if (tabClass !== null && tabClass.length > 0) {
          $tip.removeClass(tabClass.join(''));
        }
      } // Static
      ;

      Popover._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY$7);

          var _config = typeof config === 'object' ? config : null;

          if (!data && /dispose|hide/.test(config)) {
            return;
          }

          if (!data) {
            data = new Popover(this, _config);
            $(this).data(DATA_KEY$7, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(Popover, null, [{
        key: "VERSION",
        // Getters
        get: function get() {
          return VERSION$7;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default$5;
        }
      }, {
        key: "NAME",
        get: function get() {
          return NAME$7;
        }
      }, {
        key: "DATA_KEY",
        get: function get() {
          return DATA_KEY$7;
        }
      }, {
        key: "Event",
        get: function get() {
          return Event$7;
        }
      }, {
        key: "EVENT_KEY",
        get: function get() {
          return EVENT_KEY$7;
        }
      }, {
        key: "DefaultType",
        get: function get() {
          return DefaultType$5;
        }
      }]);

      return Popover;
    }(Tooltip);
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */


    $.fn[NAME$7] = Popover._jQueryInterface;
    $.fn[NAME$7].Constructor = Popover;

    $.fn[NAME$7].noConflict = function () {
      $.fn[NAME$7] = JQUERY_NO_CONFLICT$7;
      return Popover._jQueryInterface;
    };

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$8 = 'scrollspy';
    var VERSION$8 = '4.3.1';
    var DATA_KEY$8 = 'bs.scrollspy';
    var EVENT_KEY$8 = "." + DATA_KEY$8;
    var DATA_API_KEY$6 = '.data-api';
    var JQUERY_NO_CONFLICT$8 = $.fn[NAME$8];
    var Default$6 = {
      offset: 10,
      method: 'auto',
      target: ''
    };
    var DefaultType$6 = {
      offset: 'number',
      method: 'string',
      target: '(string|element)'
    };
    var Event$8 = {
      ACTIVATE: "activate" + EVENT_KEY$8,
      SCROLL: "scroll" + EVENT_KEY$8,
      LOAD_DATA_API: "load" + EVENT_KEY$8 + DATA_API_KEY$6
    };
    var ClassName$8 = {
      DROPDOWN_ITEM: 'dropdown-item',
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active'
    };
    var Selector$8 = {
      DATA_SPY: '[data-spy="scroll"]',
      ACTIVE: '.active',
      NAV_LIST_GROUP: '.nav, .list-group',
      NAV_LINKS: '.nav-link',
      NAV_ITEMS: '.nav-item',
      LIST_ITEMS: '.list-group-item',
      DROPDOWN: '.dropdown',
      DROPDOWN_ITEMS: '.dropdown-item',
      DROPDOWN_TOGGLE: '.dropdown-toggle'
    };
    var OffsetMethod = {
      OFFSET: 'offset',
      POSITION: 'position'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var ScrollSpy =
    /*#__PURE__*/
    function () {
      function ScrollSpy(element, config) {
        var _this = this;

        this._element = element;
        this._scrollElement = element.tagName === 'BODY' ? window : element;
        this._config = this._getConfig(config);
        this._selector = this._config.target + " " + Selector$8.NAV_LINKS + "," + (this._config.target + " " + Selector$8.LIST_ITEMS + ",") + (this._config.target + " " + Selector$8.DROPDOWN_ITEMS);
        this._offsets = [];
        this._targets = [];
        this._activeTarget = null;
        this._scrollHeight = 0;
        $(this._scrollElement).on(Event$8.SCROLL, function (event) {
          return _this._process(event);
        });
        this.refresh();

        this._process();
      } // Getters


      var _proto = ScrollSpy.prototype;

      // Public
      _proto.refresh = function refresh() {
        var _this2 = this;

        var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
        var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
        var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
        this._offsets = [];
        this._targets = [];
        this._scrollHeight = this._getScrollHeight();
        var targets = [].slice.call(document.querySelectorAll(this._selector));
        targets.map(function (element) {
          var target;
          var targetSelector = Util.getSelectorFromElement(element);

          if (targetSelector) {
            target = document.querySelector(targetSelector);
          }

          if (target) {
            var targetBCR = target.getBoundingClientRect();

            if (targetBCR.width || targetBCR.height) {
              // TODO (fat): remove sketch reliance on jQuery position/offset
              return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
            }
          }

          return null;
        }).filter(function (item) {
          return item;
        }).sort(function (a, b) {
          return a[0] - b[0];
        }).forEach(function (item) {
          _this2._offsets.push(item[0]);

          _this2._targets.push(item[1]);
        });
      };

      _proto.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY$8);
        $(this._scrollElement).off(EVENT_KEY$8);
        this._element = null;
        this._scrollElement = null;
        this._config = null;
        this._selector = null;
        this._offsets = null;
        this._targets = null;
        this._activeTarget = null;
        this._scrollHeight = null;
      } // Private
      ;

      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, Default$6, typeof config === 'object' && config ? config : {});

        if (typeof config.target !== 'string') {
          var id = $(config.target).attr('id');

          if (!id) {
            id = Util.getUID(NAME$8);
            $(config.target).attr('id', id);
          }

          config.target = "#" + id;
        }

        Util.typeCheckConfig(NAME$8, config, DefaultType$6);
        return config;
      };

      _proto._getScrollTop = function _getScrollTop() {
        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
      };

      _proto._getScrollHeight = function _getScrollHeight() {
        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      };

      _proto._getOffsetHeight = function _getOffsetHeight() {
        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
      };

      _proto._process = function _process() {
        var scrollTop = this._getScrollTop() + this._config.offset;

        var scrollHeight = this._getScrollHeight();

        var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

        if (this._scrollHeight !== scrollHeight) {
          this.refresh();
        }

        if (scrollTop >= maxScroll) {
          var target = this._targets[this._targets.length - 1];

          if (this._activeTarget !== target) {
            this._activate(target);
          }

          return;
        }

        if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
          this._activeTarget = null;

          this._clear();

          return;
        }

        var offsetLength = this._offsets.length;

        for (var i = offsetLength; i--;) {
          var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

          if (isActiveTarget) {
            this._activate(this._targets[i]);
          }
        }
      };

      _proto._activate = function _activate(target) {
        this._activeTarget = target;

        this._clear();

        var queries = this._selector.split(',').map(function (selector) {
          return selector + "[data-target=\"" + target + "\"]," + selector + "[href=\"" + target + "\"]";
        });

        var $link = $([].slice.call(document.querySelectorAll(queries.join(','))));

        if ($link.hasClass(ClassName$8.DROPDOWN_ITEM)) {
          $link.closest(Selector$8.DROPDOWN).find(Selector$8.DROPDOWN_TOGGLE).addClass(ClassName$8.ACTIVE);
          $link.addClass(ClassName$8.ACTIVE);
        } else {
          // Set triggered link as active
          $link.addClass(ClassName$8.ACTIVE); // Set triggered links parents as active
          // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

          $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_LINKS + ", " + Selector$8.LIST_ITEMS).addClass(ClassName$8.ACTIVE); // Handle special case when .nav-link is inside .nav-item

          $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_ITEMS).children(Selector$8.NAV_LINKS).addClass(ClassName$8.ACTIVE);
        }

        $(this._scrollElement).trigger(Event$8.ACTIVATE, {
          relatedTarget: target
        });
      };

      _proto._clear = function _clear() {
        [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {
          return node.classList.contains(ClassName$8.ACTIVE);
        }).forEach(function (node) {
          return node.classList.remove(ClassName$8.ACTIVE);
        });
      } // Static
      ;

      ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY$8);

          var _config = typeof config === 'object' && config;

          if (!data) {
            data = new ScrollSpy(this, _config);
            $(this).data(DATA_KEY$8, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(ScrollSpy, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION$8;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default$6;
        }
      }]);

      return ScrollSpy;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $(window).on(Event$8.LOAD_DATA_API, function () {
      var scrollSpys = [].slice.call(document.querySelectorAll(Selector$8.DATA_SPY));
      var scrollSpysLength = scrollSpys.length;

      for (var i = scrollSpysLength; i--;) {
        var $spy = $(scrollSpys[i]);

        ScrollSpy._jQueryInterface.call($spy, $spy.data());
      }
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME$8] = ScrollSpy._jQueryInterface;
    $.fn[NAME$8].Constructor = ScrollSpy;

    $.fn[NAME$8].noConflict = function () {
      $.fn[NAME$8] = JQUERY_NO_CONFLICT$8;
      return ScrollSpy._jQueryInterface;
    };

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$9 = 'tab';
    var VERSION$9 = '4.3.1';
    var DATA_KEY$9 = 'bs.tab';
    var EVENT_KEY$9 = "." + DATA_KEY$9;
    var DATA_API_KEY$7 = '.data-api';
    var JQUERY_NO_CONFLICT$9 = $.fn[NAME$9];
    var Event$9 = {
      HIDE: "hide" + EVENT_KEY$9,
      HIDDEN: "hidden" + EVENT_KEY$9,
      SHOW: "show" + EVENT_KEY$9,
      SHOWN: "shown" + EVENT_KEY$9,
      CLICK_DATA_API: "click" + EVENT_KEY$9 + DATA_API_KEY$7
    };
    var ClassName$9 = {
      DROPDOWN_MENU: 'dropdown-menu',
      ACTIVE: 'active',
      DISABLED: 'disabled',
      FADE: 'fade',
      SHOW: 'show'
    };
    var Selector$9 = {
      DROPDOWN: '.dropdown',
      NAV_LIST_GROUP: '.nav, .list-group',
      ACTIVE: '.active',
      ACTIVE_UL: '> li > .active',
      DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
      DROPDOWN_TOGGLE: '.dropdown-toggle',
      DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Tab =
    /*#__PURE__*/
    function () {
      function Tab(element) {
        this._element = element;
      } // Getters


      var _proto = Tab.prototype;

      // Public
      _proto.show = function show() {
        var _this = this;

        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName$9.ACTIVE) || $(this._element).hasClass(ClassName$9.DISABLED)) {
          return;
        }

        var target;
        var previous;
        var listElement = $(this._element).closest(Selector$9.NAV_LIST_GROUP)[0];
        var selector = Util.getSelectorFromElement(this._element);

        if (listElement) {
          var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? Selector$9.ACTIVE_UL : Selector$9.ACTIVE;
          previous = $.makeArray($(listElement).find(itemSelector));
          previous = previous[previous.length - 1];
        }

        var hideEvent = $.Event(Event$9.HIDE, {
          relatedTarget: this._element
        });
        var showEvent = $.Event(Event$9.SHOW, {
          relatedTarget: previous
        });

        if (previous) {
          $(previous).trigger(hideEvent);
        }

        $(this._element).trigger(showEvent);

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
          return;
        }

        if (selector) {
          target = document.querySelector(selector);
        }

        this._activate(this._element, listElement);

        var complete = function complete() {
          var hiddenEvent = $.Event(Event$9.HIDDEN, {
            relatedTarget: _this._element
          });
          var shownEvent = $.Event(Event$9.SHOWN, {
            relatedTarget: previous
          });
          $(previous).trigger(hiddenEvent);
          $(_this._element).trigger(shownEvent);
        };

        if (target) {
          this._activate(target, target.parentNode, complete);
        } else {
          complete();
        }
      };

      _proto.dispose = function dispose() {
        $.removeData(this._element, DATA_KEY$9);
        this._element = null;
      } // Private
      ;

      _proto._activate = function _activate(element, container, callback) {
        var _this2 = this;

        var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $(container).find(Selector$9.ACTIVE_UL) : $(container).children(Selector$9.ACTIVE);
        var active = activeElements[0];
        var isTransitioning = callback && active && $(active).hasClass(ClassName$9.FADE);

        var complete = function complete() {
          return _this2._transitionComplete(element, active, callback);
        };

        if (active && isTransitioning) {
          var transitionDuration = Util.getTransitionDurationFromElement(active);
          $(active).removeClass(ClassName$9.SHOW).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      };

      _proto._transitionComplete = function _transitionComplete(element, active, callback) {
        if (active) {
          $(active).removeClass(ClassName$9.ACTIVE);
          var dropdownChild = $(active.parentNode).find(Selector$9.DROPDOWN_ACTIVE_CHILD)[0];

          if (dropdownChild) {
            $(dropdownChild).removeClass(ClassName$9.ACTIVE);
          }

          if (active.getAttribute('role') === 'tab') {
            active.setAttribute('aria-selected', false);
          }
        }

        $(element).addClass(ClassName$9.ACTIVE);

        if (element.getAttribute('role') === 'tab') {
          element.setAttribute('aria-selected', true);
        }

        Util.reflow(element);

        if (element.classList.contains(ClassName$9.FADE)) {
          element.classList.add(ClassName$9.SHOW);
        }

        if (element.parentNode && $(element.parentNode).hasClass(ClassName$9.DROPDOWN_MENU)) {
          var dropdownElement = $(element).closest(Selector$9.DROPDOWN)[0];

          if (dropdownElement) {
            var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector$9.DROPDOWN_TOGGLE));
            $(dropdownToggleList).addClass(ClassName$9.ACTIVE);
          }

          element.setAttribute('aria-expanded', true);
        }

        if (callback) {
          callback();
        }
      } // Static
      ;

      Tab._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data(DATA_KEY$9);

          if (!data) {
            data = new Tab(this);
            $this.data(DATA_KEY$9, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config]();
          }
        });
      };

      _createClass(Tab, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION$9;
        }
      }]);

      return Tab;
    }();
    /**
     * ------------------------------------------------------------------------
     * Data Api implementation
     * ------------------------------------------------------------------------
     */


    $(document).on(Event$9.CLICK_DATA_API, Selector$9.DATA_TOGGLE, function (event) {
      event.preventDefault();

      Tab._jQueryInterface.call($(this), 'show');
    });
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */

    $.fn[NAME$9] = Tab._jQueryInterface;
    $.fn[NAME$9].Constructor = Tab;

    $.fn[NAME$9].noConflict = function () {
      $.fn[NAME$9] = JQUERY_NO_CONFLICT$9;
      return Tab._jQueryInterface;
    };

    /**
     * ------------------------------------------------------------------------
     * Constants
     * ------------------------------------------------------------------------
     */

    var NAME$a = 'toast';
    var VERSION$a = '4.3.1';
    var DATA_KEY$a = 'bs.toast';
    var EVENT_KEY$a = "." + DATA_KEY$a;
    var JQUERY_NO_CONFLICT$a = $.fn[NAME$a];
    var Event$a = {
      CLICK_DISMISS: "click.dismiss" + EVENT_KEY$a,
      HIDE: "hide" + EVENT_KEY$a,
      HIDDEN: "hidden" + EVENT_KEY$a,
      SHOW: "show" + EVENT_KEY$a,
      SHOWN: "shown" + EVENT_KEY$a
    };
    var ClassName$a = {
      FADE: 'fade',
      HIDE: 'hide',
      SHOW: 'show',
      SHOWING: 'showing'
    };
    var DefaultType$7 = {
      animation: 'boolean',
      autohide: 'boolean',
      delay: 'number'
    };
    var Default$7 = {
      animation: true,
      autohide: true,
      delay: 500
    };
    var Selector$a = {
      DATA_DISMISS: '[data-dismiss="toast"]'
      /**
       * ------------------------------------------------------------------------
       * Class Definition
       * ------------------------------------------------------------------------
       */

    };

    var Toast =
    /*#__PURE__*/
    function () {
      function Toast(element, config) {
        this._element = element;
        this._config = this._getConfig(config);
        this._timeout = null;

        this._setListeners();
      } // Getters


      var _proto = Toast.prototype;

      // Public
      _proto.show = function show() {
        var _this = this;

        $(this._element).trigger(Event$a.SHOW);

        if (this._config.animation) {
          this._element.classList.add(ClassName$a.FADE);
        }

        var complete = function complete() {
          _this._element.classList.remove(ClassName$a.SHOWING);

          _this._element.classList.add(ClassName$a.SHOW);

          $(_this._element).trigger(Event$a.SHOWN);

          if (_this._config.autohide) {
            _this.hide();
          }
        };

        this._element.classList.remove(ClassName$a.HIDE);

        this._element.classList.add(ClassName$a.SHOWING);

        if (this._config.animation) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      };

      _proto.hide = function hide(withoutTimeout) {
        var _this2 = this;

        if (!this._element.classList.contains(ClassName$a.SHOW)) {
          return;
        }

        $(this._element).trigger(Event$a.HIDE);

        if (withoutTimeout) {
          this._close();
        } else {
          this._timeout = setTimeout(function () {
            _this2._close();
          }, this._config.delay);
        }
      };

      _proto.dispose = function dispose() {
        clearTimeout(this._timeout);
        this._timeout = null;

        if (this._element.classList.contains(ClassName$a.SHOW)) {
          this._element.classList.remove(ClassName$a.SHOW);
        }

        $(this._element).off(Event$a.CLICK_DISMISS);
        $.removeData(this._element, DATA_KEY$a);
        this._element = null;
        this._config = null;
      } // Private
      ;

      _proto._getConfig = function _getConfig(config) {
        config = _objectSpread({}, Default$7, $(this._element).data(), typeof config === 'object' && config ? config : {});
        Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);
        return config;
      };

      _proto._setListeners = function _setListeners() {
        var _this3 = this;

        $(this._element).on(Event$a.CLICK_DISMISS, Selector$a.DATA_DISMISS, function () {
          return _this3.hide(true);
        });
      };

      _proto._close = function _close() {
        var _this4 = this;

        var complete = function complete() {
          _this4._element.classList.add(ClassName$a.HIDE);

          $(_this4._element).trigger(Event$a.HIDDEN);
        };

        this._element.classList.remove(ClassName$a.SHOW);

        if (this._config.animation) {
          var transitionDuration = Util.getTransitionDurationFromElement(this._element);
          $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      } // Static
      ;

      Toast._jQueryInterface = function _jQueryInterface(config) {
        return this.each(function () {
          var $element = $(this);
          var data = $element.data(DATA_KEY$a);

          var _config = typeof config === 'object' && config;

          if (!data) {
            data = new Toast(this, _config);
            $element.data(DATA_KEY$a, data);
          }

          if (typeof config === 'string') {
            if (typeof data[config] === 'undefined') {
              throw new TypeError("No method named \"" + config + "\"");
            }

            data[config](this);
          }
        });
      };

      _createClass(Toast, null, [{
        key: "VERSION",
        get: function get() {
          return VERSION$a;
        }
      }, {
        key: "DefaultType",
        get: function get() {
          return DefaultType$7;
        }
      }, {
        key: "Default",
        get: function get() {
          return Default$7;
        }
      }]);

      return Toast;
    }();
    /**
     * ------------------------------------------------------------------------
     * jQuery
     * ------------------------------------------------------------------------
     */


    $.fn[NAME$a] = Toast._jQueryInterface;
    $.fn[NAME$a].Constructor = Toast;

    $.fn[NAME$a].noConflict = function () {
      $.fn[NAME$a] = JQUERY_NO_CONFLICT$a;
      return Toast._jQueryInterface;
    };

    /**
     * --------------------------------------------------------------------------
     * Bootstrap (v4.3.1): index.js
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * --------------------------------------------------------------------------
     */

    (function () {
      if (typeof $ === 'undefined') {
        throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
      }

      var version = $.fn.jquery.split(' ')[0].split('.');
      var minMajor = 1;
      var ltMajor = 2;
      var minMinor = 9;
      var minPatch = 1;
      var maxMajor = 4;

      if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
        throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
      }
    })();

    exports.Util = Util;
    exports.Alert = Alert;
    exports.Button = Button;
    exports.Carousel = Carousel;
    exports.Collapse = Collapse;
    exports.Dropdown = Dropdown;
    exports.Modal = Modal;
    exports.Popover = Popover;
    exports.Scrollspy = ScrollSpy;
    exports.Tab = Tab;
    exports.Toast = Toast;
    exports.Tooltip = Tooltip;

    Object.defineProperty(exports, '__esModule', { value: true });

  }));

  });

  var bootstrap$1 = unwrapExports(bootstrap);

  /**
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright JS Foundation and other contributors <https://js.foundation/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      nullTag = '[object Null]',
      proxyTag = '[object Proxy]',
      undefinedTag = '[object Undefined]';

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$1 = freeGlobal || freeSelf || Function('return this')();

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Built-in value references. */
  var Symbol$1 = root$1.Symbol,
      symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$2.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$1(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var lodash_isfunction = isFunction$1;

  function getScrollbarWidth() {
    var scrollDiv = document.createElement('div'); // .modal-scrollbar-measure styles // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.4/scss/_modal.scss#L106-L113

    scrollDiv.style.position = 'absolute';
    scrollDiv.style.top = '-9999px';
    scrollDiv.style.width = '50px';
    scrollDiv.style.height = '50px';
    scrollDiv.style.overflow = 'scroll';
    document.body.appendChild(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarWidth;
  }
  function setScrollbarWidth(padding) {
    document.body.style.paddingRight = padding > 0 ? padding + "px" : null;
  }
  function isBodyOverflowing() {
    return document.body.clientWidth < window.innerWidth;
  }
  function getOriginalBodyPadding() {
    var style = window.getComputedStyle(document.body, null);
    return parseInt(style && style.getPropertyValue('padding-right') || 0, 10);
  }
  function conditionallyUpdateScrollbar() {
    var scrollbarWidth = getScrollbarWidth(); // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.6/js/src/modal.js#L433

    var fixedContent = document.querySelectorAll('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top')[0];
    var bodyPadding = fixedContent ? parseInt(fixedContent.style.paddingRight || 0, 10) : 0;

    if (isBodyOverflowing()) {
      setScrollbarWidth(bodyPadding + scrollbarWidth);
    }
  }
  var globalCssModule;
  function setGlobalCssModule(cssModule) {
    globalCssModule = cssModule;
  }
  function mapToCssModules(className, cssModule) {
    if (className === void 0) {
      className = '';
    }

    if (cssModule === void 0) {
      cssModule = globalCssModule;
    }

    if (!cssModule) return className;
    return className.split(' ').map(function (c) {
      return cssModule[c] || c;
    }).join(' ');
  }
  /**
   * Returns a new object with the key/value pairs from `obj` that are not in the array `omitKeys`.
   */

  function omit(obj, omitKeys) {
    var result = {};
    Object.keys(obj).forEach(function (key) {
      if (omitKeys.indexOf(key) === -1) {
        result[key] = obj[key];
      }
    });
    return result;
  }
  /**
   * Returns a filtered copy of an object with only the specified keys.
   */

  function pick(obj, keys) {
    var pickKeys = Array.isArray(keys) ? keys : [keys];
    var length = pickKeys.length;
    var key;
    var result = {};

    while (length > 0) {
      length -= 1;
      key = pickKeys[length];
      result[key] = obj[key];
    }

    return result;
  }
  var warned = {};
  function warnOnce(message) {
    if (!warned[message]) {
      /* istanbul ignore else */
      if (typeof console !== 'undefined') {
        console.error(message); // eslint-disable-line no-console
      }

      warned[message] = true;
    }
  }
  function deprecated(propType, explanation) {
    return function validate(props, propName, componentName) {
      if (props[propName] !== null && typeof props[propName] !== 'undefined') {
        warnOnce("\"" + propName + "\" property of \"" + componentName + "\" has been deprecated.\n" + explanation);
      }

      for (var _len = arguments.length, rest = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        rest[_key - 3] = arguments[_key];
      }

      return propType.apply(void 0, [props, propName, componentName].concat(rest));
    };
  } // Shim Element if needed (e.g. in Node environment)

  var Element$1 = typeof window === 'object' && window.Element || function () {};

  function DOMElement(props, propName, componentName) {
    if (!(props[propName] instanceof Element$1)) {
      return new Error('Invalid prop `' + propName + '` supplied to `' + componentName + '`. Expected prop to be an instance of Element. Validation failed.');
    }
  }
  var targetPropType = propTypes.oneOfType([propTypes.string, propTypes.func, DOMElement, propTypes.shape({
    current: propTypes.any
  })]);
  var tagPropType = propTypes.oneOfType([propTypes.func, propTypes.string, propTypes.shape({
    $$typeof: propTypes.symbol,
    render: propTypes.func
  }), propTypes.arrayOf(propTypes.oneOfType([propTypes.func, propTypes.string, propTypes.shape({
    $$typeof: propTypes.symbol,
    render: propTypes.func
  })]))]);
  /* eslint key-spacing: ["error", { afterColon: true, align: "value" }] */
  // These are all setup to match what is in the bootstrap _variables.scss
  // https://github.com/twbs/bootstrap/blob/v4-dev/scss/_variables.scss

  var TransitionTimeouts = {
    Fade: 150,
    // $transition-fade
    Collapse: 350,
    // $transition-collapse
    Modal: 300,
    // $modal-transition
    Carousel: 600 // $carousel-transition

  }; // Duplicated Transition.propType keys to ensure that Reactstrap builds
  // for distribution properly exclude these keys for nested child HTML attributes
  // since `react-transition-group` removes propTypes in production builds.

  var TransitionPropTypeKeys = ['in', 'mountOnEnter', 'unmountOnExit', 'appear', 'enter', 'exit', 'timeout', 'onEnter', 'onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited'];
  var TransitionStatuses = {
    ENTERING: 'entering',
    ENTERED: 'entered',
    EXITING: 'exiting',
    EXITED: 'exited'
  };
  var keyCodes = {
    esc: 27,
    space: 32,
    enter: 13,
    tab: 9,
    up: 38,
    down: 40,
    home: 36,
    end: 35,
    n: 78,
    p: 80
  };
  var PopperPlacements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  function isReactRefObj(target) {
    if (target && typeof target === 'object') {
      return 'current' in target;
    }

    return false;
  }
  function findDOMElements(target) {
    if (isReactRefObj(target)) {
      return target.current;
    }

    if (lodash_isfunction(target)) {
      return target();
    }

    if (typeof target === 'string' && canUseDOM) {
      var selection = document.querySelectorAll(target);

      if (!selection.length) {
        selection = document.querySelectorAll("#" + target);
      }

      if (!selection.length) {
        throw new Error("The target '" + target + "' could not be identified in the dom, tip: check spelling");
      }

      return selection;
    }

    return target;
  }
  function isArrayOrNodeList(els) {
    if (els === null) {
      return false;
    }

    return Array.isArray(els) || canUseDOM && typeof els.length === 'number';
  }
  function getTarget(target) {
    var els = findDOMElements(target);

    if (isArrayOrNodeList(els)) {
      return els[0];
    }

    return els;
  }
  var defaultToggleEvents = ['touchstart', 'click'];
  function addMultipleEventListeners(_els, handler, _events, useCapture) {
    var els = _els;

    if (!isArrayOrNodeList(els)) {
      els = [els];
    }

    var events = _events;

    if (typeof events === 'string') {
      events = events.split(/\s+/);
    }

    if (!isArrayOrNodeList(els) || typeof handler !== 'function' || !Array.isArray(events)) {
      throw new Error("\n      The first argument of this function must be DOM node or an array on DOM nodes or NodeList.\n      The second must be a function.\n      The third is a string or an array of strings that represents DOM events\n    ");
    }

    Array.prototype.forEach.call(events, function (event) {
      Array.prototype.forEach.call(els, function (el) {
        el.addEventListener(event, handler, useCapture);
      });
    });
    return function removeEvents() {
      Array.prototype.forEach.call(events, function (event) {
        Array.prototype.forEach.call(els, function (el) {
          el.removeEventListener(event, handler, useCapture);
        });
      });
    };
  }
  var focusableElements = ['a[href]', 'area[href]', 'input:not([disabled]):not([type=hidden])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'object', 'embed', '[tabindex]:not(.modal)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'];

  var utils = /*#__PURE__*/Object.freeze({
    getScrollbarWidth: getScrollbarWidth,
    setScrollbarWidth: setScrollbarWidth,
    isBodyOverflowing: isBodyOverflowing,
    getOriginalBodyPadding: getOriginalBodyPadding,
    conditionallyUpdateScrollbar: conditionallyUpdateScrollbar,
    setGlobalCssModule: setGlobalCssModule,
    mapToCssModules: mapToCssModules,
    omit: omit,
    pick: pick,
    warnOnce: warnOnce,
    deprecated: deprecated,
    DOMElement: DOMElement,
    targetPropType: targetPropType,
    tagPropType: tagPropType,
    TransitionTimeouts: TransitionTimeouts,
    TransitionPropTypeKeys: TransitionPropTypeKeys,
    TransitionStatuses: TransitionStatuses,
    keyCodes: keyCodes,
    PopperPlacements: PopperPlacements,
    canUseDOM: canUseDOM,
    isReactRefObj: isReactRefObj,
    findDOMElements: findDOMElements,
    isArrayOrNodeList: isArrayOrNodeList,
    getTarget: getTarget,
    defaultToggleEvents: defaultToggleEvents,
    addMultipleEventListeners: addMultipleEventListeners,
    focusableElements: focusableElements
  });

  var propTypes$1 = {
    tag: tagPropType,
    fluid: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$5 = {
    tag: 'div'
  };

  var Container$2 = function Container(props) {
    var className = props.className,
        cssModule = props.cssModule,
        fluid = props.fluid,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "fluid", "tag"]);

    var classes = mapToCssModules(classnames(className, fluid ? 'container-fluid' : 'container'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  Container$2.propTypes = propTypes$1;
  Container$2.defaultProps = defaultProps$5;

  var propTypes$2 = {
    tag: tagPropType,
    noGutters: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object,
    form: propTypes.bool
  };
  var defaultProps$6 = {
    tag: 'div'
  };

  var Row = function Row(props) {
    var className = props.className,
        cssModule = props.cssModule,
        noGutters = props.noGutters,
        Tag = props.tag,
        form = props.form,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "noGutters", "tag", "form"]);

    var classes = mapToCssModules(classnames(className, noGutters ? 'no-gutters' : null, form ? 'form-row' : 'row'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  Row.propTypes = propTypes$2;
  Row.defaultProps = defaultProps$6;

  /**
   * lodash 3.0.2 (Custom Build) <https://lodash.com/>
   * Build: `lodash modern modularize exports="npm" -o ./`
   * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   * Available under MIT license <https://lodash.com/license>
   */

  /**
   * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject$1(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  var lodash_isobject = isObject$1;

  var colWidths = ['xs', 'sm', 'md', 'lg', 'xl'];
  var stringOrNumberProp = propTypes.oneOfType([propTypes.number, propTypes.string]);
  var columnProps = propTypes.oneOfType([propTypes.bool, propTypes.number, propTypes.string, propTypes.shape({
    size: propTypes.oneOfType([propTypes.bool, propTypes.number, propTypes.string]),
    order: stringOrNumberProp,
    offset: stringOrNumberProp
  })]);
  var propTypes$3 = {
    tag: tagPropType,
    xs: columnProps,
    sm: columnProps,
    md: columnProps,
    lg: columnProps,
    xl: columnProps,
    className: propTypes.string,
    cssModule: propTypes.object,
    widths: propTypes.array
  };
  var defaultProps$7 = {
    tag: 'div',
    widths: colWidths
  };

  var getColumnSizeClass = function getColumnSizeClass(isXs, colWidth, colSize) {
    if (colSize === true || colSize === '') {
      return isXs ? 'col' : "col-" + colWidth;
    } else if (colSize === 'auto') {
      return isXs ? 'col-auto' : "col-" + colWidth + "-auto";
    }

    return isXs ? "col-" + colSize : "col-" + colWidth + "-" + colSize;
  };

  var Col = function Col(props) {
    var className = props.className,
        cssModule = props.cssModule,
        widths = props.widths,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "widths", "tag"]);

    var colClasses = [];
    widths.forEach(function (colWidth, i) {
      var columnProp = props[colWidth];
      delete attributes[colWidth];

      if (!columnProp && columnProp !== '') {
        return;
      }

      var isXs = !i;

      if (lodash_isobject(columnProp)) {
        var _classNames;

        var colSizeInterfix = isXs ? '-' : "-" + colWidth + "-";
        var colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
        colClasses.push(mapToCssModules(classnames((_classNames = {}, _classNames[colClass] = columnProp.size || columnProp.size === '', _classNames["order" + colSizeInterfix + columnProp.order] = columnProp.order || columnProp.order === 0, _classNames["offset" + colSizeInterfix + columnProp.offset] = columnProp.offset || columnProp.offset === 0, _classNames)), cssModule));
      } else {
        var _colClass = getColumnSizeClass(isXs, colWidth, columnProp);

        colClasses.push(_colClass);
      }
    });

    if (!colClasses.length) {
      colClasses.push('col');
    }

    var classes = mapToCssModules(classnames(className, colClasses), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  Col.propTypes = propTypes$3;
  Col.defaultProps = defaultProps$7;

  var propTypes$4 = {
    light: propTypes.bool,
    dark: propTypes.bool,
    full: propTypes.bool,
    fixed: propTypes.string,
    sticky: propTypes.string,
    color: propTypes.string,
    role: propTypes.string,
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object,
    expand: propTypes.oneOfType([propTypes.bool, propTypes.string])
  };
  var defaultProps$8 = {
    tag: 'nav',
    expand: false
  };

  var getExpandClass = function getExpandClass(expand) {
    if (expand === false) {
      return false;
    } else if (expand === true || expand === 'xs') {
      return 'navbar-expand';
    }

    return "navbar-expand-" + expand;
  };

  var Navbar = function Navbar(props) {
    var _classNames;

    var expand = props.expand,
        className = props.className,
        cssModule = props.cssModule,
        light = props.light,
        dark = props.dark,
        fixed = props.fixed,
        sticky = props.sticky,
        color = props.color,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["expand", "className", "cssModule", "light", "dark", "fixed", "sticky", "color", "tag"]);

    var classes = mapToCssModules(classnames(className, 'navbar', getExpandClass(expand), (_classNames = {
      'navbar-light': light,
      'navbar-dark': dark
    }, _classNames["bg-" + color] = color, _classNames["fixed-" + fixed] = fixed, _classNames["sticky-" + sticky] = sticky, _classNames)), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  Navbar.propTypes = propTypes$4;
  Navbar.defaultProps = defaultProps$8;

  var propTypes$5 = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$9 = {
    tag: 'a'
  };

  var NavbarBrand$1 = function NavbarBrand(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'navbar-brand'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  NavbarBrand$1.propTypes = propTypes$5;
  NavbarBrand$1.defaultProps = defaultProps$9;

  var propTypes$6 = {
    tag: tagPropType,
    type: propTypes.string,
    className: propTypes.string,
    cssModule: propTypes.object,
    children: propTypes.node
  };
  var defaultProps$a = {
    tag: 'button',
    type: 'button'
  };

  var NavbarToggler$1 = function NavbarToggler(props) {
    var className = props.className,
        cssModule = props.cssModule,
        children = props.children,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "children", "tag"]);

    var classes = mapToCssModules(classnames(className, 'navbar-toggler'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }), children || react.createElement("span", {
      className: mapToCssModules('navbar-toggler-icon', cssModule)
    }));
  };

  NavbarToggler$1.propTypes = propTypes$6;
  NavbarToggler$1.defaultProps = defaultProps$a;

  var propTypes$7 = {
    tabs: propTypes.bool,
    pills: propTypes.bool,
    vertical: propTypes.oneOfType([propTypes.bool, propTypes.string]),
    horizontal: propTypes.string,
    justified: propTypes.bool,
    fill: propTypes.bool,
    navbar: propTypes.bool,
    card: propTypes.bool,
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$b = {
    tag: 'ul',
    vertical: false
  };

  var getVerticalClass = function getVerticalClass(vertical) {
    if (vertical === false) {
      return false;
    } else if (vertical === true || vertical === 'xs') {
      return 'flex-column';
    }

    return "flex-" + vertical + "-column";
  };

  var Nav$1 = function Nav(props) {
    var className = props.className,
        cssModule = props.cssModule,
        tabs = props.tabs,
        pills = props.pills,
        vertical = props.vertical,
        horizontal = props.horizontal,
        justified = props.justified,
        fill = props.fill,
        navbar = props.navbar,
        card = props.card,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tabs", "pills", "vertical", "horizontal", "justified", "fill", "navbar", "card", "tag"]);

    var classes = mapToCssModules(classnames(className, navbar ? 'navbar-nav' : 'nav', horizontal ? "justify-content-" + horizontal : false, getVerticalClass(vertical), {
      'nav-tabs': tabs,
      'card-header-tabs': card && tabs,
      'nav-pills': pills,
      'card-header-pills': card && pills,
      'nav-justified': justified,
      'nav-fill': fill
    }), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  Nav$1.propTypes = propTypes$7;
  Nav$1.defaultProps = defaultProps$b;

  var propTypes$8 = {
    tag: tagPropType,
    active: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$c = {
    tag: 'li'
  };

  var NavItem$1 = function NavItem(props) {
    var className = props.className,
        cssModule = props.cssModule,
        active = props.active,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "active", "tag"]);

    var classes = mapToCssModules(classnames(className, 'nav-item', active ? 'active' : false), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  NavItem$1.propTypes = propTypes$8;
  NavItem$1.defaultProps = defaultProps$c;

  var propTypes$9 = {
    tag: tagPropType,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.func, propTypes.string]),
    disabled: propTypes.bool,
    active: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object,
    onClick: propTypes.func,
    href: propTypes.any
  };
  var defaultProps$d = {
    tag: 'a'
  };

  var NavLink =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(NavLink, _React$Component);

    function NavLink(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = NavLink.prototype;

    _proto.onClick = function onClick(e) {
      if (this.props.disabled) {
        e.preventDefault();
        return;
      }

      if (this.props.href === '#') {
        e.preventDefault();
      }

      if (this.props.onClick) {
        this.props.onClick(e);
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          active = _this$props.active,
          Tag = _this$props.tag,
          innerRef = _this$props.innerRef,
          attributes = _objectWithoutPropertiesLoose(_this$props, ["className", "cssModule", "active", "tag", "innerRef"]);

      var classes = mapToCssModules(classnames(className, 'nav-link', {
        disabled: attributes.disabled,
        active: active
      }), cssModule);
      return react.createElement(Tag, _extends$9({}, attributes, {
        ref: innerRef,
        onClick: this.onClick,
        className: classes
      }));
    };

    return NavLink;
  }(react.Component);

  NavLink.propTypes = propTypes$9;
  NavLink.defaultProps = defaultProps$d;

  var propTypes$a = {
    tag: tagPropType,
    listTag: tagPropType,
    className: propTypes.string,
    listClassName: propTypes.string,
    cssModule: propTypes.object,
    children: propTypes.node,
    'aria-label': propTypes.string
  };
  var defaultProps$e = {
    tag: 'nav',
    listTag: 'ol',
    'aria-label': 'breadcrumb'
  };

  var Breadcrumb$1 = function Breadcrumb(props) {
    var className = props.className,
        listClassName = props.listClassName,
        cssModule = props.cssModule,
        children = props.children,
        Tag = props.tag,
        ListTag = props.listTag,
        label = props['aria-label'],
        attributes = _objectWithoutPropertiesLoose(props, ["className", "listClassName", "cssModule", "children", "tag", "listTag", "aria-label"]);

    var classes = mapToCssModules(classnames(className), cssModule);
    var listClasses = mapToCssModules(classnames('breadcrumb', listClassName), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes,
      "aria-label": label
    }), react.createElement(ListTag, {
      className: listClasses
    }, children));
  };

  Breadcrumb$1.propTypes = propTypes$a;
  Breadcrumb$1.defaultProps = defaultProps$e;

  var propTypes$b = {
    tag: tagPropType,
    active: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$f = {
    tag: 'li'
  };

  var BreadcrumbItem$1 = function BreadcrumbItem(props) {
    var className = props.className,
        cssModule = props.cssModule,
        active = props.active,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "active", "tag"]);

    var classes = mapToCssModules(classnames(className, active ? 'active' : false, 'breadcrumb-item'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes,
      "aria-current": active ? 'page' : undefined
    }));
  };

  BreadcrumbItem$1.propTypes = propTypes$b;
  BreadcrumbItem$1.defaultProps = defaultProps$f;

  var propTypes$c = {
    active: propTypes.bool,
    'aria-label': propTypes.string,
    block: propTypes.bool,
    color: propTypes.string,
    disabled: propTypes.bool,
    outline: propTypes.bool,
    tag: tagPropType,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.func, propTypes.string]),
    onClick: propTypes.func,
    size: propTypes.string,
    children: propTypes.node,
    className: propTypes.string,
    cssModule: propTypes.object,
    close: propTypes.bool
  };
  var defaultProps$g = {
    color: 'secondary',
    tag: 'button'
  };

  var Button$1 =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Button, _React$Component);

    function Button(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = Button.prototype;

    _proto.onClick = function onClick(e) {
      if (this.props.disabled) {
        e.preventDefault();
        return;
      }

      if (this.props.onClick) {
        this.props.onClick(e);
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          active = _this$props.active,
          ariaLabel = _this$props['aria-label'],
          block = _this$props.block,
          className = _this$props.className,
          close = _this$props.close,
          cssModule = _this$props.cssModule,
          color = _this$props.color,
          outline = _this$props.outline,
          size = _this$props.size,
          Tag = _this$props.tag,
          innerRef = _this$props.innerRef,
          attributes = _objectWithoutPropertiesLoose(_this$props, ["active", "aria-label", "block", "className", "close", "cssModule", "color", "outline", "size", "tag", "innerRef"]);

      if (close && typeof attributes.children === 'undefined') {
        attributes.children = react.createElement("span", {
          "aria-hidden": true
        }, "\xD7");
      }

      var btnOutlineColor = "btn" + (outline ? '-outline' : '') + "-" + color;
      var classes = mapToCssModules(classnames(className, {
        close: close
      }, close || 'btn', close || btnOutlineColor, size ? "btn-" + size : false, block ? 'btn-block' : false, {
        active: active,
        disabled: this.props.disabled
      }), cssModule);

      if (attributes.href && Tag === 'button') {
        Tag = 'a';
      }

      var defaultAriaLabel = close ? 'Close' : null;
      return react.createElement(Tag, _extends$9({
        type: Tag === 'button' && attributes.onClick ? 'button' : undefined
      }, attributes, {
        className: classes,
        ref: innerRef,
        onClick: this.onClick,
        "aria-label": ariaLabel || defaultAriaLabel
      }));
    };

    return Button;
  }(react.Component);

  Button$1.propTypes = propTypes$c;
  Button$1.defaultProps = defaultProps$g;

  /**
   * DropdownContext
   * {
   *  toggle: PropTypes.func.isRequired,
   *  isOpen: PropTypes.bool.isRequired,
   *  direction: PropTypes.oneOf(['up', 'down', 'left', 'right']).isRequired,
   *  inNavbar: PropTypes.bool.isRequired,
   * }
   */

  var DropdownContext = react.createContext({});

  var propTypes$d = {
    disabled: propTypes.bool,
    direction: propTypes.oneOf(['up', 'down', 'left', 'right']),
    group: propTypes.bool,
    isOpen: propTypes.bool,
    nav: propTypes.bool,
    active: propTypes.bool,
    addonType: propTypes.oneOfType([propTypes.bool, propTypes.oneOf(['prepend', 'append'])]),
    size: propTypes.string,
    tag: tagPropType,
    toggle: propTypes.func,
    children: propTypes.node,
    className: propTypes.string,
    cssModule: propTypes.object,
    inNavbar: propTypes.bool,
    setActiveFromChild: propTypes.bool
  };
  var defaultProps$h = {
    isOpen: false,
    direction: 'down',
    nav: false,
    active: false,
    addonType: false,
    inNavbar: false,
    setActiveFromChild: false
  };

  var Dropdown$1 =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Dropdown, _React$Component);

    function Dropdown(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.addEvents = _this.addEvents.bind(_assertThisInitialized(_this));
      _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized(_this));
      _this.handleKeyDown = _this.handleKeyDown.bind(_assertThisInitialized(_this));
      _this.removeEvents = _this.removeEvents.bind(_assertThisInitialized(_this));
      _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));
      _this.containerRef = react.createRef();
      return _this;
    }

    var _proto = Dropdown.prototype;

    _proto.getContextValue = function getContextValue() {
      return {
        toggle: this.props.toggle,
        isOpen: this.props.isOpen,
        direction: this.props.direction === 'down' && this.props.dropup ? 'up' : this.props.direction,
        inNavbar: this.props.inNavbar
      };
    };

    _proto.componentDidMount = function componentDidMount() {
      this.handleProps();
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (this.props.isOpen !== prevProps.isOpen) {
        this.handleProps();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.removeEvents();
    };

    _proto.getContainer = function getContainer() {
      return this.containerRef.current;
    };

    _proto.getMenuCtrl = function getMenuCtrl() {
      if (this._$menuCtrl) return this._$menuCtrl;
      this._$menuCtrl = this.getContainer().querySelector('[aria-expanded]');
      return this._$menuCtrl;
    };

    _proto.getMenuItems = function getMenuItems() {
      return [].slice.call(this.getContainer().querySelectorAll('[role="menuitem"]'));
    };

    _proto.addEvents = function addEvents() {
      var _this2 = this;

      ['click', 'touchstart', 'keyup'].forEach(function (event) {
        return document.addEventListener(event, _this2.handleDocumentClick, true);
      });
    };

    _proto.removeEvents = function removeEvents() {
      var _this3 = this;

      ['click', 'touchstart', 'keyup'].forEach(function (event) {
        return document.removeEventListener(event, _this3.handleDocumentClick, true);
      });
    };

    _proto.handleDocumentClick = function handleDocumentClick(e) {
      if (e && (e.which === 3 || e.type === 'keyup' && e.which !== keyCodes.tab)) return;
      var container = this.getContainer();

      if (container.contains(e.target) && container !== e.target && (e.type !== 'keyup' || e.which === keyCodes.tab)) {
        return;
      }

      this.toggle(e);
    };

    _proto.handleKeyDown = function handleKeyDown(e) {
      var _this4 = this;

      if (/input|textarea/i.test(e.target.tagName) || keyCodes.tab === e.which && e.target.getAttribute('role') !== 'menuitem') {
        return;
      }

      e.preventDefault();
      if (this.props.disabled) return;

      if (this.getMenuCtrl() === e.target) {
        if (!this.props.isOpen && [keyCodes.space, keyCodes.enter, keyCodes.up, keyCodes.down].indexOf(e.which) > -1) {
          this.toggle(e);
          setTimeout(function () {
            return _this4.getMenuItems()[0].focus();
          });
        }
      }

      if (this.props.isOpen && e.target.getAttribute('role') === 'menuitem') {
        if ([keyCodes.tab, keyCodes.esc].indexOf(e.which) > -1) {
          this.toggle(e);
          this.getMenuCtrl().focus();
        } else if ([keyCodes.space, keyCodes.enter].indexOf(e.which) > -1) {
          e.target.click();
          this.getMenuCtrl().focus();
        } else if ([keyCodes.down, keyCodes.up].indexOf(e.which) > -1 || [keyCodes.n, keyCodes.p].indexOf(e.which) > -1 && e.ctrlKey) {
          var $menuitems = this.getMenuItems();
          var index = $menuitems.indexOf(e.target);

          if (keyCodes.up === e.which || keyCodes.p === e.which && e.ctrlKey) {
            index = index !== 0 ? index - 1 : $menuitems.length - 1;
          } else if (keyCodes.down === e.which || keyCodes.n === e.which && e.ctrlKey) {
            index = index === $menuitems.length - 1 ? 0 : index + 1;
          }

          $menuitems[index].focus();
        } else if (keyCodes.end === e.which) {
          var _$menuitems = this.getMenuItems();

          _$menuitems[_$menuitems.length - 1].focus();
        } else if (keyCodes.home === e.which) {
          var _$menuitems2 = this.getMenuItems();

          _$menuitems2[0].focus();
        } else if (e.which >= 48 && e.which <= 90) {
          var _$menuitems3 = this.getMenuItems();

          var charPressed = String.fromCharCode(e.which).toLowerCase();

          for (var i = 0; i < _$menuitems3.length; i += 1) {
            var firstLetter = _$menuitems3[i].textContent && _$menuitems3[i].textContent[0].toLowerCase();

            if (firstLetter === charPressed) {
              _$menuitems3[i].focus();

              break;
            }
          }
        }
      }
    };

    _proto.handleProps = function handleProps() {
      if (this.props.isOpen) {
        this.addEvents();
      } else {
        this.removeEvents();
      }
    };

    _proto.toggle = function toggle(e) {
      if (this.props.disabled) {
        return e && e.preventDefault();
      }

      return this.props.toggle(e);
    };

    _proto.render = function render() {
      var _classNames, _ref;

      var _omit = omit(this.props, ['toggle', 'disabled', 'inNavbar']),
          className = _omit.className,
          cssModule = _omit.cssModule,
          direction = _omit.direction,
          isOpen = _omit.isOpen,
          group = _omit.group,
          size = _omit.size,
          nav = _omit.nav,
          setActiveFromChild = _omit.setActiveFromChild,
          active = _omit.active,
          addonType = _omit.addonType,
          tag = _omit.tag,
          attrs = _objectWithoutPropertiesLoose(_omit, ["className", "cssModule", "direction", "isOpen", "group", "size", "nav", "setActiveFromChild", "active", "addonType", "tag"]);

      var Tag = tag || (nav ? 'li' : 'div');
      var subItemIsActive = false;

      if (setActiveFromChild) {
        react.Children.map(this.props.children[1].props.children, function (dropdownItem) {
          if (dropdownItem && dropdownItem.props.active) subItemIsActive = true;
        });
      }

      var classes = mapToCssModules(classnames(className, direction !== 'down' && "drop" + direction, nav && active ? 'active' : false, setActiveFromChild && subItemIsActive ? 'active' : false, (_classNames = {}, _classNames["input-group-" + addonType] = addonType, _classNames['btn-group'] = group, _classNames["btn-group-" + size] = !!size, _classNames.dropdown = !group && !addonType, _classNames.show = isOpen, _classNames['nav-item'] = nav, _classNames)), cssModule);
      return react.createElement(DropdownContext.Provider, {
        value: this.getContextValue()
      }, react.createElement(Manager, null, react.createElement(Tag, _extends$9({}, attrs, (_ref = {}, _ref[typeof Tag === 'string' ? 'ref' : 'innerRef'] = this.containerRef, _ref), {
        onKeyDown: this.handleKeyDown,
        className: classes
      }))));
    };

    return Dropdown;
  }(react.Component);

  Dropdown$1.propTypes = propTypes$d;
  Dropdown$1.defaultProps = defaultProps$h;

  var propTypes$e = {
    children: propTypes.node
  };

  var ButtonDropdown = function ButtonDropdown(props) {
    return react.createElement(Dropdown$1, _extends$9({
      group: true
    }, props));
  };

  ButtonDropdown.propTypes = propTypes$e;

  var propTypes$f = {
    tag: tagPropType,
    'aria-label': propTypes.string,
    className: propTypes.string,
    cssModule: propTypes.object,
    role: propTypes.string,
    size: propTypes.string,
    vertical: propTypes.bool
  };
  var defaultProps$i = {
    tag: 'div',
    role: 'group'
  };

  var ButtonGroup = function ButtonGroup(props) {
    var className = props.className,
        cssModule = props.cssModule,
        size = props.size,
        vertical = props.vertical,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "size", "vertical", "tag"]);

    var classes = mapToCssModules(classnames(className, size ? 'btn-group-' + size : false, vertical ? 'btn-group-vertical' : 'btn-group'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  ButtonGroup.propTypes = propTypes$f;
  ButtonGroup.defaultProps = defaultProps$i;

  var propTypes$g = {
    tag: tagPropType,
    'aria-label': propTypes.string,
    className: propTypes.string,
    cssModule: propTypes.object,
    role: propTypes.string
  };
  var defaultProps$j = {
    tag: 'div',
    role: 'toolbar'
  };

  var ButtonToolbar = function ButtonToolbar(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'btn-toolbar'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  ButtonToolbar.propTypes = propTypes$g;
  ButtonToolbar.defaultProps = defaultProps$j;

  var propTypes$h = {
    children: propTypes.node,
    active: propTypes.bool,
    disabled: propTypes.bool,
    divider: propTypes.bool,
    tag: tagPropType,
    header: propTypes.bool,
    onClick: propTypes.func,
    className: propTypes.string,
    cssModule: propTypes.object,
    toggle: propTypes.bool
  };
  var defaultProps$k = {
    tag: 'button',
    toggle: true
  };

  var DropdownItem$1 =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(DropdownItem, _React$Component);

    function DropdownItem(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      _this.getTabIndex = _this.getTabIndex.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = DropdownItem.prototype;

    _proto.onClick = function onClick(e) {
      if (this.props.disabled || this.props.header || this.props.divider) {
        e.preventDefault();
        return;
      }

      if (this.props.onClick) {
        this.props.onClick(e);
      }

      if (this.props.toggle) {
        this.context.toggle(e);
      }
    };

    _proto.getTabIndex = function getTabIndex() {
      if (this.props.disabled || this.props.header || this.props.divider) {
        return '-1';
      }

      return '0';
    };

    _proto.render = function render() {
      var tabIndex = this.getTabIndex();
      var role = tabIndex > -1 ? 'menuitem' : undefined;

      var _omit = omit(this.props, ['toggle']),
          className = _omit.className,
          cssModule = _omit.cssModule,
          divider = _omit.divider,
          Tag = _omit.tag,
          header = _omit.header,
          active = _omit.active,
          props = _objectWithoutPropertiesLoose(_omit, ["className", "cssModule", "divider", "tag", "header", "active"]);

      var classes = mapToCssModules(classnames(className, {
        disabled: props.disabled,
        'dropdown-item': !divider && !header,
        active: active,
        'dropdown-header': header,
        'dropdown-divider': divider
      }), cssModule);

      if (Tag === 'button') {
        if (header) {
          Tag = 'h6';
        } else if (divider) {
          Tag = 'div';
        } else if (props.href) {
          Tag = 'a';
        }
      }

      return react.createElement(Tag, _extends$9({
        type: Tag === 'button' && (props.onClick || this.props.toggle) ? 'button' : undefined
      }, props, {
        tabIndex: tabIndex,
        role: role,
        className: classes,
        onClick: this.onClick
      }));
    };

    return DropdownItem;
  }(react.Component);

  DropdownItem$1.propTypes = propTypes$h;
  DropdownItem$1.defaultProps = defaultProps$k;
  DropdownItem$1.contextType = DropdownContext;

  function _objectSpread$2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  var propTypes$i = {
    tag: tagPropType,
    children: propTypes.node.isRequired,
    right: propTypes.bool,
    flip: propTypes.bool,
    modifiers: propTypes.object,
    className: propTypes.string,
    cssModule: propTypes.object,
    persist: propTypes.bool
  };
  var defaultProps$l = {
    tag: 'div',
    flip: true
  };
  var noFlipModifier = {
    flip: {
      enabled: false
    }
  };
  var directionPositionMap = {
    up: 'top',
    left: 'left',
    right: 'right',
    down: 'bottom'
  };

  var DropdownMenu$1 =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(DropdownMenu, _React$Component);

    function DropdownMenu() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = DropdownMenu.prototype;

    _proto.render = function render() {
      var _this = this;

      var _this$props = this.props,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          right = _this$props.right,
          tag = _this$props.tag,
          flip = _this$props.flip,
          modifiers = _this$props.modifiers,
          persist = _this$props.persist,
          attrs = _objectWithoutPropertiesLoose(_this$props, ["className", "cssModule", "right", "tag", "flip", "modifiers", "persist"]);

      var classes = mapToCssModules(classnames(className, 'dropdown-menu', {
        'dropdown-menu-right': right,
        show: this.context.isOpen
      }), cssModule);
      var Tag = tag;

      if (persist || this.context.isOpen && !this.context.inNavbar) {
        var position1 = directionPositionMap[this.context.direction] || 'bottom';
        var position2 = right ? 'end' : 'start';
        var poperPlacement = position1 + "-" + position2;
        var poperModifiers = !flip ? _objectSpread$2({}, modifiers, noFlipModifier) : modifiers;
        return react.createElement(Popper$1, {
          placement: poperPlacement,
          modifiers: poperModifiers
        }, function (_ref) {
          var ref = _ref.ref,
              style = _ref.style,
              placement = _ref.placement;
          return react.createElement(Tag, _extends$9({
            tabIndex: "-1",
            role: "menu",
            ref: ref,
            style: style
          }, attrs, {
            "aria-hidden": !_this.context.isOpen,
            className: classes,
            "x-placement": placement
          }));
        });
      }

      return react.createElement(Tag, _extends$9({
        tabIndex: "-1",
        role: "menu"
      }, attrs, {
        "aria-hidden": !this.context.isOpen,
        className: classes,
        "x-placement": attrs.placement
      }));
    };

    return DropdownMenu;
  }(react.Component);
  DropdownMenu$1.propTypes = propTypes$i;
  DropdownMenu$1.defaultProps = defaultProps$l;
  DropdownMenu$1.contextType = DropdownContext;

  var propTypes$j = {
    caret: propTypes.bool,
    color: propTypes.string,
    children: propTypes.node,
    className: propTypes.string,
    cssModule: propTypes.object,
    disabled: propTypes.bool,
    onClick: propTypes.func,
    'aria-haspopup': propTypes.bool,
    split: propTypes.bool,
    tag: tagPropType,
    nav: propTypes.bool
  };
  var defaultProps$m = {
    'aria-haspopup': true,
    color: 'secondary'
  };

  var DropdownToggle$1 =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(DropdownToggle, _React$Component);

    function DropdownToggle(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = DropdownToggle.prototype;

    _proto.onClick = function onClick(e) {
      if (this.props.disabled) {
        e.preventDefault();
        return;
      }

      if (this.props.nav && !this.props.tag) {
        e.preventDefault();
      }

      if (this.props.onClick) {
        this.props.onClick(e);
      }

      this.context.toggle(e);
    };

    _proto.render = function render() {
      var _this2 = this;

      var _this$props = this.props,
          className = _this$props.className,
          color = _this$props.color,
          cssModule = _this$props.cssModule,
          caret = _this$props.caret,
          split = _this$props.split,
          nav = _this$props.nav,
          tag = _this$props.tag,
          props = _objectWithoutPropertiesLoose(_this$props, ["className", "color", "cssModule", "caret", "split", "nav", "tag"]);

      var ariaLabel = props['aria-label'] || 'Toggle Dropdown';
      var classes = mapToCssModules(classnames(className, {
        'dropdown-toggle': caret || split,
        'dropdown-toggle-split': split,
        'nav-link': nav
      }), cssModule);
      var children = props.children || react.createElement("span", {
        className: "sr-only"
      }, ariaLabel);
      var Tag;

      if (nav && !tag) {
        Tag = 'a';
        props.href = '#';
      } else if (!tag) {
        Tag = Button$1;
        props.color = color;
        props.cssModule = cssModule;
      } else {
        Tag = tag;
      }

      if (this.context.inNavbar) {
        return react.createElement(Tag, _extends$9({}, props, {
          className: classes,
          onClick: this.onClick,
          "aria-expanded": this.context.isOpen,
          children: children
        }));
      }

      return react.createElement(Reference, null, function (_ref) {
        var _ref2;

        var ref = _ref.ref;
        return react.createElement(Tag, _extends$9({}, props, (_ref2 = {}, _ref2[typeof Tag === 'string' ? 'ref' : 'innerRef'] = ref, _ref2), {
          className: classes,
          onClick: _this2.onClick,
          "aria-expanded": _this2.context.isOpen,
          children: children
        }));
      });
    };

    return DropdownToggle;
  }(react.Component);

  DropdownToggle$1.propTypes = propTypes$j;
  DropdownToggle$1.defaultProps = defaultProps$m;
  DropdownToggle$1.contextType = DropdownContext;

  var interopRequireDefault = createCommonjsModule(function (module) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  module.exports = _interopRequireDefault;
  });

  unwrapExports(interopRequireDefault);

  var hasClass_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.default = hasClass;

  function hasClass(element, className) {
    if (element.classList) return !!className && element.classList.contains(className);else return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }

  module.exports = exports["default"];
  });

  unwrapExports(hasClass_1);

  var addClass_1 = createCommonjsModule(function (module, exports) {



  exports.__esModule = true;
  exports.default = addClass;

  var _hasClass = interopRequireDefault(hasClass_1);

  function addClass(element, className) {
    if (element.classList) element.classList.add(className);else if (!(0, _hasClass.default)(element, className)) if (typeof element.className === 'string') element.className = element.className + ' ' + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + ' ' + className);
  }

  module.exports = exports["default"];
  });

  var addOneClass = unwrapExports(addClass_1);

  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp('(^|\\s)' + classToRemove + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
  }

  var removeClass = function removeClass(element, className) {
    if (element.classList) element.classList.remove(className);else if (typeof element.className === 'string') element.className = replaceClassName(element.className, className);else element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  function componentWillMount() {
    // Call this.constructor.gDSFP to support sub-classes.
    var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
    if (state !== null && state !== undefined) {
      this.setState(state);
    }
  }

  function componentWillReceiveProps(nextProps) {
    // Call this.constructor.gDSFP to support sub-classes.
    // Use the setState() updater to ensure state isn't stale in certain edge cases.
    function updater(prevState) {
      var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
      return state !== null && state !== undefined ? state : null;
    }
    // Binding "this" is important for shallow renderer support.
    this.setState(updater.bind(this));
  }

  function componentWillUpdate(nextProps, nextState) {
    try {
      var prevProps = this.props;
      var prevState = this.state;
      this.props = nextProps;
      this.state = nextState;
      this.__reactInternalSnapshotFlag = true;
      this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
        prevProps,
        prevState
      );
    } finally {
      this.props = prevProps;
      this.state = prevState;
    }
  }

  // React may warn about cWM/cWRP/cWU methods being deprecated.
  // Add a flag to suppress these warnings for this special case.
  componentWillMount.__suppressDeprecationWarning = true;
  componentWillReceiveProps.__suppressDeprecationWarning = true;
  componentWillUpdate.__suppressDeprecationWarning = true;

  function polyfill(Component) {
    var prototype = Component.prototype;

    if (!prototype || !prototype.isReactComponent) {
      throw new Error('Can only polyfill class components');
    }

    if (
      typeof Component.getDerivedStateFromProps !== 'function' &&
      typeof prototype.getSnapshotBeforeUpdate !== 'function'
    ) {
      return Component;
    }

    // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Error if any of these lifecycles are present,
    // Because they would work differently between older and newer (16.3+) versions of React.
    var foundWillMountName = null;
    var foundWillReceivePropsName = null;
    var foundWillUpdateName = null;
    if (typeof prototype.componentWillMount === 'function') {
      foundWillMountName = 'componentWillMount';
    } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {
      foundWillMountName = 'UNSAFE_componentWillMount';
    }
    if (typeof prototype.componentWillReceiveProps === 'function') {
      foundWillReceivePropsName = 'componentWillReceiveProps';
    } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {
      foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
    }
    if (typeof prototype.componentWillUpdate === 'function') {
      foundWillUpdateName = 'componentWillUpdate';
    } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {
      foundWillUpdateName = 'UNSAFE_componentWillUpdate';
    }
    if (
      foundWillMountName !== null ||
      foundWillReceivePropsName !== null ||
      foundWillUpdateName !== null
    ) {
      var componentName = Component.displayName || Component.name;
      var newApiName =
        typeof Component.getDerivedStateFromProps === 'function'
          ? 'getDerivedStateFromProps()'
          : 'getSnapshotBeforeUpdate()';

      throw Error(
        'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' +
          componentName +
          ' uses ' +
          newApiName +
          ' but also contains the following legacy lifecycles:' +
          (foundWillMountName !== null ? '\n  ' + foundWillMountName : '') +
          (foundWillReceivePropsName !== null
            ? '\n  ' + foundWillReceivePropsName
            : '') +
          (foundWillUpdateName !== null ? '\n  ' + foundWillUpdateName : '') +
          '\n\nThe above lifecycles should be removed. Learn more about this warning here:\n' +
          'https://fb.me/react-async-component-lifecycle-hooks'
      );
    }

    // React <= 16.2 does not support static getDerivedStateFromProps.
    // As a workaround, use cWM and cWRP to invoke the new static lifecycle.
    // Newer versions of React will ignore these lifecycles if gDSFP exists.
    if (typeof Component.getDerivedStateFromProps === 'function') {
      prototype.componentWillMount = componentWillMount;
      prototype.componentWillReceiveProps = componentWillReceiveProps;
    }

    // React <= 16.2 does not support getSnapshotBeforeUpdate.
    // As a workaround, use cWU to invoke the new lifecycle.
    // Newer versions of React will ignore that lifecycle if gSBU exists.
    if (typeof prototype.getSnapshotBeforeUpdate === 'function') {
      if (typeof prototype.componentDidUpdate !== 'function') {
        throw new Error(
          'Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype'
        );
      }

      prototype.componentWillUpdate = componentWillUpdate;

      var componentDidUpdate = prototype.componentDidUpdate;

      prototype.componentDidUpdate = function componentDidUpdatePolyfill(
        prevProps,
        prevState,
        maybeSnapshot
      ) {
        // 16.3+ will not execute our will-update method;
        // It will pass a snapshot value to did-update though.
        // Older versions will require our polyfilled will-update value.
        // We need to handle both cases, but can't just check for the presence of "maybeSnapshot",
        // Because for <= 15.x versions this might be a "prevContext" object.
        // We also can't just check "__reactInternalSnapshot",
        // Because get-snapshot might return a falsy value.
        // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.
        var snapshot = this.__reactInternalSnapshotFlag
          ? this.__reactInternalSnapshot
          : maybeSnapshot;

        componentDidUpdate.call(this, prevProps, prevState, snapshot);
      };
    }

    return Component;
  }

  var reactLifecyclesCompat_es = /*#__PURE__*/Object.freeze({
    polyfill: polyfill
  });

  var PropTypes = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.classNamesShape = exports.timeoutsShape = void 0;

  var _propTypes = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  var timeoutsShape = null;
  exports.timeoutsShape = timeoutsShape;
  var classNamesShape = null;
  exports.classNamesShape = classNamesShape;
  });

  unwrapExports(PropTypes);
  var PropTypes_1 = PropTypes.classNamesShape;
  var PropTypes_2 = PropTypes.timeoutsShape;

  var Transition_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;

  var PropTypes = _interopRequireWildcard(propTypes);

  var _react = _interopRequireDefault(react);

  var _reactDom = _interopRequireDefault(reactDom);





  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

  function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  var UNMOUNTED = 'unmounted';
  exports.UNMOUNTED = UNMOUNTED;
  var EXITED = 'exited';
  exports.EXITED = EXITED;
  var ENTERING = 'entering';
  exports.ENTERING = ENTERING;
  var ENTERED = 'entered';
  exports.ENTERED = ENTERED;
  var EXITING = 'exiting';
  /**
   * The Transition component lets you describe a transition from one component
   * state to another _over time_ with a simple declarative API. Most commonly
   * it's used to animate the mounting and unmounting of a component, but can also
   * be used to describe in-place transition states as well.
   *
   * ---
   *
   * **Note**: `Transition` is a platform-agnostic base component. If you're using
   * transitions in CSS, you'll probably want to use
   * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
   * instead. It inherits all the features of `Transition`, but contains
   * additional features necessary to play nice with CSS transitions (hence the
   * name of the component).
   *
   * ---
   *
   * By default the `Transition` component does not alter the behavior of the
   * component it renders, it only tracks "enter" and "exit" states for the
   * components. It's up to you to give meaning and effect to those states. For
   * example we can add styles to a component when it enters or exits:
   *
   * ```jsx
   * import { Transition } from 'react-transition-group';
   *
   * const duration = 300;
   *
   * const defaultStyle = {
   *   transition: `opacity ${duration}ms ease-in-out`,
   *   opacity: 0,
   * }
   *
   * const transitionStyles = {
   *   entering: { opacity: 0 },
   *   entered:  { opacity: 1 },
   * };
   *
   * const Fade = ({ in: inProp }) => (
   *   <Transition in={inProp} timeout={duration}>
   *     {state => (
   *       <div style={{
   *         ...defaultStyle,
   *         ...transitionStyles[state]
   *       }}>
   *         I'm a fade Transition!
   *       </div>
   *     )}
   *   </Transition>
   * );
   * ```
   *
   * There are 4 main states a Transition can be in:
   *  - `'entering'`
   *  - `'entered'`
   *  - `'exiting'`
   *  - `'exited'`
   *
   * Transition state is toggled via the `in` prop. When `true` the component
   * begins the "Enter" stage. During this stage, the component will shift from
   * its current transition state, to `'entering'` for the duration of the
   * transition and then to the `'entered'` stage once it's complete. Let's take
   * the following example (we'll use the
   * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
   *
   * ```jsx
   * function App() {
   *   const [inProp, setInProp] = useState(false);
   *   return (
   *     <div>
   *       <Transition in={inProp} timeout={500}>
   *         {state => (
   *           // ...
   *         )}
   *       </Transition>
   *       <button onClick={() => setInProp(true)}>
   *         Click to Enter
   *       </button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the button is clicked the component will shift to the `'entering'` state
   * and stay there for 500ms (the value of `timeout`) before it finally switches
   * to `'entered'`.
   *
   * When `in` is `false` the same thing happens except the state moves from
   * `'exiting'` to `'exited'`.
   */

  exports.EXITING = EXITING;

  var Transition =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Transition, _React$Component);

    function Transition(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context.transitionGroup; // In the context of a TransitionGroup all enters are really appears

      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;

      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }

      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }

    var _proto = Transition.prototype;

    _proto.getChildContext = function getChildContext() {
      return {
        transitionGroup: null // allows for nested Transitions

      };
    };

    Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;

      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }

      return null;
    }; // getSnapshotBeforeUpdate(prevProps) {
    //   let nextStatus = null
    //   if (prevProps !== this.props) {
    //     const { status } = this.state
    //     if (this.props.in) {
    //       if (status !== ENTERING && status !== ENTERED) {
    //         nextStatus = ENTERING
    //       }
    //     } else {
    //       if (status === ENTERING || status === ENTERED) {
    //         nextStatus = EXITING
    //       }
    //     }
    //   }
    //   return { nextStatus }
    // }


    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;

      if (prevProps !== this.props) {
        var status = this.state.status;

        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }

      this.updateStatus(false, nextStatus);
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };

    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;

      if (timeout != null && typeof timeout !== 'number') {
        exit = timeout.exit;
        enter = timeout.enter; // TODO: remove fallback for next major

        appear = timeout.appear !== undefined ? timeout.appear : enter;
      }

      return {
        exit: exit,
        enter: enter,
        appear: appear
      };
    };

    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }

      if (nextStatus !== null) {
        // nextStatus will always be ENTERING or EXITING.
        this.cancelNextCallback();

        var node = _reactDom.default.findDOMNode(this);

        if (nextStatus === ENTERING) {
          this.performEnter(node, mounting);
        } else {
          this.performExit(node);
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };

    _proto.performEnter = function performEnter(node, mounting) {
      var _this2 = this;

      var enter = this.props.enter;
      var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;
      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
      // if we are mounting and running this it means appear _must_ be set

      if (!mounting && !enter) {
        this.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(node);
        });
        return;
      }

      this.props.onEnter(node, appearing);
      this.safeSetState({
        status: ENTERING
      }, function () {
        _this2.props.onEntering(node, appearing);

        _this2.onTransitionEnd(node, enterTimeout, function () {
          _this2.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(node, appearing);
          });
        });
      });
    };

    _proto.performExit = function performExit(node) {
      var _this3 = this;

      var exit = this.props.exit;
      var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

      if (!exit) {
        this.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(node);
        });
        return;
      }

      this.props.onExit(node);
      this.safeSetState({
        status: EXITING
      }, function () {
        _this3.props.onExiting(node);

        _this3.onTransitionEnd(node, timeouts.exit, function () {
          _this3.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(node);
          });
        });
      });
    };

    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };

    _proto.safeSetState = function safeSetState(nextState, callback) {
      // This shouldn't be necessary, but there are weird race conditions with
      // setState callbacks and unmounting in testing, so always make sure that
      // we can cancel any pending setState callbacks after we unmount.
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };

    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;

      var active = true;

      this.nextCallback = function (event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };

      this.nextCallback.cancel = function () {
        active = false;
      };

      return this.nextCallback;
    };

    _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
      this.setNextCallback(handler);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }

      if (this.props.addEndListener) {
        this.props.addEndListener(node, this.nextCallback);
      }

      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };

    _proto.render = function render() {
      var status = this.state.status;

      if (status === UNMOUNTED) {
        return null;
      }

      var _this$props = this.props,
          children = _this$props.children,
          childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]); // filter props for Transtition


      delete childProps.in;
      delete childProps.mountOnEnter;
      delete childProps.unmountOnExit;
      delete childProps.appear;
      delete childProps.enter;
      delete childProps.exit;
      delete childProps.timeout;
      delete childProps.addEndListener;
      delete childProps.onEnter;
      delete childProps.onEntering;
      delete childProps.onEntered;
      delete childProps.onExit;
      delete childProps.onExiting;
      delete childProps.onExited;

      if (typeof children === 'function') {
        return children(status, childProps);
      }

      var child = _react.default.Children.only(children);

      return _react.default.cloneElement(child, childProps);
    };

    return Transition;
  }(_react.default.Component);

  Transition.contextTypes = {
    transitionGroup: PropTypes.object
  };
  Transition.childContextTypes = {
    transitionGroup: function transitionGroup() {}
  };
  Transition.propTypes = {};

  function noop() {}

  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
  };
  Transition.UNMOUNTED = 0;
  Transition.EXITED = 1;
  Transition.ENTERING = 2;
  Transition.ENTERED = 3;
  Transition.EXITING = 4;

  var _default = (0, reactLifecyclesCompat_es.polyfill)(Transition);

  exports.default = _default;
  });

  unwrapExports(Transition_1);
  var Transition_2 = Transition_1.EXITING;
  var Transition_3 = Transition_1.ENTERED;
  var Transition_4 = Transition_1.ENTERING;
  var Transition_5 = Transition_1.EXITED;
  var Transition_6 = Transition_1.UNMOUNTED;

  var CSSTransition_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.default = void 0;

  var PropTypes = _interopRequireWildcard(propTypes);

  var _addClass = _interopRequireDefault(addClass_1);

  var _removeClass = _interopRequireDefault(removeClass);

  var _react = _interopRequireDefault(react);

  var _Transition = _interopRequireDefault(Transition_1);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

  function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  var addClass = function addClass(node, classes) {
    return node && classes && classes.split(' ').forEach(function (c) {
      return (0, _addClass.default)(node, c);
    });
  };

  var removeClass$1 = function removeClass(node, classes) {
    return node && classes && classes.split(' ').forEach(function (c) {
      return (0, _removeClass.default)(node, c);
    });
  };
  /**
   * A transition component inspired by the excellent
   * [ng-animate](http://www.nganimate.org/) library, you should use it if you're
   * using CSS transitions or animations. It's built upon the
   * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
   * component, so it inherits all of its props.
   *
   * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
   * and `exit` states of the transition. The first class is applied and then a
   * second `*-active` class in order to activate the CSSS transition. After the
   * transition, matching `*-done` class names are applied to persist the
   * transition state.
   *
   * ```jsx
   * function App() {
   *   const [inProp, setInProp] = useState(false);
   *   return (
   *     <div>
   *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
   *         <div>
   *           {"I'll receive my-node-* classes"}
   *         </div>
   *       </CSSTransition>
   *       <button type="button" onClick={() => setInProp(true)}>
   *         Click to Enter
   *       </button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the `in` prop is set to `true`, the child component will first receive
   * the class `example-enter`, then the `example-enter-active` will be added in
   * the next tick. `CSSTransition` [forces a
   * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
   * between before adding the `example-enter-active`. This is an important trick
   * because it allows us to transition between `example-enter` and
   * `example-enter-active` even though they were added immediately one after
   * another. Most notably, this is what makes it possible for us to animate
   * _appearance_.
   *
   * ```css
   * .my-node-enter {
   *   opacity: 0;
   * }
   * .my-node-enter-active {
   *   opacity: 1;
   *   transition: opacity 200ms;
   * }
   * .my-node-exit {
   *   opacity: 1;
   * }
   * .my-node-exit-active {
   *   opacity: 0;
   *   transition: opacity: 200ms;
   * }
   * ```
   *
   * `*-active` classes represent which styles you want to animate **to**.
   */


  var CSSTransition =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(CSSTransition, _React$Component);

    function CSSTransition() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _this.onEnter = function (node, appearing) {
        var _this$getClassNames = _this.getClassNames(appearing ? 'appear' : 'enter'),
            className = _this$getClassNames.className;

        _this.removeClasses(node, 'exit');

        addClass(node, className);

        if (_this.props.onEnter) {
          _this.props.onEnter(node, appearing);
        }
      };

      _this.onEntering = function (node, appearing) {
        var _this$getClassNames2 = _this.getClassNames(appearing ? 'appear' : 'enter'),
            activeClassName = _this$getClassNames2.activeClassName;

        _this.reflowAndAddClass(node, activeClassName);

        if (_this.props.onEntering) {
          _this.props.onEntering(node, appearing);
        }
      };

      _this.onEntered = function (node, appearing) {
        var appearClassName = _this.getClassNames('appear').doneClassName;

        var enterClassName = _this.getClassNames('enter').doneClassName;

        var doneClassName = appearing ? appearClassName + " " + enterClassName : enterClassName;

        _this.removeClasses(node, appearing ? 'appear' : 'enter');

        addClass(node, doneClassName);

        if (_this.props.onEntered) {
          _this.props.onEntered(node, appearing);
        }
      };

      _this.onExit = function (node) {
        var _this$getClassNames3 = _this.getClassNames('exit'),
            className = _this$getClassNames3.className;

        _this.removeClasses(node, 'appear');

        _this.removeClasses(node, 'enter');

        addClass(node, className);

        if (_this.props.onExit) {
          _this.props.onExit(node);
        }
      };

      _this.onExiting = function (node) {
        var _this$getClassNames4 = _this.getClassNames('exit'),
            activeClassName = _this$getClassNames4.activeClassName;

        _this.reflowAndAddClass(node, activeClassName);

        if (_this.props.onExiting) {
          _this.props.onExiting(node);
        }
      };

      _this.onExited = function (node) {
        var _this$getClassNames5 = _this.getClassNames('exit'),
            doneClassName = _this$getClassNames5.doneClassName;

        _this.removeClasses(node, 'exit');

        addClass(node, doneClassName);

        if (_this.props.onExited) {
          _this.props.onExited(node);
        }
      };

      _this.getClassNames = function (type) {
        var classNames = _this.props.classNames;
        var isStringClassNames = typeof classNames === 'string';
        var prefix = isStringClassNames && classNames ? classNames + '-' : '';
        var className = isStringClassNames ? prefix + type : classNames[type];
        var activeClassName = isStringClassNames ? className + '-active' : classNames[type + 'Active'];
        var doneClassName = isStringClassNames ? className + '-done' : classNames[type + 'Done'];
        return {
          className: className,
          activeClassName: activeClassName,
          doneClassName: doneClassName
        };
      };

      return _this;
    }

    var _proto = CSSTransition.prototype;

    _proto.removeClasses = function removeClasses(node, type) {
      var _this$getClassNames6 = this.getClassNames(type),
          className = _this$getClassNames6.className,
          activeClassName = _this$getClassNames6.activeClassName,
          doneClassName = _this$getClassNames6.doneClassName;

      className && removeClass$1(node, className);
      activeClassName && removeClass$1(node, activeClassName);
      doneClassName && removeClass$1(node, doneClassName);
    };

    _proto.reflowAndAddClass = function reflowAndAddClass(node, className) {
      // This is for to force a repaint,
      // which is necessary in order to transition styles when adding a class name.
      if (className) {
        /* eslint-disable no-unused-expressions */
        node && node.scrollTop;
        /* eslint-enable no-unused-expressions */

        addClass(node, className);
      }
    };

    _proto.render = function render() {
      var props = _extends({}, this.props);

      delete props.classNames;
      return _react.default.createElement(_Transition.default, _extends({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };

    return CSSTransition;
  }(_react.default.Component);

  CSSTransition.defaultProps = {
    classNames: ''
  };
  CSSTransition.propTypes = {};
  var _default = CSSTransition;
  exports.default = _default;
  module.exports = exports["default"];
  });

  unwrapExports(CSSTransition_1);

  var ChildMapping = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.getChildMapping = getChildMapping;
  exports.mergeChildMappings = mergeChildMappings;
  exports.getInitialChildMapping = getInitialChildMapping;
  exports.getNextChildMapping = getNextChildMapping;



  /**
   * Given `this.props.children`, return an object mapping key to child.
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */
  function getChildMapping(children, mapFn) {
    var mapper = function mapper(child) {
      return mapFn && (0, react.isValidElement)(child) ? mapFn(child) : child;
    };

    var result = Object.create(null);
    if (children) react.Children.map(children, function (c) {
      return c;
    }).forEach(function (child) {
      // run the map function here instead so that the key is the computed one
      result[child.key] = mapper(child);
    });
    return result;
  }
  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */


  function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      return key in next ? next[key] : prev[key];
    } // For each key of `next`, the list of keys to insert before that key in
    // the combined list


    var nextKeysPending = Object.create(null);
    var pendingKeys = [];

    for (var prevKey in prev) {
      if (prevKey in next) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};

    for (var nextKey in next) {
      if (nextKeysPending[nextKey]) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }

      childMapping[nextKey] = getValueForKey(nextKey);
    } // Finally, add the keys which didn't appear before any key in `next`


    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }

  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }

  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function (child) {
      return (0, react.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, 'appear', props),
        enter: getProp(child, 'enter', props),
        exit: getProp(child, 'exit', props)
      });
    });
  }

  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function (key) {
      var child = children[key];
      if (!(0, react.isValidElement)(child)) return;
      var hasPrev = key in prevChildMapping;
      var hasNext = key in nextChildMapping;
      var prevChild = prevChildMapping[key];
      var isLeaving = (0, react.isValidElement)(prevChild) && !prevChild.props.in; // item is new (entering)

      if (hasNext && (!hasPrev || isLeaving)) {
        // console.log('entering', key)
        children[key] = (0, react.cloneElement)(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        // item is old (exiting)
        // console.log('leaving', key)
        children[key] = (0, react.cloneElement)(child, {
          in: false
        });
      } else if (hasNext && hasPrev && (0, react.isValidElement)(prevChild)) {
        // item hasn't changed transition states
        // copy over the last transition props;
        // console.log('unchanged', key)
        children[key] = (0, react.cloneElement)(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      }
    });
    return children;
  }
  });

  unwrapExports(ChildMapping);
  var ChildMapping_1 = ChildMapping.getChildMapping;
  var ChildMapping_2 = ChildMapping.mergeChildMappings;
  var ChildMapping_3 = ChildMapping.getInitialChildMapping;
  var ChildMapping_4 = ChildMapping.getNextChildMapping;

  var TransitionGroup_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.default = void 0;

  var _propTypes = _interopRequireDefault(propTypes);

  var _react = _interopRequireDefault(react);





  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  var values = Object.values || function (obj) {
    return Object.keys(obj).map(function (k) {
      return obj[k];
    });
  };

  var defaultProps = {
    component: 'div',
    childFactory: function childFactory(child) {
      return child;
    }
    /**
     * The `<TransitionGroup>` component manages a set of transition components
     * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
     * components, `<TransitionGroup>` is a state machine for managing the mounting
     * and unmounting of components over time.
     *
     * Consider the example below. As items are removed or added to the TodoList the
     * `in` prop is toggled automatically by the `<TransitionGroup>`.
     *
     * Note that `<TransitionGroup>`  does not define any animation behavior!
     * Exactly _how_ a list item animates is up to the individual transition
     * component. This means you can mix and match animations across different list
     * items.
     */

  };

  var TransitionGroup =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(TransitionGroup, _React$Component);

    function TransitionGroup(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;

      var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this))); // Initial children should all be entering, dependent on appear


      _this.state = {
        handleExited: handleExited,
        firstRender: true
      };
      return _this;
    }

    var _proto = TransitionGroup.prototype;

    _proto.getChildContext = function getChildContext() {
      return {
        transitionGroup: {
          isMounting: !this.appeared
        }
      };
    };

    _proto.componentDidMount = function componentDidMount() {
      this.appeared = true;
      this.mounted = true;
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };

    TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children,
          handleExited = _ref.handleExited,
          firstRender = _ref.firstRender;
      return {
        children: firstRender ? (0, ChildMapping.getInitialChildMapping)(nextProps, handleExited) : (0, ChildMapping.getNextChildMapping)(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };

    _proto.handleExited = function handleExited(child, node) {
      var currentChildMapping = (0, ChildMapping.getChildMapping)(this.props.children);
      if (child.key in currentChildMapping) return;

      if (child.props.onExited) {
        child.props.onExited(node);
      }

      if (this.mounted) {
        this.setState(function (state) {
          var children = _extends({}, state.children);

          delete children[child.key];
          return {
            children: children
          };
        });
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          Component = _this$props.component,
          childFactory = _this$props.childFactory,
          props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

      var children = values(this.state.children).map(childFactory);
      delete props.appear;
      delete props.enter;
      delete props.exit;

      if (Component === null) {
        return children;
      }

      return _react.default.createElement(Component, props, children);
    };

    return TransitionGroup;
  }(_react.default.Component);

  TransitionGroup.childContextTypes = {
    transitionGroup: _propTypes.default.object.isRequired
  };
  TransitionGroup.propTypes = {};
  TransitionGroup.defaultProps = defaultProps;

  var _default = (0, reactLifecyclesCompat_es.polyfill)(TransitionGroup);

  exports.default = _default;
  module.exports = exports["default"];
  });

  unwrapExports(TransitionGroup_1);

  var ReplaceTransition_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.default = void 0;

  var _propTypes = _interopRequireDefault(propTypes);

  var _react = _interopRequireDefault(react);



  var _TransitionGroup = _interopRequireDefault(TransitionGroup_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  /**
   * The `<ReplaceTransition>` component is a specialized `Transition` component
   * that animates between two children.
   *
   * ```jsx
   * <ReplaceTransition in>
   *   <Fade><div>I appear first</div></Fade>
   *   <Fade><div>I replace the above</div></Fade>
   * </ReplaceTransition>
   * ```
   */
  var ReplaceTransition =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(ReplaceTransition, _React$Component);

    function ReplaceTransition() {
      var _this;

      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
        _args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

      _this.handleEnter = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return _this.handleLifecycle('onEnter', 0, args);
      };

      _this.handleEntering = function () {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return _this.handleLifecycle('onEntering', 0, args);
      };

      _this.handleEntered = function () {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return _this.handleLifecycle('onEntered', 0, args);
      };

      _this.handleExit = function () {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return _this.handleLifecycle('onExit', 1, args);
      };

      _this.handleExiting = function () {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        return _this.handleLifecycle('onExiting', 1, args);
      };

      _this.handleExited = function () {
        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        return _this.handleLifecycle('onExited', 1, args);
      };

      return _this;
    }

    var _proto = ReplaceTransition.prototype;

    _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
      var _child$props;

      var children = this.props.children;

      var child = _react.default.Children.toArray(children)[idx];

      if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
      if (this.props[handler]) this.props[handler]((0, reactDom.findDOMNode)(this));
    };

    _proto.render = function render() {
      var _this$props = this.props,
          children = _this$props.children,
          inProp = _this$props.in,
          props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);

      var _React$Children$toArr = _react.default.Children.toArray(children),
          first = _React$Children$toArr[0],
          second = _React$Children$toArr[1];

      delete props.onEnter;
      delete props.onEntering;
      delete props.onEntered;
      delete props.onExit;
      delete props.onExiting;
      delete props.onExited;
      return _react.default.createElement(_TransitionGroup.default, props, inProp ? _react.default.cloneElement(first, {
        key: 'first',
        onEnter: this.handleEnter,
        onEntering: this.handleEntering,
        onEntered: this.handleEntered
      }) : _react.default.cloneElement(second, {
        key: 'second',
        onEnter: this.handleExit,
        onEntering: this.handleExiting,
        onEntered: this.handleExited
      }));
    };

    return ReplaceTransition;
  }(_react.default.Component);

  ReplaceTransition.propTypes = {};
  var _default = ReplaceTransition;
  exports.default = _default;
  module.exports = exports["default"];
  });

  unwrapExports(ReplaceTransition_1);

  var reactTransitionGroup = createCommonjsModule(function (module) {

  var _CSSTransition = _interopRequireDefault(CSSTransition_1);

  var _ReplaceTransition = _interopRequireDefault(ReplaceTransition_1);

  var _TransitionGroup = _interopRequireDefault(TransitionGroup_1);

  var _Transition = _interopRequireDefault(Transition_1);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  module.exports = {
    Transition: _Transition.default,
    TransitionGroup: _TransitionGroup.default,
    ReplaceTransition: _ReplaceTransition.default,
    CSSTransition: _CSSTransition.default
  };
  });

  unwrapExports(reactTransitionGroup);
  var reactTransitionGroup_1 = reactTransitionGroup.Transition;
  var reactTransitionGroup_2 = reactTransitionGroup.TransitionGroup;
  var reactTransitionGroup_3 = reactTransitionGroup.ReplaceTransition;
  var reactTransitionGroup_4 = reactTransitionGroup.CSSTransition;

  var propTypes$k = _objectSpread$2({}, reactTransitionGroup_1.propTypes, {
    children: propTypes.oneOfType([propTypes.arrayOf(propTypes.node), propTypes.node]),
    tag: tagPropType,
    baseClass: propTypes.string,
    baseClassActive: propTypes.string,
    className: propTypes.string,
    cssModule: propTypes.object,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.string, propTypes.func])
  });

  var defaultProps$n = _objectSpread$2({}, reactTransitionGroup_1.defaultProps, {
    tag: 'div',
    baseClass: 'fade',
    baseClassActive: 'show',
    timeout: TransitionTimeouts.Fade,
    appear: true,
    enter: true,
    exit: true,
    in: true
  });

  function Fade(props) {
    var Tag = props.tag,
        baseClass = props.baseClass,
        baseClassActive = props.baseClassActive,
        className = props.className,
        cssModule = props.cssModule,
        children = props.children,
        innerRef = props.innerRef,
        otherProps = _objectWithoutPropertiesLoose(props, ["tag", "baseClass", "baseClassActive", "className", "cssModule", "children", "innerRef"]);

    var transitionProps = pick(otherProps, TransitionPropTypeKeys);
    var childProps = omit(otherProps, TransitionPropTypeKeys);
    return react.createElement(reactTransitionGroup_1, transitionProps, function (status) {
      var isActive = status === 'entered';
      var classes = mapToCssModules(classnames(className, baseClass, isActive && baseClassActive), cssModule);
      return react.createElement(Tag, _extends$9({
        className: classes
      }, childProps, {
        ref: innerRef
      }), children);
    });
  }

  Fade.propTypes = propTypes$k;
  Fade.defaultProps = defaultProps$n;

  var propTypes$l = {
    color: propTypes.string,
    pill: propTypes.bool,
    tag: tagPropType,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.func, propTypes.string]),
    children: propTypes.node,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$o = {
    color: 'secondary',
    pill: false,
    tag: 'span'
  };

  var Badge = function Badge(props) {
    var className = props.className,
        cssModule = props.cssModule,
        color = props.color,
        innerRef = props.innerRef,
        pill = props.pill,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "color", "innerRef", "pill", "tag"]);

    var classes = mapToCssModules(classnames(className, 'badge', 'badge-' + color, pill ? 'badge-pill' : false), cssModule);

    if (attributes.href && Tag === 'span') {
      Tag = 'a';
    }

    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes,
      ref: innerRef
    }));
  };

  Badge.propTypes = propTypes$l;
  Badge.defaultProps = defaultProps$o;

  var propTypes$m = {
    tag: tagPropType,
    inverse: propTypes.bool,
    color: propTypes.string,
    body: propTypes.bool,
    outline: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.string, propTypes.func])
  };
  var defaultProps$p = {
    tag: 'div'
  };

  var Card = function Card(props) {
    var className = props.className,
        cssModule = props.cssModule,
        color = props.color,
        body = props.body,
        inverse = props.inverse,
        outline = props.outline,
        Tag = props.tag,
        innerRef = props.innerRef,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "color", "body", "inverse", "outline", "tag", "innerRef"]);

    var classes = mapToCssModules(classnames(className, 'card', inverse ? 'text-white' : false, body ? 'card-body' : false, color ? (outline ? 'border' : 'bg') + "-" + color : false), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes,
      ref: innerRef
    }));
  };

  Card.propTypes = propTypes$m;
  Card.defaultProps = defaultProps$p;

  var propTypes$n = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$q = {
    tag: 'div'
  };

  var CardGroup = function CardGroup(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-group'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardGroup.propTypes = propTypes$n;
  CardGroup.defaultProps = defaultProps$q;

  var propTypes$o = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$r = {
    tag: 'div'
  };

  var CardDeck = function CardDeck(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-deck'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardDeck.propTypes = propTypes$o;
  CardDeck.defaultProps = defaultProps$r;

  var propTypes$p = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$s = {
    tag: 'div'
  };

  var CardColumns = function CardColumns(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-columns'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardColumns.propTypes = propTypes$p;
  CardColumns.defaultProps = defaultProps$s;

  var propTypes$q = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.string, propTypes.func])
  };
  var defaultProps$t = {
    tag: 'div'
  };

  var CardBody = function CardBody(props) {
    var className = props.className,
        cssModule = props.cssModule,
        innerRef = props.innerRef,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "innerRef", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-body'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes,
      ref: innerRef
    }));
  };

  CardBody.propTypes = propTypes$q;
  CardBody.defaultProps = defaultProps$t;

  var propTypes$r = {
    tag: tagPropType,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.func, propTypes.string]),
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$u = {
    tag: 'a'
  };

  var CardLink = function CardLink(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        innerRef = props.innerRef,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag", "innerRef"]);

    var classes = mapToCssModules(classnames(className, 'card-link'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      ref: innerRef,
      className: classes
    }));
  };

  CardLink.propTypes = propTypes$r;
  CardLink.defaultProps = defaultProps$u;

  var propTypes$s = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$v = {
    tag: 'div'
  };

  var CardFooter = function CardFooter(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-footer'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardFooter.propTypes = propTypes$s;
  CardFooter.defaultProps = defaultProps$v;

  var propTypes$t = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$w = {
    tag: 'div'
  };

  var CardHeader = function CardHeader(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-header'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardHeader.propTypes = propTypes$t;
  CardHeader.defaultProps = defaultProps$w;

  var propTypes$u = {
    tag: tagPropType,
    top: propTypes.bool,
    bottom: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$x = {
    tag: 'img'
  };

  var CardImg = function CardImg(props) {
    var className = props.className,
        cssModule = props.cssModule,
        top = props.top,
        bottom = props.bottom,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "top", "bottom", "tag"]);

    var cardImgClassName = 'card-img';

    if (top) {
      cardImgClassName = 'card-img-top';
    }

    if (bottom) {
      cardImgClassName = 'card-img-bottom';
    }

    var classes = mapToCssModules(classnames(className, cardImgClassName), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardImg.propTypes = propTypes$u;
  CardImg.defaultProps = defaultProps$x;

  var propTypes$v = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$y = {
    tag: 'div'
  };

  var CardImgOverlay = function CardImgOverlay(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-img-overlay'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardImgOverlay.propTypes = propTypes$v;
  CardImgOverlay.defaultProps = defaultProps$y;

  var CarouselItem =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(CarouselItem, _React$Component);

    function CarouselItem(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.state = {
        startAnimation: false
      };
      _this.onEnter = _this.onEnter.bind(_assertThisInitialized(_this));
      _this.onEntering = _this.onEntering.bind(_assertThisInitialized(_this));
      _this.onExit = _this.onExit.bind(_assertThisInitialized(_this));
      _this.onExiting = _this.onExiting.bind(_assertThisInitialized(_this));
      _this.onExited = _this.onExited.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = CarouselItem.prototype;

    _proto.onEnter = function onEnter(node, isAppearing) {
      this.setState({
        startAnimation: false
      });
      this.props.onEnter(node, isAppearing);
    };

    _proto.onEntering = function onEntering(node, isAppearing) {
      // getting this variable triggers a reflow
      var offsetHeight = node.offsetHeight;
      this.setState({
        startAnimation: true
      });
      this.props.onEntering(node, isAppearing);
      return offsetHeight;
    };

    _proto.onExit = function onExit(node) {
      this.setState({
        startAnimation: false
      });
      this.props.onExit(node);
    };

    _proto.onExiting = function onExiting(node) {
      this.setState({
        startAnimation: true
      });
      node.dispatchEvent(new CustomEvent('slide.bs.carousel'));
      this.props.onExiting(node);
    };

    _proto.onExited = function onExited(node) {
      node.dispatchEvent(new CustomEvent('slid.bs.carousel'));
      this.props.onExited(node);
    };

    _proto.render = function render() {
      var _this2 = this;

      var _this$props = this.props,
          isIn = _this$props.in,
          children = _this$props.children,
          cssModule = _this$props.cssModule,
          slide = _this$props.slide,
          Tag = _this$props.tag,
          className = _this$props.className,
          transitionProps = _objectWithoutPropertiesLoose(_this$props, ["in", "children", "cssModule", "slide", "tag", "className"]);

      return react.createElement(reactTransitionGroup_1, _extends$9({}, transitionProps, {
        enter: slide,
        exit: slide,
        in: isIn,
        onEnter: this.onEnter,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }), function (status) {
        var direction = _this2.context.direction;
        var isActive = status === TransitionStatuses.ENTERED || status === TransitionStatuses.EXITING;
        var directionClassName = (status === TransitionStatuses.ENTERING || status === TransitionStatuses.EXITING) && _this2.state.startAnimation && (direction === 'right' ? 'carousel-item-left' : 'carousel-item-right');
        var orderClassName = status === TransitionStatuses.ENTERING && (direction === 'right' ? 'carousel-item-next' : 'carousel-item-prev');
        var itemClasses = mapToCssModules(classnames(className, 'carousel-item', isActive && 'active', directionClassName, orderClassName), cssModule);
        return react.createElement(Tag, {
          className: itemClasses
        }, children);
      });
    };

    return CarouselItem;
  }(react.Component);

  CarouselItem.propTypes = _objectSpread$2({}, reactTransitionGroup_1.propTypes, {
    tag: tagPropType,
    in: propTypes.bool,
    cssModule: propTypes.object,
    children: propTypes.node,
    slide: propTypes.bool,
    className: propTypes.string
  });
  CarouselItem.defaultProps = _objectSpread$2({}, reactTransitionGroup_1.defaultProps, {
    tag: 'div',
    timeout: TransitionTimeouts.Carousel,
    slide: true
  });
  CarouselItem.contextTypes = {
    direction: propTypes.string
  };

  var Carousel =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Carousel, _React$Component);

    function Carousel(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.handleKeyPress = _this.handleKeyPress.bind(_assertThisInitialized(_this));
      _this.renderItems = _this.renderItems.bind(_assertThisInitialized(_this));
      _this.hoverStart = _this.hoverStart.bind(_assertThisInitialized(_this));
      _this.hoverEnd = _this.hoverEnd.bind(_assertThisInitialized(_this));
      _this.state = {
        direction: 'right',
        indicatorClicked: false
      };
      return _this;
    }

    var _proto = Carousel.prototype;

    _proto.getChildContext = function getChildContext() {
      return {
        direction: this.state.direction
      };
    };

    _proto.componentDidMount = function componentDidMount() {
      // Set up the cycle
      if (this.props.ride === 'carousel') {
        this.setInterval();
      } // TODO: move this to the specific carousel like bootstrap. Currently it will trigger ALL carousels on the page.


      document.addEventListener('keyup', this.handleKeyPress);
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      this.setInterval(nextProps); // Calculate the direction to turn

      if (this.props.activeIndex + 1 === nextProps.activeIndex) {
        this.setState({
          direction: 'right'
        });
      } else if (this.props.activeIndex - 1 === nextProps.activeIndex) {
        this.setState({
          direction: 'left'
        });
      } else if (this.props.activeIndex > nextProps.activeIndex) {
        this.setState({
          direction: this.state.indicatorClicked ? 'left' : 'right'
        });
      } else if (this.props.activeIndex !== nextProps.activeIndex) {
        this.setState({
          direction: this.state.indicatorClicked ? 'right' : 'left'
        });
      }

      this.setState({
        indicatorClicked: false
      });
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.clearInterval();
      document.removeEventListener('keyup', this.handleKeyPress);
    };

    _proto.setInterval = function (_setInterval) {
      function setInterval() {
        return _setInterval.apply(this, arguments);
      }

      setInterval.toString = function () {
        return _setInterval.toString();
      };

      return setInterval;
    }(function (props) {
      if (props === void 0) {
        props = this.props;
      }

      // make sure not to have multiple intervals going...
      this.clearInterval();

      if (props.interval) {
        this.cycleInterval = setInterval(function () {
          props.next();
        }, parseInt(props.interval, 10));
      }
    });

    _proto.clearInterval = function (_clearInterval) {
      function clearInterval() {
        return _clearInterval.apply(this, arguments);
      }

      clearInterval.toString = function () {
        return _clearInterval.toString();
      };

      return clearInterval;
    }(function () {
      clearInterval(this.cycleInterval);
    });

    _proto.hoverStart = function hoverStart() {
      if (this.props.pause === 'hover') {
        this.clearInterval();
      }

      if (this.props.mouseEnter) {
        var _this$props;

        (_this$props = this.props).mouseEnter.apply(_this$props, arguments);
      }
    };

    _proto.hoverEnd = function hoverEnd() {
      if (this.props.pause === 'hover') {
        this.setInterval();
      }

      if (this.props.mouseLeave) {
        var _this$props2;

        (_this$props2 = this.props).mouseLeave.apply(_this$props2, arguments);
      }
    };

    _proto.handleKeyPress = function handleKeyPress(evt) {
      if (this.props.keyboard) {
        if (evt.keyCode === 37) {
          this.props.previous();
        } else if (evt.keyCode === 39) {
          this.props.next();
        }
      }
    };

    _proto.renderItems = function renderItems(carouselItems, className) {
      var _this2 = this;

      var slide = this.props.slide;
      return react.createElement("div", {
        className: className
      }, carouselItems.map(function (item, index) {
        var isIn = index === _this2.props.activeIndex;
        return react.cloneElement(item, {
          in: isIn,
          slide: slide
        });
      }));
    };

    _proto.render = function render() {
      var _this3 = this;

      var _this$props3 = this.props,
          cssModule = _this$props3.cssModule,
          slide = _this$props3.slide,
          className = _this$props3.className;
      var outerClasses = mapToCssModules(classnames(className, 'carousel', slide && 'slide'), cssModule);
      var innerClasses = mapToCssModules(classnames('carousel-inner'), cssModule); // filter out booleans, null, or undefined

      var children = this.props.children.filter(function (child) {
        return child !== null && child !== undefined && typeof child !== 'boolean';
      });
      var slidesOnly = children.every(function (child) {
        return child.type === CarouselItem;
      }); // Rendering only slides

      if (slidesOnly) {
        return react.createElement("div", {
          className: outerClasses,
          onMouseEnter: this.hoverStart,
          onMouseLeave: this.hoverEnd
        }, this.renderItems(children, innerClasses));
      } // Rendering slides and controls


      if (children[0] instanceof Array) {
        var _carouselItems = children[0];
        var _controlLeft = children[1];
        var _controlRight = children[2];
        return react.createElement("div", {
          className: outerClasses,
          onMouseEnter: this.hoverStart,
          onMouseLeave: this.hoverEnd
        }, this.renderItems(_carouselItems, innerClasses), _controlLeft, _controlRight);
      } // Rendering indicators, slides and controls


      var indicators = children[0];

      var wrappedOnClick = function wrappedOnClick(e) {
        if (typeof indicators.props.onClickHandler === 'function') {
          _this3.setState({
            indicatorClicked: true
          }, function () {
            return indicators.props.onClickHandler(e);
          });
        }
      };

      var wrappedIndicators = react.cloneElement(indicators, {
        onClickHandler: wrappedOnClick
      });
      var carouselItems = children[1];
      var controlLeft = children[2];
      var controlRight = children[3];
      return react.createElement("div", {
        className: outerClasses,
        onMouseEnter: this.hoverStart,
        onMouseLeave: this.hoverEnd
      }, wrappedIndicators, this.renderItems(carouselItems, innerClasses), controlLeft, controlRight);
    };

    return Carousel;
  }(react.Component);

  Carousel.propTypes = {
    // the current active slide of the carousel
    activeIndex: propTypes.number,
    // a function which should advance the carousel to the next slide (via activeIndex)
    next: propTypes.func.isRequired,
    // a function which should advance the carousel to the previous slide (via activeIndex)
    previous: propTypes.func.isRequired,
    // controls if the left and right arrow keys should control the carousel
    keyboard: propTypes.bool,

    /* If set to "hover", pauses the cycling of the carousel on mouseenter and resumes the cycling of the carousel on
     * mouseleave. If set to false, hovering over the carousel won't pause it. (default: "hover")
     */
    pause: propTypes.oneOf(['hover', false]),
    // Autoplays the carousel after the user manually cycles the first item. If "carousel", autoplays the carousel on load.
    // This is how bootstrap defines it... I would prefer a bool named autoplay or something...
    ride: propTypes.oneOf(['carousel']),
    // the interval at which the carousel automatically cycles (default: 5000)
    // eslint-disable-next-line react/no-unused-prop-types
    interval: propTypes.oneOfType([propTypes.number, propTypes.string, propTypes.bool]),
    children: propTypes.array,
    // called when the mouse enters the Carousel
    mouseEnter: propTypes.func,
    // called when the mouse exits the Carousel
    mouseLeave: propTypes.func,
    // controls whether the slide animation on the Carousel works or not
    slide: propTypes.bool,
    cssModule: propTypes.object,
    className: propTypes.string
  };
  Carousel.defaultProps = {
    interval: 5000,
    pause: 'hover',
    keyboard: true,
    slide: true
  };
  Carousel.childContextTypes = {
    direction: propTypes.string
  };

  var CarouselControl = function CarouselControl(props) {
    var direction = props.direction,
        onClickHandler = props.onClickHandler,
        cssModule = props.cssModule,
        directionText = props.directionText,
        className = props.className;
    var anchorClasses = mapToCssModules(classnames(className, "carousel-control-" + direction), cssModule);
    var iconClasses = mapToCssModules(classnames("carousel-control-" + direction + "-icon"), cssModule);
    var screenReaderClasses = mapToCssModules(classnames('sr-only'), cssModule);
    return react.createElement("a", {
      className: anchorClasses,
      role: "button",
      tabIndex: "0",
      onClick: function onClick(e) {
        e.preventDefault();
        onClickHandler();
      }
    }, react.createElement("span", {
      className: iconClasses,
      "aria-hidden": "true"
    }), react.createElement("span", {
      className: screenReaderClasses
    }, directionText || direction));
  };

  CarouselControl.propTypes = {
    direction: propTypes.oneOf(['prev', 'next']).isRequired,
    onClickHandler: propTypes.func.isRequired,
    cssModule: propTypes.object,
    directionText: propTypes.string,
    className: propTypes.string
  };

  var CarouselIndicators = function CarouselIndicators(props) {
    var items = props.items,
        activeIndex = props.activeIndex,
        cssModule = props.cssModule,
        onClickHandler = props.onClickHandler,
        className = props.className;
    var listClasses = mapToCssModules(classnames(className, 'carousel-indicators'), cssModule);
    var indicators = items.map(function (item, idx) {
      var indicatorClasses = mapToCssModules(classnames({
        active: activeIndex === idx
      }), cssModule);
      return react.createElement("li", {
        key: "" + (item.key || Object.values(item).join('')),
        onClick: function onClick(e) {
          e.preventDefault();
          onClickHandler(idx);
        },
        className: indicatorClasses
      });
    });
    return react.createElement("ol", {
      className: listClasses
    }, indicators);
  };

  CarouselIndicators.propTypes = {
    items: propTypes.array.isRequired,
    activeIndex: propTypes.number.isRequired,
    cssModule: propTypes.object,
    onClickHandler: propTypes.func.isRequired,
    className: propTypes.string
  };

  var CarouselCaption = function CarouselCaption(props) {
    var captionHeader = props.captionHeader,
        captionText = props.captionText,
        cssModule = props.cssModule,
        className = props.className;
    var classes = mapToCssModules(classnames(className, 'carousel-caption', 'd-none', 'd-md-block'), cssModule);
    return react.createElement("div", {
      className: classes
    }, react.createElement("h3", null, captionHeader), react.createElement("p", null, captionText));
  };

  CarouselCaption.propTypes = {
    captionHeader: propTypes.string,
    captionText: propTypes.string.isRequired,
    cssModule: propTypes.object,
    className: propTypes.string
  };

  var propTypes$w = {
    items: propTypes.array.isRequired,
    indicators: propTypes.bool,
    controls: propTypes.bool,
    autoPlay: propTypes.bool,
    defaultActiveIndex: propTypes.number,
    activeIndex: propTypes.number,
    next: propTypes.func,
    previous: propTypes.func,
    goToIndex: propTypes.func
  };

  var UncontrolledCarousel =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(UncontrolledCarousel, _Component);

    function UncontrolledCarousel(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.animating = false;
      _this.state = {
        activeIndex: props.defaultActiveIndex || 0
      };
      _this.next = _this.next.bind(_assertThisInitialized(_this));
      _this.previous = _this.previous.bind(_assertThisInitialized(_this));
      _this.goToIndex = _this.goToIndex.bind(_assertThisInitialized(_this));
      _this.onExiting = _this.onExiting.bind(_assertThisInitialized(_this));
      _this.onExited = _this.onExited.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = UncontrolledCarousel.prototype;

    _proto.onExiting = function onExiting() {
      this.animating = true;
    };

    _proto.onExited = function onExited() {
      this.animating = false;
    };

    _proto.next = function next() {
      if (this.animating) return;
      var nextIndex = this.state.activeIndex === this.props.items.length - 1 ? 0 : this.state.activeIndex + 1;
      this.setState({
        activeIndex: nextIndex
      });
    };

    _proto.previous = function previous() {
      if (this.animating) return;
      var nextIndex = this.state.activeIndex === 0 ? this.props.items.length - 1 : this.state.activeIndex - 1;
      this.setState({
        activeIndex: nextIndex
      });
    };

    _proto.goToIndex = function goToIndex(newIndex) {
      if (this.animating) return;
      this.setState({
        activeIndex: newIndex
      });
    };

    _proto.render = function render() {
      var _this2 = this;

      var _this$props = this.props,
          defaultActiveIndex = _this$props.defaultActiveIndex,
          autoPlay = _this$props.autoPlay,
          indicators = _this$props.indicators,
          controls = _this$props.controls,
          items = _this$props.items,
          goToIndex = _this$props.goToIndex,
          props = _objectWithoutPropertiesLoose(_this$props, ["defaultActiveIndex", "autoPlay", "indicators", "controls", "items", "goToIndex"]);

      var activeIndex = this.state.activeIndex;
      var slides = items.map(function (item) {
        return react.createElement(CarouselItem, {
          onExiting: _this2.onExiting,
          onExited: _this2.onExited,
          key: item.src
        }, react.createElement("img", {
          className: "d-block w-100",
          src: item.src,
          alt: item.altText
        }), react.createElement(CarouselCaption, {
          captionText: item.caption,
          captionHeader: item.header || item.caption
        }));
      });
      return react.createElement(Carousel, _extends$9({
        activeIndex: activeIndex,
        next: this.next,
        previous: this.previous,
        ride: autoPlay ? 'carousel' : undefined
      }, props), indicators && react.createElement(CarouselIndicators, {
        items: items,
        activeIndex: props.activeIndex || activeIndex,
        onClickHandler: goToIndex || this.goToIndex
      }), slides, controls && react.createElement(CarouselControl, {
        direction: "prev",
        directionText: "Previous",
        onClickHandler: props.previous || this.previous
      }), controls && react.createElement(CarouselControl, {
        direction: "next",
        directionText: "Next",
        onClickHandler: props.next || this.next
      }));
    };

    return UncontrolledCarousel;
  }(react_2);

  UncontrolledCarousel.propTypes = propTypes$w;
  UncontrolledCarousel.defaultProps = {
    controls: true,
    indicators: true,
    autoPlay: true
  };

  var propTypes$x = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$z = {
    tag: 'div'
  };

  var CardSubtitle = function CardSubtitle(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-subtitle'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardSubtitle.propTypes = propTypes$x;
  CardSubtitle.defaultProps = defaultProps$z;

  var propTypes$y = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$A = {
    tag: 'p'
  };

  var CardText = function CardText(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-text'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardText.propTypes = propTypes$y;
  CardText.defaultProps = defaultProps$A;

  var propTypes$z = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$B = {
    tag: 'div'
  };

  var CardTitle = function CardTitle(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'card-title'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  CardTitle.propTypes = propTypes$z;
  CardTitle.defaultProps = defaultProps$B;

  var propTypes$A = {
    className: propTypes.string,
    id: propTypes.oneOfType([propTypes.string, propTypes.number]).isRequired,
    type: propTypes.string.isRequired,
    label: propTypes.node,
    inline: propTypes.bool,
    valid: propTypes.bool,
    invalid: propTypes.bool,
    bsSize: propTypes.string,
    htmlFor: propTypes.string,
    cssModule: propTypes.object,
    children: propTypes.oneOfType([propTypes.node, propTypes.array, propTypes.func]),
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.string, propTypes.func])
  };

  function CustomInput(props) {
    var className = props.className,
        label = props.label,
        inline = props.inline,
        valid = props.valid,
        invalid = props.invalid,
        cssModule = props.cssModule,
        children = props.children,
        bsSize = props.bsSize,
        innerRef = props.innerRef,
        htmlFor = props.htmlFor,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "label", "inline", "valid", "invalid", "cssModule", "children", "bsSize", "innerRef", "htmlFor"]);

    var type = attributes.type;
    var customClass = mapToCssModules(classnames(className, "custom-" + type, bsSize ? "custom-" + type + "-" + bsSize : false), cssModule);
    var validationClassNames = mapToCssModules(classnames(invalid && 'is-invalid', valid && 'is-valid'), cssModule);
    var labelHtmlFor = htmlFor || attributes.id;

    if (type === 'select') {
      return react.createElement("select", _extends$9({}, attributes, {
        ref: innerRef,
        className: classnames(validationClassNames, customClass)
      }), children);
    }

    if (type === 'file') {
      return react.createElement("div", {
        className: customClass
      }, react.createElement("input", _extends$9({}, attributes, {
        ref: innerRef,
        className: classnames(validationClassNames, mapToCssModules('custom-file-input', cssModule))
      })), react.createElement("label", {
        className: mapToCssModules('custom-file-label', cssModule),
        htmlFor: labelHtmlFor
      }, label || 'Choose file'));
    }

    if (type !== 'checkbox' && type !== 'radio' && type !== 'switch') {
      return react.createElement("input", _extends$9({}, attributes, {
        ref: innerRef,
        className: classnames(validationClassNames, customClass)
      }));
    }

    var wrapperClasses = classnames(customClass, mapToCssModules(classnames('custom-control', {
      'custom-control-inline': inline
    }), cssModule));
    return react.createElement("div", {
      className: wrapperClasses
    }, react.createElement("input", _extends$9({}, attributes, {
      type: type === 'switch' ? 'checkbox' : type,
      ref: innerRef,
      className: classnames(validationClassNames, mapToCssModules('custom-control-input', cssModule))
    })), react.createElement("label", {
      className: mapToCssModules('custom-control-label', cssModule),
      htmlFor: labelHtmlFor
    }, label), children);
  }

  CustomInput.propTypes = propTypes$A;

  function noop() {}

  var propTypes$B = {
    children: propTypes.node.isRequired,
    popperClassName: propTypes.string,
    placement: propTypes.string,
    placementPrefix: propTypes.string,
    arrowClassName: propTypes.string,
    hideArrow: propTypes.bool,
    tag: tagPropType,
    isOpen: propTypes.bool.isRequired,
    cssModule: propTypes.object,
    offset: propTypes.oneOfType([propTypes.string, propTypes.number]),
    fallbackPlacement: propTypes.oneOfType([propTypes.string, propTypes.array]),
    flip: propTypes.bool,
    container: targetPropType,
    target: targetPropType.isRequired,
    modifiers: propTypes.object,
    boundariesElement: propTypes.oneOfType([propTypes.string, DOMElement]),
    onClosed: propTypes.func,
    fade: propTypes.bool,
    transition: propTypes.shape(Fade.propTypes)
  };
  var defaultProps$C = {
    boundariesElement: 'scrollParent',
    placement: 'auto',
    hideArrow: false,
    isOpen: false,
    offset: 0,
    fallbackPlacement: 'flip',
    flip: true,
    container: 'body',
    modifiers: {},
    onClosed: noop,
    fade: true,
    transition: _objectSpread$2({}, Fade.defaultProps)
  };

  var PopperContent =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(PopperContent, _React$Component);

    function PopperContent(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.handlePlacementChange = _this.handlePlacementChange.bind(_assertThisInitialized(_this));
      _this.setTargetNode = _this.setTargetNode.bind(_assertThisInitialized(_this));
      _this.getTargetNode = _this.getTargetNode.bind(_assertThisInitialized(_this));
      _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));
      _this.onClosed = _this.onClosed.bind(_assertThisInitialized(_this));
      _this.state = {
        isOpen: props.isOpen
      };
      return _this;
    }

    PopperContent.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
      if (props.isOpen && !state.isOpen) {
        return {
          isOpen: props.isOpen
        };
      } else return null;
    };

    var _proto = PopperContent.prototype;

    _proto.componentDidUpdate = function componentDidUpdate() {
      if (this._element && this._element.childNodes && this._element.childNodes[0] && this._element.childNodes[0].focus) {
        this._element.childNodes[0].focus();
      }
    };

    _proto.setTargetNode = function setTargetNode(node) {
      this.targetNode = node;
    };

    _proto.getTargetNode = function getTargetNode() {
      return this.targetNode;
    };

    _proto.getContainerNode = function getContainerNode() {
      return getTarget(this.props.container);
    };

    _proto.getRef = function getRef(ref) {
      this._element = ref;
    };

    _proto.handlePlacementChange = function handlePlacementChange(data) {
      if (this.state.placement !== data.placement) {
        this.setState({
          placement: data.placement
        });
      }

      return data;
    };

    _proto.onClosed = function onClosed() {
      this.props.onClosed();
      this.setState({
        isOpen: false
      });
    };

    _proto.renderChildren = function renderChildren() {
      var _this$props = this.props,
          cssModule = _this$props.cssModule,
          children = _this$props.children,
          isOpen = _this$props.isOpen,
          flip = _this$props.flip,
          target = _this$props.target,
          offset = _this$props.offset,
          fallbackPlacement = _this$props.fallbackPlacement,
          placementPrefix = _this$props.placementPrefix,
          _arrowClassName = _this$props.arrowClassName,
          hideArrow = _this$props.hideArrow,
          _popperClassName = _this$props.popperClassName,
          tag = _this$props.tag,
          container = _this$props.container,
          modifiers = _this$props.modifiers,
          boundariesElement = _this$props.boundariesElement,
          onClosed = _this$props.onClosed,
          fade = _this$props.fade,
          transition = _this$props.transition,
          attrs = _objectWithoutPropertiesLoose(_this$props, ["cssModule", "children", "isOpen", "flip", "target", "offset", "fallbackPlacement", "placementPrefix", "arrowClassName", "hideArrow", "popperClassName", "tag", "container", "modifiers", "boundariesElement", "onClosed", "fade", "transition"]);

      var arrowClassName = mapToCssModules(classnames('arrow', _arrowClassName), cssModule);
      var placement = this.state.placement || attrs.placement;
      var placementFirstPart = placement.split('-')[0];
      var popperClassName = mapToCssModules(classnames(_popperClassName, placementPrefix ? placementPrefix + "-" + placementFirstPart : placementFirstPart), this.props.cssModule);

      var extendedModifiers = _objectSpread$2({
        offset: {
          offset: offset
        },
        flip: {
          enabled: flip,
          behavior: fallbackPlacement
        },
        preventOverflow: {
          boundariesElement: boundariesElement
        },
        update: {
          enabled: true,
          order: 950,
          fn: this.handlePlacementChange
        }
      }, modifiers);

      var popperTransition = _objectSpread$2({}, Fade.defaultProps, transition, {
        baseClass: fade ? transition.baseClass : '',
        timeout: fade ? transition.timeout : 0
      });

      return react.createElement(Fade, _extends$9({}, popperTransition, attrs, {
        in: isOpen,
        onExited: this.onClosed,
        tag: tag
      }), react.createElement(Popper$1, {
        referenceElement: this.targetNode,
        modifiers: extendedModifiers,
        placement: placement
      }, function (_ref) {
        var ref = _ref.ref,
            style = _ref.style,
            placement = _ref.placement,
            arrowProps = _ref.arrowProps;
        return react.createElement("div", {
          ref: ref,
          style: style,
          className: popperClassName,
          "x-placement": placement
        }, children, !hideArrow && react.createElement("span", {
          ref: arrowProps.ref,
          className: arrowClassName,
          style: arrowProps.style
        }));
      }));
    };

    _proto.render = function render() {
      this.setTargetNode(getTarget(this.props.target));

      if (this.state.isOpen) {
        return this.props.container === 'inline' ? this.renderChildren() : reactDom.createPortal(react.createElement("div", {
          ref: this.getRef
        }, this.renderChildren()), this.getContainerNode());
      }

      return null;
    };

    return PopperContent;
  }(react.Component);

  PopperContent.propTypes = propTypes$B;
  PopperContent.defaultProps = defaultProps$C;

  var PopperTargetHelper = function PopperTargetHelper(props, context) {
    context.popperManager.setTargetNode(getTarget(props.target));
    return null;
  };

  PopperTargetHelper.contextTypes = {
    popperManager: propTypes.object.isRequired
  };
  PopperTargetHelper.propTypes = {
    target: targetPropType.isRequired
  };

  var propTypes$C = {
    placement: propTypes.oneOf(PopperPlacements),
    target: targetPropType.isRequired,
    container: targetPropType,
    isOpen: propTypes.bool,
    disabled: propTypes.bool,
    hideArrow: propTypes.bool,
    boundariesElement: propTypes.oneOfType([propTypes.string, DOMElement]),
    className: propTypes.string,
    innerClassName: propTypes.string,
    arrowClassName: propTypes.string,
    popperClassName: propTypes.string,
    cssModule: propTypes.object,
    toggle: propTypes.func,
    autohide: propTypes.bool,
    placementPrefix: propTypes.string,
    delay: propTypes.oneOfType([propTypes.shape({
      show: propTypes.number,
      hide: propTypes.number
    }), propTypes.number]),
    modifiers: propTypes.object,
    offset: propTypes.oneOfType([propTypes.string, propTypes.number]),
    innerRef: propTypes.oneOfType([propTypes.func, propTypes.string, propTypes.object]),
    trigger: propTypes.string,
    fade: propTypes.bool,
    flip: propTypes.bool
  };
  var DEFAULT_DELAYS = {
    show: 0,
    hide: 0
  };
  var defaultProps$D = {
    isOpen: false,
    hideArrow: false,
    autohide: false,
    delay: DEFAULT_DELAYS,
    toggle: function toggle() {},
    trigger: 'click',
    fade: true
  };

  function isInDOMSubtree(element, subtreeRoot) {
    return subtreeRoot && (element === subtreeRoot || subtreeRoot.contains(element));
  }

  var TooltipPopoverWrapper =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(TooltipPopoverWrapper, _React$Component);

    function TooltipPopoverWrapper(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this._target = null;
      _this.addTargetEvents = _this.addTargetEvents.bind(_assertThisInitialized(_this));
      _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized(_this));
      _this.removeTargetEvents = _this.removeTargetEvents.bind(_assertThisInitialized(_this));
      _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));
      _this.showWithDelay = _this.showWithDelay.bind(_assertThisInitialized(_this));
      _this.hideWithDelay = _this.hideWithDelay.bind(_assertThisInitialized(_this));
      _this.onMouseOverTooltipContent = _this.onMouseOverTooltipContent.bind(_assertThisInitialized(_this));
      _this.onMouseLeaveTooltipContent = _this.onMouseLeaveTooltipContent.bind(_assertThisInitialized(_this));
      _this.show = _this.show.bind(_assertThisInitialized(_this));
      _this.hide = _this.hide.bind(_assertThisInitialized(_this));
      _this.onEscKeyDown = _this.onEscKeyDown.bind(_assertThisInitialized(_this));
      _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));
      _this.onClosed = _this.onClosed.bind(_assertThisInitialized(_this));
      _this.state = {
        isOpen: props.isOpen
      };
      return _this;
    }

    var _proto = TooltipPopoverWrapper.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.updateTarget();
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.removeTargetEvents();
    };

    TooltipPopoverWrapper.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
      if (props.isOpen && !state.isOpen) {
        return {
          isOpen: props.isOpen
        };
      } else return null;
    };

    _proto.onMouseOverTooltipContent = function onMouseOverTooltipContent() {
      if (this.props.trigger.indexOf('hover') > -1 && !this.props.autohide) {
        if (this._hideTimeout) {
          this.clearHideTimeout();
        }

        if (this.state.isOpen && !this.props.isOpen) {
          this.toggle();
        }
      }
    };

    _proto.onMouseLeaveTooltipContent = function onMouseLeaveTooltipContent(e) {
      if (this.props.trigger.indexOf('hover') > -1 && !this.props.autohide) {
        if (this._showTimeout) {
          this.clearShowTimeout();
        }

        e.persist();
        this._hideTimeout = setTimeout(this.hide.bind(this, e), this.getDelay('hide'));
      }
    };

    _proto.onEscKeyDown = function onEscKeyDown(e) {
      if (e.key === 'Escape') {
        this.hide(e);
      }
    };

    _proto.getRef = function getRef(ref) {
      var innerRef = this.props.innerRef;

      if (innerRef) {
        if (typeof innerRef === 'function') {
          innerRef(ref);
        } else if (typeof innerRef === 'object') {
          innerRef.current = ref;
        }
      }

      this._popover = ref;
    };

    _proto.getDelay = function getDelay(key) {
      var delay = this.props.delay;

      if (typeof delay === 'object') {
        return isNaN(delay[key]) ? DEFAULT_DELAYS[key] : delay[key];
      }

      return delay;
    };

    _proto.show = function show(e) {
      if (!this.props.isOpen) {
        this.clearShowTimeout();
        this.toggle(e);
      }
    };

    _proto.showWithDelay = function showWithDelay(e) {
      if (this._hideTimeout) {
        this.clearHideTimeout();
      }

      this._showTimeout = setTimeout(this.show.bind(this, e), this.getDelay('show'));
    };

    _proto.hide = function hide(e) {
      if (this.props.isOpen) {
        this.clearHideTimeout();
        this.toggle(e);
      }
    };

    _proto.hideWithDelay = function hideWithDelay(e) {
      if (this._showTimeout) {
        this.clearShowTimeout();
      }

      this._hideTimeout = setTimeout(this.hide.bind(this, e), this.getDelay('hide'));
    };

    _proto.clearShowTimeout = function clearShowTimeout() {
      clearTimeout(this._showTimeout);
      this._showTimeout = undefined;
    };

    _proto.clearHideTimeout = function clearHideTimeout() {
      clearTimeout(this._hideTimeout);
      this._hideTimeout = undefined;
    };

    _proto.handleDocumentClick = function handleDocumentClick(e) {
      var triggers = this.props.trigger.split(' ');

      if (triggers.indexOf('legacy') > -1 && (this.props.isOpen || isInDOMSubtree(e.target, this._target))) {
        if (this._hideTimeout) {
          this.clearHideTimeout();
        }

        if (this.props.isOpen && !isInDOMSubtree(e.target, this._popover)) {
          this.hideWithDelay(e);
        } else if (!this.props.isOpen) {
          this.showWithDelay(e);
        }
      } else if (triggers.indexOf('click') > -1 && isInDOMSubtree(e.target, this._target)) {
        if (this._hideTimeout) {
          this.clearHideTimeout();
        }

        if (!this.props.isOpen) {
          this.showWithDelay(e);
        } else {
          this.hideWithDelay(e);
        }
      }
    };

    _proto.addTargetEvents = function addTargetEvents() {
      if (this.props.trigger) {
        var triggers = this.props.trigger.split(' ');

        if (triggers.indexOf('manual') === -1) {
          if (triggers.indexOf('click') > -1 || triggers.indexOf('legacy') > -1) {
            document.addEventListener('click', this.handleDocumentClick, true);
          }

          if (this._target) {
            if (triggers.indexOf('hover') > -1) {
              this._target.addEventListener('mouseover', this.showWithDelay, true);

              this._target.addEventListener('mouseout', this.hideWithDelay, true);
            }

            if (triggers.indexOf('focus') > -1) {
              this._target.addEventListener('focusin', this.show, true);

              this._target.addEventListener('focusout', this.hide, true);
            }

            this._target.addEventListener('keydown', this.onEscKeyDown, true);
          }
        }
      }
    };

    _proto.removeTargetEvents = function removeTargetEvents() {
      if (this._target) {
        this._target.removeEventListener('mouseover', this.showWithDelay, true);

        this._target.removeEventListener('mouseout', this.hideWithDelay, true);

        this._target.removeEventListener('keydown', this.onEscKeyDown, true);

        this._target.removeEventListener('focusin', this.show, true);

        this._target.removeEventListener('focusout', this.hide, true);
      }

      document.removeEventListener('click', this.handleDocumentClick, true);
    };

    _proto.updateTarget = function updateTarget() {
      var newTarget = getTarget(this.props.target);

      if (newTarget !== this._target) {
        this.removeTargetEvents();
        this._target = newTarget;
        this.addTargetEvents();
      }
    };

    _proto.toggle = function toggle(e) {
      if (this.props.disabled) {
        return e && e.preventDefault();
      }

      return this.props.toggle(e);
    };

    _proto.onClosed = function onClosed() {
      this.setState({
        isOpen: false
      });
    };

    _proto.render = function render() {
      if (!this.state.isOpen) {
        return null;
      }

      this.updateTarget();
      var _this$props = this.props,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          innerClassName = _this$props.innerClassName,
          target = _this$props.target,
          isOpen = _this$props.isOpen,
          hideArrow = _this$props.hideArrow,
          boundariesElement = _this$props.boundariesElement,
          placement = _this$props.placement,
          placementPrefix = _this$props.placementPrefix,
          arrowClassName = _this$props.arrowClassName,
          popperClassName = _this$props.popperClassName,
          container = _this$props.container,
          modifiers = _this$props.modifiers,
          offset = _this$props.offset,
          fade = _this$props.fade,
          flip = _this$props.flip;
      var attributes = omit(this.props, Object.keys(propTypes$C));
      var popperClasses = mapToCssModules(popperClassName, cssModule);
      var classes = mapToCssModules(innerClassName, cssModule);
      return react.createElement(PopperContent, {
        className: className,
        target: target,
        isOpen: isOpen,
        hideArrow: hideArrow,
        boundariesElement: boundariesElement,
        placement: placement,
        placementPrefix: placementPrefix,
        arrowClassName: arrowClassName,
        popperClassName: popperClasses,
        container: container,
        modifiers: modifiers,
        offset: offset,
        cssModule: cssModule,
        onClosed: this.onClosed,
        fade: fade,
        flip: flip
      }, react.createElement("div", _extends$9({}, attributes, {
        ref: this.getRef,
        className: classes,
        role: "tooltip",
        "aria-hidden": isOpen,
        onMouseOver: this.onMouseOverTooltipContent,
        onMouseLeave: this.onMouseLeaveTooltipContent,
        onKeyDown: this.onEscKeyDown
      })));
    };

    return TooltipPopoverWrapper;
  }(react.Component);

  TooltipPopoverWrapper.propTypes = propTypes$C;
  TooltipPopoverWrapper.defaultProps = defaultProps$D;

  var defaultProps$E = {
    placement: 'right',
    placementPrefix: 'bs-popover',
    trigger: 'click'
  };

  var Popover$1 = function Popover(props) {
    var popperClasses = classnames('popover', 'show');
    var classes = classnames('popover-inner', props.innerClassName);
    return react.createElement(TooltipPopoverWrapper, _extends$9({}, props, {
      popperClassName: popperClasses,
      innerClassName: classes
    }));
  };

  Popover$1.propTypes = propTypes$C;
  Popover$1.defaultProps = defaultProps$E;

  var omitKeys = ['defaultOpen'];

  var UncontrolledPopover =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(UncontrolledPopover, _Component);

    function UncontrolledPopover(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.state = {
        isOpen: props.defaultOpen || false
      };
      _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = UncontrolledPopover.prototype;

    _proto.toggle = function toggle() {
      this.setState({
        isOpen: !this.state.isOpen
      });
    };

    _proto.render = function render() {
      return react.createElement(Popover$1, _extends$9({
        isOpen: this.state.isOpen,
        toggle: this.toggle
      }, omit(this.props, omitKeys)));
    };

    return UncontrolledPopover;
  }(react_2);
  UncontrolledPopover.propTypes = _objectSpread$2({
    defaultOpen: propTypes.bool
  }, Popover$1.propTypes);

  var propTypes$D = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$F = {
    tag: 'h3'
  };

  var PopoverHeader = function PopoverHeader(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'popover-header'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  PopoverHeader.propTypes = propTypes$D;
  PopoverHeader.defaultProps = defaultProps$F;

  var propTypes$E = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$G = {
    tag: 'div'
  };

  var PopoverBody = function PopoverBody(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'popover-body'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  PopoverBody.propTypes = propTypes$E;
  PopoverBody.defaultProps = defaultProps$G;

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString$1 = objectProto$1.toString;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$2(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString$1.call(value) == symbolTag);
  }

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject$2(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject$2(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  var lodash_tonumber = toNumber;

  var propTypes$F = {
    children: propTypes.node,
    bar: propTypes.bool,
    multi: propTypes.bool,
    tag: tagPropType,
    value: propTypes.oneOfType([propTypes.string, propTypes.number]),
    max: propTypes.oneOfType([propTypes.string, propTypes.number]),
    animated: propTypes.bool,
    striped: propTypes.bool,
    color: propTypes.string,
    className: propTypes.string,
    barClassName: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$H = {
    tag: 'div',
    value: 0,
    max: 100
  };

  var Progress = function Progress(props) {
    var children = props.children,
        className = props.className,
        barClassName = props.barClassName,
        cssModule = props.cssModule,
        value = props.value,
        max = props.max,
        animated = props.animated,
        striped = props.striped,
        color = props.color,
        bar = props.bar,
        multi = props.multi,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["children", "className", "barClassName", "cssModule", "value", "max", "animated", "striped", "color", "bar", "multi", "tag"]);

    var percent = lodash_tonumber(value) / lodash_tonumber(max) * 100;
    var progressClasses = mapToCssModules(classnames(className, 'progress'), cssModule);
    var progressBarClasses = mapToCssModules(classnames('progress-bar', bar ? className || barClassName : barClassName, animated ? 'progress-bar-animated' : null, color ? "bg-" + color : null, striped || animated ? 'progress-bar-striped' : null), cssModule);
    var ProgressBar = multi ? children : react.createElement("div", {
      className: progressBarClasses,
      style: {
        width: percent + "%"
      },
      role: "progressbar",
      "aria-valuenow": value,
      "aria-valuemin": "0",
      "aria-valuemax": max,
      children: children
    });

    if (bar) {
      return ProgressBar;
    }

    return react.createElement(Tag, _extends$9({}, attributes, {
      className: progressClasses,
      children: ProgressBar
    }));
  };

  Progress.propTypes = propTypes$F;
  Progress.defaultProps = defaultProps$H;

  var propTypes$G = {
    children: propTypes.node.isRequired,
    node: propTypes.any
  };

  var Portal =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Portal, _React$Component);

    function Portal() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = Portal.prototype;

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.defaultNode) {
        document.body.removeChild(this.defaultNode);
      }

      this.defaultNode = null;
    };

    _proto.render = function render() {
      if (!canUseDOM) {
        return null;
      }

      if (!this.props.node && !this.defaultNode) {
        this.defaultNode = document.createElement('div');
        document.body.appendChild(this.defaultNode);
      }

      return reactDom.createPortal(this.props.children, this.props.node || this.defaultNode);
    };

    return Portal;
  }(react.Component);

  Portal.propTypes = propTypes$G;

  function noop$1() {}

  var FadePropTypes = propTypes.shape(Fade.propTypes);
  var propTypes$H = {
    isOpen: propTypes.bool,
    autoFocus: propTypes.bool,
    centered: propTypes.bool,
    scrollable: propTypes.bool,
    size: propTypes.string,
    toggle: propTypes.func,
    keyboard: propTypes.bool,
    role: propTypes.string,
    labelledBy: propTypes.string,
    backdrop: propTypes.oneOfType([propTypes.bool, propTypes.oneOf(['static'])]),
    onEnter: propTypes.func,
    onExit: propTypes.func,
    onOpened: propTypes.func,
    onClosed: propTypes.func,
    children: propTypes.node,
    className: propTypes.string,
    wrapClassName: propTypes.string,
    modalClassName: propTypes.string,
    backdropClassName: propTypes.string,
    contentClassName: propTypes.string,
    external: propTypes.node,
    fade: propTypes.bool,
    cssModule: propTypes.object,
    zIndex: propTypes.oneOfType([propTypes.number, propTypes.string]),
    backdropTransition: FadePropTypes,
    modalTransition: FadePropTypes,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.string, propTypes.func]),
    unmountOnClose: propTypes.bool,
    returnFocusAfterClose: propTypes.bool
  };
  var propsToOmit = Object.keys(propTypes$H);
  var defaultProps$I = {
    isOpen: false,
    autoFocus: true,
    centered: false,
    scrollable: false,
    role: 'dialog',
    backdrop: true,
    keyboard: true,
    zIndex: 1050,
    fade: true,
    onOpened: noop$1,
    onClosed: noop$1,
    modalTransition: {
      timeout: TransitionTimeouts.Modal
    },
    backdropTransition: {
      mountOnEnter: true,
      timeout: TransitionTimeouts.Fade // uses standard fade transition

    },
    unmountOnClose: true,
    returnFocusAfterClose: true
  };

  var Modal =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Modal, _React$Component);

    function Modal(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this._element = null;
      _this._originalBodyPadding = null;
      _this.getFocusableChildren = _this.getFocusableChildren.bind(_assertThisInitialized(_this));
      _this.handleBackdropClick = _this.handleBackdropClick.bind(_assertThisInitialized(_this));
      _this.handleBackdropMouseDown = _this.handleBackdropMouseDown.bind(_assertThisInitialized(_this));
      _this.handleEscape = _this.handleEscape.bind(_assertThisInitialized(_this));
      _this.handleTab = _this.handleTab.bind(_assertThisInitialized(_this));
      _this.onOpened = _this.onOpened.bind(_assertThisInitialized(_this));
      _this.onClosed = _this.onClosed.bind(_assertThisInitialized(_this));
      _this.manageFocusAfterClose = _this.manageFocusAfterClose.bind(_assertThisInitialized(_this));
      _this.state = {
        isOpen: props.isOpen
      };

      if (props.isOpen) {
        _this.init();
      }

      return _this;
    }

    var _proto = Modal.prototype;

    _proto.componentDidMount = function componentDidMount() {
      if (this.props.onEnter) {
        this.props.onEnter();
      }

      if (this.state.isOpen && this.props.autoFocus) {
        this.setFocus();
      }

      this._isMounted = true;
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      if (this.props.isOpen && !prevProps.isOpen) {
        this.init();
        this.setState({
          isOpen: true
        }); // let render() renders Modal Dialog first

        return;
      } // now Modal Dialog is rendered and we can refer this._element and this._dialog


      if (this.props.autoFocus && this.state.isOpen && !prevState.isOpen) {
        this.setFocus();
      }

      if (this._element && prevProps.zIndex !== this.props.zIndex) {
        this._element.style.zIndex = this.props.zIndex;
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.props.onExit) {
        this.props.onExit();
      }

      if (this._element) {
        this.destroy();

        if (this.state.isOpen) {
          this.close();
        }
      }

      this._isMounted = false;
    };

    _proto.onOpened = function onOpened(node, isAppearing) {
      this.props.onOpened();
      (this.props.modalTransition.onEntered || noop$1)(node, isAppearing);
    };

    _proto.onClosed = function onClosed(node) {
      var unmountOnClose = this.props.unmountOnClose; // so all methods get called before it is unmounted

      this.props.onClosed();
      (this.props.modalTransition.onExited || noop$1)(node);

      if (unmountOnClose) {
        this.destroy();
      }

      this.close();

      if (this._isMounted) {
        this.setState({
          isOpen: false
        });
      }
    };

    _proto.setFocus = function setFocus() {
      if (this._dialog && this._dialog.parentNode && typeof this._dialog.parentNode.focus === 'function') {
        this._dialog.parentNode.focus();
      }
    };

    _proto.getFocusableChildren = function getFocusableChildren() {
      return this._element.querySelectorAll(focusableElements.join(', '));
    };

    _proto.getFocusedChild = function getFocusedChild() {
      var currentFocus;
      var focusableChildren = this.getFocusableChildren();

      try {
        currentFocus = document.activeElement;
      } catch (err) {
        currentFocus = focusableChildren[0];
      }

      return currentFocus;
    } // not mouseUp because scrollbar fires it, shouldn't close when user scrolls
    ;

    _proto.handleBackdropClick = function handleBackdropClick(e) {
      if (e.target === this._mouseDownElement) {
        e.stopPropagation();
        if (!this.props.isOpen || this.props.backdrop !== true) return;
        var backdrop = this._dialog ? this._dialog.parentNode : null;

        if (backdrop && e.target === backdrop && this.props.toggle) {
          this.props.toggle(e);
        }
      }
    };

    _proto.handleTab = function handleTab(e) {
      if (e.which !== 9) return;
      var focusableChildren = this.getFocusableChildren();
      var totalFocusable = focusableChildren.length;
      if (totalFocusable === 0) return;
      var currentFocus = this.getFocusedChild();
      var focusedIndex = 0;

      for (var i = 0; i < totalFocusable; i += 1) {
        if (focusableChildren[i] === currentFocus) {
          focusedIndex = i;
          break;
        }
      }

      if (e.shiftKey && focusedIndex === 0) {
        e.preventDefault();
        focusableChildren[totalFocusable - 1].focus();
      } else if (!e.shiftKey && focusedIndex === totalFocusable - 1) {
        e.preventDefault();
        focusableChildren[0].focus();
      }
    };

    _proto.handleBackdropMouseDown = function handleBackdropMouseDown(e) {
      this._mouseDownElement = e.target;
    };

    _proto.handleEscape = function handleEscape(e) {
      if (this.props.isOpen && this.props.keyboard && e.keyCode === 27 && this.props.toggle) {
        e.preventDefault();
        e.stopPropagation();
        this.props.toggle(e);
      }
    };

    _proto.init = function init() {
      try {
        this._triggeringElement = document.activeElement;
      } catch (err) {
        this._triggeringElement = null;
      }

      if (!this._element) {
        this._element = document.createElement('div');

        this._element.setAttribute('tabindex', '-1');

        this._element.style.position = 'relative';
        this._element.style.zIndex = this.props.zIndex;
        document.body.appendChild(this._element);
      }

      this._originalBodyPadding = getOriginalBodyPadding();
      conditionallyUpdateScrollbar();

      if (Modal.openCount === 0) {
        document.body.className = classnames(document.body.className, mapToCssModules('modal-open', this.props.cssModule));
      }

      Modal.openCount += 1;
    };

    _proto.destroy = function destroy() {
      if (this._element) {
        document.body.removeChild(this._element);
        this._element = null;
      }

      this.manageFocusAfterClose();
    };

    _proto.manageFocusAfterClose = function manageFocusAfterClose() {
      if (this._triggeringElement) {
        var returnFocusAfterClose = this.props.returnFocusAfterClose;
        if (this._triggeringElement.focus && returnFocusAfterClose) this._triggeringElement.focus();
        this._triggeringElement = null;
      }
    };

    _proto.close = function close() {
      if (Modal.openCount <= 1) {
        var modalOpenClassName = mapToCssModules('modal-open', this.props.cssModule); // Use regex to prevent matching `modal-open` as part of a different class, e.g. `my-modal-opened`

        var modalOpenClassNameRegex = new RegExp("(^| )" + modalOpenClassName + "( |$)");
        document.body.className = document.body.className.replace(modalOpenClassNameRegex, ' ').trim();
      }

      this.manageFocusAfterClose();
      Modal.openCount = Math.max(0, Modal.openCount - 1);
      setScrollbarWidth(this._originalBodyPadding);
    };

    _proto.renderModalDialog = function renderModalDialog() {
      var _classNames,
          _this2 = this;

      var attributes = omit(this.props, propsToOmit);
      var dialogBaseClass = 'modal-dialog';
      return react.createElement("div", _extends$9({}, attributes, {
        className: mapToCssModules(classnames(dialogBaseClass, this.props.className, (_classNames = {}, _classNames["modal-" + this.props.size] = this.props.size, _classNames[dialogBaseClass + "-centered"] = this.props.centered, _classNames[dialogBaseClass + "-scrollable"] = this.props.scrollable, _classNames)), this.props.cssModule),
        role: "document",
        ref: function ref(c) {
          _this2._dialog = c;
        }
      }), react.createElement("div", {
        className: mapToCssModules(classnames('modal-content', this.props.contentClassName), this.props.cssModule)
      }, this.props.children));
    };

    _proto.render = function render() {
      var unmountOnClose = this.props.unmountOnClose;

      if (!!this._element && (this.state.isOpen || !unmountOnClose)) {
        var isModalHidden = !!this._element && !this.state.isOpen && !unmountOnClose;
        this._element.style.display = isModalHidden ? 'none' : 'block';
        var _this$props = this.props,
            wrapClassName = _this$props.wrapClassName,
            modalClassName = _this$props.modalClassName,
            backdropClassName = _this$props.backdropClassName,
            cssModule = _this$props.cssModule,
            isOpen = _this$props.isOpen,
            backdrop = _this$props.backdrop,
            role = _this$props.role,
            labelledBy = _this$props.labelledBy,
            external = _this$props.external,
            innerRef = _this$props.innerRef;
        var modalAttributes = {
          onClick: this.handleBackdropClick,
          onMouseDown: this.handleBackdropMouseDown,
          onKeyUp: this.handleEscape,
          onKeyDown: this.handleTab,
          style: {
            display: 'block'
          },
          'aria-labelledby': labelledBy,
          role: role,
          tabIndex: '-1'
        };
        var hasTransition = this.props.fade;

        var modalTransition = _objectSpread$2({}, Fade.defaultProps, this.props.modalTransition, {
          baseClass: hasTransition ? this.props.modalTransition.baseClass : '',
          timeout: hasTransition ? this.props.modalTransition.timeout : 0
        });

        var backdropTransition = _objectSpread$2({}, Fade.defaultProps, this.props.backdropTransition, {
          baseClass: hasTransition ? this.props.backdropTransition.baseClass : '',
          timeout: hasTransition ? this.props.backdropTransition.timeout : 0
        });

        var Backdrop = backdrop && (hasTransition ? react.createElement(Fade, _extends$9({}, backdropTransition, {
          in: isOpen && !!backdrop,
          cssModule: cssModule,
          className: mapToCssModules(classnames('modal-backdrop', backdropClassName), cssModule)
        })) : react.createElement("div", {
          className: mapToCssModules(classnames('modal-backdrop', 'show', backdropClassName), cssModule)
        }));
        return react.createElement(Portal, {
          node: this._element
        }, react.createElement("div", {
          className: mapToCssModules(wrapClassName)
        }, react.createElement(Fade, _extends$9({}, modalAttributes, modalTransition, {
          in: isOpen,
          onEntered: this.onOpened,
          onExited: this.onClosed,
          cssModule: cssModule,
          className: mapToCssModules(classnames('modal', modalClassName), cssModule),
          innerRef: innerRef
        }), external, this.renderModalDialog()), Backdrop));
      }

      return null;
    };

    return Modal;
  }(react.Component);

  Modal.propTypes = propTypes$H;
  Modal.defaultProps = defaultProps$I;
  Modal.openCount = 0;

  var propTypes$I = {
    tag: tagPropType,
    wrapTag: tagPropType,
    toggle: propTypes.func,
    className: propTypes.string,
    cssModule: propTypes.object,
    children: propTypes.node,
    closeAriaLabel: propTypes.string,
    charCode: propTypes.oneOfType([propTypes.string, propTypes.number]),
    close: propTypes.object
  };
  var defaultProps$J = {
    tag: 'h5',
    wrapTag: 'div',
    closeAriaLabel: 'Close',
    charCode: 215
  };

  var ModalHeader = function ModalHeader(props) {
    var closeButton;

    var className = props.className,
        cssModule = props.cssModule,
        children = props.children,
        toggle = props.toggle,
        Tag = props.tag,
        WrapTag = props.wrapTag,
        closeAriaLabel = props.closeAriaLabel,
        charCode = props.charCode,
        close = props.close,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "children", "toggle", "tag", "wrapTag", "closeAriaLabel", "charCode", "close"]);

    var classes = mapToCssModules(classnames(className, 'modal-header'), cssModule);

    if (!close && toggle) {
      var closeIcon = typeof charCode === 'number' ? String.fromCharCode(charCode) : charCode;
      closeButton = react.createElement("button", {
        type: "button",
        onClick: toggle,
        className: mapToCssModules('close', cssModule),
        "aria-label": closeAriaLabel
      }, react.createElement("span", {
        "aria-hidden": "true"
      }, closeIcon));
    }

    return react.createElement(WrapTag, _extends$9({}, attributes, {
      className: classes
    }), react.createElement(Tag, {
      className: mapToCssModules('modal-title', cssModule)
    }, children), close || closeButton);
  };

  ModalHeader.propTypes = propTypes$I;
  ModalHeader.defaultProps = defaultProps$J;

  var propTypes$J = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$K = {
    tag: 'div'
  };

  var ModalBody = function ModalBody(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'modal-body'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  ModalBody.propTypes = propTypes$J;
  ModalBody.defaultProps = defaultProps$K;

  var propTypes$K = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$L = {
    tag: 'div'
  };

  var ModalFooter = function ModalFooter(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'modal-footer'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  ModalFooter.propTypes = propTypes$K;
  ModalFooter.defaultProps = defaultProps$L;

  var defaultProps$M = {
    placement: 'top',
    autohide: true,
    placementPrefix: 'bs-tooltip',
    trigger: 'click hover focus'
  };

  var Tooltip = function Tooltip(props) {
    var popperClasses = classnames('tooltip', 'show');
    var classes = classnames('tooltip-inner', props.innerClassName);
    return react.createElement(TooltipPopoverWrapper, _extends$9({}, props, {
      popperClassName: popperClasses,
      innerClassName: classes
    }));
  };

  Tooltip.propTypes = propTypes$C;
  Tooltip.defaultProps = defaultProps$M;

  var propTypes$L = {
    className: propTypes.string,
    cssModule: propTypes.object,
    size: propTypes.string,
    bordered: propTypes.bool,
    borderless: propTypes.bool,
    striped: propTypes.bool,
    dark: propTypes.bool,
    hover: propTypes.bool,
    responsive: propTypes.oneOfType([propTypes.bool, propTypes.string]),
    tag: tagPropType,
    responsiveTag: tagPropType,
    innerRef: propTypes.oneOfType([propTypes.func, propTypes.string, propTypes.object])
  };
  var defaultProps$N = {
    tag: 'table',
    responsiveTag: 'div'
  };

  var Table$2 = function Table(props) {
    var className = props.className,
        cssModule = props.cssModule,
        size = props.size,
        bordered = props.bordered,
        borderless = props.borderless,
        striped = props.striped,
        dark = props.dark,
        hover = props.hover,
        responsive = props.responsive,
        Tag = props.tag,
        ResponsiveTag = props.responsiveTag,
        innerRef = props.innerRef,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "size", "bordered", "borderless", "striped", "dark", "hover", "responsive", "tag", "responsiveTag", "innerRef"]);

    var classes = mapToCssModules(classnames(className, 'table', size ? 'table-' + size : false, bordered ? 'table-bordered' : false, borderless ? 'table-borderless' : false, striped ? 'table-striped' : false, dark ? 'table-dark' : false, hover ? 'table-hover' : false), cssModule);
    var table = react.createElement(Tag, _extends$9({}, attributes, {
      ref: innerRef,
      className: classes
    }));

    if (responsive) {
      var responsiveClassName = mapToCssModules(responsive === true ? 'table-responsive' : "table-responsive-" + responsive, cssModule);
      return react.createElement(ResponsiveTag, {
        className: responsiveClassName
      }, table);
    }

    return table;
  };

  Table$2.propTypes = propTypes$L;
  Table$2.defaultProps = defaultProps$N;

  var propTypes$M = {
    tag: tagPropType,
    flush: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$O = {
    tag: 'ul'
  };

  var ListGroup = function ListGroup(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        flush = props.flush,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag", "flush"]);

    var classes = mapToCssModules(classnames(className, 'list-group', flush ? 'list-group-flush' : false), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  ListGroup.propTypes = propTypes$M;
  ListGroup.defaultProps = defaultProps$O;

  var propTypes$N = {
    children: propTypes.node,
    inline: propTypes.bool,
    tag: tagPropType,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.func, propTypes.string]),
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$P = {
    tag: 'form'
  };

  var Form =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(Form, _Component);

    function Form(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));
      _this.submit = _this.submit.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = Form.prototype;

    _proto.getRef = function getRef(ref) {
      if (this.props.innerRef) {
        this.props.innerRef(ref);
      }

      this.ref = ref;
    };

    _proto.submit = function submit() {
      if (this.ref) {
        this.ref.submit();
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          inline = _this$props.inline,
          Tag = _this$props.tag,
          innerRef = _this$props.innerRef,
          attributes = _objectWithoutPropertiesLoose(_this$props, ["className", "cssModule", "inline", "tag", "innerRef"]);

      var classes = mapToCssModules(classnames(className, inline ? 'form-inline' : false), cssModule);
      return react.createElement(Tag, _extends$9({}, attributes, {
        ref: innerRef,
        className: classes
      }));
    };

    return Form;
  }(react_2);

  Form.propTypes = propTypes$N;
  Form.defaultProps = defaultProps$P;

  var propTypes$O = {
    children: propTypes.node,
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object,
    valid: propTypes.bool,
    tooltip: propTypes.bool
  };
  var defaultProps$Q = {
    tag: 'div',
    valid: undefined
  };

  var FormFeedback = function FormFeedback(props) {
    var className = props.className,
        cssModule = props.cssModule,
        valid = props.valid,
        tooltip = props.tooltip,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "valid", "tooltip", "tag"]);

    var validMode = tooltip ? 'tooltip' : 'feedback';
    var classes = mapToCssModules(classnames(className, valid ? "valid-" + validMode : "invalid-" + validMode), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  FormFeedback.propTypes = propTypes$O;
  FormFeedback.defaultProps = defaultProps$Q;

  var propTypes$P = {
    children: propTypes.node,
    row: propTypes.bool,
    check: propTypes.bool,
    inline: propTypes.bool,
    disabled: propTypes.bool,
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$R = {
    tag: 'div'
  };

  var FormGroup = function FormGroup(props) {
    var className = props.className,
        cssModule = props.cssModule,
        row = props.row,
        disabled = props.disabled,
        check = props.check,
        inline = props.inline,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "row", "disabled", "check", "inline", "tag"]);

    var classes = mapToCssModules(classnames(className, row ? 'row' : false, check ? 'form-check' : 'form-group', check && inline ? 'form-check-inline' : false, check && disabled ? 'disabled' : false), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  FormGroup.propTypes = propTypes$P;
  FormGroup.defaultProps = defaultProps$R;

  var propTypes$Q = {
    children: propTypes.node,
    inline: propTypes.bool,
    tag: tagPropType,
    color: propTypes.string,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$S = {
    tag: 'small',
    color: 'muted'
  };

  var FormText = function FormText(props) {
    var className = props.className,
        cssModule = props.cssModule,
        inline = props.inline,
        color = props.color,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "inline", "color", "tag"]);

    var classes = mapToCssModules(classnames(className, !inline ? 'form-text' : false, color ? "text-" + color : false), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  FormText.propTypes = propTypes$Q;
  FormText.defaultProps = defaultProps$S;

  var propTypes$R = {
    children: propTypes.node,
    type: propTypes.string,
    size: propTypes.string,
    bsSize: propTypes.string,
    valid: propTypes.bool,
    invalid: propTypes.bool,
    tag: tagPropType,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.func, propTypes.string]),
    plaintext: propTypes.bool,
    addon: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$T = {
    type: 'text'
  };

  var Input =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Input, _React$Component);

    function Input(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));
      _this.focus = _this.focus.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = Input.prototype;

    _proto.getRef = function getRef(ref) {
      if (this.props.innerRef) {
        this.props.innerRef(ref);
      }

      this.ref = ref;
    };

    _proto.focus = function focus() {
      if (this.ref) {
        this.ref.focus();
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          type = _this$props.type,
          bsSize = _this$props.bsSize,
          valid = _this$props.valid,
          invalid = _this$props.invalid,
          tag = _this$props.tag,
          addon = _this$props.addon,
          plaintext = _this$props.plaintext,
          innerRef = _this$props.innerRef,
          attributes = _objectWithoutPropertiesLoose(_this$props, ["className", "cssModule", "type", "bsSize", "valid", "invalid", "tag", "addon", "plaintext", "innerRef"]);

      var checkInput = ['radio', 'checkbox'].indexOf(type) > -1;
      var isNotaNumber = new RegExp('\\D', 'g');
      var fileInput = type === 'file';
      var textareaInput = type === 'textarea';
      var selectInput = type === 'select';
      var Tag = tag || (selectInput || textareaInput ? type : 'input');
      var formControlClass = 'form-control';

      if (plaintext) {
        formControlClass = formControlClass + "-plaintext";
        Tag = tag || 'input';
      } else if (fileInput) {
        formControlClass = formControlClass + "-file";
      } else if (checkInput) {
        if (addon) {
          formControlClass = null;
        } else {
          formControlClass = 'form-check-input';
        }
      }

      if (attributes.size && isNotaNumber.test(attributes.size)) {
        warnOnce('Please use the prop "bsSize" instead of the "size" to bootstrap\'s input sizing.');
        bsSize = attributes.size;
        delete attributes.size;
      }

      var classes = mapToCssModules(classnames(className, invalid && 'is-invalid', valid && 'is-valid', bsSize ? "form-control-" + bsSize : false, formControlClass), cssModule);

      if (Tag === 'input' || tag && typeof tag === 'function') {
        attributes.type = type;
      }

      if (attributes.children && !(plaintext || type === 'select' || typeof Tag !== 'string' || Tag === 'select')) {
        warnOnce("Input with a type of \"" + type + "\" cannot have children. Please use \"value\"/\"defaultValue\" instead.");
        delete attributes.children;
      }

      return react.createElement(Tag, _extends$9({}, attributes, {
        ref: innerRef,
        className: classes
      }));
    };

    return Input;
  }(react.Component);

  Input.propTypes = propTypes$R;
  Input.defaultProps = defaultProps$T;

  var propTypes$S = {
    tag: tagPropType,
    size: propTypes.string,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$U = {
    tag: 'div'
  };

  var InputGroup = function InputGroup(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        size = props.size,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag", "size"]);

    var classes = mapToCssModules(classnames(className, 'input-group', size ? "input-group-" + size : null), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  InputGroup.propTypes = propTypes$S;
  InputGroup.defaultProps = defaultProps$U;

  var propTypes$T = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$V = {
    tag: 'span'
  };

  var InputGroupText = function InputGroupText(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'input-group-text'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  InputGroupText.propTypes = propTypes$T;
  InputGroupText.defaultProps = defaultProps$V;

  var propTypes$U = {
    tag: tagPropType,
    addonType: propTypes.oneOf(['prepend', 'append']).isRequired,
    children: propTypes.node,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$W = {
    tag: 'div'
  };

  var InputGroupAddon = function InputGroupAddon(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        addonType = props.addonType,
        children = props.children,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag", "addonType", "children"]);

    var classes = mapToCssModules(classnames(className, 'input-group-' + addonType), cssModule); // Convenience to assist with transition

    if (typeof children === 'string') {
      return react.createElement(Tag, _extends$9({}, attributes, {
        className: classes
      }), react.createElement(InputGroupText, {
        children: children
      }));
    }

    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes,
      children: children
    }));
  };

  InputGroupAddon.propTypes = propTypes$U;
  InputGroupAddon.defaultProps = defaultProps$W;

  var propTypes$V = {
    addonType: propTypes.oneOf(['prepend', 'append']).isRequired,
    children: propTypes.node
  };

  var InputGroupButtonDropdown = function InputGroupButtonDropdown(props) {
    return react.createElement(Dropdown$1, props);
  };

  InputGroupButtonDropdown.propTypes = propTypes$V;

  var colWidths$1 = ['xs', 'sm', 'md', 'lg', 'xl'];
  var stringOrNumberProp$1 = propTypes.oneOfType([propTypes.number, propTypes.string]);
  var columnProps$1 = propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.shape({
    size: stringOrNumberProp$1,
    order: stringOrNumberProp$1,
    offset: stringOrNumberProp$1
  })]);
  var propTypes$W = {
    children: propTypes.node,
    hidden: propTypes.bool,
    check: propTypes.bool,
    size: propTypes.string,
    for: propTypes.string,
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object,
    xs: columnProps$1,
    sm: columnProps$1,
    md: columnProps$1,
    lg: columnProps$1,
    xl: columnProps$1,
    widths: propTypes.array
  };
  var defaultProps$X = {
    tag: 'label',
    widths: colWidths$1
  };

  var getColumnSizeClass$1 = function getColumnSizeClass(isXs, colWidth, colSize) {
    if (colSize === true || colSize === '') {
      return isXs ? 'col' : "col-" + colWidth;
    } else if (colSize === 'auto') {
      return isXs ? 'col-auto' : "col-" + colWidth + "-auto";
    }

    return isXs ? "col-" + colSize : "col-" + colWidth + "-" + colSize;
  };

  var Label = function Label(props) {
    var className = props.className,
        cssModule = props.cssModule,
        hidden = props.hidden,
        widths = props.widths,
        Tag = props.tag,
        check = props.check,
        size = props.size,
        htmlFor = props.for,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "hidden", "widths", "tag", "check", "size", "for"]);

    var colClasses = [];
    widths.forEach(function (colWidth, i) {
      var columnProp = props[colWidth];
      delete attributes[colWidth];

      if (!columnProp && columnProp !== '') {
        return;
      }

      var isXs = !i;
      var colClass;

      if (lodash_isobject(columnProp)) {
        var _classNames;

        var colSizeInterfix = isXs ? '-' : "-" + colWidth + "-";
        colClass = getColumnSizeClass$1(isXs, colWidth, columnProp.size);
        colClasses.push(mapToCssModules(classnames((_classNames = {}, _classNames[colClass] = columnProp.size || columnProp.size === '', _classNames["order" + colSizeInterfix + columnProp.order] = columnProp.order || columnProp.order === 0, _classNames["offset" + colSizeInterfix + columnProp.offset] = columnProp.offset || columnProp.offset === 0, _classNames))), cssModule);
      } else {
        colClass = getColumnSizeClass$1(isXs, colWidth, columnProp);
        colClasses.push(colClass);
      }
    });
    var classes = mapToCssModules(classnames(className, hidden ? 'sr-only' : false, check ? 'form-check-label' : false, size ? "col-form-label-" + size : false, colClasses, colClasses.length ? 'col-form-label' : false), cssModule);
    return react.createElement(Tag, _extends$9({
      htmlFor: htmlFor
    }, attributes, {
      className: classes
    }));
  };

  Label.propTypes = propTypes$W;
  Label.defaultProps = defaultProps$X;

  var propTypes$X = {
    body: propTypes.bool,
    bottom: propTypes.bool,
    children: propTypes.node,
    className: propTypes.string,
    cssModule: propTypes.object,
    heading: propTypes.bool,
    left: propTypes.bool,
    list: propTypes.bool,
    middle: propTypes.bool,
    object: propTypes.bool,
    right: propTypes.bool,
    tag: tagPropType,
    top: propTypes.bool
  };

  var Media = function Media(props) {
    var body = props.body,
        bottom = props.bottom,
        className = props.className,
        cssModule = props.cssModule,
        heading = props.heading,
        left = props.left,
        list = props.list,
        middle = props.middle,
        object = props.object,
        right = props.right,
        tag = props.tag,
        top = props.top,
        attributes = _objectWithoutPropertiesLoose(props, ["body", "bottom", "className", "cssModule", "heading", "left", "list", "middle", "object", "right", "tag", "top"]);

    var defaultTag;

    if (heading) {
      defaultTag = 'h4';
    } else if (attributes.href) {
      defaultTag = 'a';
    } else if (attributes.src || object) {
      defaultTag = 'img';
    } else if (list) {
      defaultTag = 'ul';
    } else {
      defaultTag = 'div';
    }

    var Tag = tag || defaultTag;
    var classes = mapToCssModules(classnames(className, {
      'media-body': body,
      'media-heading': heading,
      'media-left': left,
      'media-right': right,
      'media-top': top,
      'media-bottom': bottom,
      'media-middle': middle,
      'media-object': object,
      'media-list': list,
      media: !body && !heading && !left && !right && !top && !bottom && !middle && !object && !list
    }), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  Media.propTypes = propTypes$X;

  var propTypes$Y = {
    children: propTypes.node,
    className: propTypes.string,
    listClassName: propTypes.string,
    cssModule: propTypes.object,
    size: propTypes.string,
    tag: tagPropType,
    listTag: tagPropType,
    'aria-label': propTypes.string
  };
  var defaultProps$Y = {
    tag: 'nav',
    listTag: 'ul',
    'aria-label': 'pagination'
  };

  var Pagination$2 = function Pagination(props) {
    var _classNames;

    var className = props.className,
        listClassName = props.listClassName,
        cssModule = props.cssModule,
        size = props.size,
        Tag = props.tag,
        ListTag = props.listTag,
        label = props['aria-label'],
        attributes = _objectWithoutPropertiesLoose(props, ["className", "listClassName", "cssModule", "size", "tag", "listTag", "aria-label"]);

    var classes = mapToCssModules(classnames(className), cssModule);
    var listClasses = mapToCssModules(classnames(listClassName, 'pagination', (_classNames = {}, _classNames["pagination-" + size] = !!size, _classNames)), cssModule);
    return react.createElement(Tag, {
      className: classes,
      "aria-label": label
    }, react.createElement(ListTag, _extends$9({}, attributes, {
      className: listClasses
    })));
  };

  Pagination$2.propTypes = propTypes$Y;
  Pagination$2.defaultProps = defaultProps$Y;

  var propTypes$Z = {
    active: propTypes.bool,
    children: propTypes.node,
    className: propTypes.string,
    cssModule: propTypes.object,
    disabled: propTypes.bool,
    tag: tagPropType
  };
  var defaultProps$Z = {
    tag: 'li'
  };

  var PaginationItem$1 = function PaginationItem(props) {
    var active = props.active,
        className = props.className,
        cssModule = props.cssModule,
        disabled = props.disabled,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["active", "className", "cssModule", "disabled", "tag"]);

    var classes = mapToCssModules(classnames(className, 'page-item', {
      active: active,
      disabled: disabled
    }), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  PaginationItem$1.propTypes = propTypes$Z;
  PaginationItem$1.defaultProps = defaultProps$Z;

  var propTypes$_ = {
    'aria-label': propTypes.string,
    children: propTypes.node,
    className: propTypes.string,
    cssModule: propTypes.object,
    next: propTypes.bool,
    previous: propTypes.bool,
    first: propTypes.bool,
    last: propTypes.bool,
    tag: tagPropType
  };
  var defaultProps$_ = {
    tag: 'a'
  };

  var PaginationLink$1 = function PaginationLink(props) {
    var className = props.className,
        cssModule = props.cssModule,
        next = props.next,
        previous = props.previous,
        first = props.first,
        last = props.last,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "next", "previous", "first", "last", "tag"]);

    var classes = mapToCssModules(classnames(className, 'page-link'), cssModule);
    var defaultAriaLabel;

    if (previous) {
      defaultAriaLabel = 'Previous';
    } else if (next) {
      defaultAriaLabel = 'Next';
    } else if (first) {
      defaultAriaLabel = 'First';
    } else if (last) {
      defaultAriaLabel = 'Last';
    }

    var ariaLabel = props['aria-label'] || defaultAriaLabel;
    var defaultCaret;

    if (previous) {
      defaultCaret = "\u2039";
    } else if (next) {
      defaultCaret = "\u203A";
    } else if (first) {
      defaultCaret = "\xAB";
    } else if (last) {
      defaultCaret = "\xBB";
    }

    var children = props.children;

    if (children && Array.isArray(children) && children.length === 0) {
      children = null;
    }

    if (!attributes.href && Tag === 'a') {
      Tag = 'button';
    }

    if (previous || next || first || last) {
      children = [react.createElement("span", {
        "aria-hidden": "true",
        key: "caret"
      }, children || defaultCaret), react.createElement("span", {
        className: "sr-only",
        key: "sr"
      }, ariaLabel)];
    }

    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes,
      "aria-label": ariaLabel
    }), children);
  };

  PaginationLink$1.propTypes = propTypes$_;
  PaginationLink$1.defaultProps = defaultProps$_;

  /**
   * TabContext
   * {
   *  activeTabId: PropTypes.any
   * }
   */

  var TabContext = react.createContext({});

  var propTypes$$ = {
    tag: tagPropType,
    activeTab: propTypes.any,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$$ = {
    tag: 'div'
  };

  var TabContent =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(TabContent, _Component);

    TabContent.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
      if (prevState.activeTab !== nextProps.activeTab) {
        return {
          activeTab: nextProps.activeTab
        };
      }

      return null;
    };

    function TabContent(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.state = {
        activeTab: _this.props.activeTab
      };
      return _this;
    }

    var _proto = TabContent.prototype;

    _proto.render = function render() {
      var _this$props = this.props,
          className = _this$props.className,
          cssModule = _this$props.cssModule,
          Tag = _this$props.tag;
      var attributes = omit(this.props, Object.keys(propTypes$$));
      var classes = mapToCssModules(classnames('tab-content', className), cssModule);
      return react.createElement(TabContext.Provider, {
        value: {
          activeTabId: this.state.activeTab
        }
      }, react.createElement(Tag, _extends$9({}, attributes, {
        className: classes
      })));
    };

    return TabContent;
  }(react_2);

  polyfill(TabContent);
  TabContent.propTypes = propTypes$$;
  TabContent.defaultProps = defaultProps$$;

  var propTypes$10 = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object,
    tabId: propTypes.any
  };
  var defaultProps$10 = {
    tag: 'div'
  };
  function TabPane(props) {
    var className = props.className,
        cssModule = props.cssModule,
        tabId = props.tabId,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tabId", "tag"]);

    var getClasses = function getClasses(activeTabId) {
      return mapToCssModules(classnames('tab-pane', className, {
        active: tabId === activeTabId
      }), cssModule);
    };

    return react.createElement(TabContext.Consumer, null, function (_ref) {
      var activeTabId = _ref.activeTabId;
      return react.createElement(Tag, _extends$9({}, attributes, {
        className: getClasses(activeTabId)
      }));
    });
  }
  TabPane.propTypes = propTypes$10;
  TabPane.defaultProps = defaultProps$10;

  var propTypes$11 = {
    tag: tagPropType,
    fluid: propTypes.bool,
    className: propTypes.string,
    cssModule: propTypes.object
  };
  var defaultProps$11 = {
    tag: 'div'
  };

  var Jumbotron = function Jumbotron(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        fluid = props.fluid,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag", "fluid"]);

    var classes = mapToCssModules(classnames(className, 'jumbotron', fluid ? 'jumbotron-fluid' : false), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  Jumbotron.propTypes = propTypes$11;
  Jumbotron.defaultProps = defaultProps$11;

  var propTypes$12 = {
    children: propTypes.node,
    className: propTypes.string,
    closeClassName: propTypes.string,
    closeAriaLabel: propTypes.string,
    cssModule: propTypes.object,
    color: propTypes.string,
    fade: propTypes.bool,
    isOpen: propTypes.bool,
    toggle: propTypes.func,
    tag: tagPropType,
    transition: propTypes.shape(Fade.propTypes),
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.string, propTypes.func])
  };
  var defaultProps$12 = {
    color: 'success',
    isOpen: true,
    tag: 'div',
    closeAriaLabel: 'Close',
    fade: true,
    transition: _objectSpread$2({}, Fade.defaultProps, {
      unmountOnExit: true
    })
  };

  function Alert(props) {
    var className = props.className,
        closeClassName = props.closeClassName,
        closeAriaLabel = props.closeAriaLabel,
        cssModule = props.cssModule,
        Tag = props.tag,
        color = props.color,
        isOpen = props.isOpen,
        toggle = props.toggle,
        children = props.children,
        transition = props.transition,
        fade = props.fade,
        innerRef = props.innerRef,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "closeClassName", "closeAriaLabel", "cssModule", "tag", "color", "isOpen", "toggle", "children", "transition", "fade", "innerRef"]);

    var classes = mapToCssModules(classnames(className, 'alert', "alert-" + color, {
      'alert-dismissible': toggle
    }), cssModule);
    var closeClasses = mapToCssModules(classnames('close', closeClassName), cssModule);

    var alertTransition = _objectSpread$2({}, Fade.defaultProps, transition, {
      baseClass: fade ? transition.baseClass : '',
      timeout: fade ? transition.timeout : 0
    });

    return react.createElement(Fade, _extends$9({}, attributes, alertTransition, {
      tag: Tag,
      className: classes,
      in: isOpen,
      role: "alert",
      innerRef: innerRef
    }), toggle ? react.createElement("button", {
      type: "button",
      className: closeClasses,
      "aria-label": closeAriaLabel,
      onClick: toggle
    }, react.createElement("span", {
      "aria-hidden": "true"
    }, "\xD7")) : null, children);
  }

  Alert.propTypes = propTypes$12;
  Alert.defaultProps = defaultProps$12;

  var propTypes$13 = {
    children: propTypes.node,
    className: propTypes.string,
    cssModule: propTypes.object,
    fade: propTypes.bool,
    isOpen: propTypes.bool,
    tag: tagPropType,
    transition: propTypes.shape(Fade.propTypes),
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.string, propTypes.func])
  };
  var defaultProps$13 = {
    isOpen: true,
    tag: 'div',
    fade: true,
    transition: _objectSpread$2({}, Fade.defaultProps, {
      unmountOnExit: true
    })
  };

  function Toast(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        isOpen = props.isOpen,
        children = props.children,
        transition = props.transition,
        fade = props.fade,
        innerRef = props.innerRef,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag", "isOpen", "children", "transition", "fade", "innerRef"]);

    var classes = mapToCssModules(classnames(className, 'toast'), cssModule);

    var toastTransition = _objectSpread$2({}, Fade.defaultProps, transition, {
      baseClass: fade ? transition.baseClass : '',
      timeout: fade ? transition.timeout : 0
    });

    return react.createElement(Fade, _extends$9({}, attributes, toastTransition, {
      tag: Tag,
      className: classes,
      in: isOpen,
      role: "alert",
      innerRef: innerRef
    }), children);
  }

  Toast.propTypes = propTypes$13;
  Toast.defaultProps = defaultProps$13;

  var propTypes$14 = {
    tag: tagPropType,
    className: propTypes.string,
    cssModule: propTypes.object,
    innerRef: propTypes.oneOfType([propTypes.object, propTypes.string, propTypes.func])
  };
  var defaultProps$14 = {
    tag: 'div'
  };

  var ToastBody = function ToastBody(props) {
    var className = props.className,
        cssModule = props.cssModule,
        innerRef = props.innerRef,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "innerRef", "tag"]);

    var classes = mapToCssModules(classnames(className, 'toast-body'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes,
      ref: innerRef
    }));
  };

  ToastBody.propTypes = propTypes$14;
  ToastBody.defaultProps = defaultProps$14;

  var propTypes$15 = {
    tag: tagPropType,
    icon: propTypes.oneOfType([propTypes.string, propTypes.node]),
    wrapTag: tagPropType,
    toggle: propTypes.func,
    className: propTypes.string,
    cssModule: propTypes.object,
    children: propTypes.node,
    closeAriaLabel: propTypes.string,
    charCode: propTypes.oneOfType([propTypes.string, propTypes.number]),
    close: propTypes.object
  };
  var defaultProps$15 = {
    tag: 'strong',
    wrapTag: 'div',
    tagClassName: 'mr-auto',
    closeAriaLabel: 'Close',
    charCode: 215
  };

  var ToastHeader = function ToastHeader(props) {
    var closeButton;
    var icon;

    var className = props.className,
        cssModule = props.cssModule,
        children = props.children,
        toggle = props.toggle,
        Tag = props.tag,
        WrapTag = props.wrapTag,
        closeAriaLabel = props.closeAriaLabel,
        charCode = props.charCode,
        close = props.close,
        tagClassName = props.tagClassName,
        iconProp = props.icon,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "children", "toggle", "tag", "wrapTag", "closeAriaLabel", "charCode", "close", "tagClassName", "icon"]);

    var classes = mapToCssModules(classnames(className, 'toast-header'), cssModule);

    if (!close && toggle) {
      var closeIcon = typeof charCode === 'number' ? String.fromCharCode(charCode) : charCode;
      closeButton = react.createElement("button", {
        type: "button",
        onClick: toggle,
        className: mapToCssModules('close', cssModule),
        "aria-label": closeAriaLabel
      }, react.createElement("span", {
        "aria-hidden": "true"
      }, closeIcon));
    }

    if (typeof iconProp === "string") {
      icon = react.createElement("svg", {
        className: mapToCssModules("rounded text-" + iconProp),
        width: "20",
        height: "20",
        xmlns: "http://www.w3.org/2000/svg",
        preserveAspectRatio: "xMidYMid slice",
        focusable: "false",
        role: "img"
      }, react.createElement("rect", {
        fill: "currentColor",
        width: "100%",
        height: "100%"
      }));
    } else if (iconProp) {
      icon = iconProp;
    }

    return react.createElement(WrapTag, _extends$9({}, attributes, {
      className: classes
    }), icon, react.createElement(Tag, {
      className: mapToCssModules(classnames(tagClassName, {
        "ml-2": icon != null
      }), cssModule)
    }, children), close || closeButton);
  };

  ToastHeader.propTypes = propTypes$15;
  ToastHeader.defaultProps = defaultProps$15;

  var _transitionStatusToCl;

  var propTypes$16 = _objectSpread$2({}, reactTransitionGroup_1.propTypes, {
    isOpen: propTypes.bool,
    children: propTypes.oneOfType([propTypes.arrayOf(propTypes.node), propTypes.node]),
    tag: tagPropType,
    className: propTypes.node,
    navbar: propTypes.bool,
    cssModule: propTypes.object,
    innerRef: propTypes.oneOfType([propTypes.func, propTypes.string, propTypes.object])
  });

  var defaultProps$16 = _objectSpread$2({}, reactTransitionGroup_1.defaultProps, {
    isOpen: false,
    appear: false,
    enter: true,
    exit: true,
    tag: 'div',
    timeout: TransitionTimeouts.Collapse
  });

  var transitionStatusToClassHash = (_transitionStatusToCl = {}, _transitionStatusToCl[TransitionStatuses.ENTERING] = 'collapsing', _transitionStatusToCl[TransitionStatuses.ENTERED] = 'collapse show', _transitionStatusToCl[TransitionStatuses.EXITING] = 'collapsing', _transitionStatusToCl[TransitionStatuses.EXITED] = 'collapse', _transitionStatusToCl);

  function getTransitionClass(status) {
    return transitionStatusToClassHash[status] || 'collapse';
  }

  function getHeight(node) {
    return node.scrollHeight;
  }

  var Collapse =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(Collapse, _Component);

    function Collapse(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.state = {
        height: null
      };
      ['onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited'].forEach(function (name) {
        _this[name] = _this[name].bind(_assertThisInitialized(_this));
      });
      return _this;
    }

    var _proto = Collapse.prototype;

    _proto.onEntering = function onEntering(node, isAppearing) {
      this.setState({
        height: getHeight(node)
      });
      this.props.onEntering(node, isAppearing);
    };

    _proto.onEntered = function onEntered(node, isAppearing) {
      this.setState({
        height: null
      });
      this.props.onEntered(node, isAppearing);
    };

    _proto.onExit = function onExit(node) {
      this.setState({
        height: getHeight(node)
      });
      this.props.onExit(node);
    };

    _proto.onExiting = function onExiting(node) {
      // getting this variable triggers a reflow
      var _unused = node.offsetHeight; // eslint-disable-line no-unused-vars

      this.setState({
        height: 0
      });
      this.props.onExiting(node);
    };

    _proto.onExited = function onExited(node) {
      this.setState({
        height: null
      });
      this.props.onExited(node);
    };

    _proto.render = function render() {
      var _this2 = this;

      var _this$props = this.props,
          Tag = _this$props.tag,
          isOpen = _this$props.isOpen,
          className = _this$props.className,
          navbar = _this$props.navbar,
          cssModule = _this$props.cssModule,
          children = _this$props.children,
          innerRef = _this$props.innerRef,
          otherProps = _objectWithoutPropertiesLoose(_this$props, ["tag", "isOpen", "className", "navbar", "cssModule", "children", "innerRef"]);

      var height = this.state.height;
      var transitionProps = pick(otherProps, TransitionPropTypeKeys);
      var childProps = omit(otherProps, TransitionPropTypeKeys);
      return react.createElement(reactTransitionGroup_1, _extends$9({}, transitionProps, {
        in: isOpen,
        onEntering: this.onEntering,
        onEntered: this.onEntered,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }), function (status) {
        var collapseClass = getTransitionClass(status);
        var classes = mapToCssModules(classnames(className, collapseClass, navbar && 'navbar-collapse'), cssModule);
        var style = height === null ? null : {
          height: height
        };
        return react.createElement(Tag, _extends$9({}, childProps, {
          style: _objectSpread$2({}, childProps.style, style),
          className: classes,
          ref: _this2.props.innerRef
        }), children);
      });
    };

    return Collapse;
  }(react_2);

  Collapse.propTypes = propTypes$16;
  Collapse.defaultProps = defaultProps$16;

  var propTypes$17 = {
    tag: tagPropType,
    active: propTypes.bool,
    disabled: propTypes.bool,
    color: propTypes.string,
    action: propTypes.bool,
    className: propTypes.any,
    cssModule: propTypes.object
  };
  var defaultProps$17 = {
    tag: 'li'
  };

  var handleDisabledOnClick = function handleDisabledOnClick(e) {
    e.preventDefault();
  };

  var ListGroupItem = function ListGroupItem(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        active = props.active,
        disabled = props.disabled,
        action = props.action,
        color = props.color,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag", "active", "disabled", "action", "color"]);

    var classes = mapToCssModules(classnames(className, active ? 'active' : false, disabled ? 'disabled' : false, action ? 'list-group-item-action' : false, color ? "list-group-item-" + color : false, 'list-group-item'), cssModule); // Prevent click event when disabled.

    if (disabled) {
      attributes.onClick = handleDisabledOnClick;
    }

    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  ListGroupItem.propTypes = propTypes$17;
  ListGroupItem.defaultProps = defaultProps$17;

  var propTypes$18 = {
    tag: tagPropType,
    className: propTypes.any,
    cssModule: propTypes.object
  };
  var defaultProps$18 = {
    tag: 'h5'
  };

  var ListGroupItemHeading = function ListGroupItemHeading(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'list-group-item-heading'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  ListGroupItemHeading.propTypes = propTypes$18;
  ListGroupItemHeading.defaultProps = defaultProps$18;

  var propTypes$19 = {
    tag: tagPropType,
    className: propTypes.any,
    cssModule: propTypes.object
  };
  var defaultProps$19 = {
    tag: 'p'
  };

  var ListGroupItemText = function ListGroupItemText(props) {
    var className = props.className,
        cssModule = props.cssModule,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "tag"]);

    var classes = mapToCssModules(classnames(className, 'list-group-item-text'), cssModule);
    return react.createElement(Tag, _extends$9({}, attributes, {
      className: classes
    }));
  };

  ListGroupItemText.propTypes = propTypes$19;
  ListGroupItemText.defaultProps = defaultProps$19;

  var UncontrolledAlert =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(UncontrolledAlert, _Component);

    function UncontrolledAlert(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.state = {
        isOpen: true
      };
      _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = UncontrolledAlert.prototype;

    _proto.toggle = function toggle() {
      this.setState({
        isOpen: !this.state.isOpen
      });
    };

    _proto.render = function render() {
      return react.createElement(Alert, _extends$9({
        isOpen: this.state.isOpen,
        toggle: this.toggle
      }, this.props));
    };

    return UncontrolledAlert;
  }(react_2);

  var omitKeys$1 = ['defaultOpen'];

  var UncontrolledButtonDropdown =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(UncontrolledButtonDropdown, _Component);

    function UncontrolledButtonDropdown(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.state = {
        isOpen: props.defaultOpen || false
      };
      _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = UncontrolledButtonDropdown.prototype;

    _proto.toggle = function toggle() {
      this.setState({
        isOpen: !this.state.isOpen
      });
    };

    _proto.render = function render() {
      return react.createElement(ButtonDropdown, _extends$9({
        isOpen: this.state.isOpen,
        toggle: this.toggle
      }, omit(this.props, omitKeys$1)));
    };

    return UncontrolledButtonDropdown;
  }(react_2);
  UncontrolledButtonDropdown.propTypes = _objectSpread$2({
    defaultOpen: propTypes.bool
  }, ButtonDropdown.propTypes);

  var omitKeys$2 = ['toggleEvents', 'defaultOpen'];
  var propTypes$1a = {
    defaultOpen: propTypes.bool,
    toggler: propTypes.string.isRequired,
    toggleEvents: propTypes.arrayOf(propTypes.string)
  };
  var defaultProps$1a = {
    toggleEvents: defaultToggleEvents
  };

  var UncontrolledCollapse =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(UncontrolledCollapse, _Component);

    function UncontrolledCollapse(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.togglers = null;
      _this.removeEventListeners = null;
      _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));
      _this.state = {
        isOpen: props.defaultOpen || false
      };
      return _this;
    }

    var _proto = UncontrolledCollapse.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.togglers = findDOMElements(this.props.toggler);

      if (this.togglers.length) {
        this.removeEventListeners = addMultipleEventListeners(this.togglers, this.toggle, this.props.toggleEvents);
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.togglers.length && this.removeEventListeners) {
        this.removeEventListeners();
      }
    };

    _proto.toggle = function toggle(e) {
      this.setState(function (_ref) {
        var isOpen = _ref.isOpen;
        return {
          isOpen: !isOpen
        };
      });
      e.preventDefault();
    };

    _proto.render = function render() {
      return react.createElement(Collapse, _extends$9({
        isOpen: this.state.isOpen
      }, omit(this.props, omitKeys$2)));
    };

    return UncontrolledCollapse;
  }(react_2);

  UncontrolledCollapse.propTypes = propTypes$1a;
  UncontrolledCollapse.defaultProps = defaultProps$1a;

  var omitKeys$3 = ['defaultOpen'];

  var UncontrolledDropdown =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(UncontrolledDropdown, _Component);

    function UncontrolledDropdown(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.state = {
        isOpen: props.defaultOpen || false
      };
      _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = UncontrolledDropdown.prototype;

    _proto.toggle = function toggle() {
      this.setState({
        isOpen: !this.state.isOpen
      });
    };

    _proto.render = function render() {
      return react.createElement(Dropdown$1, _extends$9({
        isOpen: this.state.isOpen,
        toggle: this.toggle
      }, omit(this.props, omitKeys$3)));
    };

    return UncontrolledDropdown;
  }(react_2);
  UncontrolledDropdown.propTypes = _objectSpread$2({
    defaultOpen: propTypes.bool
  }, Dropdown$1.propTypes);

  var omitKeys$4 = ['defaultOpen'];

  var UncontrolledTooltip =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(UncontrolledTooltip, _Component);

    function UncontrolledTooltip(props) {
      var _this;

      _this = _Component.call(this, props) || this;
      _this.state = {
        isOpen: props.defaultOpen || false
      };
      _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));
      return _this;
    }

    var _proto = UncontrolledTooltip.prototype;

    _proto.toggle = function toggle() {
      this.setState({
        isOpen: !this.state.isOpen
      });
    };

    _proto.render = function render() {
      return react.createElement(Tooltip, _extends$9({
        isOpen: this.state.isOpen,
        toggle: this.toggle
      }, omit(this.props, omitKeys$4)));
    };

    return UncontrolledTooltip;
  }(react_2);
  UncontrolledTooltip.propTypes = _objectSpread$2({
    defaultOpen: propTypes.bool
  }, Tooltip.propTypes);

  var propTypes$1b = {
    tag: tagPropType,
    type: propTypes.string,
    size: propTypes.string,
    color: propTypes.string,
    className: propTypes.string,
    cssModule: propTypes.object,
    children: propTypes.string
  };
  var defaultProps$1b = {
    tag: 'div',
    type: 'border',
    children: 'Loading...'
  };

  var Spinner = function Spinner(props) {
    var className = props.className,
        cssModule = props.cssModule,
        type = props.type,
        size = props.size,
        color = props.color,
        children = props.children,
        Tag = props.tag,
        attributes = _objectWithoutPropertiesLoose(props, ["className", "cssModule", "type", "size", "color", "children", "tag"]);

    var classes = mapToCssModules(classnames(className, size ? "spinner-" + type + "-" + size : false, "spinner-" + type, color ? "text-" + color : false), cssModule);
    return react.createElement(Tag, _extends$9({
      role: "status"
    }, attributes, {
      className: classes
    }), children && react.createElement("span", {
      className: mapToCssModules('sr-only', cssModule)
    }, children));
  };

  Spinner.propTypes = propTypes$1b;
  Spinner.defaultProps = defaultProps$1b;



  var index$4 = /*#__PURE__*/Object.freeze({
    Container: Container$2,
    Row: Row,
    Col: Col,
    Navbar: Navbar,
    NavbarBrand: NavbarBrand$1,
    NavbarToggler: NavbarToggler$1,
    Nav: Nav$1,
    NavItem: NavItem$1,
    NavLink: NavLink,
    Breadcrumb: Breadcrumb$1,
    BreadcrumbItem: BreadcrumbItem$1,
    Button: Button$1,
    ButtonDropdown: ButtonDropdown,
    ButtonGroup: ButtonGroup,
    ButtonToolbar: ButtonToolbar,
    Dropdown: Dropdown$1,
    DropdownItem: DropdownItem$1,
    DropdownMenu: DropdownMenu$1,
    DropdownToggle: DropdownToggle$1,
    Fade: Fade,
    Badge: Badge,
    Card: Card,
    CardGroup: CardGroup,
    CardDeck: CardDeck,
    CardColumns: CardColumns,
    CardBody: CardBody,
    CardLink: CardLink,
    CardFooter: CardFooter,
    CardHeader: CardHeader,
    CardImg: CardImg,
    CardImgOverlay: CardImgOverlay,
    Carousel: Carousel,
    UncontrolledCarousel: UncontrolledCarousel,
    CarouselControl: CarouselControl,
    CarouselItem: CarouselItem,
    CarouselIndicators: CarouselIndicators,
    CarouselCaption: CarouselCaption,
    CardSubtitle: CardSubtitle,
    CardText: CardText,
    CardTitle: CardTitle,
    CustomInput: CustomInput,
    PopperContent: PopperContent,
    PopperTargetHelper: PopperTargetHelper,
    Popover: Popover$1,
    UncontrolledPopover: UncontrolledPopover,
    PopoverHeader: PopoverHeader,
    PopoverBody: PopoverBody,
    Progress: Progress,
    Modal: Modal,
    ModalHeader: ModalHeader,
    ModalBody: ModalBody,
    ModalFooter: ModalFooter,
    Tooltip: Tooltip,
    Table: Table$2,
    ListGroup: ListGroup,
    Form: Form,
    FormFeedback: FormFeedback,
    FormGroup: FormGroup,
    FormText: FormText,
    Input: Input,
    InputGroup: InputGroup,
    InputGroupAddon: InputGroupAddon,
    InputGroupButtonDropdown: InputGroupButtonDropdown,
    InputGroupText: InputGroupText,
    Label: Label,
    Media: Media,
    Pagination: Pagination$2,
    PaginationItem: PaginationItem$1,
    PaginationLink: PaginationLink$1,
    TabContent: TabContent,
    TabPane: TabPane,
    Jumbotron: Jumbotron,
    Alert: Alert,
    Toast: Toast,
    ToastBody: ToastBody,
    ToastHeader: ToastHeader,
    Collapse: Collapse,
    ListGroupItem: ListGroupItem,
    ListGroupItemHeading: ListGroupItemHeading,
    ListGroupItemText: ListGroupItemText,
    UncontrolledAlert: UncontrolledAlert,
    UncontrolledButtonDropdown: UncontrolledButtonDropdown,
    UncontrolledCollapse: UncontrolledCollapse,
    UncontrolledDropdown: UncontrolledDropdown,
    UncontrolledTooltip: UncontrolledTooltip,
    Spinner: Spinner,
    Util: utils
  });

  var TransitionGroupContext = react.createContext(null);

  var UNMOUNTED = 'unmounted';
  var EXITED = 'exited';
  var ENTERING = 'entering';
  var ENTERED = 'entered';
  var EXITING = 'exiting';
  /**
   * The Transition component lets you describe a transition from one component
   * state to another _over time_ with a simple declarative API. Most commonly
   * it's used to animate the mounting and unmounting of a component, but can also
   * be used to describe in-place transition states as well.
   *
   * ---
   *
   * **Note**: `Transition` is a platform-agnostic base component. If you're using
   * transitions in CSS, you'll probably want to use
   * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
   * instead. It inherits all the features of `Transition`, but contains
   * additional features necessary to play nice with CSS transitions (hence the
   * name of the component).
   *
   * ---
   *
   * By default the `Transition` component does not alter the behavior of the
   * component it renders, it only tracks "enter" and "exit" states for the
   * components. It's up to you to give meaning and effect to those states. For
   * example we can add styles to a component when it enters or exits:
   *
   * ```jsx
   * import { Transition } from 'react-transition-group';
   *
   * const duration = 300;
   *
   * const defaultStyle = {
   *   transition: `opacity ${duration}ms ease-in-out`,
   *   opacity: 0,
   * }
   *
   * const transitionStyles = {
   *   entering: { opacity: 1 },
   *   entered:  { opacity: 1 },
   *   exiting:  { opacity: 0 },
   *   exited:  { opacity: 0 },
   * };
   *
   * const Fade = ({ in: inProp }) => (
   *   <Transition in={inProp} timeout={duration}>
   *     {state => (
   *       <div style={{
   *         ...defaultStyle,
   *         ...transitionStyles[state]
   *       }}>
   *         I'm a fade Transition!
   *       </div>
   *     )}
   *   </Transition>
   * );
   * ```
   *
   * There are 4 main states a Transition can be in:
   *  - `'entering'`
   *  - `'entered'`
   *  - `'exiting'`
   *  - `'exited'`
   *
   * Transition state is toggled via the `in` prop. When `true` the component
   * begins the "Enter" stage. During this stage, the component will shift from
   * its current transition state, to `'entering'` for the duration of the
   * transition and then to the `'entered'` stage once it's complete. Let's take
   * the following example (we'll use the
   * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
   *
   * ```jsx
   * function App() {
   *   const [inProp, setInProp] = useState(false);
   *   return (
   *     <div>
   *       <Transition in={inProp} timeout={500}>
   *         {state => (
   *           // ...
   *         )}
   *       </Transition>
   *       <button onClick={() => setInProp(true)}>
   *         Click to Enter
   *       </button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the button is clicked the component will shift to the `'entering'` state
   * and stay there for 500ms (the value of `timeout`) before it finally switches
   * to `'entered'`.
   *
   * When `in` is `false` the same thing happens except the state moves from
   * `'exiting'` to `'exited'`.
   */

  var Transition =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Transition, _React$Component);

    function Transition(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;

      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }

      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }

    Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;

      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }

      return null;
    }; // getSnapshotBeforeUpdate(prevProps) {
    //   let nextStatus = null
    //   if (prevProps !== this.props) {
    //     const { status } = this.state
    //     if (this.props.in) {
    //       if (status !== ENTERING && status !== ENTERED) {
    //         nextStatus = ENTERING
    //       }
    //     } else {
    //       if (status === ENTERING || status === ENTERED) {
    //         nextStatus = EXITING
    //       }
    //     }
    //   }
    //   return { nextStatus }
    // }


    var _proto = Transition.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;

      if (prevProps !== this.props) {
        var status = this.state.status;

        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }

      this.updateStatus(false, nextStatus);
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };

    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;

      if (timeout != null && typeof timeout !== 'number') {
        exit = timeout.exit;
        enter = timeout.enter; // TODO: remove fallback for next major

        appear = timeout.appear !== undefined ? timeout.appear : enter;
      }

      return {
        exit: exit,
        enter: enter,
        appear: appear
      };
    };

    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }

      if (nextStatus !== null) {
        // nextStatus will always be ENTERING or EXITING.
        this.cancelNextCallback();
        var node = reactDom.findDOMNode(this);

        if (nextStatus === ENTERING) {
          this.performEnter(node, mounting);
        } else {
          this.performExit(node);
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };

    _proto.performEnter = function performEnter(node, mounting) {
      var _this2 = this;

      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
      // if we are mounting and running this it means appear _must_ be set

      if (!mounting && !enter) {
        this.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(node);
        });
        return;
      }

      this.props.onEnter(node, appearing);
      this.safeSetState({
        status: ENTERING
      }, function () {
        _this2.props.onEntering(node, appearing);

        _this2.onTransitionEnd(node, enterTimeout, function () {
          _this2.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(node, appearing);
          });
        });
      });
    };

    _proto.performExit = function performExit(node) {
      var _this3 = this;

      var exit = this.props.exit;
      var timeouts = this.getTimeouts(); // no exit animation skip right to EXITED

      if (!exit) {
        this.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(node);
        });
        return;
      }

      this.props.onExit(node);
      this.safeSetState({
        status: EXITING
      }, function () {
        _this3.props.onExiting(node);

        _this3.onTransitionEnd(node, timeouts.exit, function () {
          _this3.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(node);
          });
        });
      });
    };

    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };

    _proto.safeSetState = function safeSetState(nextState, callback) {
      // This shouldn't be necessary, but there are weird race conditions with
      // setState callbacks and unmounting in testing, so always make sure that
      // we can cancel any pending setState callbacks after we unmount.
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };

    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;

      var active = true;

      this.nextCallback = function (event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };

      this.nextCallback.cancel = function () {
        active = false;
      };

      return this.nextCallback;
    };

    _proto.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {
      this.setNextCallback(handler);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }

      if (this.props.addEndListener) {
        this.props.addEndListener(node, this.nextCallback);
      }

      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };

    _proto.render = function render() {
      var status = this.state.status;

      if (status === UNMOUNTED) {
        return null;
      }

      var _this$props = this.props,
          children = _this$props.children,
          childProps = _objectWithoutPropertiesLoose(_this$props, ["children"]); // filter props for Transtition


      delete childProps.in;
      delete childProps.mountOnEnter;
      delete childProps.unmountOnExit;
      delete childProps.appear;
      delete childProps.enter;
      delete childProps.exit;
      delete childProps.timeout;
      delete childProps.addEndListener;
      delete childProps.onEnter;
      delete childProps.onEntering;
      delete childProps.onEntered;
      delete childProps.onExit;
      delete childProps.onExiting;
      delete childProps.onExited;

      if (typeof children === 'function') {
        // allows for nested Transitions
        return react.createElement(TransitionGroupContext.Provider, {
          value: null
        }, children(status, childProps));
      }

      var child = react.Children.only(children);
      return (// allows for nested Transitions
        react.createElement(TransitionGroupContext.Provider, {
          value: null
        }, react.cloneElement(child, childProps))
      );
    };

    return Transition;
  }(react.Component);

  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = {};

  function noop$2() {}

  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
  };
  Transition.UNMOUNTED = 0;
  Transition.EXITED = 1;
  Transition.ENTERING = 2;
  Transition.ENTERED = 3;
  Transition.EXITING = 4;

  var _addClass = function addClass(node, classes) {
    return node && classes && classes.split(' ').forEach(function (c) {
      return addOneClass(node, c);
    });
  };

  var removeClass$1 = function removeClass$1(node, classes) {
    return node && classes && classes.split(' ').forEach(function (c) {
      return removeClass(node, c);
    });
  };
  /**
   * A transition component inspired by the excellent
   * [ng-animate](http://www.nganimate.org/) library, you should use it if you're
   * using CSS transitions or animations. It's built upon the
   * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
   * component, so it inherits all of its props.
   *
   * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
   * and `exit` states of the transition. The first class is applied and then a
   * second `*-active` class in order to activate the CSSS transition. After the
   * transition, matching `*-done` class names are applied to persist the
   * transition state.
   *
   * ```jsx
   * function App() {
   *   const [inProp, setInProp] = useState(false);
   *   return (
   *     <div>
   *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
   *         <div>
   *           {"I'll receive my-node-* classes"}
   *         </div>
   *       </CSSTransition>
   *       <button type="button" onClick={() => setInProp(true)}>
   *         Click to Enter
   *       </button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the `in` prop is set to `true`, the child component will first receive
   * the class `example-enter`, then the `example-enter-active` will be added in
   * the next tick. `CSSTransition` [forces a
   * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
   * between before adding the `example-enter-active`. This is an important trick
   * because it allows us to transition between `example-enter` and
   * `example-enter-active` even though they were added immediately one after
   * another. Most notably, this is what makes it possible for us to animate
   * _appearance_.
   *
   * ```css
   * .my-node-enter {
   *   opacity: 0;
   * }
   * .my-node-enter-active {
   *   opacity: 1;
   *   transition: opacity 200ms;
   * }
   * .my-node-exit {
   *   opacity: 1;
   * }
   * .my-node-exit-active {
   *   opacity: 0;
   *   transition: opacity 200ms;
   * }
   * ```
   *
   * `*-active` classes represent which styles you want to animate **to**.
   */


  var CSSTransition =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(CSSTransition, _React$Component);

    function CSSTransition() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };

      _this.onEnter = function (node, appearing) {
        _this.removeClasses(node, 'exit');

        _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

        if (_this.props.onEnter) {
          _this.props.onEnter(node, appearing);
        }
      };

      _this.onEntering = function (node, appearing) {
        var type = appearing ? 'appear' : 'enter';

        _this.addClass(node, type, 'active');

        if (_this.props.onEntering) {
          _this.props.onEntering(node, appearing);
        }
      };

      _this.onEntered = function (node, appearing) {
        var type = appearing ? 'appear' : 'enter';

        _this.removeClasses(node, type);

        _this.addClass(node, type, 'done');

        if (_this.props.onEntered) {
          _this.props.onEntered(node, appearing);
        }
      };

      _this.onExit = function (node) {
        _this.removeClasses(node, 'appear');

        _this.removeClasses(node, 'enter');

        _this.addClass(node, 'exit', 'base');

        if (_this.props.onExit) {
          _this.props.onExit(node);
        }
      };

      _this.onExiting = function (node) {
        _this.addClass(node, 'exit', 'active');

        if (_this.props.onExiting) {
          _this.props.onExiting(node);
        }
      };

      _this.onExited = function (node) {
        _this.removeClasses(node, 'exit');

        _this.addClass(node, 'exit', 'done');

        if (_this.props.onExited) {
          _this.props.onExited(node);
        }
      };

      _this.getClassNames = function (type) {
        var classNames = _this.props.classNames;
        var isStringClassNames = typeof classNames === 'string';
        var prefix = isStringClassNames && classNames ? classNames + "-" : '';
        var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
        return {
          baseClassName: baseClassName,
          activeClassName: activeClassName,
          doneClassName: doneClassName
        };
      };

      return _this;
    }

    var _proto = CSSTransition.prototype;

    _proto.addClass = function addClass(node, type, phase) {
      var className = this.getClassNames(type)[phase + "ClassName"];

      if (type === 'appear' && phase === 'done') {
        className += " " + this.getClassNames('enter').doneClassName;
      } // This is for to force a repaint,
      // which is necessary in order to transition styles when adding a class name.


      if (phase === 'active') {
        /* eslint-disable no-unused-expressions */
        node && node.scrollTop;
      }

      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    };

    _proto.removeClasses = function removeClasses(node, type) {
      var _this$appliedClasses$ = this.appliedClasses[type],
          baseClassName = _this$appliedClasses$.base,
          activeClassName = _this$appliedClasses$.active,
          doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type] = {};

      if (baseClassName) {
        removeClass$1(node, baseClassName);
      }

      if (activeClassName) {
        removeClass$1(node, activeClassName);
      }

      if (doneClassName) {
        removeClass$1(node, doneClassName);
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          _ = _this$props.classNames,
          props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);

      return react.createElement(Transition, _extends$9({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };

    return CSSTransition;
  }(react.Component);

  CSSTransition.defaultProps = {
    classNames: ''
  };
  CSSTransition.propTypes = {};

  /**
   * Given `this.props.children`, return an object mapping key to child.
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */

  function getChildMapping(children, mapFn) {
    var mapper = function mapper(child) {
      return mapFn && react_13(child) ? mapFn(child) : child;
    };

    var result = Object.create(null);
    if (children) react_1.map(children, function (c) {
      return c;
    }).forEach(function (child) {
      // run the map function here instead so that the key is the computed one
      result[child.key] = mapper(child);
    });
    return result;
  }
  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */

  function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      return key in next ? next[key] : prev[key];
    } // For each key of `next`, the list of keys to insert before that key in
    // the combined list


    var nextKeysPending = Object.create(null);
    var pendingKeys = [];

    for (var prevKey in prev) {
      if (prevKey in next) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};

    for (var nextKey in next) {
      if (nextKeysPending[nextKey]) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }

      childMapping[nextKey] = getValueForKey(nextKey);
    } // Finally, add the keys which didn't appear before any key in `next`


    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }

  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }

  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function (child) {
      return react_7(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, 'appear', props),
        enter: getProp(child, 'enter', props),
        exit: getProp(child, 'exit', props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function (key) {
      var child = children[key];
      if (!react_13(child)) return;
      var hasPrev = key in prevChildMapping;
      var hasNext = key in nextChildMapping;
      var prevChild = prevChildMapping[key];
      var isLeaving = react_13(prevChild) && !prevChild.props.in; // item is new (entering)

      if (hasNext && (!hasPrev || isLeaving)) {
        // console.log('entering', key)
        children[key] = react_7(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        // item is old (exiting)
        // console.log('leaving', key)
        children[key] = react_7(child, {
          in: false
        });
      } else if (hasNext && hasPrev && react_13(prevChild)) {
        // item hasn't changed transition states
        // copy over the last transition props;
        // console.log('unchanged', key)
        children[key] = react_7(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      }
    });
    return children;
  }

  var values = Object.values || function (obj) {
    return Object.keys(obj).map(function (k) {
      return obj[k];
    });
  };

  var defaultProps$1c = {
    component: 'div',
    childFactory: function childFactory(child) {
      return child;
    }
    /**
     * The `<TransitionGroup>` component manages a set of transition components
     * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
     * components, `<TransitionGroup>` is a state machine for managing the mounting
     * and unmounting of components over time.
     *
     * Consider the example below. As items are removed or added to the TodoList the
     * `in` prop is toggled automatically by the `<TransitionGroup>`.
     *
     * Note that `<TransitionGroup>`  does not define any animation behavior!
     * Exactly _how_ a list item animates is up to the individual transition
     * component. This means you can mix and match animations across different list
     * items.
     */

  };

  var TransitionGroup =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(TransitionGroup, _React$Component);

    function TransitionGroup(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;

      var handleExited = _this.handleExited.bind(_assertThisInitialized(_assertThisInitialized(_this))); // Initial children should all be entering, dependent on appear


      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited: handleExited,
        firstRender: true
      };
      return _this;
    }

    var _proto = TransitionGroup.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };

    TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children,
          handleExited = _ref.handleExited,
          firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };

    _proto.handleExited = function handleExited(child, node) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping) return;

      if (child.props.onExited) {
        child.props.onExited(node);
      }

      if (this.mounted) {
        this.setState(function (state) {
          var children = _extends$9({}, state.children);

          delete children[child.key];
          return {
            children: children
          };
        });
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          Component = _this$props.component,
          childFactory = _this$props.childFactory,
          props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

      var contextValue = this.state.contextValue;
      var children = values(this.state.children).map(childFactory);
      delete props.appear;
      delete props.enter;
      delete props.exit;

      if (Component === null) {
        return react.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, children);
      }

      return react.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, react.createElement(Component, props, children));
    };

    return TransitionGroup;
  }(react.Component);

  TransitionGroup.propTypes = {};
  TransitionGroup.defaultProps = defaultProps$1c;

  /**
   * The `<ReplaceTransition>` component is a specialized `Transition` component
   * that animates between two children.
   *
   * ```jsx
   * <ReplaceTransition in>
   *   <Fade><div>I appear first</div></Fade>
   *   <Fade><div>I replace the above</div></Fade>
   * </ReplaceTransition>
   * ```
   */

  var ReplaceTransition =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(ReplaceTransition, _React$Component);

    function ReplaceTransition() {
      var _this;

      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
        _args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

      _this.handleEnter = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return _this.handleLifecycle('onEnter', 0, args);
      };

      _this.handleEntering = function () {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return _this.handleLifecycle('onEntering', 0, args);
      };

      _this.handleEntered = function () {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        return _this.handleLifecycle('onEntered', 0, args);
      };

      _this.handleExit = function () {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        return _this.handleLifecycle('onExit', 1, args);
      };

      _this.handleExiting = function () {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        return _this.handleLifecycle('onExiting', 1, args);
      };

      _this.handleExited = function () {
        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        return _this.handleLifecycle('onExited', 1, args);
      };

      return _this;
    }

    var _proto = ReplaceTransition.prototype;

    _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
      var _child$props;

      var children = this.props.children;
      var child = react.Children.toArray(children)[idx];
      if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
      if (this.props[handler]) this.props[handler](reactDom_2(this));
    };

    _proto.render = function render() {
      var _this$props = this.props,
          children = _this$props.children,
          inProp = _this$props.in,
          props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);

      var _React$Children$toArr = react.Children.toArray(children),
          first = _React$Children$toArr[0],
          second = _React$Children$toArr[1];

      delete props.onEnter;
      delete props.onEntering;
      delete props.onEntered;
      delete props.onExit;
      delete props.onExiting;
      delete props.onExited;
      return react.createElement(TransitionGroup, props, inProp ? react.cloneElement(first, {
        key: 'first',
        onEnter: this.handleEnter,
        onEntering: this.handleEntering,
        onEntered: this.handleEntered
      }) : react.cloneElement(second, {
        key: 'second',
        onEnter: this.handleExit,
        onEntering: this.handleExiting,
        onEntered: this.handleExited
      }));
    };

    return ReplaceTransition;
  }(react.Component);

  ReplaceTransition.propTypes = {};



  var index$5 = /*#__PURE__*/Object.freeze({
    CSSTransition: CSSTransition,
    ReplaceTransition: ReplaceTransition,
    TransitionGroup: TransitionGroup,
    Transition: Transition
  });

  var AutosizeInput_1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
  	value: true
  });

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



  var _react2 = _interopRequireDefault(react);



  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var sizerStyle = {
  	position: 'absolute',
  	top: 0,
  	left: 0,
  	visibility: 'hidden',
  	height: 0,
  	overflow: 'scroll',
  	whiteSpace: 'pre'
  };

  var INPUT_PROPS_BLACKLIST = ['extraWidth', 'injectStyles', 'inputClassName', 'inputRef', 'inputStyle', 'minWidth', 'onAutosize', 'placeholderIsMinWidth'];

  var cleanInputProps = function cleanInputProps(inputProps) {
  	INPUT_PROPS_BLACKLIST.forEach(function (field) {
  		return delete inputProps[field];
  	});
  	return inputProps;
  };

  var copyStyles = function copyStyles(styles, node) {
  	node.style.fontSize = styles.fontSize;
  	node.style.fontFamily = styles.fontFamily;
  	node.style.fontWeight = styles.fontWeight;
  	node.style.fontStyle = styles.fontStyle;
  	node.style.letterSpacing = styles.letterSpacing;
  	node.style.textTransform = styles.textTransform;
  };

  var isIE = typeof window !== 'undefined' && window.navigator ? /MSIE |Trident\/|Edge\//.test(window.navigator.userAgent) : false;

  var generateId = function generateId() {
  	// we only need an auto-generated ID for stylesheet injection, which is only
  	// used for IE. so if the browser is not IE, this should return undefined.
  	return isIE ? '_' + Math.random().toString(36).substr(2, 12) : undefined;
  };

  var AutosizeInput = function (_Component) {
  	_inherits(AutosizeInput, _Component);

  	function AutosizeInput(props) {
  		_classCallCheck(this, AutosizeInput);

  		var _this = _possibleConstructorReturn(this, (AutosizeInput.__proto__ || Object.getPrototypeOf(AutosizeInput)).call(this, props));

  		_this.inputRef = function (el) {
  			_this.input = el;
  			if (typeof _this.props.inputRef === 'function') {
  				_this.props.inputRef(el);
  			}
  		};

  		_this.placeHolderSizerRef = function (el) {
  			_this.placeHolderSizer = el;
  		};

  		_this.sizerRef = function (el) {
  			_this.sizer = el;
  		};

  		_this.state = {
  			inputWidth: props.minWidth,
  			inputId: props.id || generateId()
  		};
  		return _this;
  	}

  	_createClass(AutosizeInput, [{
  		key: 'componentDidMount',
  		value: function componentDidMount() {
  			this.mounted = true;
  			this.copyInputStyles();
  			this.updateInputWidth();
  		}
  	}, {
  		key: 'componentWillReceiveProps',
  		value: function componentWillReceiveProps(nextProps) {
  			var id = nextProps.id;

  			if (id !== this.props.id) {
  				this.setState({ inputId: id || generateId() });
  			}
  		}
  	}, {
  		key: 'componentDidUpdate',
  		value: function componentDidUpdate(prevProps, prevState) {
  			if (prevState.inputWidth !== this.state.inputWidth) {
  				if (typeof this.props.onAutosize === 'function') {
  					this.props.onAutosize(this.state.inputWidth);
  				}
  			}
  			this.updateInputWidth();
  		}
  	}, {
  		key: 'componentWillUnmount',
  		value: function componentWillUnmount() {
  			this.mounted = false;
  		}
  	}, {
  		key: 'copyInputStyles',
  		value: function copyInputStyles() {
  			if (!this.mounted || !window.getComputedStyle) {
  				return;
  			}
  			var inputStyles = this.input && window.getComputedStyle(this.input);
  			if (!inputStyles) {
  				return;
  			}
  			copyStyles(inputStyles, this.sizer);
  			if (this.placeHolderSizer) {
  				copyStyles(inputStyles, this.placeHolderSizer);
  			}
  		}
  	}, {
  		key: 'updateInputWidth',
  		value: function updateInputWidth() {
  			if (!this.mounted || !this.sizer || typeof this.sizer.scrollWidth === 'undefined') {
  				return;
  			}
  			var newInputWidth = void 0;
  			if (this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth)) {
  				newInputWidth = Math.max(this.sizer.scrollWidth, this.placeHolderSizer.scrollWidth) + 2;
  			} else {
  				newInputWidth = this.sizer.scrollWidth + 2;
  			}
  			// add extraWidth to the detected width. for number types, this defaults to 16 to allow for the stepper UI
  			var extraWidth = this.props.type === 'number' && this.props.extraWidth === undefined ? 16 : parseInt(this.props.extraWidth) || 0;
  			newInputWidth += extraWidth;
  			if (newInputWidth < this.props.minWidth) {
  				newInputWidth = this.props.minWidth;
  			}
  			if (newInputWidth !== this.state.inputWidth) {
  				this.setState({
  					inputWidth: newInputWidth
  				});
  			}
  		}
  	}, {
  		key: 'getInput',
  		value: function getInput() {
  			return this.input;
  		}
  	}, {
  		key: 'focus',
  		value: function focus() {
  			this.input.focus();
  		}
  	}, {
  		key: 'blur',
  		value: function blur() {
  			this.input.blur();
  		}
  	}, {
  		key: 'select',
  		value: function select() {
  			this.input.select();
  		}
  	}, {
  		key: 'renderStyles',
  		value: function renderStyles() {
  			// this method injects styles to hide IE's clear indicator, which messes
  			// with input size detection. the stylesheet is only injected when the
  			// browser is IE, and can also be disabled by the `injectStyles` prop.
  			var injectStyles = this.props.injectStyles;

  			return isIE && injectStyles ? _react2.default.createElement('style', { dangerouslySetInnerHTML: {
  					__html: 'input#' + this.state.inputId + '::-ms-clear {display: none;}'
  				} }) : null;
  		}
  	}, {
  		key: 'render',
  		value: function render() {
  			var sizerValue = [this.props.defaultValue, this.props.value, ''].reduce(function (previousValue, currentValue) {
  				if (previousValue !== null && previousValue !== undefined) {
  					return previousValue;
  				}
  				return currentValue;
  			});

  			var wrapperStyle = _extends({}, this.props.style);
  			if (!wrapperStyle.display) wrapperStyle.display = 'inline-block';

  			var inputStyle = _extends({
  				boxSizing: 'content-box',
  				width: this.state.inputWidth + 'px'
  			}, this.props.inputStyle);

  			var inputProps = _objectWithoutProperties(this.props, []);

  			cleanInputProps(inputProps);
  			inputProps.className = this.props.inputClassName;
  			inputProps.id = this.state.inputId;
  			inputProps.style = inputStyle;

  			return _react2.default.createElement(
  				'div',
  				{ className: this.props.className, style: wrapperStyle },
  				this.renderStyles(),
  				_react2.default.createElement('input', _extends({}, inputProps, { ref: this.inputRef })),
  				_react2.default.createElement(
  					'div',
  					{ ref: this.sizerRef, style: sizerStyle },
  					sizerValue
  				),
  				this.props.placeholder ? _react2.default.createElement(
  					'div',
  					{ ref: this.placeHolderSizerRef, style: sizerStyle },
  					this.props.placeholder
  				) : null
  			);
  		}
  	}]);

  	return AutosizeInput;
  }(react.Component);

  AutosizeInput.propTypes = {
  	className: _propTypes2.default.string, // className for the outer element
  	defaultValue: _propTypes2.default.any, // default field value
  	extraWidth: _propTypes2.default.oneOfType([// additional width for input element
  	_propTypes2.default.number, _propTypes2.default.string]),
  	id: _propTypes2.default.string, // id to use for the input, can be set for consistent snapshots
  	injectStyles: _propTypes2.default.bool, // inject the custom stylesheet to hide clear UI, defaults to true
  	inputClassName: _propTypes2.default.string, // className for the input element
  	inputRef: _propTypes2.default.func, // ref callback for the input element
  	inputStyle: _propTypes2.default.object, // css styles for the input element
  	minWidth: _propTypes2.default.oneOfType([// minimum width for input element
  	_propTypes2.default.number, _propTypes2.default.string]),
  	onAutosize: _propTypes2.default.func, // onAutosize handler: function(newWidth) {}
  	onChange: _propTypes2.default.func, // onChange handler: function(event) {}
  	placeholder: _propTypes2.default.string, // placeholder text
  	placeholderIsMinWidth: _propTypes2.default.bool, // don't collapse size to less than the placeholder
  	style: _propTypes2.default.object, // css styles for the outer element
  	value: _propTypes2.default.any // field value
  };
  AutosizeInput.defaultProps = {
  	minWidth: 1,
  	injectStyles: true
  };

  exports.default = AutosizeInput;
  });

  var AutosizeInput = unwrapExports(AutosizeInput_1);

  var propIsEnumerable$1 = Object.prototype.propertyIsEnumerable;

  function ToObject(val) {
  	if (val == null) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}

  	return Object(val);
  }

  function ownEnumerableKeys(obj) {
  	var keys = Object.getOwnPropertyNames(obj);

  	if (Object.getOwnPropertySymbols) {
  		keys = keys.concat(Object.getOwnPropertySymbols(obj));
  	}

  	return keys.filter(function (key) {
  		return propIsEnumerable$1.call(obj, key);
  	});
  }

  var objectAssign$1 = Object.assign || function (target, source) {
  	var from;
  	var keys;
  	var to = ToObject(target);

  	for (var s = 1; s < arguments.length; s++) {
  		from = arguments[s];
  		keys = ownEnumerableKeys(Object(from));

  		for (var i = 0; i < keys.length; i++) {
  			to[keys[i]] = from[keys[i]];
  		}
  	}

  	return to;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */

  var emptyObject = {};

  var emptyObject_1 = emptyObject;

  var MIXINS_KEY = 'mixins';

  // Helper function to allow the creation of anonymous functions which do not
  // have .name set to the name of the variable being assigned to.
  function identity(fn) {
    return fn;
  }

  function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
    /**
     * Policies that describe methods in `ReactClassInterface`.
     */

    var injectedMixins = [];

    /**
     * Composite components are higher-level components that compose other composite
     * or host components.
     *
     * To create a new type of `ReactClass`, pass a specification of
     * your new class to `React.createClass`. The only requirement of your class
     * specification is that you implement a `render` method.
     *
     *   var MyComponent = React.createClass({
     *     render: function() {
     *       return <div>Hello World</div>;
     *     }
     *   });
     *
     * The class specification supports a specific protocol of methods that have
     * special meaning (e.g. `render`). See `ReactClassInterface` for
     * more the comprehensive protocol. Any other properties and methods in the
     * class specification will be available on the prototype.
     *
     * @interface ReactClassInterface
     * @internal
     */
    var ReactClassInterface = {
      /**
       * An array of Mixin objects to include when defining your component.
       *
       * @type {array}
       * @optional
       */
      mixins: 'DEFINE_MANY',

      /**
       * An object containing properties and methods that should be defined on
       * the component's constructor instead of its prototype (static methods).
       *
       * @type {object}
       * @optional
       */
      statics: 'DEFINE_MANY',

      /**
       * Definition of prop types for this component.
       *
       * @type {object}
       * @optional
       */
      propTypes: 'DEFINE_MANY',

      /**
       * Definition of context types for this component.
       *
       * @type {object}
       * @optional
       */
      contextTypes: 'DEFINE_MANY',

      /**
       * Definition of context types this component sets for its children.
       *
       * @type {object}
       * @optional
       */
      childContextTypes: 'DEFINE_MANY',

      // ==== Definition methods ====

      /**
       * Invoked when the component is mounted. Values in the mapping will be set on
       * `this.props` if that prop is not specified (i.e. using an `in` check).
       *
       * This method is invoked before `getInitialState` and therefore cannot rely
       * on `this.state` or use `this.setState`.
       *
       * @return {object}
       * @optional
       */
      getDefaultProps: 'DEFINE_MANY_MERGED',

      /**
       * Invoked once before the component is mounted. The return value will be used
       * as the initial value of `this.state`.
       *
       *   getInitialState: function() {
       *     return {
       *       isOn: false,
       *       fooBaz: new BazFoo()
       *     }
       *   }
       *
       * @return {object}
       * @optional
       */
      getInitialState: 'DEFINE_MANY_MERGED',

      /**
       * @return {object}
       * @optional
       */
      getChildContext: 'DEFINE_MANY_MERGED',

      /**
       * Uses props from `this.props` and state from `this.state` to render the
       * structure of the component.
       *
       * No guarantees are made about when or how often this method is invoked, so
       * it must not have side effects.
       *
       *   render: function() {
       *     var name = this.props.name;
       *     return <div>Hello, {name}!</div>;
       *   }
       *
       * @return {ReactComponent}
       * @required
       */
      render: 'DEFINE_ONCE',

      // ==== Delegate methods ====

      /**
       * Invoked when the component is initially created and about to be mounted.
       * This may have side effects, but any external subscriptions or data created
       * by this method must be cleaned up in `componentWillUnmount`.
       *
       * @optional
       */
      componentWillMount: 'DEFINE_MANY',

      /**
       * Invoked when the component has been mounted and has a DOM representation.
       * However, there is no guarantee that the DOM node is in the document.
       *
       * Use this as an opportunity to operate on the DOM when the component has
       * been mounted (initialized and rendered) for the first time.
       *
       * @param {DOMElement} rootNode DOM element representing the component.
       * @optional
       */
      componentDidMount: 'DEFINE_MANY',

      /**
       * Invoked before the component receives new props.
       *
       * Use this as an opportunity to react to a prop transition by updating the
       * state using `this.setState`. Current props are accessed via `this.props`.
       *
       *   componentWillReceiveProps: function(nextProps, nextContext) {
       *     this.setState({
       *       likesIncreasing: nextProps.likeCount > this.props.likeCount
       *     });
       *   }
       *
       * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
       * transition may cause a state change, but the opposite is not true. If you
       * need it, you are probably looking for `componentWillUpdate`.
       *
       * @param {object} nextProps
       * @optional
       */
      componentWillReceiveProps: 'DEFINE_MANY',

      /**
       * Invoked while deciding if the component should be updated as a result of
       * receiving new props, state and/or context.
       *
       * Use this as an opportunity to `return false` when you're certain that the
       * transition to the new props/state/context will not require a component
       * update.
       *
       *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
       *     return !equal(nextProps, this.props) ||
       *       !equal(nextState, this.state) ||
       *       !equal(nextContext, this.context);
       *   }
       *
       * @param {object} nextProps
       * @param {?object} nextState
       * @param {?object} nextContext
       * @return {boolean} True if the component should update.
       * @optional
       */
      shouldComponentUpdate: 'DEFINE_ONCE',

      /**
       * Invoked when the component is about to update due to a transition from
       * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
       * and `nextContext`.
       *
       * Use this as an opportunity to perform preparation before an update occurs.
       *
       * NOTE: You **cannot** use `this.setState()` in this method.
       *
       * @param {object} nextProps
       * @param {?object} nextState
       * @param {?object} nextContext
       * @param {ReactReconcileTransaction} transaction
       * @optional
       */
      componentWillUpdate: 'DEFINE_MANY',

      /**
       * Invoked when the component's DOM representation has been updated.
       *
       * Use this as an opportunity to operate on the DOM when the component has
       * been updated.
       *
       * @param {object} prevProps
       * @param {?object} prevState
       * @param {?object} prevContext
       * @param {DOMElement} rootNode DOM element representing the component.
       * @optional
       */
      componentDidUpdate: 'DEFINE_MANY',

      /**
       * Invoked when the component is about to be removed from its parent and have
       * its DOM representation destroyed.
       *
       * Use this as an opportunity to deallocate any external resources.
       *
       * NOTE: There is no `componentDidUnmount` since your component will have been
       * destroyed by that point.
       *
       * @optional
       */
      componentWillUnmount: 'DEFINE_MANY',

      /**
       * Replacement for (deprecated) `componentWillMount`.
       *
       * @optional
       */
      UNSAFE_componentWillMount: 'DEFINE_MANY',

      /**
       * Replacement for (deprecated) `componentWillReceiveProps`.
       *
       * @optional
       */
      UNSAFE_componentWillReceiveProps: 'DEFINE_MANY',

      /**
       * Replacement for (deprecated) `componentWillUpdate`.
       *
       * @optional
       */
      UNSAFE_componentWillUpdate: 'DEFINE_MANY',

      // ==== Advanced methods ====

      /**
       * Updates the component's currently mounted DOM representation.
       *
       * By default, this implements React's rendering and reconciliation algorithm.
       * Sophisticated clients may wish to override this.
       *
       * @param {ReactReconcileTransaction} transaction
       * @internal
       * @overridable
       */
      updateComponent: 'OVERRIDE_BASE'
    };

    /**
     * Similar to ReactClassInterface but for static methods.
     */
    var ReactClassStaticInterface = {
      /**
       * This method is invoked after a component is instantiated and when it
       * receives new props. Return an object to update state in response to
       * prop changes. Return null to indicate no change to state.
       *
       * If an object is returned, its keys will be merged into the existing state.
       *
       * @return {object || null}
       * @optional
       */
      getDerivedStateFromProps: 'DEFINE_MANY_MERGED'
    };

    /**
     * Mapping from class specification keys to special processing functions.
     *
     * Although these are declared like instance properties in the specification
     * when defining classes using `React.createClass`, they are actually static
     * and are accessible on the constructor instead of the prototype. Despite
     * being static, they must be defined outside of the "statics" key under
     * which all other static methods are defined.
     */
    var RESERVED_SPEC_KEYS = {
      displayName: function(Constructor, displayName) {
        Constructor.displayName = displayName;
      },
      mixins: function(Constructor, mixins) {
        if (mixins) {
          for (var i = 0; i < mixins.length; i++) {
            mixSpecIntoComponent(Constructor, mixins[i]);
          }
        }
      },
      childContextTypes: function(Constructor, childContextTypes) {
        Constructor.childContextTypes = objectAssign(
          {},
          Constructor.childContextTypes,
          childContextTypes
        );
      },
      contextTypes: function(Constructor, contextTypes) {
        Constructor.contextTypes = objectAssign(
          {},
          Constructor.contextTypes,
          contextTypes
        );
      },
      /**
       * Special case getDefaultProps which should move into statics but requires
       * automatic merging.
       */
      getDefaultProps: function(Constructor, getDefaultProps) {
        if (Constructor.getDefaultProps) {
          Constructor.getDefaultProps = createMergedResultFunction(
            Constructor.getDefaultProps,
            getDefaultProps
          );
        } else {
          Constructor.getDefaultProps = getDefaultProps;
        }
      },
      propTypes: function(Constructor, propTypes) {
        Constructor.propTypes = objectAssign({}, Constructor.propTypes, propTypes);
      },
      statics: function(Constructor, statics) {
        mixStaticSpecIntoComponent(Constructor, statics);
      },
      autobind: function() {}
    };

    function validateMethodOverride(isAlreadyDefined, name) {
      var specPolicy = ReactClassInterface.hasOwnProperty(name)
        ? ReactClassInterface[name]
        : null;

      // Disallow overriding of base class methods unless explicitly allowed.
      if (ReactClassMixin.hasOwnProperty(name)) {
        invariant_1(
          specPolicy === 'OVERRIDE_BASE',
          'ReactClassInterface: You are attempting to override ' +
            '`%s` from your class specification. Ensure that your method names ' +
            'do not overlap with React methods.',
          name
        );
      }

      // Disallow defining methods more than once unless explicitly allowed.
      if (isAlreadyDefined) {
        invariant_1(
          specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
          'ReactClassInterface: You are attempting to define ' +
            '`%s` on your component more than once. This conflict may be due ' +
            'to a mixin.',
          name
        );
      }
    }

    /**
     * Mixin helper which handles policy validation and reserved
     * specification keys when building React classes.
     */
    function mixSpecIntoComponent(Constructor, spec) {
      if (!spec) {

        return;
      }

      invariant_1(
        typeof spec !== 'function',
        "ReactClass: You're attempting to " +
          'use a component class or function as a mixin. Instead, just use a ' +
          'regular object.'
      );
      invariant_1(
        !isValidElement(spec),
        "ReactClass: You're attempting to " +
          'use a component as a mixin. Instead, just use a regular object.'
      );

      var proto = Constructor.prototype;
      var autoBindPairs = proto.__reactAutoBindPairs;

      // By handling mixins before any other properties, we ensure the same
      // chaining order is applied to methods with DEFINE_MANY policy, whether
      // mixins are listed before or after these methods in the spec.
      if (spec.hasOwnProperty(MIXINS_KEY)) {
        RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
      }

      for (var name in spec) {
        if (!spec.hasOwnProperty(name)) {
          continue;
        }

        if (name === MIXINS_KEY) {
          // We have already handled mixins in a special case above.
          continue;
        }

        var property = spec[name];
        var isAlreadyDefined = proto.hasOwnProperty(name);
        validateMethodOverride(isAlreadyDefined, name);

        if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
          RESERVED_SPEC_KEYS[name](Constructor, property);
        } else {
          // Setup methods on prototype:
          // The following member methods should not be automatically bound:
          // 1. Expected ReactClass methods (in the "interface").
          // 2. Overridden methods (that were mixed in).
          var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
          var isFunction = typeof property === 'function';
          var shouldAutoBind =
            isFunction &&
            !isReactClassMethod &&
            !isAlreadyDefined &&
            spec.autobind !== false;

          if (shouldAutoBind) {
            autoBindPairs.push(name, property);
            proto[name] = property;
          } else {
            if (isAlreadyDefined) {
              var specPolicy = ReactClassInterface[name];

              // These cases should already be caught by validateMethodOverride.
              invariant_1(
                isReactClassMethod &&
                  (specPolicy === 'DEFINE_MANY_MERGED' ||
                    specPolicy === 'DEFINE_MANY'),
                'ReactClass: Unexpected spec policy %s for key %s ' +
                  'when mixing in component specs.',
                specPolicy,
                name
              );

              // For methods which are defined more than once, call the existing
              // methods before calling the new property, merging if appropriate.
              if (specPolicy === 'DEFINE_MANY_MERGED') {
                proto[name] = createMergedResultFunction(proto[name], property);
              } else if (specPolicy === 'DEFINE_MANY') {
                proto[name] = createChainedFunction(proto[name], property);
              }
            } else {
              proto[name] = property;
            }
          }
        }
      }
    }

    function mixStaticSpecIntoComponent(Constructor, statics) {
      if (!statics) {
        return;
      }

      for (var name in statics) {
        var property = statics[name];
        if (!statics.hasOwnProperty(name)) {
          continue;
        }

        var isReserved = name in RESERVED_SPEC_KEYS;
        invariant_1(
          !isReserved,
          'ReactClass: You are attempting to define a reserved ' +
            'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
            'as an instance property instead; it will still be accessible on the ' +
            'constructor.',
          name
        );

        var isAlreadyDefined = name in Constructor;
        if (isAlreadyDefined) {
          var specPolicy = ReactClassStaticInterface.hasOwnProperty(name)
            ? ReactClassStaticInterface[name]
            : null;

          invariant_1(
            specPolicy === 'DEFINE_MANY_MERGED',
            'ReactClass: You are attempting to define ' +
              '`%s` on your component more than once. This conflict may be ' +
              'due to a mixin.',
            name
          );

          Constructor[name] = createMergedResultFunction(Constructor[name], property);

          return;
        }

        Constructor[name] = property;
      }
    }

    /**
     * Merge two objects, but throw if both contain the same key.
     *
     * @param {object} one The first object, which is mutated.
     * @param {object} two The second object
     * @return {object} one after it has been mutated to contain everything in two.
     */
    function mergeIntoWithNoDuplicateKeys(one, two) {
      invariant_1(
        one && two && typeof one === 'object' && typeof two === 'object',
        'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
      );

      for (var key in two) {
        if (two.hasOwnProperty(key)) {
          invariant_1(
            one[key] === undefined,
            'mergeIntoWithNoDuplicateKeys(): ' +
              'Tried to merge two objects with the same key: `%s`. This conflict ' +
              'may be due to a mixin; in particular, this may be caused by two ' +
              'getInitialState() or getDefaultProps() methods returning objects ' +
              'with clashing keys.',
            key
          );
          one[key] = two[key];
        }
      }
      return one;
    }

    /**
     * Creates a function that invokes two functions and merges their return values.
     *
     * @param {function} one Function to invoke first.
     * @param {function} two Function to invoke second.
     * @return {function} Function that invokes the two argument functions.
     * @private
     */
    function createMergedResultFunction(one, two) {
      return function mergedResult() {
        var a = one.apply(this, arguments);
        var b = two.apply(this, arguments);
        if (a == null) {
          return b;
        } else if (b == null) {
          return a;
        }
        var c = {};
        mergeIntoWithNoDuplicateKeys(c, a);
        mergeIntoWithNoDuplicateKeys(c, b);
        return c;
      };
    }

    /**
     * Creates a function that invokes two functions and ignores their return vales.
     *
     * @param {function} one Function to invoke first.
     * @param {function} two Function to invoke second.
     * @return {function} Function that invokes the two argument functions.
     * @private
     */
    function createChainedFunction(one, two) {
      return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
      };
    }

    /**
     * Binds a method to the component.
     *
     * @param {object} component Component whose method is going to be bound.
     * @param {function} method Method to be bound.
     * @return {function} The bound method.
     */
    function bindAutoBindMethod(component, method) {
      var boundMethod = method.bind(component);
      return boundMethod;
    }

    /**
     * Binds all auto-bound methods in a component.
     *
     * @param {object} component Component whose method is going to be bound.
     */
    function bindAutoBindMethods(component) {
      var pairs = component.__reactAutoBindPairs;
      for (var i = 0; i < pairs.length; i += 2) {
        var autoBindKey = pairs[i];
        var method = pairs[i + 1];
        component[autoBindKey] = bindAutoBindMethod(component, method);
      }
    }

    var IsMountedPreMixin = {
      componentDidMount: function() {
        this.__isMounted = true;
      }
    };

    var IsMountedPostMixin = {
      componentWillUnmount: function() {
        this.__isMounted = false;
      }
    };

    /**
     * Add more to the ReactClass base class. These are all legacy features and
     * therefore not already part of the modern ReactComponent.
     */
    var ReactClassMixin = {
      /**
       * TODO: This will be deprecated because state should always keep a consistent
       * type signature and the only use case for this, is to avoid that.
       */
      replaceState: function(newState, callback) {
        this.updater.enqueueReplaceState(this, newState, callback);
      },

      /**
       * Checks whether or not this composite component is mounted.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function() {
        return !!this.__isMounted;
      }
    };

    var ReactClassComponent = function() {};
    objectAssign(
      ReactClassComponent.prototype,
      ReactComponent.prototype,
      ReactClassMixin
    );

    /**
     * Creates a composite component class given a class specification.
     * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
     *
     * @param {object} spec Class specification (which must define `render`).
     * @return {function} Component constructor function.
     * @public
     */
    function createClass(spec) {
      // To keep our warnings more understandable, we'll use a little hack here to
      // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
      // unnecessarily identify a class without displayName as 'Constructor'.
      var Constructor = identity(function(props, context, updater) {

        // Wire up auto-binding
        if (this.__reactAutoBindPairs.length) {
          bindAutoBindMethods(this);
        }

        this.props = props;
        this.context = context;
        this.refs = emptyObject_1;
        this.updater = updater || ReactNoopUpdateQueue;

        this.state = null;

        // ReactClasses doesn't have constructors. Instead, they use the
        // getInitialState and componentWillMount methods for initialization.

        var initialState = this.getInitialState ? this.getInitialState() : null;
        invariant_1(
          typeof initialState === 'object' && !Array.isArray(initialState),
          '%s.getInitialState(): must return an object or null',
          Constructor.displayName || 'ReactCompositeComponent'
        );

        this.state = initialState;
      });
      Constructor.prototype = new ReactClassComponent();
      Constructor.prototype.constructor = Constructor;
      Constructor.prototype.__reactAutoBindPairs = [];

      injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

      mixSpecIntoComponent(Constructor, IsMountedPreMixin);
      mixSpecIntoComponent(Constructor, spec);
      mixSpecIntoComponent(Constructor, IsMountedPostMixin);

      // Initialize the defaultProps property after all mixins have been merged.
      if (Constructor.getDefaultProps) {
        Constructor.defaultProps = Constructor.getDefaultProps();
      }

      invariant_1(
        Constructor.prototype.render,
        'createClass(...): Class specification must implement a `render` method.'
      );

      // Reduce time spent doing lookups by setting these on the prototype.
      for (var methodName in ReactClassInterface) {
        if (!Constructor.prototype[methodName]) {
          Constructor.prototype[methodName] = null;
        }
      }

      return Constructor;
    }

    return createClass;
  }

  var factory_1 = factory;

  if (typeof react === 'undefined') {
    throw Error(
      'create-react-class could not find the React object. If you are using script tags, ' +
        'make sure that React is being loaded before create-react-class.'
    );
  }

  // Hack to grab NoopUpdateQueue from isomorphic React
  var ReactNoopUpdateQueue = new react.Component().updater;

  var createReactClass = factory_1(
    react.Component,
    react.isValidElement,
    ReactNoopUpdateQueue
  );

  var moment = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
      module.exports = factory();
  }(commonjsGlobal, (function () {
      var hookCallback;

      function hooks () {
          return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback (callback) {
          hookCallback = callback;
      }

      function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
      }

      function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return input != null && Object.prototype.toString.call(input) === '[object Object]';
      }

      function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
              return (Object.getOwnPropertyNames(obj).length === 0);
          } else {
              var k;
              for (k in obj) {
                  if (obj.hasOwnProperty(k)) {
                      return false;
                  }
              }
              return true;
          }
      }

      function isUndefined(input) {
          return input === void 0;
      }

      function isNumber(input) {
          return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
      }

      function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }

      function map(arr, fn) {
          var res = [], i;
          for (i = 0; i < arr.length; ++i) {
              res.push(fn(arr[i], i));
          }
          return res;
      }

      function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
      }

      function extend(a, b) {
          for (var i in b) {
              if (hasOwnProp(b, i)) {
                  a[i] = b[i];
              }
          }

          if (hasOwnProp(b, 'toString')) {
              a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
              a.valueOf = b.valueOf;
          }

          return a;
      }

      function createUTC (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
              empty           : false,
              unusedTokens    : [],
              unusedInput     : [],
              overflow        : -2,
              charsLeftOver   : 0,
              nullInput       : false,
              invalidMonth    : null,
              invalidFormat   : false,
              userInvalidated : false,
              iso             : false,
              parsedDateParts : [],
              meridiem        : null,
              rfc2822         : false,
              weekdayMismatch : false
          };
      }

      function getParsingFlags(m) {
          if (m._pf == null) {
              m._pf = defaultParsingFlags();
          }
          return m._pf;
      }

      var some;
      if (Array.prototype.some) {
          some = Array.prototype.some;
      } else {
          some = function (fun) {
              var t = Object(this);
              var len = t.length >>> 0;

              for (var i = 0; i < len; i++) {
                  if (i in t && fun.call(this, t[i], i, t)) {
                      return true;
                  }
              }

              return false;
          };
      }

      function isValid(m) {
          if (m._isValid == null) {
              var flags = getParsingFlags(m);
              var parsedParts = some.call(flags.parsedDateParts, function (i) {
                  return i != null;
              });
              var isNowValid = !isNaN(m._d.getTime()) &&
                  flags.overflow < 0 &&
                  !flags.empty &&
                  !flags.invalidMonth &&
                  !flags.invalidWeekday &&
                  !flags.weekdayMismatch &&
                  !flags.nullInput &&
                  !flags.invalidFormat &&
                  !flags.userInvalidated &&
                  (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                  isNowValid = isNowValid &&
                      flags.charsLeftOver === 0 &&
                      flags.unusedTokens.length === 0 &&
                      flags.bigHour === undefined;
              }

              if (Object.isFrozen == null || !Object.isFrozen(m)) {
                  m._isValid = isNowValid;
              }
              else {
                  return isNowValid;
              }
          }
          return m._isValid;
      }

      function createInvalid (flags) {
          var m = createUTC(NaN);
          if (flags != null) {
              extend(getParsingFlags(m), flags);
          }
          else {
              getParsingFlags(m).userInvalidated = true;
          }

          return m;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = hooks.momentProperties = [];

      function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
              to._i = from._i;
          }
          if (!isUndefined(from._f)) {
              to._f = from._f;
          }
          if (!isUndefined(from._l)) {
              to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
              to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
              to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
              to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
              for (i = 0; i < momentProperties.length; i++) {
                  prop = momentProperties[i];
                  val = from[prop];
                  if (!isUndefined(val)) {
                      to[prop] = val;
                  }
              }
          }

          return to;
      }

      var updateInProgress = false;

      // Moment prototype object
      function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
              this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
              updateInProgress = true;
              hooks.updateOffset(this);
              updateInProgress = false;
          }
      }

      function isMoment (obj) {
          return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
      }

      function absFloor (number) {
          if (number < 0) {
              // -0 -> 0
              return Math.ceil(number) || 0;
          } else {
              return Math.floor(number);
          }
      }

      function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
          }

          return value;
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
          for (i = 0; i < len; i++) {
              if ((dontConvert && array1[i] !== array2[i]) ||
                  (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                  diffs++;
              }
          }
          return diffs + lengthDiff;
      }

      function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false &&
                  (typeof console !==  'undefined') && console.warn) {
              console.warn('Deprecation warning: ' + msg);
          }
      }

      function deprecate(msg, fn) {
          var firstTime = true;

          return extend(function () {
              if (hooks.deprecationHandler != null) {
                  hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                  var args = [];
                  var arg;
                  for (var i = 0; i < arguments.length; i++) {
                      arg = '';
                      if (typeof arguments[i] === 'object') {
                          arg += '\n[' + i + '] ';
                          for (var key in arguments[0]) {
                              arg += key + ': ' + arguments[0][key] + ', ';
                          }
                          arg = arg.slice(0, -2); // Remove trailing comma and space
                      } else {
                          arg = arguments[i];
                      }
                      args.push(arg);
                  }
                  warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                  firstTime = false;
              }
              return fn.apply(this, arguments);
          }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
          }
      }

      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;

      function isFunction(input) {
          return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }

      function set (config) {
          var prop, i;
          for (i in config) {
              prop = config[i];
              if (isFunction(prop)) {
                  this[i] = prop;
              } else {
                  this['_' + i] = prop;
              }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp(
              (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                  '|' + (/\d{1,2}/).source);
      }

      function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                  if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                      res[prop] = {};
                      extend(res[prop], parentConfig[prop]);
                      extend(res[prop], childConfig[prop]);
                  } else if (childConfig[prop] != null) {
                      res[prop] = childConfig[prop];
                  } else {
                      delete res[prop];
                  }
              }
          }
          for (prop in parentConfig) {
              if (hasOwnProp(parentConfig, prop) &&
                      !hasOwnProp(childConfig, prop) &&
                      isObject(parentConfig[prop])) {
                  // make sure changes to properties don't modify parent config
                  res[prop] = extend({}, res[prop]);
              }
          }
          return res;
      }

      function Locale(config) {
          if (config != null) {
              this.set(config);
          }
      }

      var keys;

      if (Object.keys) {
          keys = Object.keys;
      } else {
          keys = function (obj) {
              var i, res = [];
              for (i in obj) {
                  if (hasOwnProp(obj, i)) {
                      res.push(i);
                  }
              }
              return res;
          };
      }

      var defaultCalendar = {
          sameDay : '[Today at] LT',
          nextDay : '[Tomorrow at] LT',
          nextWeek : 'dddd [at] LT',
          lastDay : '[Yesterday at] LT',
          lastWeek : '[Last] dddd [at] LT',
          sameElse : 'L'
      };

      function calendar (key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
      }

      var defaultLongDateFormat = {
          LTS  : 'h:mm:ss A',
          LT   : 'h:mm A',
          L    : 'MM/DD/YYYY',
          LL   : 'MMMM D, YYYY',
          LLL  : 'MMMM D, YYYY h:mm A',
          LLLL : 'dddd, MMMM D, YYYY h:mm A'
      };

      function longDateFormat (key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
              return format;
          }

          this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
              return val.slice(1);
          });

          return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate () {
          return this._invalidDate;
      }

      var defaultOrdinal = '%d';
      var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

      function ordinal (number) {
          return this._ordinal.replace('%d', number);
      }

      var defaultRelativeTime = {
          future : 'in %s',
          past   : '%s ago',
          s  : 'a few seconds',
          ss : '%d seconds',
          m  : 'a minute',
          mm : '%d minutes',
          h  : 'an hour',
          hh : '%d hours',
          d  : 'a day',
          dd : '%d days',
          M  : 'a month',
          MM : '%d months',
          y  : 'a year',
          yy : '%d years'
      };

      function relativeTime (number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return (isFunction(output)) ?
              output(number, withoutSuffix, string, isFuture) :
              output.replace(/%d/i, number);
      }

      function pastFuture (diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var aliases = {};

      function addUnitAlias (unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }

      function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                  normalizedProp = normalizeUnits(prop);
                  if (normalizedProp) {
                      normalizedInput[normalizedProp] = inputObject[prop];
                  }
              }
          }

          return normalizedInput;
      }

      var priorities = {};

      function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
      }

      function getPrioritizedUnits(unitsObj) {
          var units = [];
          for (var u in unitsObj) {
              units.push({unit: u, priority: priorities[u]});
          }
          units.sort(function (a, b) {
              return a.priority - b.priority;
          });
          return units;
      }

      function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (sign ? (forceSign ? '+' : '') : '-') +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

      var formatFunctions = {};

      var formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken (token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
              func = function () {
                  return this[callback]();
              };
          }
          if (token) {
              formatTokenFunctions[token] = func;
          }
          if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                  return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
              };
          }
          if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                  return this.localeData().ordinal(func.apply(this, arguments), token);
              };
          }
      }

      function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
          var array = format.match(formattingTokens), i, length;

          for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                  array[i] = formatTokenFunctions[array[i]];
              } else {
                  array[i] = removeFormattingTokens(array[i]);
              }
          }

          return function (mom) {
              var output = '', i;
              for (i = 0; i < length; i++) {
                  output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
              }
              return output;
          };
      }

      // format date using native date object
      function formatMoment(m, format) {
          if (!m.isValid()) {
              return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

          return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
              localFormattingTokens.lastIndex = 0;
              i -= 1;
          }

          return format;
      }

      var match1         = /\d/;            //       0 - 9
      var match2         = /\d\d/;          //      00 - 99
      var match3         = /\d{3}/;         //     000 - 999
      var match4         = /\d{4}/;         //    0000 - 9999
      var match6         = /[+-]?\d{6}/;    // -999999 - 999999
      var match1to2      = /\d\d?/;         //       0 - 99
      var match3to4      = /\d\d\d\d?/;     //     999 - 9999
      var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
      var match1to3      = /\d{1,3}/;       //       0 - 999
      var match1to4      = /\d{1,4}/;       //       0 - 9999
      var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

      var matchUnsigned  = /\d+/;           //       0 - inf
      var matchSigned    = /[+-]?\d+/;      //    -inf - inf

      var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

      // any word (or two) characters or numbers including two/three word month in arabic.
      // includes scottish gaelic two word and hyphenated months
      var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

      var regexes = {};

      function addRegexToken (token, regex, strictRegex) {
          regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
              return (isStrict && strictRegex) ? strictRegex : regex;
          };
      }

      function getParseRegexForToken (token, config) {
          if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
          }));
      }

      function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken (token, callback) {
          var i, func = callback;
          if (typeof token === 'string') {
              token = [token];
          }
          if (isNumber(callback)) {
              func = function (input, array) {
                  array[callback] = toInt(input);
              };
          }
          for (i = 0; i < token.length; i++) {
              tokens[token[i]] = func;
          }
      }

      function addWeekParseToken (token, callback) {
          addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
          });
      }

      function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
          }
      }

      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8;

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? '' + y : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
      });

      addFormatToken(0, ['YYYY',   4],       0, 'year');
      addFormatToken(0, ['YYYYY',  5],       0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PRIORITIES

      addUnitPriority('year', 1);

      // PARSING

      addRegexToken('Y',      matchSigned);
      addRegexToken('YY',     match1to2, match2);
      addRegexToken('YYYY',   match1to4, match4);
      addRegexToken('YYYYY',  match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
      }

      function isLeapYear(year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }

      // HOOKS

      hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear () {
          return isLeapYear(this.year());
      }

      function makeGetSet (unit, keepTime) {
          return function (value) {
              if (value != null) {
                  set$1(this, unit, value);
                  hooks.updateOffset(this, keepTime);
                  return this;
              } else {
                  return get(this, unit);
              }
          };
      }

      function get (mom, unit) {
          return mom.isValid() ?
              mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
      }

      function set$1 (mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
              if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
              }
              else {
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
              }
          }
      }

      // MOMENTS

      function stringGet (units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
              return this[units]();
          }
          return this;
      }


      function stringSet (units, value) {
          if (typeof units === 'object') {
              units = normalizeObjectUnits(units);
              var prioritized = getPrioritizedUnits(units);
              for (var i = 0; i < prioritized.length; i++) {
                  this[prioritized[i].unit](units[prioritized[i].unit]);
              }
          } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units](value);
              }
          }
          return this;
      }

      function mod(n, x) {
          return ((n % x) + x) % x;
      }

      var indexOf;

      if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
      } else {
          indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                  if (this[i] === o) {
                      return i;
                  }
              }
              return -1;
          };
      }

      function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
              return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PRIORITY

      addUnitPriority('month', 8);

      // PARSING

      addRegexToken('M',    match1to2);
      addRegexToken('MM',   match1to2, match2);
      addRegexToken('MMM',  function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
              array[MONTH] = month;
          } else {
              getParsingFlags(config).invalidMonth = input;
          }
      });

      // LOCALES

      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
      function localeMonths (m, format) {
          if (!m) {
              return isArray(this._months) ? this._months :
                  this._months['standalone'];
          }
          return isArray(this._months) ? this._months[m.month()] :
              this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
      }

      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
      function localeMonthsShort (m, format) {
          if (!m) {
              return isArray(this._monthsShort) ? this._monthsShort :
                  this._monthsShort['standalone'];
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
              this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }

      function handleStrictParse(monthName, format, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                  mom = createUTC([2000, i]);
                  this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                  this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeMonthsParse (monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
              return handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                  this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                  this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
              }
              if (!strict && !this._monthsParse[i]) {
                  regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                  this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                  return i;
              } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                  return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function setMonth (mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
              // No op
              return mom;
          }

          if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                  value = toInt(value);
              } else {
                  value = mom.localeData().monthsParse(value);
                  // TODO: Another silent failure?
                  if (!isNumber(value)) {
                      return mom;
                  }
              }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
      }

      function getSetMonth (value) {
          if (value != null) {
              setMonth(this, value);
              hooks.updateOffset(this, true);
              return this;
          } else {
              return get(this, 'Month');
          }
      }

      function getDaysInMonth () {
          return daysInMonth(this.year(), this.month());
      }

      var defaultMonthsShortRegex = matchWord;
      function monthsShortRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsShortStrictRegex;
              } else {
                  return this._monthsShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsShortRegex')) {
                  this._monthsShortRegex = defaultMonthsShortRegex;
              }
              return this._monthsShortStrictRegex && isStrict ?
                  this._monthsShortStrictRegex : this._monthsShortRegex;
          }
      }

      var defaultMonthsRegex = matchWord;
      function monthsRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsStrictRegex;
              } else {
                  return this._monthsRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  this._monthsRegex = defaultMonthsRegex;
              }
              return this._monthsStrictRegex && isStrict ?
                  this._monthsStrictRegex : this._monthsRegex;
          }
      }

      function computeMonthsParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom;
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ''));
              longPieces.push(this.months(mom, ''));
              mixedPieces.push(this.months(mom, ''));
              mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      }

      function createDate (y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date;
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              date = new Date(y + 400, m, d, h, M, s, ms);
              if (isFinite(date.getFullYear())) {
                  date.setFullYear(y);
              }
          } else {
              date = new Date(y, m, d, h, M, s, ms);
          }

          return date;
      }

      function createUTCDate (y) {
          var date;
          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              var args = Array.prototype.slice.call(arguments);
              // preserve leap years using a full 400 year cycle, then reset
              args[0] = y + 400;
              date = new Date(Date.UTC.apply(null, args));
              if (isFinite(date.getUTCFullYear())) {
                  date.setUTCFullYear(y);
              }
          } else {
              date = new Date(Date.UTC.apply(null, arguments));
          }

          return date;
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

          return -fwdlw + fwd - 1;
      }

      // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear, resDayOfYear;

          if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
          } else {
              resYear = year;
              resDayOfYear = dayOfYear;
          }

          return {
              year: resYear,
              dayOfYear: resDayOfYear
          };
      }

      function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek, resYear;

          if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
          } else {
              resYear = mom.year();
              resWeek = week;
          }

          return {
              week: resWeek,
              year: resYear
          };
      }

      function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PRIORITIES

      addUnitPriority('week', 5);
      addUnitPriority('isoWeek', 5);

      // PARSING

      addRegexToken('w',  match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W',  match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek (mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
          dow : 0, // Sunday is the first day of the week.
          doy : 6  // The week that contains Jan 6th is the first week of the year.
      };

      function localeFirstDayOfWeek () {
          return this._week.dow;
      }

      function localeFirstDayOfYear () {
          return this._week.doy;
      }

      // MOMENTS

      function getSetWeek (input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek (input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PRIORITY
      addUnitPriority('day', 11);
      addUnitPriority('weekday', 11);
      addUnitPriority('isoWeekday', 11);

      // PARSING

      addRegexToken('d',    match1to2);
      addRegexToken('e',    match1to2);
      addRegexToken('E',    match1to2);
      addRegexToken('dd',   function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd',   function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd',   function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
              week.d = weekday;
          } else {
              getParsingFlags(config).invalidWeekday = input;
          }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
              return input;
          }

          if (!isNaN(input)) {
              return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
              return input;
          }

          return null;
      }

      function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
              return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
      }

      // LOCALES
      function shiftWeekdays (ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
      }

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
      function localeWeekdays (m, format) {
          var weekdays = isArray(this._weekdays) ? this._weekdays :
              this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
          return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
              : (m) ? weekdays[m.day()] : weekdays;
      }

      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
      function localeWeekdaysShort (m) {
          return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
              : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }

      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
      function localeWeekdaysMin (m) {
          return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
              : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }

      function handleStrictParse$1(weekdayName, format, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                  mom = createUTC([2000, 1]).day(i);
                  this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                  this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                  this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeWeekdaysParse (weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
              return handleStrictParse$1.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                  this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                  this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                  this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
              }
              if (!this._weekdaysParse[i]) {
                  regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                  this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function getSetDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, 'd');
          } else {
              return day;
          }
      }

      function getSetLocaleDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
              var weekday = parseIsoWeekday(input, this.localeData());
              return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
              return this.day() || 7;
          }
      }

      var defaultWeekdaysRegex = matchWord;
      function weekdaysRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysStrictRegex;
              } else {
                  return this._weekdaysRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  this._weekdaysRegex = defaultWeekdaysRegex;
              }
              return this._weekdaysStrictRegex && isStrict ?
                  this._weekdaysStrictRegex : this._weekdaysRegex;
          }
      }

      var defaultWeekdaysShortRegex = matchWord;
      function weekdaysShortRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysShortStrictRegex;
              } else {
                  return this._weekdaysShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                  this._weekdaysShortRegex = defaultWeekdaysShortRegex;
              }
              return this._weekdaysShortStrictRegex && isStrict ?
                  this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
      }

      var defaultWeekdaysMinRegex = matchWord;
      function weekdaysMinRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysMinStrictRegex;
              } else {
                  return this._weekdaysMinRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                  this._weekdaysMinRegex = defaultWeekdaysMinRegex;
              }
              return this._weekdaysMinStrictRegex && isStrict ?
                  this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
      }


      function computeWeekdaysParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, 1]).day(i);
              minp = this.weekdaysMin(mom, '');
              shortp = this.weekdaysShort(mom, '');
              longp = this.weekdays(mom, '');
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 7; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;

          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
      }

      // FORMATTING

      function hFormat() {
          return this.hours() % 12 || 12;
      }

      function kFormat() {
          return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      function meridiem (token, lowercase) {
          addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PRIORITY
      addUnitPriority('hour', 13);

      // PARSING

      function matchMeridiem (isStrict, locale) {
          return locale._meridiemParse;
      }

      addRegexToken('a',  matchMeridiem);
      addRegexToken('A',  matchMeridiem);
      addRegexToken('H',  match1to2);
      addRegexToken('h',  match1to2);
      addRegexToken('k',  match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('kk', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM (input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return ((input + '').toLowerCase().charAt(0) === 'p');
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem (hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'pm' : 'PM';
          } else {
              return isLower ? 'am' : 'AM';
          }
      }


      // MOMENTS

      // Setting the hour should keep the time, because the user explicitly
      // specified which hour they want. So trying to maintain the same hour (in
      // a new timezone) makes sense. Adding/subtracting hours does not follow
      // this rule.
      var getSetHour = makeGetSet('Hours', true);

      var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,

          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,

          week: defaultLocaleWeek,

          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,

          meridiemParse: defaultLocaleMeridiemParse
      };

      // internal storage for locale config files
      var locales = {};
      var localeFamilies = {};
      var globalLocale;

      function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
          var i = 0, j, next, locale, split;

          while (i < names.length) {
              split = normalizeLocale(names[i]).split('-');
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split('-') : null;
              while (j > 0) {
                  locale = loadLocale(split.slice(0, j).join('-'));
                  if (locale) {
                      return locale;
                  }
                  if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                      //the next array item is better than a shallower substring of this one
                      break;
                  }
                  j--;
              }
              i++;
          }
          return globalLocale;
      }

      function loadLocale(name) {
          var oldLocale = null;
          // TODO: Find a better way to register and load all the locales in Node
          if (!locales[name] && ('object' !== 'undefined') &&
                  module && module.exports) {
              try {
                  oldLocale = globalLocale._abbr;
                  var aliasedRequire = commonjsRequire;
                  aliasedRequire('./locale/' + name);
                  getSetGlobalLocale(oldLocale);
              } catch (e) {}
          }
          return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function getSetGlobalLocale (key, values) {
          var data;
          if (key) {
              if (isUndefined(values)) {
                  data = getLocale(key);
              }
              else {
                  data = defineLocale(key, values);
              }

              if (data) {
                  // moment.duration._locale = moment._locale = data;
                  globalLocale = data;
              }
              else {
                  if ((typeof console !==  'undefined') && console.warn) {
                      //warn user if arguments are passed but the locale could not be set
                      console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                  }
              }
          }

          return globalLocale._abbr;
      }

      function defineLocale (name, config) {
          if (config !== null) {
              var locale, parentConfig = baseConfig;
              config.abbr = name;
              if (locales[name] != null) {
                  deprecateSimple('defineLocaleOverride',
                          'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale ' +
                          'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                  parentConfig = locales[name]._config;
              } else if (config.parentLocale != null) {
                  if (locales[config.parentLocale] != null) {
                      parentConfig = locales[config.parentLocale]._config;
                  } else {
                      locale = loadLocale(config.parentLocale);
                      if (locale != null) {
                          parentConfig = locale._config;
                      } else {
                          if (!localeFamilies[config.parentLocale]) {
                              localeFamilies[config.parentLocale] = [];
                          }
                          localeFamilies[config.parentLocale].push({
                              name: name,
                              config: config
                          });
                          return null;
                      }
                  }
              }
              locales[name] = new Locale(mergeConfigs(parentConfig, config));

              if (localeFamilies[name]) {
                  localeFamilies[name].forEach(function (x) {
                      defineLocale(x.name, x.config);
                  });
              }

              // backwards compat for now: also set the locale
              // make sure we set the locale AFTER all child locales have been
              // created, so we won't end up with the child locale set.
              getSetGlobalLocale(name);


              return locales[name];
          } else {
              // useful for testing
              delete locales[name];
              return null;
          }
      }

      function updateLocale(name, config) {
          if (config != null) {
              var locale, tmpLocale, parentConfig = baseConfig;
              // MERGE
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                  parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;

              // backwards compat for now: also set the locale
              getSetGlobalLocale(name);
          } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                  if (locales[name].parentLocale != null) {
                      locales[name] = locales[name].parentLocale;
                  } else if (locales[name] != null) {
                      delete locales[name];
                  }
              }
          }
          return locales[name];
      }

      // returns locale data
      function getLocale (key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
          }

          if (!key) {
              return globalLocale;
          }

          if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                  return locale;
              }
              key = [key];
          }

          return chooseLocale(key);
      }

      function listLocales() {
          return keys(locales);
      }

      function checkOverflow (m) {
          var overflow;
          var a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                  a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                  a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                  a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                  a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                  a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                  a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                  -1;

              if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                  overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                  overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                  overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
          }

          return m;
      }

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
          if (a != null) {
              return a;
          }
          if (b != null) {
              return b;
          }
          return c;
      }

      function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
              return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray (config) {
          var i, date, input = [], currentDate, expectedWeekday, yearToUse;

          if (config._d) {
              return;
          }

          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
              dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                  getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
              config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
          }

          // Check for 24:00:00.000
          if (config._a[HOUR] === 24 &&
                  config._a[MINUTE] === 0 &&
                  config._a[SECOND] === 0 &&
                  config._a[MILLISECOND] === 0) {
              config._nextDay = true;
              config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
              config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
              getParsingFlags(config).weekdayMismatch = true;
          }
      }

      function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                  weekdayOverflow = true;
              }
          } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              var curWeek = weekOfYear(createLocal(), dow, doy);

              weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

              // Default to current week.
              week = defaults(w.w, curWeek.week);

              if (w.d != null) {
                  // weekday -- low day numbers are considered next week
                  weekday = w.d;
                  if (weekday < 0 || weekday > 6) {
                      weekdayOverflow = true;
                  }
              } else if (w.e != null) {
                  // local weekday -- counting starts from beginning of week
                  weekday = w.e + dow;
                  if (w.e < 0 || w.e > 6) {
                      weekdayOverflow = true;
                  }
              } else {
                  // default to beginning of week
                  weekday = dow;
              }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
          } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
          }
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

      var isoDates = [
          ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
          ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
          ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
          ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
          ['YYYY-DDD', /\d{4}-\d{3}/],
          ['YYYY-MM', /\d{4}-\d\d/, false],
          ['YYYYYYMMDD', /[+-]\d{10}/],
          ['YYYYMMDD', /\d{8}/],
          // YYYYMM is NOT allowed by the standard
          ['GGGG[W]WWE', /\d{4}W\d{3}/],
          ['GGGG[W]WW', /\d{4}W\d{2}/, false],
          ['YYYYDDD', /\d{7}/]
      ];

      // iso time formats and regexes
      var isoTimes = [
          ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
          ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
          ['HH:mm:ss', /\d\d:\d\d:\d\d/],
          ['HH:mm', /\d\d:\d\d/],
          ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
          ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
          ['HHmmss', /\d\d\d\d\d\d/],
          ['HHmm', /\d\d\d\d/],
          ['HH', /\d\d/]
      ];

      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

      // date from iso format
      function configFromISO(config) {
          var i, l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime, dateFormat, timeFormat, tzFormat;

          if (match) {
              getParsingFlags(config).iso = true;

              for (i = 0, l = isoDates.length; i < l; i++) {
                  if (isoDates[i][1].exec(match[1])) {
                      dateFormat = isoDates[i][0];
                      allowTime = isoDates[i][2] !== false;
                      break;
                  }
              }
              if (dateFormat == null) {
                  config._isValid = false;
                  return;
              }
              if (match[3]) {
                  for (i = 0, l = isoTimes.length; i < l; i++) {
                      if (isoTimes[i][1].exec(match[3])) {
                          // match[2] should be 'T' or space
                          timeFormat = (match[2] || ' ') + isoTimes[i][0];
                          break;
                      }
                  }
                  if (timeFormat == null) {
                      config._isValid = false;
                      return;
                  }
              }
              if (!allowTime && timeFormat != null) {
                  config._isValid = false;
                  return;
              }
              if (match[4]) {
                  if (tzRegex.exec(match[4])) {
                      tzFormat = 'Z';
                  } else {
                      config._isValid = false;
                      return;
                  }
              }
              config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
              configFromStringAndFormat(config);
          } else {
              config._isValid = false;
          }
      }

      // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
      var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
              untruncateYear(yearStr),
              defaultLocaleMonthsShort.indexOf(monthStr),
              parseInt(dayStr, 10),
              parseInt(hourStr, 10),
              parseInt(minuteStr, 10)
          ];

          if (secondStr) {
              result.push(parseInt(secondStr, 10));
          }

          return result;
      }

      function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
              return 2000 + year;
          } else if (year <= 999) {
              return 1900 + year;
          }
          return year;
      }

      function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      }

      function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
              // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
              var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                  weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
              if (weekdayProvided !== weekdayActual) {
                  getParsingFlags(config).weekdayMismatch = true;
                  config._isValid = false;
                  return false;
              }
          }
          return true;
      }

      var obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
      };

      function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
              return obsOffsets[obsOffset];
          } else if (militaryOffset) {
              // the only allowed military tz is Z
              return 0;
          } else {
              var hm = parseInt(numOffset, 10);
              var m = hm % 100, h = (hm - m) / 100;
              return h * 60 + m;
          }
      }

      // date and time from ref 2822 format
      function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i));
          if (match) {
              var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
              if (!checkWeekday(match[1], parsedArray, config)) {
                  return;
              }

              config._a = parsedArray;
              config._tzm = calculateOffset(match[8], match[9], match[10]);

              config._d = createUTCDate.apply(null, config._a);
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

              getParsingFlags(config).rfc2822 = true;
          } else {
              config._isValid = false;
          }
      }

      // date from iso format or fallback
      function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);

          if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
          }

          configFromISO(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          configFromRFC2822(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          // Final attempt, use Input Fallback
          hooks.createFromInputFallback(config);
      }

      hooks.createFromInputFallback = deprecate(
          'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
          'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
          'discouraged and will be removed in an upcoming major release. Please refer to ' +
          'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
          function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          }
      );

      // constant that refers to the ISO standard
      hooks.ISO_8601 = function () {};

      // constant that refers to the RFC 2822 form
      hooks.RFC_2822 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
              configFromISO(config);
              return;
          }
          if (config._f === hooks.RFC_2822) {
              configFromRFC2822(config);
              return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
              i, parsedInput, tokens, token, skipped,
              stringLength = string.length,
              totalParsedInputLength = 0;

          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
              token = tokens[i];
              parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
              // console.log('token', token, 'parsedInput', parsedInput,
              //         'regex', getParseRegexForToken(token, config));
              if (parsedInput) {
                  skipped = string.substr(0, string.indexOf(parsedInput));
                  if (skipped.length > 0) {
                      getParsingFlags(config).unusedInput.push(skipped);
                  }
                  string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                  totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                  if (parsedInput) {
                      getParsingFlags(config).empty = false;
                  }
                  else {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
                  addTimeToArrayFromToken(token, parsedInput, config);
              }
              else if (config._strict && !parsedInput) {
                  getParsingFlags(config).unusedTokens.push(token);
              }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (config._a[HOUR] <= 12 &&
              getParsingFlags(config).bigHour === true &&
              config._a[HOUR] > 0) {
              getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

          configFromArray(config);
          checkOverflow(config);
      }


      function meridiemFixWrap (locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
              // nothing to do
              return hour;
          }
          if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                  hour += 12;
              }
              if (!isPm && hour === 12) {
                  hour = 0;
              }
              return hour;
          } else {
              // this is not supposed to happen
              return hour;
          }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,

              scoreToBeat,
              i,
              currentScore;

          if (config._f.length === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
          }

          for (i = 0; i < config._f.length; i++) {
              currentScore = 0;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                  tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (!isValid(tempConfig)) {
                  continue;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (scoreToBeat == null || currentScore < scoreToBeat) {
                  scoreToBeat = currentScore;
                  bestMoment = tempConfig;
              }
          }

          extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
          if (config._d) {
              return;
          }

          var i = normalizeObjectUnits(config._i);
          config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
              return obj && parseInt(obj, 10);
          });

          configFromArray(config);
      }

      function createFromConfig (config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, 'd');
              res._nextDay = undefined;
          }

          return res;
      }

      function prepareConfig (config) {
          var input = config._i,
              format = config._f;

          config._locale = config._locale || getLocale(config._l);

          if (input === null || (format === undefined && input === '')) {
              return createInvalid({nullInput: true});
          }

          if (typeof input === 'string') {
              config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
              return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
              config._d = input;
          } else if (isArray(format)) {
              configFromStringAndArray(config);
          } else if (format) {
              configFromStringAndFormat(config);
          }  else {
              configFromInput(config);
          }

          if (!isValid(config)) {
              config._d = null;
          }

          return config;
      }

      function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
              config._d = new Date(hooks.now());
          } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
              configFromString(config);
          } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                  return parseInt(obj, 10);
              });
              configFromArray(config);
          } else if (isObject(input)) {
              configFromObject(config);
          } else if (isNumber(input)) {
              // from milliseconds
              config._d = new Date(input);
          } else {
              hooks.createFromInputFallback(config);
          }
      }

      function createLocalOrUTC (input, format, locale, strict, isUTC) {
          var c = {};

          if (locale === true || locale === false) {
              strict = locale;
              locale = undefined;
          }

          if ((isObject(input) && isObjectEmpty(input)) ||
                  (isArray(input) && input.length === 0)) {
              input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;

          return createFromConfig(c);
      }

      function createLocal (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate(
          'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
          function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other < this ? this : other;
              } else {
                  return createInvalid();
              }
          }
      );

      var prototypeMax = deprecate(
          'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
          function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other > this ? this : other;
              } else {
                  return createInvalid();
              }
          }
      );

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
          }
          if (!moments.length) {
              return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                  res = moments[i];
              }
          }
          return res;
      }

      // TODO: Use [].sort instead?
      function min () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isBefore', args);
      }

      function max () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isAfter', args);
      }

      var now = function () {
          return Date.now ? Date.now() : +(new Date());
      };

      var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

      function isDurationValid(m) {
          for (var key in m) {
              if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                  return false;
              }
          }

          var unitHasDecimal = false;
          for (var i = 0; i < ordering.length; ++i) {
              if (m[ordering[i]]) {
                  if (unitHasDecimal) {
                      return false; // only allow non-integers for smallest unit
                  }
                  if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                      unitHasDecimal = true;
                  }
              }
          }

          return true;
      }

      function isValid$1() {
          return this._isValid;
      }

      function createInvalid$1() {
          return createDuration(NaN);
      }

      function Duration (duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds = +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days +
              weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months +
              quarters * 3 +
              years * 12;

          this._data = {};

          this._locale = getLocale();

          this._bubble();
      }

      function isDuration (obj) {
          return obj instanceof Duration;
      }

      function absRound (number) {
          if (number < 0) {
              return Math.round(-1 * number) * -1;
          } else {
              return Math.round(number);
          }
      }

      // FORMATTING

      function offset (token, separator) {
          addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset();
              var sign = '+';
              if (offset < 0) {
                  offset = -offset;
                  sign = '-';
              }
              return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
          });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z',  matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher);

          if (matches === null) {
              return null;
          }

          var chunk   = matches[matches.length - 1] || [];
          var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          var minutes = +(parts[1] * 60) + toInt(parts[2]);

          return minutes === 0 ?
            0 :
            parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
              res = model.clone();
              diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              hooks.updateOffset(res, false);
              return res;
          } else {
              return createLocal(input).local();
          }
      }

      function getDateOffset (m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset (input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
              localAdjust;
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          if (input != null) {
              if (typeof input === 'string') {
                  input = offsetFromString(matchShortOffset, input);
                  if (input === null) {
                      return this;
                  }
              } else if (Math.abs(input) < 16 && !keepMinutes) {
                  input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                  localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                  this.add(localAdjust, 'm');
              }
              if (offset !== input) {
                  if (!keepLocalTime || this._changeInProgress) {
                      addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                  } else if (!this._changeInProgress) {
                      this._changeInProgress = true;
                      hooks.updateOffset(this, true);
                      this._changeInProgress = null;
                  }
              }
              return this;
          } else {
              return this._isUTC ? offset : getDateOffset(this);
          }
      }

      function getSetZone (input, keepLocalTime) {
          if (input != null) {
              if (typeof input !== 'string') {
                  input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
          } else {
              return -this.utcOffset();
          }
      }

      function setOffsetToUTC (keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal (keepLocalTime) {
          if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                  this.subtract(getDateOffset(this), 'm');
              }
          }
          return this;
      }

      function setOffsetToParsedOffset () {
          if (this._tzm != null) {
              this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
              var tZone = offsetFromString(matchOffset, this._i);
              if (tZone != null) {
                  this.utcOffset(tZone);
              }
              else {
                  this.utcOffset(0, true);
              }
          }
          return this;
      }

      function hasAlignedHourOffset (input) {
          if (!this.isValid()) {
              return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;

          return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime () {
          return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
          );
      }

      function isDaylightSavingTimeShifted () {
          if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
          }

          var c = {};

          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
              var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
              this._isDSTShifted = this.isValid() &&
                  compareArrays(c._a, other.toArray()) > 0;
          } else {
              this._isDSTShifted = false;
          }

          return this._isDSTShifted;
      }

      function isLocal () {
          return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset () {
          return this.isValid() ? this._isUTC : false;
      }

      function isUtc () {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
      // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
      // and further modified to allow for strings containing both week and day
      var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

      function createDuration (input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
              duration = {
                  ms : input._milliseconds,
                  d  : input._days,
                  M  : input._months
              };
          } else if (isNumber(input)) {
              duration = {};
              if (key) {
                  duration[key] = input;
              } else {
                  duration.milliseconds = input;
              }
          } else if (!!(match = aspNetRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : 1;
              duration = {
                  y  : 0,
                  d  : toInt(match[DATE])                         * sign,
                  h  : toInt(match[HOUR])                         * sign,
                  m  : toInt(match[MINUTE])                       * sign,
                  s  : toInt(match[SECOND])                       * sign,
                  ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
              };
          } else if (!!(match = isoRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : 1;
              duration = {
                  y : parseIso(match[2], sign),
                  M : parseIso(match[3], sign),
                  w : parseIso(match[4], sign),
                  d : parseIso(match[5], sign),
                  h : parseIso(match[6], sign),
                  m : parseIso(match[7], sign),
                  s : parseIso(match[8], sign)
              };
          } else if (duration == null) {// checks for null or undefined
              duration = {};
          } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
              diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
              ret._locale = input._locale;
          }

          return ret;
      }

      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;

      function parseIso (inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
          var res = {};

          res.months = other.month() - base.month() +
              (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
              --res.months;
          }

          res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

          return res;
      }

      function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
              return {milliseconds: 0, months: 0};
          }

          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
          } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
          }

          return res;
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
          return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                  deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                  'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                  tmp = val; val = period; period = tmp;
              }

              val = typeof val === 'string' ? +val : val;
              dur = createDuration(val, period);
              addSubtract(this, dur, direction);
              return this;
          };
      }

      function addSubtract (mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
              // No op
              return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (months) {
              setMonth(mom, get(mom, 'Month') + months * isAdding);
          }
          if (days) {
              set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
              hooks.updateOffset(mom, days || months);
          }
      }

      var add      = createAdder(1, 'add');
      var subtract = createAdder(-1, 'subtract');

      function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6 ? 'sameElse' :
                  diff < -1 ? 'lastWeek' :
                  diff < 0 ? 'lastDay' :
                  diff < 1 ? 'sameDay' :
                  diff < 2 ? 'nextDay' :
                  diff < 7 ? 'nextWeek' : 'sameElse';
      }

      function calendar$1 (time, formats) {
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              format = hooks.calendarFormat(this, sod) || 'sameElse';

          var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

          return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
      }

      function clone () {
          return new Moment(this);
      }

      function isAfter (input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() > localInput.valueOf();
          } else {
              return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
      }

      function isBefore (input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() < localInput.valueOf();
          } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
      }

      function isBetween (from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
              localTo = isMoment(to) ? to : createLocal(to);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
              return false;
          }
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
              (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }

      function isSame (input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() === localInput.valueOf();
          } else {
              inputMs = localInput.valueOf();
              return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
      }

      function isSameOrAfter (input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
      }

      function isSameOrBefore (input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
      }

      function diff (input, units, asFloat) {
          var that,
              zoneDelta,
              output;

          if (!this.isValid()) {
              return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
              return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

          units = normalizeUnits(units);

          switch (units) {
              case 'year': output = monthDiff(this, that) / 12; break;
              case 'month': output = monthDiff(this, that); break;
              case 'quarter': output = monthDiff(this, that) / 3; break;
              case 'second': output = (this - that) / 1e3; break; // 1000
              case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
              case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
              case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
              case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
              default: output = this - that;
          }

          return asFloat ? output : absFloor(output);
      }

      function monthDiff (a, b) {
          // difference in months
          var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2, adjust;

          if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
          } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
      }

      hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString () {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function toISOString(keepOffset) {
          if (!this.isValid()) {
              return null;
          }
          var utc = keepOffset !== true;
          var m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
              return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
          }
          if (isFunction(Date.prototype.toISOString)) {
              // native implementation is ~50x faster, use it when we can
              if (utc) {
                  return this.toDate().toISOString();
              } else {
                  return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
              }
          }
          return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      /**
       * Return a human readable representation of a moment that can
       * also be evaluated to get a new moment which is the same
       *
       * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
       */
      function inspect () {
          if (!this.isValid()) {
              return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment';
          var zone = '';
          if (!this.isLocal()) {
              func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
              zone = 'Z';
          }
          var prefix = '[' + func + '("]';
          var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
          var datetime = '-MM-DD[T]HH:mm:ss.SSS';
          var suffix = zone + '[")]';

          return this.format(prefix + year + datetime + suffix);
      }

      function format (inputString) {
          if (!inputString) {
              inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
      }

      function from (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   createLocal(time).isValid())) {
              return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function fromNow (withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
      }

      function to (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   createLocal(time).isValid())) {
              return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function toNow (withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale (key) {
          var newLocaleData;

          if (key === undefined) {
              return this._locale._abbr;
          } else {
              newLocaleData = getLocale(key);
              if (newLocaleData != null) {
                  this._locale = newLocaleData;
              }
              return this;
          }
      }

      var lang = deprecate(
          'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
          function (key) {
              if (key === undefined) {
                  return this.localeData();
              } else {
                  return this.locale(key);
              }
          }
      );

      function localeData () {
          return this._locale;
      }

      var MS_PER_SECOND = 1000;
      var MS_PER_MINUTE = 60 * MS_PER_SECOND;
      var MS_PER_HOUR = 60 * MS_PER_MINUTE;
      var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

      // actual modulo - handles negative numbers (for dates before 1970):
      function mod$1(dividend, divisor) {
          return (dividend % divisor + divisor) % divisor;
      }

      function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return new Date(y, m, d).valueOf();
          }
      }

      function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return Date.UTC(y, m, d);
          }
      }

      function startOf (units) {
          var time;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year(), 0, 1);
                  break;
              case 'quarter':
                  time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month(), 1);
                  break;
              case 'week':
                  time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                  break;
              case 'isoWeek':
                  time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date());
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_MINUTE);
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_SECOND);
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function endOf (units) {
          var time;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year() + 1, 0, 1) - 1;
                  break;
              case 'quarter':
                  time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                  break;
              case 'week':
                  time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                  break;
              case 'isoWeek':
                  time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function valueOf () {
          return this._d.valueOf() - ((this._offset || 0) * 60000);
      }

      function unix () {
          return Math.floor(this.valueOf() / 1000);
      }

      function toDate () {
          return new Date(this.valueOf());
      }

      function toArray () {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }

      function toObject () {
          var m = this;
          return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds()
          };
      }

      function toJSON () {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
      }

      function isValid$2 () {
          return isValid(this);
      }

      function parsingFlags () {
          return extend({}, getParsingFlags(this));
      }

      function invalidAt () {
          return getParsingFlags(this).overflow;
      }

      function creationData() {
          return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict
          };
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken (token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg',     'weekYear');
      addWeekYearFormatToken('ggggg',    'weekYear');
      addWeekYearFormatToken('GGGG',  'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PRIORITY

      addUnitPriority('weekYear', 1);
      addUnitPriority('isoWeekYear', 1);


      // PARSING

      addRegexToken('G',      matchSigned);
      addRegexToken('g',      matchSigned);
      addRegexToken('GG',     match1to2, match2);
      addRegexToken('gg',     match1to2, match2);
      addRegexToken('GGGG',   match1to4, match4);
      addRegexToken('gggg',   match1to4, match4);
      addRegexToken('GGGGG',  match1to6, match6);
      addRegexToken('ggggg',  match1to6, match6);

      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
      });

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input,
                  this.week(),
                  this.weekday(),
                  this.localeData()._week.dow,
                  this.localeData()._week.doy);
      }

      function getSetISOWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }

      function getISOWeeksInYear () {
          return weeksInYear(this.year(), 1, 4);
      }

      function getWeeksInYear () {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
              return weekOfYear(this, dow, doy).year;
          } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                  week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PRIORITY

      addUnitPriority('quarter', 7);

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter (input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PRIORITY
      addUnitPriority('date', 9);

      // PARSING

      addRegexToken('D',  match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict ?
            (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
            locale._dayOfMonthOrdinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PRIORITY
      addUnitPriority('dayOfYear', 4);

      // PARSING

      addRegexToken('DDD',  match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear (input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
      }

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PRIORITY

      addUnitPriority('minute', 14);

      // PARSING

      addRegexToken('m',  match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PRIORITY

      addUnitPriority('second', 15);

      // PARSING

      addRegexToken('s',  match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
      });


      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PRIORITY

      addUnitPriority('millisecond', 16);

      // PARSING

      addRegexToken('S',    match1to3, match1);
      addRegexToken('SS',   match1to3, match2);
      addRegexToken('SSS',  match1to3, match3);

      var token;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
      }
      // MOMENTS

      var getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z',  0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr () {
          return this._isUTC ? 'UTC' : '';
      }

      function getZoneName () {
          return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var proto = Moment.prototype;

      proto.add               = add;
      proto.calendar          = calendar$1;
      proto.clone             = clone;
      proto.diff              = diff;
      proto.endOf             = endOf;
      proto.format            = format;
      proto.from              = from;
      proto.fromNow           = fromNow;
      proto.to                = to;
      proto.toNow             = toNow;
      proto.get               = stringGet;
      proto.invalidAt         = invalidAt;
      proto.isAfter           = isAfter;
      proto.isBefore          = isBefore;
      proto.isBetween         = isBetween;
      proto.isSame            = isSame;
      proto.isSameOrAfter     = isSameOrAfter;
      proto.isSameOrBefore    = isSameOrBefore;
      proto.isValid           = isValid$2;
      proto.lang              = lang;
      proto.locale            = locale;
      proto.localeData        = localeData;
      proto.max               = prototypeMax;
      proto.min               = prototypeMin;
      proto.parsingFlags      = parsingFlags;
      proto.set               = stringSet;
      proto.startOf           = startOf;
      proto.subtract          = subtract;
      proto.toArray           = toArray;
      proto.toObject          = toObject;
      proto.toDate            = toDate;
      proto.toISOString       = toISOString;
      proto.inspect           = inspect;
      proto.toJSON            = toJSON;
      proto.toString          = toString;
      proto.unix              = unix;
      proto.valueOf           = valueOf;
      proto.creationData      = creationData;
      proto.year       = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear    = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month       = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week           = proto.weeks        = getSetWeek;
      proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
      proto.weeksInYear    = getWeeksInYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.date       = getSetDayOfMonth;
      proto.day        = proto.days             = getSetDayOfWeek;
      proto.weekday    = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear  = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset            = getSetOffset;
      proto.utc                  = setOffsetToUTC;
      proto.local                = setOffsetToLocal;
      proto.parseZone            = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST                = isDaylightSavingTime;
      proto.isLocal              = isLocal;
      proto.isUtcOffset          = isUtcOffset;
      proto.isUtc                = isUtc;
      proto.isUTC                = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
      proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

      function createUnix (input) {
          return createLocal(input * 1000);
      }

      function createInZone () {
          return createLocal.apply(null, arguments).parseZone();
      }

      function preParsePostFormat (string) {
          return string;
      }

      var proto$1 = Locale.prototype;

      proto$1.calendar        = calendar;
      proto$1.longDateFormat  = longDateFormat;
      proto$1.invalidDate     = invalidDate;
      proto$1.ordinal         = ordinal;
      proto$1.preparse        = preParsePostFormat;
      proto$1.postformat      = preParsePostFormat;
      proto$1.relativeTime    = relativeTime;
      proto$1.pastFuture      = pastFuture;
      proto$1.set             = set;

      proto$1.months            =        localeMonths;
      proto$1.monthsShort       =        localeMonthsShort;
      proto$1.monthsParse       =        localeMonthsParse;
      proto$1.monthsRegex       = monthsRegex;
      proto$1.monthsShortRegex  = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;

      proto$1.weekdays       =        localeWeekdays;
      proto$1.weekdaysMin    =        localeWeekdaysMin;
      proto$1.weekdaysShort  =        localeWeekdaysShort;
      proto$1.weekdaysParse  =        localeWeekdaysParse;

      proto$1.weekdaysRegex       =        weekdaysRegex;
      proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
      proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;

      function get$1 (format, index, field, setter) {
          var locale = getLocale();
          var utc = createUTC().set(setter, index);
          return locale[field](utc, format);
      }

      function listMonthsImpl (format, index, field) {
          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';

          if (index != null) {
              return get$1(format, index, field, 'month');
          }

          var i;
          var out = [];
          for (i = 0; i < 12; i++) {
              out[i] = get$1(format, i, field, 'month');
          }
          return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl (localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          }

          var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0;

          if (index != null) {
              return get$1(format, (index + shift) % 7, field, 'day');
          }

          var i;
          var out = [];
          for (i = 0; i < 7; i++) {
              out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
      }

      function listMonths (format, index) {
          return listMonthsImpl(format, index, 'months');
      }

      function listMonthsShort (format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
      }

      function listWeekdays (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function listWeekdaysShort (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function listWeekdaysMin (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      getSetGlobalLocale('en', {
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal : function (number) {
              var b = number % 10,
                  output = (toInt(number % 100 / 10) === 1) ? 'th' :
                  (b === 1) ? 'st' :
                  (b === 2) ? 'nd' :
                  (b === 3) ? 'rd' : 'th';
              return number + output;
          }
      });

      // Side effect imports

      hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
      hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

      var mathAbs = Math.abs;

      function abs () {
          var data           = this._data;

          this._milliseconds = mathAbs(this._milliseconds);
          this._days         = mathAbs(this._days);
          this._months       = mathAbs(this._months);

          data.milliseconds  = mathAbs(data.milliseconds);
          data.seconds       = mathAbs(data.seconds);
          data.minutes       = mathAbs(data.minutes);
          data.hours         = mathAbs(data.hours);
          data.months        = mathAbs(data.months);
          data.years         = mathAbs(data.years);

          return this;
      }

      function addSubtract$1 (duration, input, value, direction) {
          var other = createDuration(input, value);

          duration._milliseconds += direction * other._milliseconds;
          duration._days         += direction * other._days;
          duration._months       += direction * other._months;

          return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function add$1 (input, value) {
          return addSubtract$1(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function subtract$1 (input, value) {
          return addSubtract$1(this, input, value, -1);
      }

      function absCeil (number) {
          if (number < 0) {
              return Math.floor(number);
          } else {
              return Math.ceil(number);
          }
      }

      function bubble () {
          var milliseconds = this._milliseconds;
          var days         = this._days;
          var months       = this._months;
          var data         = this._data;
          var seconds, minutes, hours, years, monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0))) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;

          seconds           = absFloor(milliseconds / 1000);
          data.seconds      = seconds % 60;

          minutes           = absFloor(seconds / 60);
          data.minutes      = minutes % 60;

          hours             = absFloor(minutes / 60);
          data.hours        = hours % 24;

          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          data.days   = days;
          data.months = months;
          data.years  = years;

          return this;
      }

      function daysToMonths (days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
      }

      function monthsToDays (months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
      }

      function as (units) {
          if (!this.isValid()) {
              return NaN;
          }
          var days;
          var months;
          var milliseconds = this._milliseconds;

          units = normalizeUnits(units);

          if (units === 'month' || units === 'quarter' || units === 'year') {
              days = this._days + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              switch (units) {
                  case 'month':   return months;
                  case 'quarter': return months / 3;
                  case 'year':    return months / 12;
              }
          } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                  case 'week'   : return days / 7     + milliseconds / 6048e5;
                  case 'day'    : return days         + milliseconds / 864e5;
                  case 'hour'   : return days * 24    + milliseconds / 36e5;
                  case 'minute' : return days * 1440  + milliseconds / 6e4;
                  case 'second' : return days * 86400 + milliseconds / 1000;
                  // Math.floor prevents floating point math errors here
                  case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                  default: throw new Error('Unknown unit ' + units);
              }
          }
      }

      // TODO: Use this.as('ms')?
      function valueOf$1 () {
          if (!this.isValid()) {
              return NaN;
          }
          return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
          );
      }

      function makeAs (alias) {
          return function () {
              return this.as(alias);
          };
      }

      var asMilliseconds = makeAs('ms');
      var asSeconds      = makeAs('s');
      var asMinutes      = makeAs('m');
      var asHours        = makeAs('h');
      var asDays         = makeAs('d');
      var asWeeks        = makeAs('w');
      var asMonths       = makeAs('M');
      var asQuarters     = makeAs('Q');
      var asYears        = makeAs('y');

      function clone$1 () {
          return createDuration(this);
      }

      function get$2 (units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
      }

      function makeGetter(name) {
          return function () {
              return this.isValid() ? this._data[name] : NaN;
          };
      }

      var milliseconds = makeGetter('milliseconds');
      var seconds      = makeGetter('seconds');
      var minutes      = makeGetter('minutes');
      var hours        = makeGetter('hours');
      var days         = makeGetter('days');
      var months       = makeGetter('months');
      var years        = makeGetter('years');

      function weeks () {
          return absFloor(this.days() / 7);
      }

      var round = Math.round;
      var thresholds = {
          ss: 44,         // a few seconds to seconds
          s : 45,         // seconds to minute
          m : 45,         // minutes to hour
          h : 22,         // hours to day
          d : 26,         // days to month
          M : 11          // months to year
      };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
          var duration = createDuration(posNegDuration).abs();
          var seconds  = round(duration.as('s'));
          var minutes  = round(duration.as('m'));
          var hours    = round(duration.as('h'));
          var days     = round(duration.as('d'));
          var months   = round(duration.as('M'));
          var years    = round(duration.as('y'));

          var a = seconds <= thresholds.ss && ['s', seconds]  ||
                  seconds < thresholds.s   && ['ss', seconds] ||
                  minutes <= 1             && ['m']           ||
                  minutes < thresholds.m   && ['mm', minutes] ||
                  hours   <= 1             && ['h']           ||
                  hours   < thresholds.h   && ['hh', hours]   ||
                  days    <= 1             && ['d']           ||
                  days    < thresholds.d   && ['dd', days]    ||
                  months  <= 1             && ['M']           ||
                  months  < thresholds.M   && ['MM', months]  ||
                  years   <= 1             && ['y']           || ['yy', years];

          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set the rounding function for relative time strings
      function getSetRelativeTimeRounding (roundingFunction) {
          if (roundingFunction === undefined) {
              return round;
          }
          if (typeof(roundingFunction) === 'function') {
              round = roundingFunction;
              return true;
          }
          return false;
      }

      // This function allows you to set a threshold for relative time strings
      function getSetRelativeTimeThreshold (threshold, limit) {
          if (thresholds[threshold] === undefined) {
              return false;
          }
          if (limit === undefined) {
              return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
              thresholds.ss = limit - 1;
          }
          return true;
      }

      function humanize (withSuffix) {
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var locale = this.localeData();
          var output = relativeTime$1(this, !withSuffix, locale);

          if (withSuffix) {
              output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
      }

      var abs$1 = Math.abs;

      function sign(x) {
          return ((x > 0) - (x < 0)) || +x;
      }

      function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var seconds = abs$1(this._milliseconds) / 1000;
          var days         = abs$1(this._days);
          var months       = abs$1(this._months);
          var minutes, hours, years;

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes           = absFloor(seconds / 60);
          hours             = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years  = absFloor(months / 12);
          months %= 12;


          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          var Y = years;
          var M = months;
          var D = days;
          var h = hours;
          var m = minutes;
          var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
          var total = this.asSeconds();

          if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return 'P0D';
          }

          var totalSign = total < 0 ? '-' : '';
          var ymSign = sign(this._months) !== sign(total) ? '-' : '';
          var daysSign = sign(this._days) !== sign(total) ? '-' : '';
          var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

          return totalSign + 'P' +
              (Y ? ymSign + Y + 'Y' : '') +
              (M ? ymSign + M + 'M' : '') +
              (D ? daysSign + D + 'D' : '') +
              ((h || m || s) ? 'T' : '') +
              (h ? hmsSign + h + 'H' : '') +
              (m ? hmsSign + m + 'M' : '') +
              (s ? hmsSign + s + 'S' : '');
      }

      var proto$2 = Duration.prototype;

      proto$2.isValid        = isValid$1;
      proto$2.abs            = abs;
      proto$2.add            = add$1;
      proto$2.subtract       = subtract$1;
      proto$2.as             = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds      = asSeconds;
      proto$2.asMinutes      = asMinutes;
      proto$2.asHours        = asHours;
      proto$2.asDays         = asDays;
      proto$2.asWeeks        = asWeeks;
      proto$2.asMonths       = asMonths;
      proto$2.asQuarters     = asQuarters;
      proto$2.asYears        = asYears;
      proto$2.valueOf        = valueOf$1;
      proto$2._bubble        = bubble;
      proto$2.clone          = clone$1;
      proto$2.get            = get$2;
      proto$2.milliseconds   = milliseconds;
      proto$2.seconds        = seconds;
      proto$2.minutes        = minutes;
      proto$2.hours          = hours;
      proto$2.days           = days;
      proto$2.weeks          = weeks;
      proto$2.months         = months;
      proto$2.years          = years;
      proto$2.humanize       = humanize;
      proto$2.toISOString    = toISOString$1;
      proto$2.toString       = toISOString$1;
      proto$2.toJSON         = toISOString$1;
      proto$2.locale         = locale;
      proto$2.localeData     = localeData;

      proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
      proto$2.lang = lang;

      // Side effect imports

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input, 10) * 1000);
      });
      addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
      });

      // Side effect imports


      hooks.version = '2.24.0';

      setHookCallback(createLocal);

      hooks.fn                    = proto;
      hooks.min                   = min;
      hooks.max                   = max;
      hooks.now                   = now;
      hooks.utc                   = createUTC;
      hooks.unix                  = createUnix;
      hooks.months                = listMonths;
      hooks.isDate                = isDate;
      hooks.locale                = getSetGlobalLocale;
      hooks.invalid               = createInvalid;
      hooks.duration              = createDuration;
      hooks.isMoment              = isMoment;
      hooks.weekdays              = listWeekdays;
      hooks.parseZone             = createInZone;
      hooks.localeData            = getLocale;
      hooks.isDuration            = isDuration;
      hooks.monthsShort           = listMonthsShort;
      hooks.weekdaysMin           = listWeekdaysMin;
      hooks.defineLocale          = defineLocale;
      hooks.updateLocale          = updateLocale;
      hooks.locales               = listLocales;
      hooks.weekdaysShort         = listWeekdaysShort;
      hooks.normalizeUnits        = normalizeUnits;
      hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat        = getCalendarFormat;
      hooks.prototype             = proto;

      // currently HTML5 input type only supports 24-hour formats
      hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD',                             // <input type="date" />
          TIME: 'HH:mm',                                  // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW',                             // <input type="week" />
          MONTH: 'YYYY-MM'                                // <input type="month" />
      };

      return hooks;

  })));
  });

  var moment$1 = /*#__PURE__*/Object.freeze({
    'default': moment,
    __moduleExports: moment
  });

  var DateTimePickerDays = createReactClass({
  	render: function() {
  		var footer = this.renderFooter(),
  			date = this.props.viewDate,
  			locale = date.localeData(),
  			tableChildren
  			;

  		tableChildren = [
  			react.createElement('thead', { key: 'th' }, [
  				react.createElement('tr', { key: 'h' }, [
  					react.createElement('th', { key: 'p', className: 'rdtPrev', onClick: this.props.subtractTime( 1, 'months' )}, react.createElement('span', {}, '‹' )),
  					react.createElement('th', { key: 's', className: 'rdtSwitch', onClick: this.props.showView( 'months' ), colSpan: 5, 'data-value': this.props.viewDate.month() }, locale.months( date ) + ' ' + date.year() ),
  					react.createElement('th', { key: 'n', className: 'rdtNext', onClick: this.props.addTime( 1, 'months' )}, react.createElement('span', {}, '›' ))
  				]),
  				react.createElement('tr', { key: 'd'}, this.getDaysOfWeek( locale ).map( function( day, index ) { return react.createElement('th', { key: day + index, className: 'dow'}, day ); }) )
  			]),
  			react.createElement('tbody', { key: 'tb' }, this.renderDays())
  		];

  		if ( footer )
  			tableChildren.push( footer );

  		return react.createElement('div', { className: 'rdtDays' },
  			react.createElement('table', {}, tableChildren )
  		);
  	},

  	/**
  	 * Get a list of the days of the week
  	 * depending on the current locale
  	 * @return {array} A list with the shortname of the days
  	 */
  	getDaysOfWeek: function( locale ) {
  		var days = locale._weekdaysMin,
  			first = locale.firstDayOfWeek(),
  			dow = [],
  			i = 0
  			;

  		days.forEach( function( day ) {
  			dow[ (7 + ( i++ ) - first) % 7 ] = day;
  		});

  		return dow;
  	},

  	renderDays: function() {
  		var date = this.props.viewDate,
  			selected = this.props.selectedDate && this.props.selectedDate.clone(),
  			prevMonth = date.clone().subtract( 1, 'months' ),
  			currentYear = date.year(),
  			currentMonth = date.month(),
  			weeks = [],
  			days = [],
  			renderer = this.props.renderDay || this.renderDay,
  			isValid = this.props.isValidDate || this.alwaysValidDate,
  			classes, isDisabled, dayProps, currentDate
  			;

  		// Go to the last week of the previous month
  		prevMonth.date( prevMonth.daysInMonth() ).startOf( 'week' );
  		var lastDay = prevMonth.clone().add( 42, 'd' );

  		while ( prevMonth.isBefore( lastDay ) ) {
  			classes = 'rdtDay';
  			currentDate = prevMonth.clone();

  			if ( ( prevMonth.year() === currentYear && prevMonth.month() < currentMonth ) || ( prevMonth.year() < currentYear ) )
  				classes += ' rdtOld';
  			else if ( ( prevMonth.year() === currentYear && prevMonth.month() > currentMonth ) || ( prevMonth.year() > currentYear ) )
  				classes += ' rdtNew';

  			if ( selected && prevMonth.isSame( selected, 'day' ) )
  				classes += ' rdtActive';

  			if ( prevMonth.isSame( moment(), 'day' ) )
  				classes += ' rdtToday';

  			isDisabled = !isValid( currentDate, selected );
  			if ( isDisabled )
  				classes += ' rdtDisabled';

  			dayProps = {
  				key: prevMonth.format( 'M_D' ),
  				'data-value': prevMonth.date(),
  				className: classes
  			};

  			if ( !isDisabled )
  				dayProps.onClick = this.updateSelectedDate;

  			days.push( renderer( dayProps, currentDate, selected ) );

  			if ( days.length === 7 ) {
  				weeks.push( react.createElement('tr', { key: prevMonth.format( 'M_D' )}, days ) );
  				days = [];
  			}

  			prevMonth.add( 1, 'd' );
  		}

  		return weeks;
  	},

  	updateSelectedDate: function( event ) {
  		this.props.updateSelectedDate( event, true );
  	},

  	renderDay: function( props, currentDate ) {
  		return react.createElement('td',  props, currentDate.date() );
  	},

  	renderFooter: function() {
  		if ( !this.props.timeFormat )
  			return '';

  		var date = this.props.selectedDate || this.props.viewDate;

  		return react.createElement('tfoot', { key: 'tf'},
  			react.createElement('tr', {},
  				react.createElement('td', { onClick: this.props.showView( 'time' ), colSpan: 7, className: 'rdtTimeToggle' }, date.format( this.props.timeFormat ))
  			)
  		);
  	},

  	alwaysValidDate: function() {
  		return 1;
  	}
  });

  var DaysView = DateTimePickerDays;

  var DateTimePickerMonths = createReactClass({
  	render: function() {
  		return react.createElement('div', { className: 'rdtMonths' }, [
  			react.createElement('table', { key: 'a' }, react.createElement('thead', {}, react.createElement('tr', {}, [
  				react.createElement('th', { key: 'prev', className: 'rdtPrev', onClick: this.props.subtractTime( 1, 'years' )}, react.createElement('span', {}, '‹' )),
  				react.createElement('th', { key: 'year', className: 'rdtSwitch', onClick: this.props.showView( 'years' ), colSpan: 2, 'data-value': this.props.viewDate.year() }, this.props.viewDate.year() ),
  				react.createElement('th', { key: 'next', className: 'rdtNext', onClick: this.props.addTime( 1, 'years' )}, react.createElement('span', {}, '›' ))
  			]))),
  			react.createElement('table', { key: 'months' }, react.createElement('tbody', { key: 'b' }, this.renderMonths()))
  		]);
  	},

  	renderMonths: function() {
  		var date = this.props.selectedDate,
  			month = this.props.viewDate.month(),
  			year = this.props.viewDate.year(),
  			rows = [],
  			i = 0,
  			months = [],
  			renderer = this.props.renderMonth || this.renderMonth,
  			isValid = this.props.isValidDate || this.alwaysValidDate,
  			classes, props, currentMonth, isDisabled, noOfDaysInMonth, daysInMonth, validDay,
  			// Date is irrelevant because we're only interested in month
  			irrelevantDate = 1
  			;

  		while (i < 12) {
  			classes = 'rdtMonth';
  			currentMonth =
  				this.props.viewDate.clone().set({ year: year, month: i, date: irrelevantDate });

  			noOfDaysInMonth = currentMonth.endOf( 'month' ).format( 'D' );
  			daysInMonth = Array.from({ length: noOfDaysInMonth }, function( e, i ) {
  				return i + 1;
  			});

  			validDay = daysInMonth.find(function( d ) {
  				var day = currentMonth.clone().set( 'date', d );
  				return isValid( day );
  			});

  			isDisabled = ( validDay === undefined );

  			if ( isDisabled )
  				classes += ' rdtDisabled';

  			if ( date && i === date.month() && year === date.year() )
  				classes += ' rdtActive';

  			props = {
  				key: i,
  				'data-value': i,
  				className: classes
  			};

  			if ( !isDisabled )
  				props.onClick = ( this.props.updateOn === 'months' ?
  					this.updateSelectedMonth : this.props.setDate( 'month' ) );

  			months.push( renderer( props, i, year, date && date.clone() ) );

  			if ( months.length === 4 ) {
  				rows.push( react.createElement('tr', { key: month + '_' + rows.length }, months ) );
  				months = [];
  			}

  			i++;
  		}

  		return rows;
  	},

  	updateSelectedMonth: function( event ) {
  		this.props.updateSelectedDate( event );
  	},

  	renderMonth: function( props, month ) {
  		var localMoment = this.props.viewDate;
  		var monthStr = localMoment.localeData().monthsShort( localMoment.month( month ) );
  		var strLength = 3;
  		// Because some months are up to 5 characters long, we want to
  		// use a fixed string length for consistency
  		var monthStrFixedLength = monthStr.substring( 0, strLength );
  		return react.createElement('td', props, capitalize( monthStrFixedLength ) );
  	},

  	alwaysValidDate: function() {
  		return 1;
  	},
  });

  function capitalize( str ) {
  	return str.charAt( 0 ).toUpperCase() + str.slice( 1 );
  }

  var MonthsView = DateTimePickerMonths;

  var DateTimePickerYears = createReactClass({
  	render: function() {
  		var year = parseInt( this.props.viewDate.year() / 10, 10 ) * 10;

  		return react.createElement('div', { className: 'rdtYears' }, [
  			react.createElement('table', { key: 'a' }, react.createElement('thead', {}, react.createElement('tr', {}, [
  				react.createElement('th', { key: 'prev', className: 'rdtPrev', onClick: this.props.subtractTime( 10, 'years' )}, react.createElement('span', {}, '‹' )),
  				react.createElement('th', { key: 'year', className: 'rdtSwitch', onClick: this.props.showView( 'years' ), colSpan: 2 }, year + '-' + ( year + 9 ) ),
  				react.createElement('th', { key: 'next', className: 'rdtNext', onClick: this.props.addTime( 10, 'years' )}, react.createElement('span', {}, '›' ))
  			]))),
  			react.createElement('table', { key: 'years' }, react.createElement('tbody',  {}, this.renderYears( year )))
  		]);
  	},

  	renderYears: function( year ) {
  		var years = [],
  			i = -1,
  			rows = [],
  			renderer = this.props.renderYear || this.renderYear,
  			selectedDate = this.props.selectedDate,
  			isValid = this.props.isValidDate || this.alwaysValidDate,
  			classes, props, currentYear, isDisabled, noOfDaysInYear, daysInYear, validDay,
  			// Month and date are irrelevant here because
  			// we're only interested in the year
  			irrelevantMonth = 0,
  			irrelevantDate = 1
  			;

  		year--;
  		while (i < 11) {
  			classes = 'rdtYear';
  			currentYear = this.props.viewDate.clone().set(
  				{ year: year, month: irrelevantMonth, date: irrelevantDate } );

  			// Not sure what 'rdtOld' is for, commenting out for now as it's not working properly
  			// if ( i === -1 | i === 10 )
  				// classes += ' rdtOld';

  			noOfDaysInYear = currentYear.endOf( 'year' ).format( 'DDD' );
  			daysInYear = Array.from({ length: noOfDaysInYear }, function( e, i ) {
  				return i + 1;
  			});

  			validDay = daysInYear.find(function( d ) {
  				var day = currentYear.clone().dayOfYear( d );
  				return isValid( day );
  			});

  			isDisabled = ( validDay === undefined );

  			if ( isDisabled )
  				classes += ' rdtDisabled';

  			if ( selectedDate && selectedDate.year() === year )
  				classes += ' rdtActive';

  			props = {
  				key: year,
  				'data-value': year,
  				className: classes
  			};

  			if ( !isDisabled )
  				props.onClick = ( this.props.updateOn === 'years' ?
  					this.updateSelectedYear : this.props.setDate('year') );

  			years.push( renderer( props, year, selectedDate && selectedDate.clone() ));

  			if ( years.length === 4 ) {
  				rows.push( react.createElement('tr', { key: i }, years ) );
  				years = [];
  			}

  			year++;
  			i++;
  		}

  		return rows;
  	},

  	updateSelectedYear: function( event ) {
  		this.props.updateSelectedDate( event );
  	},

  	renderYear: function( props, year ) {
  		return react.createElement('td',  props, year );
  	},

  	alwaysValidDate: function() {
  		return 1;
  	},
  });

  var YearsView = DateTimePickerYears;

  var DateTimePickerTime = createReactClass({
  	getInitialState: function() {
  		return this.calculateState( this.props );
  	},

  	calculateState: function( props ) {
  		var date = props.selectedDate || props.viewDate,
  			format = props.timeFormat,
  			counters = []
  			;

  		if ( format.toLowerCase().indexOf('h') !== -1 ) {
  			counters.push('hours');
  			if ( format.indexOf('m') !== -1 ) {
  				counters.push('minutes');
  				if ( format.indexOf('s') !== -1 ) {
  					counters.push('seconds');
  				}
  			}
  		}

  		var hours = date.format( 'H' );

  		var daypart = false;
  		if ( this.state !== null && this.props.timeFormat.toLowerCase().indexOf( ' a' ) !== -1 ) {
  			if ( this.props.timeFormat.indexOf( ' A' ) !== -1 ) {
  				daypart = ( hours >= 12 ) ? 'PM' : 'AM';
  			} else {
  				daypart = ( hours >= 12 ) ? 'pm' : 'am';
  			}
  		}

  		return {
  			hours: hours,
  			minutes: date.format( 'mm' ),
  			seconds: date.format( 'ss' ),
  			milliseconds: date.format( 'SSS' ),
  			daypart: daypart,
  			counters: counters
  		};
  	},

  	renderCounter: function( type ) {
  		if ( type !== 'daypart' ) {
  			var value = this.state[ type ];
  			if ( type === 'hours' && this.props.timeFormat.toLowerCase().indexOf( ' a' ) !== -1 ) {
  				value = ( value - 1 ) % 12 + 1;

  				if ( value === 0 ) {
  					value = 12;
  				}
  			}
  			return react.createElement('div', { key: type, className: 'rdtCounter' }, [
  				react.createElement('span', { key: 'up', className: 'rdtBtn', onMouseDown: this.onStartClicking( 'increase', type ), onContextMenu: this.disableContextMenu }, '▲' ),
  				react.createElement('div', { key: 'c', className: 'rdtCount' }, value ),
  				react.createElement('span', { key: 'do', className: 'rdtBtn', onMouseDown: this.onStartClicking( 'decrease', type ), onContextMenu: this.disableContextMenu }, '▼' )
  			]);
  		}
  		return '';
  	},

  	renderDayPart: function() {
  		return react.createElement('div', { key: 'dayPart', className: 'rdtCounter' }, [
  			react.createElement('span', { key: 'up', className: 'rdtBtn', onMouseDown: this.onStartClicking( 'toggleDayPart', 'hours'), onContextMenu: this.disableContextMenu }, '▲' ),
  			react.createElement('div', { key: this.state.daypart, className: 'rdtCount' }, this.state.daypart ),
  			react.createElement('span', { key: 'do', className: 'rdtBtn', onMouseDown: this.onStartClicking( 'toggleDayPart', 'hours'), onContextMenu: this.disableContextMenu }, '▼' )
  		]);
  	},

  	render: function() {
  		var me = this,
  			counters = []
  		;

  		this.state.counters.forEach( function( c ) {
  			if ( counters.length )
  				counters.push( react.createElement('div', { key: 'sep' + counters.length, className: 'rdtCounterSeparator' }, ':' ) );
  			counters.push( me.renderCounter( c ) );
  		});

  		if ( this.state.daypart !== false ) {
  			counters.push( me.renderDayPart() );
  		}

  		if ( this.state.counters.length === 3 && this.props.timeFormat.indexOf( 'S' ) !== -1 ) {
  			counters.push( react.createElement('div', { className: 'rdtCounterSeparator', key: 'sep5' }, ':' ) );
  			counters.push(
  				react.createElement('div', { className: 'rdtCounter rdtMilli', key: 'm' },
  					react.createElement('input', { value: this.state.milliseconds, type: 'text', onChange: this.updateMilli } )
  					)
  				);
  		}

  		return react.createElement('div', { className: 'rdtTime' },
  			react.createElement('table', {}, [
  				this.renderHeader(),
  				react.createElement('tbody', { key: 'b'}, react.createElement('tr', {}, react.createElement('td', {},
  					react.createElement('div', { className: 'rdtCounters' }, counters )
  				)))
  			])
  		);
  	},

  	componentWillMount: function() {
  		var me = this;
  		me.timeConstraints = {
  			hours: {
  				min: 0,
  				max: 23,
  				step: 1
  			},
  			minutes: {
  				min: 0,
  				max: 59,
  				step: 1
  			},
  			seconds: {
  				min: 0,
  				max: 59,
  				step: 1
  			},
  			milliseconds: {
  				min: 0,
  				max: 999,
  				step: 1
  			}
  		};
  		['hours', 'minutes', 'seconds', 'milliseconds'].forEach( function( type ) {
  			objectAssign$1(me.timeConstraints[ type ], me.props.timeConstraints[ type ]);
  		});
  		this.setState( this.calculateState( this.props ) );
  	},

  	componentWillReceiveProps: function( nextProps ) {
  		this.setState( this.calculateState( nextProps ) );
  	},

  	updateMilli: function( e ) {
  		var milli = parseInt( e.target.value, 10 );
  		if ( milli === e.target.value && milli >= 0 && milli < 1000 ) {
  			this.props.setTime( 'milliseconds', milli );
  			this.setState( { milliseconds: milli } );
  		}
  	},

  	renderHeader: function() {
  		if ( !this.props.dateFormat )
  			return null;

  		var date = this.props.selectedDate || this.props.viewDate;
  		return react.createElement('thead', { key: 'h' }, react.createElement('tr', {},
  			react.createElement('th', { className: 'rdtSwitch', colSpan: 4, onClick: this.props.showView( 'days' ) }, date.format( this.props.dateFormat ) )
  		));
  	},

  	onStartClicking: function( action, type ) {
  		var me = this;

  		return function() {
  			var update = {};
  			update[ type ] = me[ action ]( type );
  			me.setState( update );

  			me.timer = setTimeout( function() {
  				me.increaseTimer = setInterval( function() {
  					update[ type ] = me[ action ]( type );
  					me.setState( update );
  				}, 70);
  			}, 500);

  			me.mouseUpListener = function() {
  				clearTimeout( me.timer );
  				clearInterval( me.increaseTimer );
  				me.props.setTime( type, me.state[ type ] );
  				document.body.removeEventListener( 'mouseup', me.mouseUpListener );
  				document.body.removeEventListener( 'touchend', me.mouseUpListener );
  			};

  			document.body.addEventListener( 'mouseup', me.mouseUpListener );
  			document.body.addEventListener( 'touchend', me.mouseUpListener );
  		};
  	},

  	disableContextMenu: function( event ) {
  		event.preventDefault();
  		return false;
  	},

  	padValues: {
  		hours: 1,
  		minutes: 2,
  		seconds: 2,
  		milliseconds: 3
  	},

  	toggleDayPart: function( type ) { // type is always 'hours'
  		var value = parseInt( this.state[ type ], 10) + 12;
  		if ( value > this.timeConstraints[ type ].max )
  			value = this.timeConstraints[ type ].min + ( value - ( this.timeConstraints[ type ].max + 1 ) );
  		return this.pad( type, value );
  	},

  	increase: function( type ) {
  		var value = parseInt( this.state[ type ], 10) + this.timeConstraints[ type ].step;
  		if ( value > this.timeConstraints[ type ].max )
  			value = this.timeConstraints[ type ].min + ( value - ( this.timeConstraints[ type ].max + 1 ) );
  		return this.pad( type, value );
  	},

  	decrease: function( type ) {
  		var value = parseInt( this.state[ type ], 10) - this.timeConstraints[ type ].step;
  		if ( value < this.timeConstraints[ type ].min )
  			value = this.timeConstraints[ type ].max + 1 - ( this.timeConstraints[ type ].min - value );
  		return this.pad( type, value );
  	},

  	pad: function( type, value ) {
  		var str = value + '';
  		while ( str.length < this.padValues[ type ] )
  			str = '0' + str;
  		return str;
  	},
  });

  var TimeView = DateTimePickerTime;

  var CalendarContainer = createReactClass({
  	viewComponents: {
  		days: DaysView,
  		months: MonthsView,
  		years: YearsView,
  		time: TimeView
  	},

  	render: function() {
  		return react.createElement( this.viewComponents[ this.props.view ], this.props.viewProps );
  	}
  });

  var CalendarContainer_1 = CalendarContainer;

  function _inheritsLoose$2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  function _objectWithoutProperties$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  /**
   * Check whether some DOM node is our Component's node.
   */
  function isNodeFound(current, componentNode, ignoreClass) {
    if (current === componentNode) {
      return true;
    } // SVG <use/> elements do not technically reside in the rendered DOM, so
    // they do not have classList directly, but they offer a link to their
    // corresponding element, which can have classList. This extra check is for
    // that case.
    // See: http://www.w3.org/TR/SVG11/struct.html#InterfaceSVGUseElement
    // Discussion: https://github.com/Pomax/react-onclickoutside/pull/17


    if (current.correspondingElement) {
      return current.correspondingElement.classList.contains(ignoreClass);
    }

    return current.classList.contains(ignoreClass);
  }
  /**
   * Try to find our node in a hierarchy of nodes, returning the document
   * node as highest node if our node is not found in the path up.
   */

  function findHighest(current, componentNode, ignoreClass) {
    if (current === componentNode) {
      return true;
    } // If source=local then this event came from 'somewhere'
    // inside and should be ignored. We could handle this with
    // a layered approach, too, but that requires going back to
    // thinking in terms of Dom node nesting, running counter
    // to React's 'you shouldn't care about the DOM' philosophy.


    while (current.parentNode) {
      if (isNodeFound(current, componentNode, ignoreClass)) {
        return true;
      }

      current = current.parentNode;
    }

    return current;
  }
  /**
   * Check if the browser scrollbar was clicked
   */

  function clickedScrollbar(evt) {
    return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
  }

  // ideally will get replaced with external dep
  // when rafrex/detect-passive-events#4 and rafrex/detect-passive-events#5 get merged in
  var testPassiveEventSupport = function testPassiveEventSupport() {
    if (typeof window === 'undefined' || typeof window.addEventListener !== 'function') {
      return;
    }

    var passive = false;
    var options = Object.defineProperty({}, 'passive', {
      get: function get() {
        passive = true;
      }
    });

    var noop = function noop() {};

    window.addEventListener('testPassiveEventSupport', noop, options);
    window.removeEventListener('testPassiveEventSupport', noop, options);
    return passive;
  };

  function autoInc(seed) {
    if (seed === void 0) {
      seed = 0;
    }

    return function () {
      return ++seed;
    };
  }

  var uid = autoInc();

  var passiveEventSupport;
  var handlersMap = {};
  var enabledInstances = {};
  var touchEvents = ['touchstart', 'touchmove'];
  var IGNORE_CLASS_NAME = 'ignore-react-onclickoutside';
  /**
   * Options for addEventHandler and removeEventHandler
   */

  function getEventHandlerOptions(instance, eventName) {
    var handlerOptions = null;
    var isTouchEvent = touchEvents.indexOf(eventName) !== -1;

    if (isTouchEvent && passiveEventSupport) {
      handlerOptions = {
        passive: !instance.props.preventDefault
      };
    }

    return handlerOptions;
  }
  /**
   * This function generates the HOC function that you'll use
   * in order to impart onOutsideClick listening to an
   * arbitrary component. It gets called at the end of the
   * bootstrapping code to yield an instance of the
   * onClickOutsideHOC function defined inside setupHOC().
   */


  function onClickOutsideHOC(WrappedComponent, config) {
    var _class, _temp;

    var componentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
    return _temp = _class =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose$2(onClickOutside, _Component);

      function onClickOutside(props) {
        var _this;

        _this = _Component.call(this, props) || this;

        _this.__outsideClickHandler = function (event) {
          if (typeof _this.__clickOutsideHandlerProp === 'function') {
            _this.__clickOutsideHandlerProp(event);

            return;
          }

          var instance = _this.getInstance();

          if (typeof instance.props.handleClickOutside === 'function') {
            instance.props.handleClickOutside(event);
            return;
          }

          if (typeof instance.handleClickOutside === 'function') {
            instance.handleClickOutside(event);
            return;
          }

          throw new Error("WrappedComponent: " + componentName + " lacks a handleClickOutside(event) function for processing outside click events.");
        };

        _this.enableOnClickOutside = function () {
          if (typeof document === 'undefined' || enabledInstances[_this._uid]) {
            return;
          }

          if (typeof passiveEventSupport === 'undefined') {
            passiveEventSupport = testPassiveEventSupport();
          }

          enabledInstances[_this._uid] = true;
          var events = _this.props.eventTypes;

          if (!events.forEach) {
            events = [events];
          }

          handlersMap[_this._uid] = function (event) {
            if (_this.componentNode === null) return;

            if (_this.props.preventDefault) {
              event.preventDefault();
            }

            if (_this.props.stopPropagation) {
              event.stopPropagation();
            }

            if (_this.props.excludeScrollbar && clickedScrollbar(event)) return;
            var current = event.target;

            if (findHighest(current, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
              return;
            }

            _this.__outsideClickHandler(event);
          };

          events.forEach(function (eventName) {
            document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_this, eventName));
          });
        };

        _this.disableOnClickOutside = function () {
          delete enabledInstances[_this._uid];
          var fn = handlersMap[_this._uid];

          if (fn && typeof document !== 'undefined') {
            var events = _this.props.eventTypes;

            if (!events.forEach) {
              events = [events];
            }

            events.forEach(function (eventName) {
              return document.removeEventListener(eventName, fn, getEventHandlerOptions(_this, eventName));
            });
            delete handlersMap[_this._uid];
          }
        };

        _this.getRef = function (ref) {
          return _this.instanceRef = ref;
        };

        _this._uid = uid();
        return _this;
      }
      /**
       * Access the WrappedComponent's instance.
       */


      var _proto = onClickOutside.prototype;

      _proto.getInstance = function getInstance() {
        if (!WrappedComponent.prototype.isReactComponent) {
          return this;
        }

        var ref = this.instanceRef;
        return ref.getInstance ? ref.getInstance() : ref;
      };

      /**
       * Add click listeners to the current document,
       * linked to this component's state.
       */
      _proto.componentDidMount = function componentDidMount() {
        // If we are in an environment without a DOM such
        // as shallow rendering or snapshots then we exit
        // early to prevent any unhandled errors being thrown.
        if (typeof document === 'undefined' || !document.createElement) {
          return;
        }

        var instance = this.getInstance();

        if (config && typeof config.handleClickOutside === 'function') {
          this.__clickOutsideHandlerProp = config.handleClickOutside(instance);

          if (typeof this.__clickOutsideHandlerProp !== 'function') {
            throw new Error("WrappedComponent: " + componentName + " lacks a function for processing outside click events specified by the handleClickOutside config option.");
          }
        }

        this.componentNode = reactDom_2(this.getInstance()); // return early so we dont initiate onClickOutside

        if (this.props.disableOnClickOutside) return;
        this.enableOnClickOutside();
      };

      _proto.componentDidUpdate = function componentDidUpdate() {
        this.componentNode = reactDom_2(this.getInstance());
      };
      /**
       * Remove all document's event listeners for this component
       */


      _proto.componentWillUnmount = function componentWillUnmount() {
        this.disableOnClickOutside();
      };
      /**
       * Can be called to explicitly enable event listening
       * for clicks and touches outside of this element.
       */


      /**
       * Pass-through render
       */
      _proto.render = function render() {
        // eslint-disable-next-line no-unused-vars
        var _props = this.props,
            excludeScrollbar = _props.excludeScrollbar,
            props = _objectWithoutProperties$1(_props, ["excludeScrollbar"]);

        if (WrappedComponent.prototype.isReactComponent) {
          props.ref = this.getRef;
        } else {
          props.wrappedRef = this.getRef;
        }

        props.disableOnClickOutside = this.disableOnClickOutside;
        props.enableOnClickOutside = this.enableOnClickOutside;
        return react_9(WrappedComponent, props);
      };

      return onClickOutside;
    }(react_2), _class.displayName = "OnClickOutside(" + componentName + ")", _class.defaultProps = {
      eventTypes: ['mousedown', 'touchstart'],
      excludeScrollbar: config && config.excludeScrollbar || false,
      outsideClickIgnoreClass: IGNORE_CLASS_NAME,
      preventDefault: false,
      stopPropagation: false
    }, _class.getClass = function () {
      return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
    }, _temp;
  }

  var viewModes = Object.freeze({
  	YEARS: 'years',
  	MONTHS: 'months',
  	DAYS: 'days',
  	TIME: 'time',
  });

  var TYPES = propTypes;
  var Datetime = createReactClass({
  	displayName: 'DateTime',
  	propTypes: {
  		// value: TYPES.object | TYPES.string,
  		// defaultValue: TYPES.object | TYPES.string,
  		// viewDate: TYPES.object | TYPES.string,
  		onFocus: TYPES.func,
  		onBlur: TYPES.func,
  		onChange: TYPES.func,
  		onViewModeChange: TYPES.func,
  		onNavigateBack: TYPES.func,
  		onNavigateForward: TYPES.func,
  		locale: TYPES.string,
  		utc: TYPES.bool,
  		displayTimeZone: TYPES.string,
  		input: TYPES.bool,
  		// dateFormat: TYPES.string | TYPES.bool,
  		// timeFormat: TYPES.string | TYPES.bool,
  		inputProps: TYPES.object,
  		timeConstraints: TYPES.object,
  		viewMode: TYPES.oneOf([viewModes.YEARS, viewModes.MONTHS, viewModes.DAYS, viewModes.TIME]),
  		isValidDate: TYPES.func,
  		open: TYPES.bool,
  		strictParsing: TYPES.bool,
  		closeOnSelect: TYPES.bool,
  		closeOnTab: TYPES.bool
  	},

  	getInitialState: function() {
  		this.checkTZ( this.props );
  		
  		var state = this.getStateFromProps( this.props );

  		if ( state.open === undefined )
  			state.open = !this.props.input;

  		state.currentView = this.props.dateFormat ?
  			(this.props.viewMode || state.updateOn || viewModes.DAYS) : viewModes.TIME;

  		return state;
  	},

  	parseDate: function (date, formats) {
  		var parsedDate;

  		if (date && typeof date === 'string')
  			parsedDate = this.localMoment(date, formats.datetime);
  		else if (date)
  			parsedDate = this.localMoment(date);

  		if (parsedDate && !parsedDate.isValid())
  			parsedDate = null;

  		return parsedDate;
  	},

  	getStateFromProps: function( props ) {
  		var formats = this.getFormats( props ),
  			date = props.value || props.defaultValue,
  			selectedDate, viewDate, updateOn, inputValue
  			;

  		selectedDate = this.parseDate(date, formats);

  		viewDate = this.parseDate(props.viewDate, formats);

  		viewDate = selectedDate ?
  			selectedDate.clone().startOf('month') :
  			viewDate ? viewDate.clone().startOf('month') : this.localMoment().startOf('month');

  		updateOn = this.getUpdateOn(formats);

  		if ( selectedDate )
  			inputValue = selectedDate.format(formats.datetime);
  		else if ( date.isValid && !date.isValid() )
  			inputValue = '';
  		else
  			inputValue = date || '';

  		return {
  			updateOn: updateOn,
  			inputFormat: formats.datetime,
  			viewDate: viewDate,
  			selectedDate: selectedDate,
  			inputValue: inputValue,
  			open: props.open
  		};
  	},

  	getUpdateOn: function( formats ) {
  		if ( formats.date.match(/[lLD]/) ) {
  			return viewModes.DAYS;
  		} else if ( formats.date.indexOf('M') !== -1 ) {
  			return viewModes.MONTHS;
  		} else if ( formats.date.indexOf('Y') !== -1 ) {
  			return viewModes.YEARS;
  		}

  		return viewModes.DAYS;
  	},

  	getFormats: function( props ) {
  		var formats = {
  				date: props.dateFormat || '',
  				time: props.timeFormat || ''
  			},
  			locale = this.localMoment( props.date, null, props ).localeData()
  			;

  		if ( formats.date === true ) {
  			formats.date = locale.longDateFormat('L');
  		}
  		else if ( this.getUpdateOn(formats) !== viewModes.DAYS ) {
  			formats.time = '';
  		}

  		if ( formats.time === true ) {
  			formats.time = locale.longDateFormat('LT');
  		}

  		formats.datetime = formats.date && formats.time ?
  			formats.date + ' ' + formats.time :
  			formats.date || formats.time
  		;

  		return formats;
  	},

  	componentWillReceiveProps: function( nextProps ) {
  		var formats = this.getFormats( nextProps ),
  			updatedState = {}
  		;

  		if ( nextProps.value !== this.props.value ||
  			formats.datetime !== this.getFormats( this.props ).datetime ) {
  			updatedState = this.getStateFromProps( nextProps );
  		}

  		if ( updatedState.open === undefined ) {
  			if ( typeof nextProps.open !== 'undefined' ) {
  				updatedState.open = nextProps.open;
  			} else if ( this.props.closeOnSelect && this.state.currentView !== viewModes.TIME ) {
  				updatedState.open = false;
  			} else {
  				updatedState.open = this.state.open;
  			}
  		}

  		if ( nextProps.viewMode !== this.props.viewMode ) {
  			updatedState.currentView = nextProps.viewMode;
  		}

  		if ( nextProps.locale !== this.props.locale ) {
  			if ( this.state.viewDate ) {
  				var updatedViewDate = this.state.viewDate.clone().locale( nextProps.locale );
  				updatedState.viewDate = updatedViewDate;
  			}
  			if ( this.state.selectedDate ) {
  				var updatedSelectedDate = this.state.selectedDate.clone().locale( nextProps.locale );
  				updatedState.selectedDate = updatedSelectedDate;
  				updatedState.inputValue = updatedSelectedDate.format( formats.datetime );
  			}
  		}

  		if ( nextProps.utc !== this.props.utc || nextProps.displayTimeZone !== this.props.displayTimeZone ) {
  			if ( nextProps.utc ) {
  				if ( this.state.viewDate )
  					updatedState.viewDate = this.state.viewDate.clone().utc();
  				if ( this.state.selectedDate ) {
  					updatedState.selectedDate = this.state.selectedDate.clone().utc();
  					updatedState.inputValue = updatedState.selectedDate.format( formats.datetime );
  				}
  			} else if ( nextProps.displayTimeZone ) {
  				if ( this.state.viewDate )
  					updatedState.viewDate = this.state.viewDate.clone().tz(nextProps.displayTimeZone);
  				if ( this.state.selectedDate ) {
  					updatedState.selectedDate = this.state.selectedDate.clone().tz(nextProps.displayTimeZone);
  					updatedState.inputValue = updatedState.selectedDate.tz(nextProps.displayTimeZone).format( formats.datetime );
  				}
  			} else {
  				if ( this.state.viewDate )
  					updatedState.viewDate = this.state.viewDate.clone().local();
  				if ( this.state.selectedDate ) {
  					updatedState.selectedDate = this.state.selectedDate.clone().local();
  					updatedState.inputValue = updatedState.selectedDate.format(formats.datetime);
  				}
  			}
  		}

  		if ( nextProps.viewDate !== this.props.viewDate ) {
  			updatedState.viewDate = moment(nextProps.viewDate);
  		}

  		this.checkTZ( nextProps );

  		this.setState( updatedState );
  	},

  	onInputChange: function( e ) {
  		var value = e.target === null ? e : e.target.value,
  			localMoment = this.localMoment( value, this.state.inputFormat ),
  			update = { inputValue: value }
  			;

  		if ( localMoment.isValid() && !this.props.value ) {
  			update.selectedDate = localMoment;
  			update.viewDate = localMoment.clone().startOf('month');
  		} else {
  			update.selectedDate = null;
  		}

  		return this.setState( update, function() {
  			return this.props.onChange( localMoment.isValid() ? localMoment : this.state.inputValue );
  		});
  	},

  	onInputKey: function( e ) {
  		if ( e.which === 9 && this.props.closeOnTab ) {
  			this.closeCalendar();
  		}
  	},

  	showView: function( view ) {
  		var me = this;
  		return function() {
  			me.state.currentView !== view && me.props.onViewModeChange( view );
  			me.setState({ currentView: view });
  		};
  	},

  	setDate: function( type ) {
  		var me = this,
  			nextViews = {
  				month: viewModes.DAYS,
  				year: viewModes.MONTHS,
  			}
  		;
  		return function( e ) {
  			me.setState({
  				viewDate: me.state.viewDate.clone()[ type ]( parseInt(e.target.getAttribute('data-value'), 10) ).startOf( type ),
  				currentView: nextViews[ type ]
  			});
  			me.props.onViewModeChange( nextViews[ type ] );
  		};
  	},

  	subtractTime: function( amount, type, toSelected ) {
  		var me = this;
  		return function() {
  			me.props.onNavigateBack( amount, type );
  			me.updateTime( 'subtract', amount, type, toSelected );
  		};
  	},

  	addTime: function( amount, type, toSelected ) {
  		var me = this;
  		return function() {
  			me.props.onNavigateForward( amount, type );
  			me.updateTime( 'add', amount, type, toSelected );
  		};
  	},

  	updateTime: function( op, amount, type, toSelected ) {
  		var update = {},
  			date = toSelected ? 'selectedDate' : 'viewDate';

  		update[ date ] = this.state[ date ].clone()[ op ]( amount, type );

  		this.setState( update );
  	},

  	allowedSetTime: ['hours', 'minutes', 'seconds', 'milliseconds'],
  	setTime: function( type, value ) {
  		var index = this.allowedSetTime.indexOf( type ) + 1,
  			state = this.state,
  			date = (state.selectedDate || state.viewDate).clone(),
  			nextType
  			;

  		// It is needed to set all the time properties
  		// to not to reset the time
  		date[ type ]( value );
  		for (; index < this.allowedSetTime.length; index++) {
  			nextType = this.allowedSetTime[index];
  			date[ nextType ]( date[nextType]() );
  		}

  		if ( !this.props.value ) {
  			this.setState({
  				selectedDate: date,
  				inputValue: date.format( state.inputFormat )
  			});
  		}
  		this.props.onChange( date );
  	},

  	updateSelectedDate: function( e, close ) {
  		var target = e.currentTarget,
  			modifier = 0,
  			viewDate = this.state.viewDate,
  			currentDate = this.state.selectedDate || viewDate,
  			date
  			;

  		if (target.className.indexOf('rdtDay') !== -1) {
  			if (target.className.indexOf('rdtNew') !== -1)
  				modifier = 1;
  			else if (target.className.indexOf('rdtOld') !== -1)
  				modifier = -1;

  			date = viewDate.clone()
  				.month( viewDate.month() + modifier )
  				.date( parseInt( target.getAttribute('data-value'), 10 ) );
  		} else if (target.className.indexOf('rdtMonth') !== -1) {
  			date = viewDate.clone()
  				.month( parseInt( target.getAttribute('data-value'), 10 ) )
  				.date( currentDate.date() );
  		} else if (target.className.indexOf('rdtYear') !== -1) {
  			date = viewDate.clone()
  				.month( currentDate.month() )
  				.date( currentDate.date() )
  				.year( parseInt( target.getAttribute('data-value'), 10 ) );
  		}

  		date.hours( currentDate.hours() )
  			.minutes( currentDate.minutes() )
  			.seconds( currentDate.seconds() )
  			.milliseconds( currentDate.milliseconds() );

  		if ( !this.props.value ) {
  			var open = !( this.props.closeOnSelect && close );
  			if ( !open ) {
  				this.props.onBlur( date );
  			}

  			this.setState({
  				selectedDate: date,
  				viewDate: date.clone().startOf('month'),
  				inputValue: date.format( this.state.inputFormat ),
  				open: open
  			});
  		} else {
  			if ( this.props.closeOnSelect && close ) {
  				this.closeCalendar();
  			}
  		}

  		this.props.onChange( date );
  	},

  	openCalendar: function( e ) {
  		if ( !this.state.open ) {
  			this.setState({ open: true }, function() {
  				this.props.onFocus( e );
  			});
  		}
  	},

  	closeCalendar: function() {
  		this.setState({ open: false }, function () {
  			this.props.onBlur( this.state.selectedDate || this.state.inputValue );
  		});
  	},

  	handleClickOutside: function() {
  		if ( this.props.input && this.state.open && this.props.open === undefined && !this.props.disableCloseOnClickOutside ) {
  			this.setState({ open: false }, function() {
  				this.props.onBlur( this.state.selectedDate || this.state.inputValue );
  			});
  		}
  	},

  	localMoment: function( date, format, props ) {
  		props = props || this.props;
  		var m = null;

  		if (props.utc) {
  			m = moment.utc(date, format, props.strictParsing);
  		} else if (props.displayTimeZone) {
  			m = moment.tz(date, format, props.displayTimeZone);
  		} else {
  			m = moment(date, format, props.strictParsing);
  		}

  		if ( props.locale )
  			m.locale( props.locale );
  		return m;
  	},

  	checkTZ: function( props ) {
  		var con = console;

  		if ( props.displayTimeZone && !this.tzWarning && !moment.tz ) {
  			this.tzWarning = true;
  			con && con.error('react-datetime: displayTimeZone prop with value "' + props.displayTimeZone +  '" is used but moment.js timezone is not loaded.');
  		}
  	},

  	componentProps: {
  		fromProps: ['value', 'isValidDate', 'renderDay', 'renderMonth', 'renderYear', 'timeConstraints'],
  		fromState: ['viewDate', 'selectedDate', 'updateOn'],
  		fromThis: ['setDate', 'setTime', 'showView', 'addTime', 'subtractTime', 'updateSelectedDate', 'localMoment', 'handleClickOutside']
  	},

  	getComponentProps: function() {
  		var me = this,
  			formats = this.getFormats( this.props ),
  			props = {dateFormat: formats.date, timeFormat: formats.time}
  			;

  		this.componentProps.fromProps.forEach( function( name ) {
  			props[ name ] = me.props[ name ];
  		});
  		this.componentProps.fromState.forEach( function( name ) {
  			props[ name ] = me.state[ name ];
  		});
  		this.componentProps.fromThis.forEach( function( name ) {
  			props[ name ] = me[ name ];
  		});

  		return props;
  	},

  	overrideEvent: function( handler, action ) {
  		if ( !this.overridenEvents ) {
  			this.overridenEvents = {};
  		}

  		if ( !this.overridenEvents[handler] ) {
  			var me = this;
  			this.overridenEvents[handler] = function( e ) {
  				var result;
  				if ( me.props.inputProps && me.props.inputProps[handler] ) {
  					result = me.props.inputProps[handler]( e );
  				}
  				if ( result !== false ) {
  					action( e );
  				}
  			};
  		}

  		return this.overridenEvents[handler];
  	},

  	render: function() {
  		// TODO: Make a function or clean up this code,
  		// logic right now is really hard to follow
  		var className = 'rdt' + (this.props.className ?
  									( Array.isArray( this.props.className ) ?
  									' ' + this.props.className.join( ' ' ) : ' ' + this.props.className) : ''),
  			children = [];

  		if ( this.props.input ) {
  			var finalInputProps = objectAssign$1(
  				{ type: 'text', className: 'form-control', value: this.state.inputValue },
  				this.props.inputProps,
  				{
  					onClick: this.overrideEvent( 'onClick', this.openCalendar ),
  					onFocus: this.overrideEvent( 'onFocus', this.openCalendar ),
  					onChange: this.overrideEvent( 'onChange', this.onInputChange ),
  					onKeyDown: this.overrideEvent( 'onKeyDown', this.onInputKey ),
  				}
  			);

  			if ( this.props.renderInput ) {
  				children = [ react.createElement('div', { key: 'i' }, this.props.renderInput( finalInputProps, this.openCalendar, this.closeCalendar )) ];
  			} else {
  				children = [ react.createElement('input', objectAssign$1({ key: 'i' }, finalInputProps ))];
  			}
  		} else {
  			className += ' rdtStatic';
  		}

  		if ( this.props.open || (this.props.open === undefined && this.state.open ) )
  			className += ' rdtOpen';

  		return react.createElement( ClickableWrapper, {className: className, onClickOut: this.handleClickOutside}, children.concat(
  			react.createElement( 'div',
  				{ key: 'dt', className: 'rdtPicker' },
  				react.createElement( CalendarContainer_1, { view: this.state.currentView, viewProps: this.getComponentProps() })
  			)
  		));
  	}
  });

  var ClickableWrapper = onClickOutsideHOC( createReactClass({
  	render: function() {
  		return react.createElement( 'div', { className: this.props.className }, this.props.children );
  	},
  	handleClickOutside: function( e ) {
  		this.props.onClickOut( e );
  	}
  }));

  Datetime.defaultProps = {
  	className: '',
  	defaultValue: '',
  	inputProps: {},
  	input: true,
  	onFocus: function() {},
  	onBlur: function() {},
  	onChange: function() {},
  	onViewModeChange: function() {},
  	onNavigateBack: function() {},
  	onNavigateForward: function() {},
  	timeFormat: true,
  	timeConstraints: {},
  	dateFormat: true,
  	strictParsing: true,
  	closeOnSelect: false,
  	closeOnTab: true,
  	utc: false
  };

  // Make moment accessible through the Datetime class
  Datetime.moment = moment;

  var DateTime = Datetime;

  var utils$1 = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.noop = noop;
  exports.returnTrue = returnTrue;
  exports.charIsNumber = charIsNumber;
  exports.escapeRegExp = escapeRegExp;
  exports.getThousandsGroupRegex = getThousandsGroupRegex;
  exports.applyThousandSeparator = applyThousandSeparator;
  exports.splitDecimal = splitDecimal;
  exports.fixLeadingZero = fixLeadingZero;
  exports.limitToScale = limitToScale;
  exports.roundToPrecision = roundToPrecision;
  exports.omit = omit;
  exports.setCaretPosition = setCaretPosition;
  exports.findChangedIndex = findChangedIndex;
  exports.clamp = clamp;
  exports.getCurrentCaretPosition = getCurrentCaretPosition;

  // basic noop function
  function noop() {}

  function returnTrue() {
    return true;
  }

  function charIsNumber(char) {
    return !!(char || '').match(/\d/);
  }

  function escapeRegExp(str) {
    return str.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
  }

  function getThousandsGroupRegex(thousandsGroupStyle) {
    switch (thousandsGroupStyle) {
      case 'lakh':
        return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g;

      case 'wan':
        return /(\d)(?=(\d{4})+(?!\d))/g;

      case 'thousand':
      default:
        return /(\d)(?=(\d{3})+(?!\d))/g;
    }
  }

  function applyThousandSeparator(str, thousandSeparator, thousandsGroupStyle) {
    var thousandsGroupRegex = getThousandsGroupRegex(thousandsGroupStyle);
    var index = str.search(/[1-9]/);
    return str.substring(0, index) + str.substring(index, str.length).replace(thousandsGroupRegex, '$1' + thousandSeparator);
  } //spilt a float number into different parts beforeDecimal, afterDecimal, and negation


  function splitDecimal(numStr) {
    var allowNegative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var hasNagation = numStr[0] === '-';
    var addNegation = hasNagation && allowNegative;
    numStr = numStr.replace('-', '');
    var parts = numStr.split('.');
    var beforeDecimal = parts[0];
    var afterDecimal = parts[1] || '';
    return {
      beforeDecimal: beforeDecimal,
      afterDecimal: afterDecimal,
      hasNagation: hasNagation,
      addNegation: addNegation
    };
  }

  function fixLeadingZero(numStr) {
    if (!numStr) return numStr;
    var isNegative = numStr[0] === '-';
    if (isNegative) numStr = numStr.substring(1, numStr.length);
    var parts = numStr.split('.');
    var beforeDecimal = parts[0].replace(/^0+/, '') || '0';
    var afterDecimal = parts[1] || '';
    return "".concat(isNegative ? '-' : '').concat(beforeDecimal).concat(afterDecimal ? ".".concat(afterDecimal) : '');
  }
  /**
   * limit decimal numbers to given scale
   * Not used .fixedTo because that will break with big numbers
   */


  function limitToScale(numStr, scale, fixedDecimalScale) {
    var str = '';
    var filler = fixedDecimalScale ? '0' : '';

    for (var i = 0; i <= scale - 1; i++) {
      str += numStr[i] || filler;
    }

    return str;
  }
  /**
   * This method is required to round prop value to given scale.
   * Not used .round or .fixedTo because that will break with big numbers
   */


  function roundToPrecision(numStr, scale, fixedDecimalScale) {
    //if number is empty don't do anything return empty string
    if (['', '-'].indexOf(numStr) !== -1) return numStr;
    var shoudHaveDecimalSeparator = numStr.indexOf('.') !== -1 && scale;

    var _splitDecimal = splitDecimal(numStr),
        beforeDecimal = _splitDecimal.beforeDecimal,
        afterDecimal = _splitDecimal.afterDecimal,
        hasNagation = _splitDecimal.hasNagation;

    var roundedDecimalParts = parseFloat("0.".concat(afterDecimal || '0')).toFixed(scale).split('.');
    var intPart = beforeDecimal.split('').reverse().reduce(function (roundedStr, current, idx) {
      if (roundedStr.length > idx) {
        return (Number(roundedStr[0]) + Number(current)).toString() + roundedStr.substring(1, roundedStr.length);
      }

      return current + roundedStr;
    }, roundedDecimalParts[0]);
    var decimalPart = limitToScale(roundedDecimalParts[1] || '', Math.min(scale, afterDecimal.length), fixedDecimalScale);
    var negation = hasNagation ? '-' : '';
    var decimalSeparator = shoudHaveDecimalSeparator ? '.' : '';
    return "".concat(negation).concat(intPart).concat(decimalSeparator).concat(decimalPart);
  }

  function omit(obj, keyMaps) {
    var filteredObj = {};
    Object.keys(obj).forEach(function (key) {
      if (!keyMaps[key]) filteredObj[key] = obj[key];
    });
    return filteredObj;
  }
  /** set the caret positon in an input field **/


  function setCaretPosition(el, caretPos) {
    el.value = el.value; // ^ this is used to not only get "focus", but
    // to make sure we don't have it everything -selected-
    // (it causes an issue in chrome, and having it doesn't hurt any other browser)

    if (el !== null) {
      if (el.createTextRange) {
        var range = el.createTextRange();
        range.move('character', caretPos);
        range.select();
        return true;
      } // (el.selectionStart === 0 added for Firefox bug)


      if (el.selectionStart || el.selectionStart === 0) {
        el.focus();
        el.setSelectionRange(caretPos, caretPos);
        return true;
      } // fail city, fortunately this never happens (as far as I've tested) :)


      el.focus();
      return false;
    }
  }
  /**
    Given previous value and newValue it returns the index
    start - end to which values have changed.
    This function makes assumption about only consecutive
    characters are changed which is correct assumption for caret input.
  */


  function findChangedIndex(prevValue, newValue) {
    var i = 0,
        j = 0;
    var prevLength = prevValue.length;
    var newLength = newValue.length;

    while (prevValue[i] === newValue[i] && i < prevLength) {
      i++;
    } //check what has been changed from last


    while (prevValue[prevLength - 1 - j] === newValue[newLength - 1 - j] && newLength - j > i && prevLength - j > i) {
      j++;
    }

    return {
      start: i,
      end: prevLength - j
    };
  }
  /*
    Returns a number whose value is limited to the given range
  */


  function clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
  }

  function getCurrentCaretPosition(el) {
    /*Max of selectionStart and selectionEnd is taken for the patch of pixel and other mobile device caret bug*/
    return Math.max(el.selectionStart, el.selectionEnd);
  }
  });

  unwrapExports(utils$1);
  var utils_1 = utils$1.noop;
  var utils_2 = utils$1.returnTrue;
  var utils_3 = utils$1.charIsNumber;
  var utils_4 = utils$1.escapeRegExp;
  var utils_5 = utils$1.getThousandsGroupRegex;
  var utils_6 = utils$1.applyThousandSeparator;
  var utils_7 = utils$1.splitDecimal;
  var utils_8 = utils$1.fixLeadingZero;
  var utils_9 = utils$1.limitToScale;
  var utils_10 = utils$1.roundToPrecision;
  var utils_11 = utils$1.omit;
  var utils_12 = utils$1.setCaretPosition;
  var utils_13 = utils$1.findChangedIndex;
  var utils_14 = utils$1.clamp;
  var utils_15 = utils$1.getCurrentCaretPosition;

  var number_format = createCommonjsModule(function (module, exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;

  var _propTypes = _interopRequireDefault(propTypes);

  var _react = _interopRequireDefault(react);



  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  var propTypes$1 = {
    thousandSeparator: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.oneOf([true])]),
    decimalSeparator: _propTypes.default.string,
    thousandsGroupStyle: _propTypes.default.oneOf(['thousand', 'lakh', 'wan']),
    decimalScale: _propTypes.default.number,
    fixedDecimalScale: _propTypes.default.bool,
    displayType: _propTypes.default.oneOf(['input', 'text']),
    prefix: _propTypes.default.string,
    suffix: _propTypes.default.string,
    format: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func]),
    removeFormatting: _propTypes.default.func,
    mask: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.arrayOf(_propTypes.default.string)]),
    value: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    defaultValue: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
    isNumericString: _propTypes.default.bool,
    customInput: _propTypes.default.elementType,
    allowNegative: _propTypes.default.bool,
    allowEmptyFormatting: _propTypes.default.bool,
    onValueChange: _propTypes.default.func,
    onKeyDown: _propTypes.default.func,
    onMouseUp: _propTypes.default.func,
    onChange: _propTypes.default.func,
    onFocus: _propTypes.default.func,
    onBlur: _propTypes.default.func,
    type: _propTypes.default.oneOf(['text', 'tel', 'password']),
    isAllowed: _propTypes.default.func,
    renderText: _propTypes.default.func,
    getInputRef: _propTypes.default.func
  };
  var defaultProps = {
    displayType: 'input',
    decimalSeparator: '.',
    thousandsGroupStyle: 'thousand',
    fixedDecimalScale: false,
    prefix: '',
    suffix: '',
    allowNegative: true,
    allowEmptyFormatting: false,
    isNumericString: false,
    type: 'text',
    onValueChange: utils$1.noop,
    onChange: utils$1.noop,
    onKeyDown: utils$1.noop,
    onMouseUp: utils$1.noop,
    onFocus: utils$1.noop,
    onBlur: utils$1.noop,
    isAllowed: utils$1.returnTrue,
    getInputRef: utils$1.noop
  };

  var NumberFormat =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(NumberFormat, _React$Component);

    function NumberFormat(props) {
      var _this;

      _classCallCheck(this, NumberFormat);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(NumberFormat).call(this, props));
      var defaultValue = props.defaultValue; //validate props

      _this.validateProps();

      var formattedValue = _this.formatValueProp(defaultValue);

      _this.state = {
        value: formattedValue,
        numAsString: _this.removeFormatting(formattedValue)
      };
      _this.selectionBeforeInput = {
        selectionStart: 0,
        selectionEnd: 0
      };
      _this.onChange = _this.onChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.onMouseUp = _this.onMouseUp.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.onFocus = _this.onFocus.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      _this.onBlur = _this.onBlur.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }

    _createClass(NumberFormat, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        this.updateValueIfRequired(prevProps);
      }
    }, {
      key: "updateValueIfRequired",
      value: function updateValueIfRequired(prevProps) {
        var props = this.props,
            state = this.state,
            focusedElm = this.focusedElm;
        var stateValue = state.value,
            _state$numAsString = state.numAsString,
            lastNumStr = _state$numAsString === void 0 ? '' : _state$numAsString;

        if (prevProps !== props) {
          //validate props
          this.validateProps();
          var lastValueWithNewFormat = this.formatNumString(lastNumStr);
          var formattedValue = props.value === undefined ? lastValueWithNewFormat : this.formatValueProp();
          var numAsString = this.removeFormatting(formattedValue);
          var floatValue = parseFloat(numAsString);
          var lastFloatValue = parseFloat(lastNumStr);

          if ( //while typing set state only when float value changes
          (!isNaN(floatValue) || !isNaN(lastFloatValue)) && floatValue !== lastFloatValue || //can also set state when float value is same and the format props changes
          lastValueWithNewFormat !== stateValue || //set state always when not in focus and formatted value is changed
          focusedElm === null && formattedValue !== stateValue) {
            this.updateValue({
              formattedValue: formattedValue,
              numAsString: numAsString,
              input: focusedElm
            });
          }
        }
      }
      /** Misc methods **/

    }, {
      key: "getFloatString",
      value: function getFloatString() {
        var num = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var decimalScale = this.props.decimalScale;

        var _this$getSeparators = this.getSeparators(),
            decimalSeparator = _this$getSeparators.decimalSeparator;

        var numRegex = this.getNumberRegex(true); //remove negation for regex check

        var hasNegation = num[0] === '-';
        if (hasNegation) num = num.replace('-', ''); //if decimal scale is zero remove decimal and number after decimalSeparator

        if (decimalSeparator && decimalScale === 0) {
          num = num.split(decimalSeparator)[0];
        }

        num = (num.match(numRegex) || []).join('').replace(decimalSeparator, '.'); //remove extra decimals

        var firstDecimalIndex = num.indexOf('.');

        if (firstDecimalIndex !== -1) {
          num = "".concat(num.substring(0, firstDecimalIndex), ".").concat(num.substring(firstDecimalIndex + 1, num.length).replace(new RegExp((0, utils$1.escapeRegExp)(decimalSeparator), 'g'), ''));
        } //add negation back


        if (hasNegation) num = '-' + num;
        return num;
      } //returned regex assumes decimalSeparator is as per prop

    }, {
      key: "getNumberRegex",
      value: function getNumberRegex(g, ignoreDecimalSeparator) {
        var _this$props = this.props,
            format = _this$props.format,
            decimalScale = _this$props.decimalScale;

        var _this$getSeparators2 = this.getSeparators(),
            decimalSeparator = _this$getSeparators2.decimalSeparator;

        return new RegExp('\\d' + (decimalSeparator && decimalScale !== 0 && !ignoreDecimalSeparator && !format ? '|' + (0, utils$1.escapeRegExp)(decimalSeparator) : ''), g ? 'g' : undefined);
      }
    }, {
      key: "getSeparators",
      value: function getSeparators() {
        var decimalSeparator = this.props.decimalSeparator;
        var thousandSeparator = this.props.thousandSeparator;

        if (thousandSeparator === true) {
          thousandSeparator = ',';
        }

        return {
          decimalSeparator: decimalSeparator,
          thousandSeparator: thousandSeparator
        };
      }
    }, {
      key: "getMaskAtIndex",
      value: function getMaskAtIndex(index) {
        var _this$props$mask = this.props.mask,
            mask = _this$props$mask === void 0 ? ' ' : _this$props$mask;

        if (typeof mask === 'string') {
          return mask;
        }

        return mask[index] || ' ';
      }
    }, {
      key: "getValueObject",
      value: function getValueObject(formattedValue, numAsString) {
        var floatValue = parseFloat(numAsString);
        return {
          formattedValue: formattedValue,
          value: numAsString,
          floatValue: isNaN(floatValue) ? undefined : floatValue
        };
      }
    }, {
      key: "validateProps",
      value: function validateProps() {
        var mask = this.props.mask; //validate decimalSeparator and thousandSeparator

        var _this$getSeparators3 = this.getSeparators(),
            decimalSeparator = _this$getSeparators3.decimalSeparator,
            thousandSeparator = _this$getSeparators3.thousandSeparator;

        if (decimalSeparator === thousandSeparator) {
          throw new Error("\n          Decimal separator can't be same as thousand separator.\n          thousandSeparator: ".concat(thousandSeparator, " (thousandSeparator = {true} is same as thousandSeparator = \",\")\n          decimalSeparator: ").concat(decimalSeparator, " (default value for decimalSeparator is .)\n       "));
        } //validate mask


        if (mask) {
          var maskAsStr = mask === 'string' ? mask : mask.toString();

          if (maskAsStr.match(/\d/g)) {
            throw new Error("\n          Mask ".concat(mask, " should not contain numeric character;\n        "));
          }
        }
      }
      /** Misc methods end **/

      /** caret specific methods **/

    }, {
      key: "setPatchedCaretPosition",
      value: function setPatchedCaretPosition(el, caretPos, currentValue) {
        /* setting caret position within timeout of 0ms is required for mobile chrome,
        otherwise browser resets the caret position after we set it
        We are also setting it without timeout so that in normal browser we don't see the flickering */
        (0, utils$1.setCaretPosition)(el, caretPos);
        setTimeout(function () {
          if (el.value === currentValue) (0, utils$1.setCaretPosition)(el, caretPos);
        }, 0);
      }
      /* This keeps the caret within typing area so people can't type in between prefix or suffix */

    }, {
      key: "correctCaretPosition",
      value: function correctCaretPosition(value, caretPos, direction) {
        var _this$props2 = this.props,
            prefix = _this$props2.prefix,
            suffix = _this$props2.suffix,
            format = _this$props2.format; //if value is empty return 0

        if (value === '') return 0; //caret position should be between 0 and value length

        caretPos = (0, utils$1.clamp)(caretPos, 0, value.length); //in case of format as number limit between prefix and suffix

        if (!format) {
          var hasNegation = value[0] === '-';
          return (0, utils$1.clamp)(caretPos, prefix.length + (hasNegation ? 1 : 0), value.length - suffix.length);
        } //in case if custom format method don't do anything


        if (typeof format === 'function') return caretPos;
        /* in case format is string find the closest # position from the caret position */
        //in case the caretPos have input value on it don't do anything

        if (format[caretPos] === '#' && (0, utils$1.charIsNumber)(value[caretPos])) return caretPos; //if caretPos is just after input value don't do anything

        if (format[caretPos - 1] === '#' && (0, utils$1.charIsNumber)(value[caretPos - 1])) return caretPos; //find the nearest caret position

        var firstHashPosition = format.indexOf('#');
        var lastHashPosition = format.lastIndexOf('#'); //limit the cursor between the first # position and the last # position

        caretPos = (0, utils$1.clamp)(caretPos, firstHashPosition, lastHashPosition + 1);
        var nextPos = format.substring(caretPos, format.length).indexOf('#');
        var caretLeftBound = caretPos;
        var caretRightBound = caretPos + (nextPos === -1 ? 0 : nextPos); //get the position where the last number is present

        while (caretLeftBound > firstHashPosition && (format[caretLeftBound] !== '#' || !(0, utils$1.charIsNumber)(value[caretLeftBound]))) {
          caretLeftBound -= 1;
        }

        var goToLeft = !(0, utils$1.charIsNumber)(value[caretRightBound]) || direction === 'left' && caretPos !== firstHashPosition || caretPos - caretLeftBound < caretRightBound - caretPos;

        if (goToLeft) {
          //check if number should be taken after the bound or after it
          //if number preceding a valid number keep it after
          return (0, utils$1.charIsNumber)(value[caretLeftBound]) ? caretLeftBound + 1 : caretLeftBound;
        }

        return caretRightBound;
      }
    }, {
      key: "getCaretPosition",
      value: function getCaretPosition(inputValue, formattedValue, caretPos) {
        var format = this.props.format;
        var stateValue = this.state.value;
        var numRegex = this.getNumberRegex(true);
        var inputNumber = (inputValue.match(numRegex) || []).join('');
        var formattedNumber = (formattedValue.match(numRegex) || []).join('');
        var j, i;
        j = 0;

        for (i = 0; i < caretPos; i++) {
          var currentInputChar = inputValue[i] || '';
          var currentFormatChar = formattedValue[j] || ''; //no need to increase new cursor position if formatted value does not have those characters
          //case inputValue = 1a23 and formattedValue =  123

          if (!currentInputChar.match(numRegex) && currentInputChar !== currentFormatChar) continue; //When we are striping out leading zeros maintain the new cursor position
          //Case inputValue = 00023 and formattedValue = 23;

          if (currentInputChar === '0' && currentFormatChar.match(numRegex) && currentFormatChar !== '0' && inputNumber.length !== formattedNumber.length) continue; //we are not using currentFormatChar because j can change here

          while (currentInputChar !== formattedValue[j] && j < formattedValue.length) {
            j++;
          }

          j++;
        }

        if (typeof format === 'string' && !stateValue) {
          //set it to the maximum value so it goes after the last number
          j = formattedValue.length;
        } //correct caret position if its outside of editable area


        j = this.correctCaretPosition(formattedValue, j);
        return j;
      }
      /** caret specific methods ends **/

      /** methods to remove formattting **/

    }, {
      key: "removePrefixAndSuffix",
      value: function removePrefixAndSuffix(val) {
        var _this$props3 = this.props,
            format = _this$props3.format,
            prefix = _this$props3.prefix,
            suffix = _this$props3.suffix; //remove prefix and suffix

        if (!format && val) {
          var isNegative = val[0] === '-'; //remove negation sign

          if (isNegative) val = val.substring(1, val.length); //remove prefix

          val = prefix && val.indexOf(prefix) === 0 ? val.substring(prefix.length, val.length) : val; //remove suffix

          var suffixLastIndex = val.lastIndexOf(suffix);
          val = suffix && suffixLastIndex !== -1 && suffixLastIndex === val.length - suffix.length ? val.substring(0, suffixLastIndex) : val; //add negation sign back

          if (isNegative) val = '-' + val;
        }

        return val;
      }
    }, {
      key: "removePatternFormatting",
      value: function removePatternFormatting(val) {
        var format = this.props.format;
        var formatArray = format.split('#').filter(function (str) {
          return str !== '';
        });
        var start = 0;
        var numStr = '';

        for (var i = 0, ln = formatArray.length; i <= ln; i++) {
          var part = formatArray[i] || ''; //if i is the last fragment take the index of end of the value
          //For case like +1 (911) 911 91 91 having pattern +1 (###) ### ## ##

          var index = i === ln ? val.length : val.indexOf(part, start);
          /* in any case if we don't find the pattern part in the value assume the val as numeric string
          This will be also in case if user has started typing, in any other case it will not be -1
          unless wrong prop value is provided */

          if (index === -1) {
            numStr = val;
            break;
          } else {
            numStr += val.substring(start, index);
            start = index + part.length;
          }
        }

        return (numStr.match(/\d/g) || []).join('');
      }
    }, {
      key: "removeFormatting",
      value: function removeFormatting(val) {
        var _this$props4 = this.props,
            format = _this$props4.format,
            removeFormatting = _this$props4.removeFormatting;
        if (!val) return val;

        if (!format) {
          val = this.removePrefixAndSuffix(val);
          val = this.getFloatString(val);
        } else if (typeof format === 'string') {
          val = this.removePatternFormatting(val);
        } else if (typeof removeFormatting === 'function') {
          //condition need to be handled if format method is provide,
          val = removeFormatting(val);
        } else {
          val = (val.match(/\d/g) || []).join('');
        }

        return val;
      }
      /** methods to remove formattting end **/

      /*** format specific methods start ***/

      /**
       * Format when # based string is provided
       * @param  {string} numStr Numeric String
       * @return {string}        formatted Value
       */

    }, {
      key: "formatWithPattern",
      value: function formatWithPattern(numStr) {
        var format = this.props.format;
        var hashCount = 0;
        var formattedNumberAry = format.split('');

        for (var i = 0, ln = format.length; i < ln; i++) {
          if (format[i] === '#') {
            formattedNumberAry[i] = numStr[hashCount] || this.getMaskAtIndex(hashCount);
            hashCount += 1;
          }
        }

        return formattedNumberAry.join('');
      }
      /**
       * @param  {string} numStr Numeric string/floatString] It always have decimalSeparator as .
       * @return {string} formatted Value
       */

    }, {
      key: "formatAsNumber",
      value: function formatAsNumber(numStr) {
        var _this$props5 = this.props,
            decimalScale = _this$props5.decimalScale,
            fixedDecimalScale = _this$props5.fixedDecimalScale,
            prefix = _this$props5.prefix,
            suffix = _this$props5.suffix,
            allowNegative = _this$props5.allowNegative,
            thousandsGroupStyle = _this$props5.thousandsGroupStyle;

        var _this$getSeparators4 = this.getSeparators(),
            thousandSeparator = _this$getSeparators4.thousandSeparator,
            decimalSeparator = _this$getSeparators4.decimalSeparator;

        var hasDecimalSeparator = numStr.indexOf('.') !== -1 || decimalScale && fixedDecimalScale;

        var _splitDecimal = (0, utils$1.splitDecimal)(numStr, allowNegative),
            beforeDecimal = _splitDecimal.beforeDecimal,
            afterDecimal = _splitDecimal.afterDecimal,
            addNegation = _splitDecimal.addNegation; // eslint-disable-line prefer-const
        //apply decimal precision if its defined


        if (decimalScale !== undefined) afterDecimal = (0, utils$1.limitToScale)(afterDecimal, decimalScale, fixedDecimalScale);

        if (thousandSeparator) {
          beforeDecimal = (0, utils$1.applyThousandSeparator)(beforeDecimal, thousandSeparator, thousandsGroupStyle);
        } //add prefix and suffix


        if (prefix) beforeDecimal = prefix + beforeDecimal;
        if (suffix) afterDecimal = afterDecimal + suffix; //restore negation sign

        if (addNegation) beforeDecimal = '-' + beforeDecimal;
        numStr = beforeDecimal + (hasDecimalSeparator && decimalSeparator || '') + afterDecimal;
        return numStr;
      }
    }, {
      key: "formatNumString",
      value: function formatNumString() {
        var numStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var _this$props6 = this.props,
            format = _this$props6.format,
            allowEmptyFormatting = _this$props6.allowEmptyFormatting;
        var formattedValue = numStr;

        if (numStr === '' && !allowEmptyFormatting) {
          formattedValue = '';
        } else if (numStr === '-' && !format) {
          formattedValue = '-';
        } else if (typeof format === 'string') {
          formattedValue = this.formatWithPattern(formattedValue);
        } else if (typeof format === 'function') {
          formattedValue = format(formattedValue);
        } else {
          formattedValue = this.formatAsNumber(formattedValue);
        }

        return formattedValue;
      }
    }, {
      key: "formatValueProp",
      value: function formatValueProp(defaultValue) {
        var _this$props7 = this.props,
            format = _this$props7.format,
            decimalScale = _this$props7.decimalScale,
            fixedDecimalScale = _this$props7.fixedDecimalScale,
            allowEmptyFormatting = _this$props7.allowEmptyFormatting;
        var _this$props8 = this.props,
            _this$props8$value = _this$props8.value,
            value = _this$props8$value === void 0 ? defaultValue : _this$props8$value,
            isNumericString = _this$props8.isNumericString;
        var isNonNumericFalsy = !value && value !== 0;

        if (isNonNumericFalsy && allowEmptyFormatting) {
          value = '';
        } // if value is not defined return empty string


        if (isNonNumericFalsy && !allowEmptyFormatting) return '';

        if (typeof value === 'number') {
          value = value.toString();
          isNumericString = true;
        } //change infinity value to empty string


        if (value === 'Infinity' && isNumericString) {
          value = '';
        } //round the number based on decimalScale
        //format only if non formatted value is provided


        if (isNumericString && !format && typeof decimalScale === 'number') {
          value = (0, utils$1.roundToPrecision)(value, decimalScale, fixedDecimalScale);
        }

        var formattedValue = isNumericString ? this.formatNumString(value) : this.formatInput(value);
        return formattedValue;
      }
    }, {
      key: "formatNegation",
      value: function formatNegation() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var allowNegative = this.props.allowNegative;
        var negationRegex = new RegExp('(-)');
        var doubleNegationRegex = new RegExp('(-)(.)*(-)'); // Check number has '-' value

        var hasNegation = negationRegex.test(value); // Check number has 2 or more '-' values

        var removeNegation = doubleNegationRegex.test(value); //remove negation

        value = value.replace(/-/g, '');

        if (hasNegation && !removeNegation && allowNegative) {
          value = '-' + value;
        }

        return value;
      }
    }, {
      key: "formatInput",
      value: function formatInput() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var format = this.props.format; //format negation only if we are formatting as number

        if (!format) {
          value = this.removePrefixAndSuffix(value);
          value = this.formatNegation(value);
        } //remove formatting from number


        value = this.removeFormatting(value);
        return this.formatNumString(value);
      }
      /*** format specific methods end ***/

    }, {
      key: "isCharacterAFormat",
      value: function isCharacterAFormat(caretPos, value) {
        var _this$props9 = this.props,
            format = _this$props9.format,
            prefix = _this$props9.prefix,
            suffix = _this$props9.suffix,
            decimalScale = _this$props9.decimalScale,
            fixedDecimalScale = _this$props9.fixedDecimalScale;

        var _this$getSeparators5 = this.getSeparators(),
            decimalSeparator = _this$getSeparators5.decimalSeparator; //check within format pattern


        if (typeof format === 'string' && format[caretPos] !== '#') return true; //check in number format

        if (!format && (caretPos < prefix.length || caretPos >= value.length - suffix.length || decimalScale && fixedDecimalScale && value[caretPos] === decimalSeparator)) {
          return true;
        }

        return false;
      }
    }, {
      key: "checkIfFormatGotDeleted",
      value: function checkIfFormatGotDeleted(start, end, value) {
        for (var i = start; i < end; i++) {
          if (this.isCharacterAFormat(i, value)) return true;
        }

        return false;
      }
      /**
       * This will check if any formatting got removed by the delete or backspace and reset the value
       * It will also work as fallback if android chome keyDown handler does not work
       **/

    }, {
      key: "correctInputValue",
      value: function correctInputValue(caretPos, lastValue, value) {
        var _this$props10 = this.props,
            format = _this$props10.format,
            allowNegative = _this$props10.allowNegative,
            prefix = _this$props10.prefix,
            suffix = _this$props10.suffix;

        var _this$getSeparators6 = this.getSeparators(),
            decimalSeparator = _this$getSeparators6.decimalSeparator;

        var lastNumStr = this.state.numAsString || '';
        var _this$selectionBefore = this.selectionBeforeInput,
            selectionStart = _this$selectionBefore.selectionStart,
            selectionEnd = _this$selectionBefore.selectionEnd;

        var _findChangedIndex = (0, utils$1.findChangedIndex)(lastValue, value),
            start = _findChangedIndex.start,
            end = _findChangedIndex.end;
        /** Check if only . is added in the numeric format and replace it with decimal separator */


        if (!format && decimalSeparator !== '.' && start === end && value[selectionStart] === '.') {
          return value.substr(0, selectionStart) + decimalSeparator + value.substr(selectionStart + 1, value.length);
        }
        /* don't do anyhting if something got added,
         or if value is empty string (when whole input is cleared)
         or whole input is replace with a number
        */


        var leftBound = !!format ? 0 : prefix.length;
        var rightBound = lastValue.length - (!!format ? 0 : suffix.length);

        if (value.length > lastValue.length || !value.length || start === end || selectionStart === 0 && selectionEnd === lastValue.length || selectionStart === leftBound && selectionEnd === rightBound) {
          return value;
        } //if format got deleted reset the value to last value


        if (this.checkIfFormatGotDeleted(start, end, lastValue)) {
          value = lastValue;
        } //for numbers check if beforeDecimal got deleted and there is nothing after decimal,
        //clear all numbers in such case while keeping the - sign


        if (!format) {
          var numericString = this.removeFormatting(value);

          var _splitDecimal2 = (0, utils$1.splitDecimal)(numericString, allowNegative),
              beforeDecimal = _splitDecimal2.beforeDecimal,
              afterDecimal = _splitDecimal2.afterDecimal,
              addNegation = _splitDecimal2.addNegation; // eslint-disable-line prefer-const
          //clear only if something got deleted


          var isBeforeDecimalPoint = caretPos < value.indexOf(decimalSeparator) + 1;

          if (numericString.length < lastNumStr.length && isBeforeDecimalPoint && beforeDecimal === '' && !parseFloat(afterDecimal)) {
            return addNegation ? '-' : '';
          }
        }

        return value;
      }
      /** Update value and caret position */

    }, {
      key: "updateValue",
      value: function updateValue(params) {
        var _this2 = this;

        var onUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : utils$1.noop;
        var formattedValue = params.formattedValue,
            input = params.input;
        var numAsString = params.numAsString,
            caretPos = params.caretPos;
        var onValueChange = this.props.onValueChange;
        var lastValue = this.state.value; //set caret position, and value imperatively when element is provided

        if (input) {
          //calculate caret position if not defined
          if (!caretPos) {
            var inputValue = params.inputValue || input.value;
            var currentCaretPosition = (0, utils$1.getCurrentCaretPosition)(input); //get the caret position

            caretPos = this.getCaretPosition(inputValue, formattedValue, currentCaretPosition);
          } //set the value imperatively, this is required for IE fix


          input.value = formattedValue; //set caret position

          this.setPatchedCaretPosition(input, caretPos, formattedValue);
        } //calculate numeric string if not passed


        if (numAsString === undefined) {
          numAsString = this.removeFormatting(formattedValue);
        } //update state if value is changed


        if (formattedValue !== lastValue) {
          this.setState({
            value: formattedValue,
            numAsString: numAsString
          }, function () {
            onValueChange(_this2.getValueObject(formattedValue, numAsString));
            onUpdate();
          });
        } else {
          onUpdate();
        }
      }
    }, {
      key: "onChange",
      value: function onChange(e) {
        e.persist();
        var el = e.target;
        var inputValue = el.value;
        var state = this.state,
            props = this.props;
        var isAllowed = props.isAllowed;
        var lastValue = state.value || '';
        var currentCaretPosition = (0, utils$1.getCurrentCaretPosition)(el);
        inputValue = this.correctInputValue(currentCaretPosition, lastValue, inputValue);
        var formattedValue = this.formatInput(inputValue) || '';
        var numAsString = this.removeFormatting(formattedValue);
        var valueObj = this.getValueObject(formattedValue, numAsString);

        if (!isAllowed(valueObj)) {
          formattedValue = lastValue;
        }

        this.updateValue({
          formattedValue: formattedValue,
          numAsString: numAsString,
          inputValue: inputValue,
          input: el
        }, function () {
          props.onChange(e);
        });
      }
    }, {
      key: "onBlur",
      value: function onBlur(e) {
        var props = this.props,
            state = this.state;
        var format = props.format,
            onBlur = props.onBlur;
        var numAsString = state.numAsString;
        var lastValue = state.value;
        this.focusedElm = null;

        if (!format) {
          numAsString = (0, utils$1.fixLeadingZero)(numAsString);
          var formattedValue = this.formatNumString(numAsString); //change the state

          if (formattedValue !== lastValue) {
            // the event needs to be persisted because its properties can be accessed in an asynchronous way
            e.persist();
            this.updateValue({
              formattedValue: formattedValue,
              numAsString: numAsString
            }, function () {
              onBlur(e);
            });
            return;
          }
        }

        onBlur(e);
      }
    }, {
      key: "onKeyDown",
      value: function onKeyDown(e) {
        var el = e.target;
        var key = e.key;
        var selectionStart = el.selectionStart,
            selectionEnd = el.selectionEnd,
            _el$value = el.value,
            value = _el$value === void 0 ? '' : _el$value;
        var expectedCaretPosition;
        var _this$props11 = this.props,
            decimalScale = _this$props11.decimalScale,
            fixedDecimalScale = _this$props11.fixedDecimalScale,
            prefix = _this$props11.prefix,
            suffix = _this$props11.suffix,
            format = _this$props11.format,
            onKeyDown = _this$props11.onKeyDown,
            onValueChange = _this$props11.onValueChange;
        var ignoreDecimalSeparator = decimalScale !== undefined && fixedDecimalScale;
        var numRegex = this.getNumberRegex(false, ignoreDecimalSeparator);
        var negativeRegex = new RegExp('-');
        var isPatternFormat = typeof format === 'string';
        this.selectionBeforeInput = {
          selectionStart: selectionStart,
          selectionEnd: selectionEnd //Handle backspace and delete against non numerical/decimal characters or arrow keys

        };

        if (key === 'ArrowLeft' || key === 'Backspace') {
          expectedCaretPosition = selectionStart - 1;
        } else if (key === 'ArrowRight') {
          expectedCaretPosition = selectionStart + 1;
        } else if (key === 'Delete') {
          expectedCaretPosition = selectionStart;
        } //if expectedCaretPosition is not set it means we don't want to Handle keyDown
        //also if multiple characters are selected don't handle


        if (expectedCaretPosition === undefined || selectionStart !== selectionEnd) {
          onKeyDown(e);
          return;
        }

        var newCaretPosition = expectedCaretPosition;
        var leftBound = isPatternFormat ? format.indexOf('#') : prefix.length;
        var rightBound = isPatternFormat ? format.lastIndexOf('#') + 1 : value.length - suffix.length;

        if (key === 'ArrowLeft' || key === 'ArrowRight') {
          var direction = key === 'ArrowLeft' ? 'left' : 'right';
          newCaretPosition = this.correctCaretPosition(value, expectedCaretPosition, direction);
        } else if (key === 'Delete' && !numRegex.test(value[expectedCaretPosition]) && !negativeRegex.test(value[expectedCaretPosition])) {
          while (!numRegex.test(value[newCaretPosition]) && newCaretPosition < rightBound) {
            newCaretPosition++;
          }
        } else if (key === 'Backspace' && !numRegex.test(value[expectedCaretPosition])) {
          /* NOTE: This is special case when backspace is pressed on a
          negative value while the cursor position is after prefix. We can't handle it on onChange because
          we will not have any information of keyPress
          */
          if (selectionStart <= leftBound + 1 && value[0] === '-' && typeof format === 'undefined') {
            var newValue = value.substring(1); //persist event before performing async task

            e.persist();
            this.updateValue({
              formattedValue: newValue,
              caretPos: newCaretPosition,
              input: el
            });
          } else if (!negativeRegex.test(value[expectedCaretPosition])) {
            while (!numRegex.test(value[newCaretPosition - 1]) && newCaretPosition > leftBound) {
              newCaretPosition--;
            }

            newCaretPosition = this.correctCaretPosition(value, newCaretPosition, 'left');
          }
        }

        if (newCaretPosition !== expectedCaretPosition || expectedCaretPosition < leftBound || expectedCaretPosition > rightBound) {
          e.preventDefault();
          this.setPatchedCaretPosition(el, newCaretPosition, value);
        }
        /* NOTE: this is just required for unit test as we need to get the newCaretPosition,
                Remove this when you find different solution */


        if (e.isUnitTestRun) {
          this.setPatchedCaretPosition(el, newCaretPosition, value);
        }

        this.props.onKeyDown(e);
      }
      /** required to handle the caret position when click anywhere within the input **/

    }, {
      key: "onMouseUp",
      value: function onMouseUp(e) {
        var el = e.target;
        /**
         * NOTE: we have to give default value for value as in case when custom input is provided
         * value can come as undefined when nothing is provided on value prop.
        */

        var selectionStart = el.selectionStart,
            selectionEnd = el.selectionEnd,
            _el$value2 = el.value,
            value = _el$value2 === void 0 ? '' : _el$value2;

        if (selectionStart === selectionEnd) {
          var caretPosition = this.correctCaretPosition(value, selectionStart);

          if (caretPosition !== selectionStart) {
            this.setPatchedCaretPosition(el, caretPosition, value);
          }
        }

        this.props.onMouseUp(e);
      }
    }, {
      key: "onFocus",
      value: function onFocus(e) {
        var _this3 = this;

        // Workaround Chrome and Safari bug https://bugs.chromium.org/p/chromium/issues/detail?id=779328
        // (onFocus event target selectionStart is always 0 before setTimeout)
        e.persist();
        this.focusedElm = e.target;
        setTimeout(function () {
          var el = e.target;
          var selectionStart = el.selectionStart,
              selectionEnd = el.selectionEnd,
              _el$value3 = el.value,
              value = _el$value3 === void 0 ? '' : _el$value3;

          var caretPosition = _this3.correctCaretPosition(value, selectionStart); //setPatchedCaretPosition only when everything is not selected on focus (while tabbing into the field)


          if (caretPosition !== selectionStart && !(selectionStart === 0 && selectionEnd === value.length)) {
            _this3.setPatchedCaretPosition(el, caretPosition, value);
          }

          _this3.props.onFocus(e);
        }, 0);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props12 = this.props,
            type = _this$props12.type,
            displayType = _this$props12.displayType,
            customInput = _this$props12.customInput,
            renderText = _this$props12.renderText,
            getInputRef = _this$props12.getInputRef;
        var value = this.state.value;
        var otherProps = (0, utils$1.omit)(this.props, propTypes$1);

        var inputProps = _extends({}, otherProps, {
          type: type,
          value: value,
          onChange: this.onChange,
          onKeyDown: this.onKeyDown,
          onMouseUp: this.onMouseUp,
          onFocus: this.onFocus,
          onBlur: this.onBlur
        });

        if (displayType === 'text') {
          return renderText ? renderText(value) || null : _react.default.createElement("span", _extends({}, otherProps, {
            ref: getInputRef
          }), value);
        } else if (customInput) {
          var CustomInput = customInput;
          return _react.default.createElement(CustomInput, inputProps);
        }

        return _react.default.createElement("input", _extends({}, inputProps, {
          ref: getInputRef
        }));
      }
    }]);

    return NumberFormat;
  }(_react.default.Component);

  NumberFormat.propTypes = propTypes$1;
  NumberFormat.defaultProps = defaultProps;
  var _default = NumberFormat;
  exports.default = _default;
  module.exports = exports.default;
  });

  var number_format$1 = unwrapExports(number_format);

  function isAbsolute(pathname) {
    return pathname.charAt(0) === '/';
  }

  // About 1.5x faster than the two-arg version of Array#splice()
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
      list[i] = list[k];
    }

    list.pop();
  }

  // This implementation is based heavily on node's url.parse
  function resolvePathname(to) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    var toParts = to && to.split('/') || [];
    var fromParts = from && from.split('/') || [];

    var isToAbs = to && isAbsolute(to);
    var isFromAbs = from && isAbsolute(from);
    var mustEndAbs = isToAbs || isFromAbs;

    if (to && isAbsolute(to)) {
      // to is absolute
      fromParts = toParts;
    } else if (toParts.length) {
      // to is relative, drop the filename
      fromParts.pop();
      fromParts = fromParts.concat(toParts);
    }

    if (!fromParts.length) return '/';

    var hasTrailingSlash = void 0;
    if (fromParts.length) {
      var last = fromParts[fromParts.length - 1];
      hasTrailingSlash = last === '.' || last === '..' || last === '';
    } else {
      hasTrailingSlash = false;
    }

    var up = 0;
    for (var i = fromParts.length; i >= 0; i--) {
      var part = fromParts[i];

      if (part === '.') {
        spliceOne(fromParts, i);
      } else if (part === '..') {
        spliceOne(fromParts, i);
        up++;
      } else if (up) {
        spliceOne(fromParts, i);
        up--;
      }
    }

    if (!mustEndAbs) for (; up--; up) {
      fromParts.unshift('..');
    }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

    var result = fromParts.join('/');

    if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

    return result;
  }

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function valueEqual(a, b) {
    if (a === b) return true;

    if (a == null || b == null) return false;

    if (Array.isArray(a)) {
      return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
        return valueEqual(item, b[index]);
      });
    }

    var aType = typeof a === 'undefined' ? 'undefined' : _typeof$1(a);
    var bType = typeof b === 'undefined' ? 'undefined' : _typeof$1(b);

    if (aType !== bType) return false;

    if (aType === 'object') {
      var aValue = a.valueOf();
      var bValue = b.valueOf();

      if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

      var aKeys = Object.keys(a);
      var bKeys = Object.keys(b);

      if (aKeys.length !== bKeys.length) return false;

      return aKeys.every(function (key) {
        return valueEqual(a[key], b[key]);
      });
    }

    return false;
  }

  var prefix = 'Invariant failed';
  function invariant$2(condition, message) {
    if (condition) {
      return;
    }

    {
      throw new Error(prefix);
    }
  }

  function addLeadingSlash(path) {
    return path.charAt(0) === '/' ? path : '/' + path;
  }
  function stripLeadingSlash(path) {
    return path.charAt(0) === '/' ? path.substr(1) : path;
  }
  function hasBasename(path, prefix) {
    return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
  }
  function stripBasename(path, prefix) {
    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
  }
  function stripTrailingSlash(path) {
    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
  }
  function parsePath(path) {
    var pathname = path || '/';
    var search = '';
    var hash = '';
    var hashIndex = pathname.indexOf('#');

    if (hashIndex !== -1) {
      hash = pathname.substr(hashIndex);
      pathname = pathname.substr(0, hashIndex);
    }

    var searchIndex = pathname.indexOf('?');

    if (searchIndex !== -1) {
      search = pathname.substr(searchIndex);
      pathname = pathname.substr(0, searchIndex);
    }

    return {
      pathname: pathname,
      search: search === '?' ? '' : search,
      hash: hash === '#' ? '' : hash
    };
  }
  function createPath(location) {
    var pathname = location.pathname,
        search = location.search,
        hash = location.hash;
    var path = pathname || '/';
    if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
    if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
    return path;
  }

  function createLocation(path, state, key, currentLocation) {
    var location;

    if (typeof path === 'string') {
      // Two-arg form: push(path, state)
      location = parsePath(path);
      location.state = state;
    } else {
      // One-arg form: push(location)
      location = _extends$9({}, path);
      if (location.pathname === undefined) location.pathname = '';

      if (location.search) {
        if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
      } else {
        location.search = '';
      }

      if (location.hash) {
        if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
      } else {
        location.hash = '';
      }

      if (state !== undefined && location.state === undefined) location.state = state;
    }

    try {
      location.pathname = decodeURI(location.pathname);
    } catch (e) {
      if (e instanceof URIError) {
        throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
      } else {
        throw e;
      }
    }

    if (key) location.key = key;

    if (currentLocation) {
      // Resolve incomplete/relative pathname relative to current location.
      if (!location.pathname) {
        location.pathname = currentLocation.pathname;
      } else if (location.pathname.charAt(0) !== '/') {
        location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
      }
    } else {
      // When there is no prior location and pathname is empty, set it to /
      if (!location.pathname) {
        location.pathname = '/';
      }
    }

    return location;
  }
  function locationsAreEqual(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
  }

  function createTransitionManager() {
    var prompt = null;

    function setPrompt(nextPrompt) {
      prompt = nextPrompt;
      return function () {
        if (prompt === nextPrompt) prompt = null;
      };
    }

    function confirmTransitionTo(location, action, getUserConfirmation, callback) {
      // TODO: If another transition starts while we're still confirming
      // the previous one, we may end up in a weird state. Figure out the
      // best way to handle this.
      if (prompt != null) {
        var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

        if (typeof result === 'string') {
          if (typeof getUserConfirmation === 'function') {
            getUserConfirmation(result, callback);
          } else {
            callback(true);
          }
        } else {
          // Return false from a transition hook to cancel the transition.
          callback(result !== false);
        }
      } else {
        callback(true);
      }
    }

    var listeners = [];

    function appendListener(fn) {
      var isActive = true;

      function listener() {
        if (isActive) fn.apply(void 0, arguments);
      }

      listeners.push(listener);
      return function () {
        isActive = false;
        listeners = listeners.filter(function (item) {
          return item !== listener;
        });
      };
    }

    function notifyListeners() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      listeners.forEach(function (listener) {
        return listener.apply(void 0, args);
      });
    }

    return {
      setPrompt: setPrompt,
      confirmTransitionTo: confirmTransitionTo,
      appendListener: appendListener,
      notifyListeners: notifyListeners
    };
  }

  var canUseDOM$1 = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  function getConfirmation(message, callback) {
    callback(window.confirm(message)); // eslint-disable-line no-alert
  }
  /**
   * Returns true if the HTML5 history API is supported. Taken from Modernizr.
   *
   * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
   * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
   * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
   */

  function supportsHistory() {
    var ua = window.navigator.userAgent;
    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
    return window.history && 'pushState' in window.history;
  }
  /**
   * Returns true if browser fires popstate on hash change.
   * IE10 and IE11 do not.
   */

  function supportsPopStateOnHashChange() {
    return window.navigator.userAgent.indexOf('Trident') === -1;
  }
  /**
   * Returns false if using go(n) with hash history causes a full page reload.
   */

  function supportsGoWithoutReloadUsingHash() {
    return window.navigator.userAgent.indexOf('Firefox') === -1;
  }
  /**
   * Returns true if a given popstate event is an extraneous WebKit event.
   * Accounts for the fact that Chrome on iOS fires real popstate events
   * containing undefined state when pressing the back button.
   */

  function isExtraneousPopstateEvent(event) {
    event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
  }

  var PopStateEvent = 'popstate';
  var HashChangeEvent = 'hashchange';

  function getHistoryState() {
    try {
      return window.history.state || {};
    } catch (e) {
      // IE 11 sometimes throws when accessing window.history.state
      // See https://github.com/ReactTraining/history/pull/289
      return {};
    }
  }
  /**
   * Creates a history object that uses the HTML5 history API including
   * pushState, replaceState, and the popstate event.
   */


  function createBrowserHistory(props) {
    if (props === void 0) {
      props = {};
    }

    !canUseDOM$1 ? invariant$2(false) : void 0;
    var globalHistory = window.history;
    var canUseHistory = supportsHistory();
    var needsHashChangeListener = !supportsPopStateOnHashChange();
    var _props = props,
        _props$forceRefresh = _props.forceRefresh,
        forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
        _props$getUserConfirm = _props.getUserConfirmation,
        getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
        _props$keyLength = _props.keyLength,
        keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

    function getDOMLocation(historyState) {
      var _ref = historyState || {},
          key = _ref.key,
          state = _ref.state;

      var _window$location = window.location,
          pathname = _window$location.pathname,
          search = _window$location.search,
          hash = _window$location.hash;
      var path = pathname + search + hash;
      if (basename) path = stripBasename(path, basename);
      return createLocation(path, state, key);
    }

    function createKey() {
      return Math.random().toString(36).substr(2, keyLength);
    }

    var transitionManager = createTransitionManager();

    function setState(nextState) {
      _extends$9(history, nextState);

      history.length = globalHistory.length;
      transitionManager.notifyListeners(history.location, history.action);
    }

    function handlePopState(event) {
      // Ignore extraneous popstate events in WebKit.
      if (isExtraneousPopstateEvent(event)) return;
      handlePop(getDOMLocation(event.state));
    }

    function handleHashChange() {
      handlePop(getDOMLocation(getHistoryState()));
    }

    var forceNextPop = false;

    function handlePop(location) {
      if (forceNextPop) {
        forceNextPop = false;
        setState();
      } else {
        var action = 'POP';
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
          if (ok) {
            setState({
              action: action,
              location: location
            });
          } else {
            revertPop(location);
          }
        });
      }
    }

    function revertPop(fromLocation) {
      var toLocation = history.location; // TODO: We could probably make this more reliable by
      // keeping a list of keys we've seen in sessionStorage.
      // Instead, we just default to 0 for keys we don't know.

      var toIndex = allKeys.indexOf(toLocation.key);
      if (toIndex === -1) toIndex = 0;
      var fromIndex = allKeys.indexOf(fromLocation.key);
      if (fromIndex === -1) fromIndex = 0;
      var delta = toIndex - fromIndex;

      if (delta) {
        forceNextPop = true;
        go(delta);
      }
    }

    var initialLocation = getDOMLocation(getHistoryState());
    var allKeys = [initialLocation.key]; // Public interface

    function createHref(location) {
      return basename + createPath(location);
    }

    function push(path, state) {
      var action = 'PUSH';
      var location = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;
        var href = createHref(location);
        var key = location.key,
            state = location.state;

        if (canUseHistory) {
          globalHistory.pushState({
            key: key,
            state: state
          }, null, href);

          if (forceRefresh) {
            window.location.href = href;
          } else {
            var prevIndex = allKeys.indexOf(history.location.key);
            var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
            nextKeys.push(location.key);
            allKeys = nextKeys;
            setState({
              action: action,
              location: location
            });
          }
        } else {
          window.location.href = href;
        }
      });
    }

    function replace(path, state) {
      var action = 'REPLACE';
      var location = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;
        var href = createHref(location);
        var key = location.key,
            state = location.state;

        if (canUseHistory) {
          globalHistory.replaceState({
            key: key,
            state: state
          }, null, href);

          if (forceRefresh) {
            window.location.replace(href);
          } else {
            var prevIndex = allKeys.indexOf(history.location.key);
            if (prevIndex !== -1) allKeys[prevIndex] = location.key;
            setState({
              action: action,
              location: location
            });
          }
        } else {
          window.location.replace(href);
        }
      });
    }

    function go(n) {
      globalHistory.go(n);
    }

    function goBack() {
      go(-1);
    }

    function goForward() {
      go(1);
    }

    var listenerCount = 0;

    function checkDOMListeners(delta) {
      listenerCount += delta;

      if (listenerCount === 1 && delta === 1) {
        window.addEventListener(PopStateEvent, handlePopState);
        if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
      } else if (listenerCount === 0) {
        window.removeEventListener(PopStateEvent, handlePopState);
        if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
      }
    }

    var isBlocked = false;

    function block(prompt) {
      if (prompt === void 0) {
        prompt = false;
      }

      var unblock = transitionManager.setPrompt(prompt);

      if (!isBlocked) {
        checkDOMListeners(1);
        isBlocked = true;
      }

      return function () {
        if (isBlocked) {
          isBlocked = false;
          checkDOMListeners(-1);
        }

        return unblock();
      };
    }

    function listen(listener) {
      var unlisten = transitionManager.appendListener(listener);
      checkDOMListeners(1);
      return function () {
        checkDOMListeners(-1);
        unlisten();
      };
    }

    var history = {
      length: globalHistory.length,
      action: 'POP',
      location: initialLocation,
      createHref: createHref,
      push: push,
      replace: replace,
      go: go,
      goBack: goBack,
      goForward: goForward,
      block: block,
      listen: listen
    };
    return history;
  }

  var HashChangeEvent$1 = 'hashchange';
  var HashPathCoders = {
    hashbang: {
      encodePath: function encodePath(path) {
        return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
      },
      decodePath: function decodePath(path) {
        return path.charAt(0) === '!' ? path.substr(1) : path;
      }
    },
    noslash: {
      encodePath: stripLeadingSlash,
      decodePath: addLeadingSlash
    },
    slash: {
      encodePath: addLeadingSlash,
      decodePath: addLeadingSlash
    }
  };

  function getHashPath() {
    // We can't use window.location.hash here because it's not
    // consistent across browsers - Firefox will pre-decode it!
    var href = window.location.href;
    var hashIndex = href.indexOf('#');
    return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
  }

  function pushHashPath(path) {
    window.location.hash = path;
  }

  function replaceHashPath(path) {
    var hashIndex = window.location.href.indexOf('#');
    window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
  }

  function createHashHistory(props) {
    if (props === void 0) {
      props = {};
    }

    !canUseDOM$1 ? invariant$2(false) : void 0;
    var globalHistory = window.history;
    var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
    var _props = props,
        _props$getUserConfirm = _props.getUserConfirmation,
        getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
        _props$hashType = _props.hashType,
        hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
    var _HashPathCoders$hashT = HashPathCoders[hashType],
        encodePath = _HashPathCoders$hashT.encodePath,
        decodePath = _HashPathCoders$hashT.decodePath;

    function getDOMLocation() {
      var path = decodePath(getHashPath());
      if (basename) path = stripBasename(path, basename);
      return createLocation(path);
    }

    var transitionManager = createTransitionManager();

    function setState(nextState) {
      _extends$9(history, nextState);

      history.length = globalHistory.length;
      transitionManager.notifyListeners(history.location, history.action);
    }

    var forceNextPop = false;
    var ignorePath = null;

    function handleHashChange() {
      var path = getHashPath();
      var encodedPath = encodePath(path);

      if (path !== encodedPath) {
        // Ensure we always have a properly-encoded hash.
        replaceHashPath(encodedPath);
      } else {
        var location = getDOMLocation();
        var prevLocation = history.location;
        if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.

        if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

        ignorePath = null;
        handlePop(location);
      }
    }

    function handlePop(location) {
      if (forceNextPop) {
        forceNextPop = false;
        setState();
      } else {
        var action = 'POP';
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
          if (ok) {
            setState({
              action: action,
              location: location
            });
          } else {
            revertPop(location);
          }
        });
      }
    }

    function revertPop(fromLocation) {
      var toLocation = history.location; // TODO: We could probably make this more reliable by
      // keeping a list of paths we've seen in sessionStorage.
      // Instead, we just default to 0 for paths we don't know.

      var toIndex = allPaths.lastIndexOf(createPath(toLocation));
      if (toIndex === -1) toIndex = 0;
      var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
      if (fromIndex === -1) fromIndex = 0;
      var delta = toIndex - fromIndex;

      if (delta) {
        forceNextPop = true;
        go(delta);
      }
    } // Ensure the hash is encoded properly before doing anything else.


    var path = getHashPath();
    var encodedPath = encodePath(path);
    if (path !== encodedPath) replaceHashPath(encodedPath);
    var initialLocation = getDOMLocation();
    var allPaths = [createPath(initialLocation)]; // Public interface

    function createHref(location) {
      return '#' + encodePath(basename + createPath(location));
    }

    function push(path, state) {
      var action = 'PUSH';
      var location = createLocation(path, undefined, undefined, history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;
        var path = createPath(location);
        var encodedPath = encodePath(basename + path);
        var hashChanged = getHashPath() !== encodedPath;

        if (hashChanged) {
          // We cannot tell if a hashchange was caused by a PUSH, so we'd
          // rather setState here and ignore the hashchange. The caveat here
          // is that other hash histories in the page will consider it a POP.
          ignorePath = path;
          pushHashPath(encodedPath);
          var prevIndex = allPaths.lastIndexOf(createPath(history.location));
          var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
          nextPaths.push(path);
          allPaths = nextPaths;
          setState({
            action: action,
            location: location
          });
        } else {
          setState();
        }
      });
    }

    function replace(path, state) {
      var action = 'REPLACE';
      var location = createLocation(path, undefined, undefined, history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;
        var path = createPath(location);
        var encodedPath = encodePath(basename + path);
        var hashChanged = getHashPath() !== encodedPath;

        if (hashChanged) {
          // We cannot tell if a hashchange was caused by a REPLACE, so we'd
          // rather setState here and ignore the hashchange. The caveat here
          // is that other hash histories in the page will consider it a POP.
          ignorePath = path;
          replaceHashPath(encodedPath);
        }

        var prevIndex = allPaths.indexOf(createPath(history.location));
        if (prevIndex !== -1) allPaths[prevIndex] = path;
        setState({
          action: action,
          location: location
        });
      });
    }

    function go(n) {
      globalHistory.go(n);
    }

    function goBack() {
      go(-1);
    }

    function goForward() {
      go(1);
    }

    var listenerCount = 0;

    function checkDOMListeners(delta) {
      listenerCount += delta;

      if (listenerCount === 1 && delta === 1) {
        window.addEventListener(HashChangeEvent$1, handleHashChange);
      } else if (listenerCount === 0) {
        window.removeEventListener(HashChangeEvent$1, handleHashChange);
      }
    }

    var isBlocked = false;

    function block(prompt) {
      if (prompt === void 0) {
        prompt = false;
      }

      var unblock = transitionManager.setPrompt(prompt);

      if (!isBlocked) {
        checkDOMListeners(1);
        isBlocked = true;
      }

      return function () {
        if (isBlocked) {
          isBlocked = false;
          checkDOMListeners(-1);
        }

        return unblock();
      };
    }

    function listen(listener) {
      var unlisten = transitionManager.appendListener(listener);
      checkDOMListeners(1);
      return function () {
        checkDOMListeners(-1);
        unlisten();
      };
    }

    var history = {
      length: globalHistory.length,
      action: 'POP',
      location: initialLocation,
      createHref: createHref,
      push: push,
      replace: replace,
      go: go,
      goBack: goBack,
      goForward: goForward,
      block: block,
      listen: listen
    };
    return history;
  }

  function clamp$2(n, lowerBound, upperBound) {
    return Math.min(Math.max(n, lowerBound), upperBound);
  }
  /**
   * Creates a history object that stores locations in memory.
   */


  function createMemoryHistory(props) {
    if (props === void 0) {
      props = {};
    }

    var _props = props,
        getUserConfirmation = _props.getUserConfirmation,
        _props$initialEntries = _props.initialEntries,
        initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
        _props$initialIndex = _props.initialIndex,
        initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
        _props$keyLength = _props.keyLength,
        keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
    var transitionManager = createTransitionManager();

    function setState(nextState) {
      _extends$9(history, nextState);

      history.length = history.entries.length;
      transitionManager.notifyListeners(history.location, history.action);
    }

    function createKey() {
      return Math.random().toString(36).substr(2, keyLength);
    }

    var index = clamp$2(initialIndex, 0, initialEntries.length - 1);
    var entries = initialEntries.map(function (entry) {
      return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
    }); // Public interface

    var createHref = createPath;

    function push(path, state) {
      var action = 'PUSH';
      var location = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;
        var prevIndex = history.index;
        var nextIndex = prevIndex + 1;
        var nextEntries = history.entries.slice(0);

        if (nextEntries.length > nextIndex) {
          nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
        } else {
          nextEntries.push(location);
        }

        setState({
          action: action,
          location: location,
          index: nextIndex,
          entries: nextEntries
        });
      });
    }

    function replace(path, state) {
      var action = 'REPLACE';
      var location = createLocation(path, state, createKey(), history.location);
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;
        history.entries[history.index] = location;
        setState({
          action: action,
          location: location
        });
      });
    }

    function go(n) {
      var nextIndex = clamp$2(history.index + n, 0, history.entries.length - 1);
      var action = 'POP';
      var location = history.entries[nextIndex];
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location,
            index: nextIndex
          });
        } else {
          // Mimic the behavior of DOM histories by
          // causing a render after a cancelled POP.
          setState();
        }
      });
    }

    function goBack() {
      go(-1);
    }

    function goForward() {
      go(1);
    }

    function canGo(n) {
      var nextIndex = history.index + n;
      return nextIndex >= 0 && nextIndex < history.entries.length;
    }

    function block(prompt) {
      if (prompt === void 0) {
        prompt = false;
      }

      return transitionManager.setPrompt(prompt);
    }

    function listen(listener) {
      return transitionManager.appendListener(listener);
    }

    var history = {
      length: entries.length,
      action: 'POP',
      location: entries[index],
      index: index,
      entries: entries,
      createHref: createHref,
      push: push,
      replace: replace,
      go: go,
      goBack: goBack,
      goForward: goForward,
      canGo: canGo,
      block: block,
      listen: listen
    };
    return history;
  }

  var isarray = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) == '[object Array]';
  };

  /**
   * Expose `pathToRegexp`.
   */
  var pathToRegexp_1 = pathToRegexp;
  var parse_1 = parse;
  var compile_1 = compile;
  var tokensToFunction_1 = tokensToFunction;
  var tokensToRegExp_1 = tokensToRegExp;

  /**
   * The main path matching regexp utility.
   *
   * @type {RegExp}
   */
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    '(\\\\.)',
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
    // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
    // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
    '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
  ].join('|'), 'g');

  /**
   * Parse a string for the raw tokens.
   *
   * @param  {string}  str
   * @param  {Object=} options
   * @return {!Array}
   */
  function parse (str, options) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path = '';
    var defaultDelimiter = options && options.delimiter || '/';
    var res;

    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path += str.slice(index, offset);
      index = offset + m.length;

      // Ignore already escaped sequences.
      if (escaped) {
        path += escaped[1];
        continue
      }

      var next = str[index];
      var prefix = res[2];
      var name = res[3];
      var capture = res[4];
      var group = res[5];
      var modifier = res[6];
      var asterisk = res[7];

      // Push the current path onto the tokens.
      if (path) {
        tokens.push(path);
        path = '';
      }

      var partial = prefix != null && next != null && next !== prefix;
      var repeat = modifier === '+' || modifier === '*';
      var optional = modifier === '?' || modifier === '*';
      var delimiter = res[2] || defaultDelimiter;
      var pattern = capture || group;

      tokens.push({
        name: name || key++,
        prefix: prefix || '',
        delimiter: delimiter,
        optional: optional,
        repeat: repeat,
        partial: partial,
        asterisk: !!asterisk,
        pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
      });
    }

    // Match any characters still remaining.
    if (index < str.length) {
      path += str.substr(index);
    }

    // If the path exists, push it onto the end.
    if (path) {
      tokens.push(path);
    }

    return tokens
  }

  /**
   * Compile a string to a template function for the path.
   *
   * @param  {string}             str
   * @param  {Object=}            options
   * @return {!function(Object=, Object=)}
   */
  function compile (str, options) {
    return tokensToFunction(parse(str, options))
  }

  /**
   * Prettier encoding of URI path segments.
   *
   * @param  {string}
   * @return {string}
   */
  function encodeURIComponentPretty (str) {
    return encodeURI(str).replace(/[\/?#]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase()
    })
  }

  /**
   * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
   *
   * @param  {string}
   * @return {string}
   */
  function encodeAsterisk (str) {
    return encodeURI(str).replace(/[?#]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase()
    })
  }

  /**
   * Expose a method for transforming tokens into the path function.
   */
  function tokensToFunction (tokens) {
    // Compile all the tokens into regexps.
    var matches = new Array(tokens.length);

    // Compile all the patterns before compilation.
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === 'object') {
        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
      }
    }

    return function (obj, opts) {
      var path = '';
      var data = obj || {};
      var options = opts || {};
      var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (typeof token === 'string') {
          path += token;

          continue
        }

        var value = data[token.name];
        var segment;

        if (value == null) {
          if (token.optional) {
            // Prepend partial segment prefixes.
            if (token.partial) {
              path += token.prefix;
            }

            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to be defined')
          }
        }

        if (isarray(value)) {
          if (!token.repeat) {
            throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
          }

          if (value.length === 0) {
            if (token.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + token.name + '" to not be empty')
            }
          }

          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j]);

            if (!matches[i].test(segment)) {
              throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
            }

            path += (j === 0 ? token.prefix : token.delimiter) + segment;
          }

          continue
        }

        segment = token.asterisk ? encodeAsterisk(value) : encode(value);

        if (!matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
        }

        path += token.prefix + segment;
      }

      return path
    }
  }

  /**
   * Escape a regular expression string.
   *
   * @param  {string} str
   * @return {string}
   */
  function escapeString (str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
  }

  /**
   * Escape the capturing group by escaping special characters and meaning.
   *
   * @param  {string} group
   * @return {string}
   */
  function escapeGroup (group) {
    return group.replace(/([=!:$\/()])/g, '\\$1')
  }

  /**
   * Attach the keys as a property of the regexp.
   *
   * @param  {!RegExp} re
   * @param  {Array}   keys
   * @return {!RegExp}
   */
  function attachKeys (re, keys) {
    re.keys = keys;
    return re
  }

  /**
   * Get the flags for a regexp from the options.
   *
   * @param  {Object} options
   * @return {string}
   */
  function flags (options) {
    return options.sensitive ? '' : 'i'
  }

  /**
   * Pull out keys from a regexp.
   *
   * @param  {!RegExp} path
   * @param  {!Array}  keys
   * @return {!RegExp}
   */
  function regexpToRegexp (path, keys) {
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);

    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          asterisk: false,
          pattern: null
        });
      }
    }

    return attachKeys(path, keys)
  }

  /**
   * Transform an array into a regexp.
   *
   * @param  {!Array}  path
   * @param  {Array}   keys
   * @param  {!Object} options
   * @return {!RegExp}
   */
  function arrayToRegexp (path, keys, options) {
    var parts = [];

    for (var i = 0; i < path.length; i++) {
      parts.push(pathToRegexp(path[i], keys, options).source);
    }

    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

    return attachKeys(regexp, keys)
  }

  /**
   * Create a path regexp from string input.
   *
   * @param  {string}  path
   * @param  {!Array}  keys
   * @param  {!Object} options
   * @return {!RegExp}
   */
  function stringToRegexp (path, keys, options) {
    return tokensToRegExp(parse(path, options), keys, options)
  }

  /**
   * Expose a function for taking tokens and returning a RegExp.
   *
   * @param  {!Array}          tokens
   * @param  {(Array|Object)=} keys
   * @param  {Object=}         options
   * @return {!RegExp}
   */
  function tokensToRegExp (tokens, keys, options) {
    if (!isarray(keys)) {
      options = /** @type {!Object} */ (keys || options);
      keys = [];
    }

    options = options || {};

    var strict = options.strict;
    var end = options.end !== false;
    var route = '';

    // Iterate over the tokens and create our regexp string.
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        route += escapeString(token);
      } else {
        var prefix = escapeString(token.prefix);
        var capture = '(?:' + token.pattern + ')';

        keys.push(token);

        if (token.repeat) {
          capture += '(?:' + prefix + capture + ')*';
        }

        if (token.optional) {
          if (!token.partial) {
            capture = '(?:' + prefix + '(' + capture + '))?';
          } else {
            capture = prefix + '(' + capture + ')?';
          }
        } else {
          capture = prefix + '(' + capture + ')';
        }

        route += capture;
      }
    }

    var delimiter = escapeString(options.delimiter || '/');
    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

    // In non-strict mode we allow a slash at the end of match. If the path to
    // match already ends with a slash, we remove it for consistency. The slash
    // is valid at the end of a path match, not in the middle. This is important
    // in non-ending mode, where "/test/" shouldn't match "/test//route".
    if (!strict) {
      route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
    }

    if (end) {
      route += '$';
    } else {
      // In non-ending mode, we need the capturing groups to match as much as
      // possible by using a positive lookahead to the end or next path segment.
      route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
    }

    return attachKeys(new RegExp('^' + route, flags(options)), keys)
  }

  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   *
   * @param  {(string|RegExp|Array)} path
   * @param  {(Array|Object)=}       keys
   * @param  {Object=}               options
   * @return {!RegExp}
   */
  function pathToRegexp (path, keys, options) {
    if (!isarray(keys)) {
      options = /** @type {!Object} */ (keys || options);
      keys = [];
    }

    options = options || {};

    if (path instanceof RegExp) {
      return regexpToRegexp(path, /** @type {!Array} */ (keys))
    }

    if (isarray(path)) {
      return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
    }

    return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
  }
  pathToRegexp_1.parse = parse_1;
  pathToRegexp_1.compile = compile_1;
  pathToRegexp_1.tokensToFunction = tokensToFunction_1;
  pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

  // TODO: Replace with React.createContext once we can assume React 16+

  var createNamedContext = function createNamedContext(name) {
    var context = createContext();
    context.Provider.displayName = name + ".Provider";
    context.Consumer.displayName = name + ".Consumer";
    return context;
  };

  var context =
  /*#__PURE__*/
  createNamedContext('Router');

  /**
   * The public API for putting history on context.
   */

  var Router =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Router, _React$Component);

    Router.computeRootMatch = function computeRootMatch(pathname) {
      return {
        path: "/",
        url: "/",
        params: {},
        isExact: pathname === "/"
      };
    };

    function Router(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.state = {
        location: props.history.location
      }; // This is a bit of a hack. We have to start listening for location
      // changes here in the constructor in case there are any <Redirect>s
      // on the initial render. If there are, they will replace/push when
      // they mount and since cDM fires in children before parents, we may
      // get a new location before the <Router> is mounted.

      _this._isMounted = false;
      _this._pendingLocation = null;

      if (!props.staticContext) {
        _this.unlisten = props.history.listen(function (location) {
          if (_this._isMounted) {
            _this.setState({
              location: location
            });
          } else {
            _this._pendingLocation = location;
          }
        });
      }

      return _this;
    }

    var _proto = Router.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this._isMounted = true;

      if (this._pendingLocation) {
        this.setState({
          location: this._pendingLocation
        });
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.unlisten) this.unlisten();
    };

    _proto.render = function render() {
      return react.createElement(context.Provider, {
        children: this.props.children || null,
        value: {
          history: this.props.history,
          location: this.state.location,
          match: Router.computeRootMatch(this.state.location.pathname),
          staticContext: this.props.staticContext
        }
      });
    };

    return Router;
  }(react.Component);

  /**
   * The public API for a <Router> that stores location in memory.
   */

  var MemoryRouter =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(MemoryRouter, _React$Component);

    function MemoryRouter() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.history = createMemoryHistory(_this.props);
      return _this;
    }

    var _proto = MemoryRouter.prototype;

    _proto.render = function render() {
      return react.createElement(Router, {
        history: this.history,
        children: this.props.children
      });
    };

    return MemoryRouter;
  }(react.Component);

  var Lifecycle =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Lifecycle, _React$Component);

    function Lifecycle() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = Lifecycle.prototype;

    _proto.componentDidMount = function componentDidMount() {
      if (this.props.onMount) this.props.onMount.call(this, this);
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      if (this.props.onUnmount) this.props.onUnmount.call(this, this);
    };

    _proto.render = function render() {
      return null;
    };

    return Lifecycle;
  }(react.Component);

  /**
   * The public API for prompting the user before navigating away from a screen.
   */

  function Prompt(_ref) {
    var message = _ref.message,
        _ref$when = _ref.when,
        when = _ref$when === void 0 ? true : _ref$when;
    return react.createElement(context.Consumer, null, function (context$$1) {
      !context$$1 ? invariant$2(false) : void 0;
      if (!when || context$$1.staticContext) return null;
      var method = context$$1.history.block;
      return react.createElement(Lifecycle, {
        onMount: function onMount(self) {
          self.release = method(message);
        },
        onUpdate: function onUpdate(self, prevProps) {
          if (prevProps.message !== message) {
            self.release();
            self.release = method(message);
          }
        },
        onUnmount: function onUnmount(self) {
          self.release();
        },
        message: message
      });
    });
  }

  var cache = {};
  var cacheLimit = 10000;
  var cacheCount = 0;

  function compilePath(path) {
    if (cache[path]) return cache[path];
    var generator = pathToRegexp_1.compile(path);

    if (cacheCount < cacheLimit) {
      cache[path] = generator;
      cacheCount++;
    }

    return generator;
  }
  /**
   * Public API for generating a URL pathname from a path and parameters.
   */


  function generatePath(path, params) {
    if (path === void 0) {
      path = "/";
    }

    if (params === void 0) {
      params = {};
    }

    return path === "/" ? path : compilePath(path)(params, {
      pretty: true
    });
  }

  /**
   * The public API for navigating programmatically with a component.
   */

  function Redirect(_ref) {
    var computedMatch = _ref.computedMatch,
        to = _ref.to,
        _ref$push = _ref.push,
        push = _ref$push === void 0 ? false : _ref$push;
    return react.createElement(context.Consumer, null, function (context$$1) {
      !context$$1 ? invariant$2(false) : void 0;
      var history = context$$1.history,
          staticContext = context$$1.staticContext;
      var method = push ? history.push : history.replace;
      var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends$9({}, to, {
        pathname: generatePath(to.pathname, computedMatch.params)
      }) : to); // When rendering in a static context,
      // set the new location immediately.

      if (staticContext) {
        method(location);
        return null;
      }

      return react.createElement(Lifecycle, {
        onMount: function onMount() {
          method(location);
        },
        onUpdate: function onUpdate(self, prevProps) {
          if (!locationsAreEqual(prevProps.to, location)) {
            method(location);
          }
        },
        to: to
      });
    });
  }

  var cache$1 = {};
  var cacheLimit$1 = 10000;
  var cacheCount$1 = 0;

  function compilePath$1(path, options) {
    var cacheKey = "" + options.end + options.strict + options.sensitive;
    var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
    if (pathCache[path]) return pathCache[path];
    var keys = [];
    var regexp = pathToRegexp_1(path, keys, options);
    var result = {
      regexp: regexp,
      keys: keys
    };

    if (cacheCount$1 < cacheLimit$1) {
      pathCache[path] = result;
      cacheCount$1++;
    }

    return result;
  }
  /**
   * Public API for matching a URL pathname to a path.
   */


  function matchPath(pathname, options) {
    if (options === void 0) {
      options = {};
    }

    if (typeof options === "string") options = {
      path: options
    };
    var _options = options,
        path = _options.path,
        _options$exact = _options.exact,
        exact = _options$exact === void 0 ? false : _options$exact,
        _options$strict = _options.strict,
        strict = _options$strict === void 0 ? false : _options$strict,
        _options$sensitive = _options.sensitive,
        sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
    var paths = [].concat(path);
    return paths.reduce(function (matched, path) {
      if (matched) return matched;

      var _compilePath = compilePath$1(path, {
        end: exact,
        strict: strict,
        sensitive: sensitive
      }),
          regexp = _compilePath.regexp,
          keys = _compilePath.keys;

      var match = regexp.exec(pathname);
      if (!match) return null;
      var url = match[0],
          values = match.slice(1);
      var isExact = pathname === url;
      if (exact && !isExact) return null;
      return {
        path: path,
        // the path used to match
        url: path === "/" && url === "" ? "/" : url,
        // the matched portion of the URL
        isExact: isExact,
        // whether or not we matched exactly
        params: keys.reduce(function (memo, key, index) {
          memo[key.name] = values[index];
          return memo;
        }, {})
      };
    }, null);
  }

  function isEmptyChildren(children) {
    return react.Children.count(children) === 0;
  }
  /**
   * The public API for matching a single path and rendering.
   */


  var Route$1 =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Route, _React$Component);

    function Route() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = Route.prototype;

    _proto.render = function render() {
      var _this = this;

      return react.createElement(context.Consumer, null, function (context$$1) {
        !context$$1 ? invariant$2(false) : void 0;
        var location = _this.props.location || context$$1.location;
        var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us
        : _this.props.path ? matchPath(location.pathname, _this.props) : context$$1.match;

        var props = _extends$9({}, context$$1, {
          location: location,
          match: match
        });

        var _this$props = _this.props,
            children = _this$props.children,
            component = _this$props.component,
            render = _this$props.render; // Preact uses an empty array as children by
        // default, so use null if that's the case.

        if (Array.isArray(children) && children.length === 0) {
          children = null;
        }

        if (typeof children === "function") {
          children = children(props);

          if (children === undefined) {

            children = null;
          }
        }

        return react.createElement(context.Provider, {
          value: props
        }, children && !isEmptyChildren(children) ? children : props.match ? component ? react.createElement(component, props) : render ? render(props) : null : null);
      });
    };

    return Route;
  }(react.Component);

  function addLeadingSlash$1(path) {
    return path.charAt(0) === "/" ? path : "/" + path;
  }

  function addBasename(basename, location) {
    if (!basename) return location;
    return _extends$9({}, location, {
      pathname: addLeadingSlash$1(basename) + location.pathname
    });
  }

  function stripBasename$1(basename, location) {
    if (!basename) return location;
    var base = addLeadingSlash$1(basename);
    if (location.pathname.indexOf(base) !== 0) return location;
    return _extends$9({}, location, {
      pathname: location.pathname.substr(base.length)
    });
  }

  function createURL(location) {
    return typeof location === "string" ? location : createPath(location);
  }

  function staticHandler(methodName) {
    return function () {
      invariant$2(false);
    };
  }

  function noop$3() {}
  /**
   * The public top-level API for a "static" <Router>, so-called because it
   * can't actually change the current location. Instead, it just records
   * location changes in a context object. Useful mainly in testing and
   * server-rendering scenarios.
   */


  var StaticRouter =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(StaticRouter, _React$Component);

    function StaticRouter() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

      _this.handlePush = function (location) {
        return _this.navigateTo(location, "PUSH");
      };

      _this.handleReplace = function (location) {
        return _this.navigateTo(location, "REPLACE");
      };

      _this.handleListen = function () {
        return noop$3;
      };

      _this.handleBlock = function () {
        return noop$3;
      };

      return _this;
    }

    var _proto = StaticRouter.prototype;

    _proto.navigateTo = function navigateTo(location, action) {
      var _this$props = this.props,
          _this$props$basename = _this$props.basename,
          basename = _this$props$basename === void 0 ? "" : _this$props$basename,
          context = _this$props.context;
      context.action = action;
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    };

    _proto.render = function render() {
      var _this$props2 = this.props,
          _this$props2$basename = _this$props2.basename,
          basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,
          _this$props2$context = _this$props2.context,
          context = _this$props2$context === void 0 ? {} : _this$props2$context,
          _this$props2$location = _this$props2.location,
          location = _this$props2$location === void 0 ? "/" : _this$props2$location,
          rest = _objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);

      var history = {
        createHref: function createHref(path) {
          return addLeadingSlash$1(basename + createURL(path));
        },
        action: "POP",
        location: stripBasename$1(basename, createLocation(location)),
        push: this.handlePush,
        replace: this.handleReplace,
        go: staticHandler("go"),
        goBack: staticHandler("goBack"),
        goForward: staticHandler("goForward"),
        listen: this.handleListen,
        block: this.handleBlock
      };
      return react.createElement(Router, _extends$9({}, rest, {
        history: history,
        staticContext: context
      }));
    };

    return StaticRouter;
  }(react.Component);

  /**
   * The public API for rendering the first <Route> that matches.
   */

  var Switch =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Switch, _React$Component);

    function Switch() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = Switch.prototype;

    _proto.render = function render() {
      var _this = this;

      return react.createElement(context.Consumer, null, function (context$$1) {
        !context$$1 ? invariant$2(false) : void 0;
        var location = _this.props.location || context$$1.location;
        var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()
        // here because toArray adds keys to all child elements and we do not want
        // to trigger an unmount/remount for two <Route>s that render the same
        // component at different URLs.

        react.Children.forEach(_this.props.children, function (child) {
          if (match == null && react.isValidElement(child)) {
            element = child;
            var path = child.props.path || child.props.from;
            match = path ? matchPath(location.pathname, _extends$9({}, child.props, {
              path: path
            })) : context$$1.match;
          }
        });
        return match ? react.cloneElement(element, {
          location: location,
          computedMatch: match
        }) : null;
      });
    };

    return Switch;
  }(react.Component);

  /**
   * A public higher-order component to access the imperative API
   */

  function withRouter(Component) {
    var C = function C(props) {
      var wrappedComponentRef = props.wrappedComponentRef,
          remainingProps = _objectWithoutPropertiesLoose(props, ["wrappedComponentRef"]);

      return react.createElement(Route$1, {
        children: function children(routeComponentProps) {
          return react.createElement(Component, _extends$9({}, remainingProps, routeComponentProps, {
            ref: wrappedComponentRef
          }));
        }
      });
    };

    C.displayName = "withRouter(" + (Component.displayName || Component.name) + ")";
    C.WrappedComponent = Component;

    return hoistNonReactStatics_cjs(C, Component);
  }

  /**
   * The public API for a <Router> that uses HTML5 history.
   */

  var BrowserRouter =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(BrowserRouter, _React$Component);

    function BrowserRouter() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.history = createBrowserHistory(_this.props);
      return _this;
    }

    var _proto = BrowserRouter.prototype;

    _proto.render = function render() {
      return react.createElement(Router, {
        history: this.history,
        children: this.props.children
      });
    };

    return BrowserRouter;
  }(react.Component);

  /**
   * The public API for a <Router> that uses window.location.hash.
   */

  var HashRouter =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(HashRouter, _React$Component);

    function HashRouter() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.history = createHashHistory(_this.props);
      return _this;
    }

    var _proto = HashRouter.prototype;

    _proto.render = function render() {
      return react.createElement(Router, {
        history: this.history,
        children: this.props.children
      });
    };

    return HashRouter;
  }(react.Component);

  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }
  /**
   * The public API for rendering a history-aware <a>.
   */


  var Link$1 =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(Link, _React$Component);

    function Link() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = Link.prototype;

    _proto.handleClick = function handleClick(event, history) {
      if (this.props.onClick) this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && ( // ignore everything but left clicks
      !this.props.target || this.props.target === "_self") && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();
          var method = this.props.replace ? history.replace : history.push;
          method(this.props.to);
        }
    };

    _proto.render = function render() {
      var _this = this;

      var _this$props = this.props,
          innerRef = _this$props.innerRef,
          replace = _this$props.replace,
          to = _this$props.to,
          rest = _objectWithoutPropertiesLoose(_this$props, ["innerRef", "replace", "to"]); // eslint-disable-line no-unused-vars


      return react.createElement(context.Consumer, null, function (context) {
        !context ? invariant$2(false) : void 0;
        var location = typeof to === "string" ? createLocation(to, null, null, context.location) : to;
        var href = location ? context.history.createHref(location) : "";
        return react.createElement("a", _extends$9({}, rest, {
          onClick: function onClick(event) {
            return _this.handleClick(event, context.history);
          },
          href: href,
          ref: innerRef
        }));
      });
    };

    return Link;
  }(react.Component);

  function joinClassnames() {
    for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
      classnames[_key] = arguments[_key];
    }

    return classnames.filter(function (i) {
      return i;
    }).join(" ");
  }
  /**
   * A <Link> wrapper that knows if it's "active" or not.
   */


  function NavLink$1(_ref) {
    var _ref$ariaCurrent = _ref["aria-current"],
        ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,
        _ref$activeClassName = _ref.activeClassName,
        activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,
        activeStyle = _ref.activeStyle,
        classNameProp = _ref.className,
        exact = _ref.exact,
        isActiveProp = _ref.isActive,
        location = _ref.location,
        strict = _ref.strict,
        styleProp = _ref.style,
        to = _ref.to,
        rest = _objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "strict", "style", "to"]);

    var path = typeof to === "object" ? to.pathname : to; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202

    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    return react.createElement(Route$1, {
      path: escapedPath,
      exact: exact,
      strict: strict,
      location: location,
      children: function children(_ref2) {
        var location = _ref2.location,
            match = _ref2.match;
        var isActive = !!(isActiveProp ? isActiveProp(match, location) : match);
        var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;
        var style = isActive ? _extends$9({}, styleProp, activeStyle) : styleProp;
        return react.createElement(Link$1, _extends$9({
          "aria-current": isActive && ariaCurrent || null,
          className: className,
          style: style,
          to: to
        }, rest));
      }
    });
  }

  var reactRouterDom = /*#__PURE__*/Object.freeze({
    BrowserRouter: BrowserRouter,
    HashRouter: HashRouter,
    Link: Link$1,
    NavLink: NavLink$1,
    MemoryRouter: MemoryRouter,
    Prompt: Prompt,
    Redirect: Redirect,
    Route: Route$1,
    Router: Router,
    StaticRouter: StaticRouter,
    Switch: Switch,
    generatePath: generatePath,
    matchPath: matchPath,
    withRouter: withRouter,
    __RouterContext: context
  });

  function arrowRenderer(_ref) {
  	var onMouseDown = _ref.onMouseDown;

  	return react.createElement('span', {
  		className: 'Select-arrow',
  		onMouseDown: onMouseDown
  	});
  }

  arrowRenderer.propTypes = {
  	onMouseDown: propTypes.func
  };

  var map = [{ 'base': 'A', 'letters': /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g }, { 'base': 'AA', 'letters': /[\uA732]/g }, { 'base': 'AE', 'letters': /[\u00C6\u01FC\u01E2]/g }, { 'base': 'AO', 'letters': /[\uA734]/g }, { 'base': 'AU', 'letters': /[\uA736]/g }, { 'base': 'AV', 'letters': /[\uA738\uA73A]/g }, { 'base': 'AY', 'letters': /[\uA73C]/g }, { 'base': 'B', 'letters': /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g }, { 'base': 'C', 'letters': /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g }, { 'base': 'D', 'letters': /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g }, { 'base': 'DZ', 'letters': /[\u01F1\u01C4]/g }, { 'base': 'Dz', 'letters': /[\u01F2\u01C5]/g }, { 'base': 'E', 'letters': /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g }, { 'base': 'F', 'letters': /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g }, { 'base': 'G', 'letters': /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g }, { 'base': 'H', 'letters': /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g }, { 'base': 'I', 'letters': /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g }, { 'base': 'J', 'letters': /[\u004A\u24BF\uFF2A\u0134\u0248]/g }, { 'base': 'K', 'letters': /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g }, { 'base': 'L', 'letters': /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g }, { 'base': 'LJ', 'letters': /[\u01C7]/g }, { 'base': 'Lj', 'letters': /[\u01C8]/g }, { 'base': 'M', 'letters': /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g }, { 'base': 'N', 'letters': /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g }, { 'base': 'NJ', 'letters': /[\u01CA]/g }, { 'base': 'Nj', 'letters': /[\u01CB]/g }, { 'base': 'O', 'letters': /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g }, { 'base': 'OI', 'letters': /[\u01A2]/g }, { 'base': 'OO', 'letters': /[\uA74E]/g }, { 'base': 'OU', 'letters': /[\u0222]/g }, { 'base': 'P', 'letters': /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g }, { 'base': 'Q', 'letters': /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g }, { 'base': 'R', 'letters': /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g }, { 'base': 'S', 'letters': /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g }, { 'base': 'T', 'letters': /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g }, { 'base': 'TZ', 'letters': /[\uA728]/g }, { 'base': 'U', 'letters': /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g }, { 'base': 'V', 'letters': /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g }, { 'base': 'VY', 'letters': /[\uA760]/g }, { 'base': 'W', 'letters': /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g }, { 'base': 'X', 'letters': /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g }, { 'base': 'Y', 'letters': /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g }, { 'base': 'Z', 'letters': /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g }, { 'base': 'a', 'letters': /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g }, { 'base': 'aa', 'letters': /[\uA733]/g }, { 'base': 'ae', 'letters': /[\u00E6\u01FD\u01E3]/g }, { 'base': 'ao', 'letters': /[\uA735]/g }, { 'base': 'au', 'letters': /[\uA737]/g }, { 'base': 'av', 'letters': /[\uA739\uA73B]/g }, { 'base': 'ay', 'letters': /[\uA73D]/g }, { 'base': 'b', 'letters': /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g }, { 'base': 'c', 'letters': /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g }, { 'base': 'd', 'letters': /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g }, { 'base': 'dz', 'letters': /[\u01F3\u01C6]/g }, { 'base': 'e', 'letters': /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g }, { 'base': 'f', 'letters': /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g }, { 'base': 'g', 'letters': /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g }, { 'base': 'h', 'letters': /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g }, { 'base': 'hv', 'letters': /[\u0195]/g }, { 'base': 'i', 'letters': /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g }, { 'base': 'j', 'letters': /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g }, { 'base': 'k', 'letters': /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g }, { 'base': 'l', 'letters': /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g }, { 'base': 'lj', 'letters': /[\u01C9]/g }, { 'base': 'm', 'letters': /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g }, { 'base': 'n', 'letters': /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g }, { 'base': 'nj', 'letters': /[\u01CC]/g }, { 'base': 'o', 'letters': /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g }, { 'base': 'oi', 'letters': /[\u01A3]/g }, { 'base': 'ou', 'letters': /[\u0223]/g }, { 'base': 'oo', 'letters': /[\uA74F]/g }, { 'base': 'p', 'letters': /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g }, { 'base': 'q', 'letters': /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g }, { 'base': 'r', 'letters': /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g }, { 'base': 's', 'letters': /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g }, { 'base': 't', 'letters': /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g }, { 'base': 'tz', 'letters': /[\uA729]/g }, { 'base': 'u', 'letters': /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g }, { 'base': 'v', 'letters': /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g }, { 'base': 'vy', 'letters': /[\uA761]/g }, { 'base': 'w', 'letters': /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g }, { 'base': 'x', 'letters': /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g }, { 'base': 'y', 'letters': /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g }, { 'base': 'z', 'letters': /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g }];

  function stripDiacritics(str) {
  	for (var i = 0; i < map.length; i++) {
  		str = str.replace(map[i].letters, map[i].base);
  	}
  	return str;
  }

  function trim(str) {
      return str.replace(/^\s+|\s+$/g, '');
  }

  function filterOptions(options, filterValue, excludeOptions, props) {
  	var _this = this;

  	if (props.ignoreAccents) {
  		filterValue = stripDiacritics(filterValue);
  	}

  	if (props.ignoreCase) {
  		filterValue = filterValue.toLowerCase();
  	}

  	if (props.trimFilter) {
  		filterValue = trim(filterValue);
  	}

  	if (excludeOptions) excludeOptions = excludeOptions.map(function (i) {
  		return i[props.valueKey];
  	});

  	return options.filter(function (option) {
  		if (excludeOptions && excludeOptions.indexOf(option[props.valueKey]) > -1) return false;
  		if (props.filterOption) return props.filterOption.call(_this, option, filterValue);
  		if (!filterValue) return true;
  		var valueTest = String(option[props.valueKey]);
  		var labelTest = String(option[props.labelKey]);

  		if (props.ignoreAccents) {
  			if (props.matchProp !== 'label') valueTest = stripDiacritics(valueTest);
  			if (props.matchProp !== 'value') labelTest = stripDiacritics(labelTest);
  		}

  		if (props.ignoreCase) {
  			if (props.matchProp !== 'label') valueTest = valueTest.toLowerCase();
  			if (props.matchProp !== 'value') labelTest = labelTest.toLowerCase();
  		}
  		return props.matchPos === 'start' ? props.matchProp !== 'label' && valueTest.substr(0, filterValue.length) === filterValue || props.matchProp !== 'value' && labelTest.substr(0, filterValue.length) === filterValue : props.matchProp !== 'label' && valueTest.indexOf(filterValue) >= 0 || props.matchProp !== 'value' && labelTest.indexOf(filterValue) >= 0;
  	});
  }

  function menuRenderer(_ref) {
  	var focusedOption = _ref.focusedOption,
  	    instancePrefix = _ref.instancePrefix,
  	    labelKey = _ref.labelKey,
  	    onFocus = _ref.onFocus,
  	    onSelect = _ref.onSelect,
  	    optionClassName = _ref.optionClassName,
  	    optionComponent = _ref.optionComponent,
  	    optionRenderer = _ref.optionRenderer,
  	    options = _ref.options,
  	    valueArray = _ref.valueArray,
  	    valueKey = _ref.valueKey,
  	    onOptionRef = _ref.onOptionRef;

  	var Option = optionComponent;

  	return options.map(function (option, i) {
  		var isSelected = valueArray && valueArray.some(function (x) {
  			return x[valueKey] == option[valueKey];
  		});
  		var isFocused = option === focusedOption;
  		var optionClass = classnames(optionClassName, {
  			'Select-option': true,
  			'is-selected': isSelected,
  			'is-focused': isFocused,
  			'is-disabled': option.disabled
  		});

  		return react.createElement(
  			Option,
  			{
  				className: optionClass,
  				instancePrefix: instancePrefix,
  				isDisabled: option.disabled,
  				isFocused: isFocused,
  				isSelected: isSelected,
  				key: 'option-' + i + '-' + option[valueKey],
  				onFocus: onFocus,
  				onSelect: onSelect,
  				option: option,
  				optionIndex: i,
  				ref: function ref(_ref2) {
  					onOptionRef(_ref2, isFocused);
  				}
  			},
  			optionRenderer(option, i)
  		);
  	});
  }

  function clearRenderer() {
  	return react.createElement('span', {
  		className: 'Select-clear',
  		dangerouslySetInnerHTML: { __html: '&times;' }
  	});
  }

  var _typeof$2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };





  var classCallCheck$1 = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();





  var defineProperty$3 = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends$c = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };



  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };









  var objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var Option = function (_React$Component) {
  	inherits(Option, _React$Component);

  	function Option(props) {
  		classCallCheck$1(this, Option);

  		var _this = possibleConstructorReturn(this, (Option.__proto__ || Object.getPrototypeOf(Option)).call(this, props));

  		_this.handleMouseDown = _this.handleMouseDown.bind(_this);
  		_this.handleMouseEnter = _this.handleMouseEnter.bind(_this);
  		_this.handleMouseMove = _this.handleMouseMove.bind(_this);
  		_this.handleTouchStart = _this.handleTouchStart.bind(_this);
  		_this.handleTouchEnd = _this.handleTouchEnd.bind(_this);
  		_this.handleTouchMove = _this.handleTouchMove.bind(_this);
  		_this.onFocus = _this.onFocus.bind(_this);
  		return _this;
  	}

  	createClass$1(Option, [{
  		key: 'blockEvent',
  		value: function blockEvent(event) {
  			event.preventDefault();
  			event.stopPropagation();
  			if (event.target.tagName !== 'A' || !('href' in event.target)) {
  				return;
  			}
  			if (event.target.target) {
  				window.open(event.target.href, event.target.target);
  			} else {
  				window.location.href = event.target.href;
  			}
  		}
  	}, {
  		key: 'handleMouseDown',
  		value: function handleMouseDown(event) {
  			event.preventDefault();
  			event.stopPropagation();
  			this.props.onSelect(this.props.option, event);
  		}
  	}, {
  		key: 'handleMouseEnter',
  		value: function handleMouseEnter(event) {
  			this.onFocus(event);
  		}
  	}, {
  		key: 'handleMouseMove',
  		value: function handleMouseMove(event) {
  			this.onFocus(event);
  		}
  	}, {
  		key: 'handleTouchEnd',
  		value: function handleTouchEnd(event) {
  			// Check if the view is being dragged, In this case
  			// we don't want to fire the click event (because the user only wants to scroll)
  			if (this.dragging) return;

  			this.handleMouseDown(event);
  		}
  	}, {
  		key: 'handleTouchMove',
  		value: function handleTouchMove(event) {
  			// Set a flag that the view is being dragged
  			this.dragging = true;
  		}
  	}, {
  		key: 'handleTouchStart',
  		value: function handleTouchStart(event) {
  			// Set a flag that the view is not being dragged
  			this.dragging = false;
  		}
  	}, {
  		key: 'onFocus',
  		value: function onFocus(event) {
  			if (!this.props.isFocused) {
  				this.props.onFocus(this.props.option, event);
  			}
  		}
  	}, {
  		key: 'render',
  		value: function render() {
  			var _props = this.props,
  			    option = _props.option,
  			    instancePrefix = _props.instancePrefix,
  			    optionIndex = _props.optionIndex;

  			var className = classnames(this.props.className, option.className);

  			return option.disabled ? react.createElement(
  				'div',
  				{ className: className,
  					onMouseDown: this.blockEvent,
  					onClick: this.blockEvent },
  				this.props.children
  			) : react.createElement(
  				'div',
  				{ className: className,
  					style: option.style,
  					role: 'option',
  					'aria-label': option.label,
  					onMouseDown: this.handleMouseDown,
  					onMouseEnter: this.handleMouseEnter,
  					onMouseMove: this.handleMouseMove,
  					onTouchStart: this.handleTouchStart,
  					onTouchMove: this.handleTouchMove,
  					onTouchEnd: this.handleTouchEnd,
  					id: instancePrefix + '-option-' + optionIndex,
  					title: option.title },
  				this.props.children
  			);
  		}
  	}]);
  	return Option;
  }(react.Component);



  Option.propTypes = {
  	children: propTypes.node,
  	className: propTypes.string, // className (based on mouse position)
  	instancePrefix: propTypes.string.isRequired, // unique prefix for the ids (used for aria)
  	isDisabled: propTypes.bool, // the option is disabled
  	isFocused: propTypes.bool, // the option is focused
  	isSelected: propTypes.bool, // the option is selected
  	onFocus: propTypes.func, // method to handle mouseEnter on option element
  	onSelect: propTypes.func, // method to handle click on option element
  	onUnfocus: propTypes.func, // method to handle mouseLeave on option element
  	option: propTypes.object.isRequired, // object that is base for that option
  	optionIndex: propTypes.number // index of the option, used to generate unique ids for aria
  };

  var Value = function (_React$Component) {
  	inherits(Value, _React$Component);

  	function Value(props) {
  		classCallCheck$1(this, Value);

  		var _this = possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).call(this, props));

  		_this.handleMouseDown = _this.handleMouseDown.bind(_this);
  		_this.onRemove = _this.onRemove.bind(_this);
  		_this.handleTouchEndRemove = _this.handleTouchEndRemove.bind(_this);
  		_this.handleTouchMove = _this.handleTouchMove.bind(_this);
  		_this.handleTouchStart = _this.handleTouchStart.bind(_this);
  		return _this;
  	}

  	createClass$1(Value, [{
  		key: 'handleMouseDown',
  		value: function handleMouseDown(event) {
  			if (event.type === 'mousedown' && event.button !== 0) {
  				return;
  			}
  			if (this.props.onClick) {
  				event.stopPropagation();
  				this.props.onClick(this.props.value, event);
  				return;
  			}
  			if (this.props.value.href) {
  				event.stopPropagation();
  			}
  		}
  	}, {
  		key: 'onRemove',
  		value: function onRemove(event) {
  			event.preventDefault();
  			event.stopPropagation();
  			this.props.onRemove(this.props.value);
  		}
  	}, {
  		key: 'handleTouchEndRemove',
  		value: function handleTouchEndRemove(event) {
  			// Check if the view is being dragged, In this case
  			// we don't want to fire the click event (because the user only wants to scroll)
  			if (this.dragging) return;

  			// Fire the mouse events
  			this.onRemove(event);
  		}
  	}, {
  		key: 'handleTouchMove',
  		value: function handleTouchMove(event) {
  			// Set a flag that the view is being dragged
  			this.dragging = true;
  		}
  	}, {
  		key: 'handleTouchStart',
  		value: function handleTouchStart(event) {
  			// Set a flag that the view is not being dragged
  			this.dragging = false;
  		}
  	}, {
  		key: 'renderRemoveIcon',
  		value: function renderRemoveIcon() {
  			if (this.props.disabled || !this.props.onRemove) return;
  			return react.createElement(
  				'span',
  				{ className: 'Select-value-icon',
  					'aria-hidden': 'true',
  					onMouseDown: this.onRemove,
  					onTouchEnd: this.handleTouchEndRemove,
  					onTouchStart: this.handleTouchStart,
  					onTouchMove: this.handleTouchMove },
  				'\xD7'
  			);
  		}
  	}, {
  		key: 'renderLabel',
  		value: function renderLabel() {
  			var className = 'Select-value-label';
  			return this.props.onClick || this.props.value.href ? react.createElement(
  				'a',
  				{ className: className, href: this.props.value.href, target: this.props.value.target, onMouseDown: this.handleMouseDown, onTouchEnd: this.handleMouseDown },
  				this.props.children
  			) : react.createElement(
  				'span',
  				{ className: className, role: 'option', 'aria-selected': 'true', id: this.props.id },
  				this.props.children
  			);
  		}
  	}, {
  		key: 'render',
  		value: function render() {
  			return react.createElement(
  				'div',
  				{ className: classnames('Select-value', this.props.value.className),
  					style: this.props.value.style,
  					title: this.props.value.title
  				},
  				this.renderRemoveIcon(),
  				this.renderLabel()
  			);
  		}
  	}]);
  	return Value;
  }(react.Component);



  Value.propTypes = {
  	children: propTypes.node,
  	disabled: propTypes.bool, // disabled prop passed to ReactSelect
  	id: propTypes.string, // Unique id for the value - used for aria
  	onClick: propTypes.func, // method to handle click on value label
  	onRemove: propTypes.func, // method to handle removal of the value
  	value: propTypes.object.isRequired // the option object for this value
  };

  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/react-select
  */
  var stringifyValue = function stringifyValue(value) {
  	return typeof value === 'string' ? value : value !== null && JSON.stringify(value) || '';
  };

  var stringOrNode = propTypes.oneOfType([propTypes.string, propTypes.node]);
  var stringOrNumber = propTypes.oneOfType([propTypes.string, propTypes.number]);

  var instanceId = 1;

  var Select$1 = function (_React$Component) {
  	inherits(Select, _React$Component);

  	function Select(props) {
  		classCallCheck$1(this, Select);

  		var _this = possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).call(this, props));

  		['clearValue', 'focusOption', 'handleInputBlur', 'handleInputChange', 'handleInputFocus', 'handleInputValueChange', 'handleKeyDown', 'handleMenuScroll', 'handleMouseDown', 'handleMouseDownOnArrow', 'handleMouseDownOnMenu', 'handleRequired', 'handleTouchOutside', 'handleTouchMove', 'handleTouchStart', 'handleTouchEnd', 'handleTouchEndClearValue', 'handleValueClick', 'getOptionLabel', 'onOptionRef', 'removeValue', 'selectValue'].forEach(function (fn) {
  			return _this[fn] = _this[fn].bind(_this);
  		});

  		_this.state = {
  			inputValue: '',
  			isFocused: false,
  			isOpen: false,
  			isPseudoFocused: false,
  			required: false
  		};
  		return _this;
  	}

  	createClass$1(Select, [{
  		key: 'componentWillMount',
  		value: function componentWillMount() {
  			this._instancePrefix = 'react-select-' + (this.props.instanceId || ++instanceId) + '-';
  			var valueArray = this.getValueArray(this.props.value);

  			if (this.props.required) {
  				this.setState({
  					required: this.handleRequired(valueArray[0], this.props.multi)
  				});
  			}
  		}
  	}, {
  		key: 'componentDidMount',
  		value: function componentDidMount() {
  			if (typeof this.props.autofocus !== 'undefined' && typeof console !== 'undefined') {
  				console.warn('Warning: The autofocus prop has changed to autoFocus, support will be removed after react-select@1.0');
  			}
  			if (this.props.autoFocus || this.props.autofocus) {
  				this.focus();
  			}
  		}
  	}, {
  		key: 'componentWillReceiveProps',
  		value: function componentWillReceiveProps(nextProps) {
  			var valueArray = this.getValueArray(nextProps.value, nextProps);

  			if (nextProps.required) {
  				this.setState({
  					required: this.handleRequired(valueArray[0], nextProps.multi)
  				});
  			} else if (this.props.required) {
  				// Used to be required but it's not any more
  				this.setState({ required: false });
  			}
  		}
  	}, {
  		key: 'componentDidUpdate',
  		value: function componentDidUpdate(prevProps, prevState) {
  			// focus to the selected option
  			if (this.menu && this.focused && this.state.isOpen && !this.hasScrolledToOption) {
  				var focusedOptionNode = reactDom_2(this.focused);
  				var menuNode = reactDom_2(this.menu);
  				menuNode.scrollTop = focusedOptionNode.offsetTop;
  				this.hasScrolledToOption = true;
  			} else if (!this.state.isOpen) {
  				this.hasScrolledToOption = false;
  			}

  			if (this._scrollToFocusedOptionOnUpdate && this.focused && this.menu) {
  				this._scrollToFocusedOptionOnUpdate = false;
  				var focusedDOM = reactDom_2(this.focused);
  				var menuDOM = reactDom_2(this.menu);
  				var focusedRect = focusedDOM.getBoundingClientRect();
  				var menuRect = menuDOM.getBoundingClientRect();
  				if (focusedRect.bottom > menuRect.bottom) {
  					menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight;
  				} else if (focusedRect.top < menuRect.top) {
  					menuDOM.scrollTop = focusedDOM.offsetTop;
  				}
  			}
  			if (this.props.scrollMenuIntoView && this.menuContainer) {
  				var menuContainerRect = this.menuContainer.getBoundingClientRect();
  				if (window.innerHeight < menuContainerRect.bottom + this.props.menuBuffer) {
  					window.scrollBy(0, menuContainerRect.bottom + this.props.menuBuffer - window.innerHeight);
  				}
  			}
  			if (prevProps.disabled !== this.props.disabled) {
  				this.setState({ isFocused: false }); // eslint-disable-line react/no-did-update-set-state
  				this.closeMenu();
  			}
  			if (prevState.isOpen !== this.state.isOpen) {
  				this.toggleTouchOutsideEvent(this.state.isOpen);
  				var handler = this.state.isOpen ? this.props.onOpen : this.props.onClose;
  				handler && handler();
  			}
  		}
  	}, {
  		key: 'componentWillUnmount',
  		value: function componentWillUnmount() {
  			this.toggleTouchOutsideEvent(false);
  		}
  	}, {
  		key: 'toggleTouchOutsideEvent',
  		value: function toggleTouchOutsideEvent(enabled) {
  			if (enabled) {
  				if (!document.addEventListener && document.attachEvent) {
  					document.attachEvent('ontouchstart', this.handleTouchOutside);
  				} else {
  					document.addEventListener('touchstart', this.handleTouchOutside);
  				}
  			} else {
  				if (!document.removeEventListener && document.detachEvent) {
  					document.detachEvent('ontouchstart', this.handleTouchOutside);
  				} else {
  					document.removeEventListener('touchstart', this.handleTouchOutside);
  				}
  			}
  		}
  	}, {
  		key: 'handleTouchOutside',
  		value: function handleTouchOutside(event) {
  			// handle touch outside on ios to dismiss menu
  			if (this.wrapper && !this.wrapper.contains(event.target)) {
  				this.closeMenu();
  			}
  		}
  	}, {
  		key: 'focus',
  		value: function focus() {
  			if (!this.input) return;
  			this.input.focus();
  		}
  	}, {
  		key: 'blurInput',
  		value: function blurInput() {
  			if (!this.input) return;
  			this.input.blur();
  		}
  	}, {
  		key: 'handleTouchMove',
  		value: function handleTouchMove(event) {
  			// Set a flag that the view is being dragged
  			this.dragging = true;
  		}
  	}, {
  		key: 'handleTouchStart',
  		value: function handleTouchStart(event) {
  			// Set a flag that the view is not being dragged
  			this.dragging = false;
  		}
  	}, {
  		key: 'handleTouchEnd',
  		value: function handleTouchEnd(event) {
  			// Check if the view is being dragged, In this case
  			// we don't want to fire the click event (because the user only wants to scroll)
  			if (this.dragging) return;

  			// Fire the mouse events
  			this.handleMouseDown(event);
  		}
  	}, {
  		key: 'handleTouchEndClearValue',
  		value: function handleTouchEndClearValue(event) {
  			// Check if the view is being dragged, In this case
  			// we don't want to fire the click event (because the user only wants to scroll)
  			if (this.dragging) return;

  			// Clear the value
  			this.clearValue(event);
  		}
  	}, {
  		key: 'handleMouseDown',
  		value: function handleMouseDown(event) {
  			// if the event was triggered by a mousedown and not the primary
  			// button, or if the component is disabled, ignore it.
  			if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
  				return;
  			}

  			if (event.target.tagName === 'INPUT') {
  				return;
  			}

  			// prevent default event handlers
  			event.stopPropagation();
  			event.preventDefault();

  			// for the non-searchable select, toggle the menu
  			if (!this.props.searchable) {
  				// TODO: This code means that if a select is searchable, onClick the options menu will not appear, only on subsequent click will it open.
  				this.focus();
  				return this.setState({
  					isOpen: !this.state.isOpen
  				});
  			}

  			if (this.state.isFocused) {
  				// On iOS, we can get into a state where we think the input is focused but it isn't really,
  				// since iOS ignores programmatic calls to input.focus() that weren't triggered by a click event.
  				// Call focus() again here to be safe.
  				this.focus();

  				var input = this.input;
  				if (typeof input.getInput === 'function') {
  					// Get the actual DOM input if the ref is an <AutosizeInput /> component
  					input = input.getInput();
  				}

  				// clears the value so that the cursor will be at the end of input when the component re-renders
  				input.value = '';

  				// if the input is focused, ensure the menu is open
  				this.setState({
  					isOpen: true,
  					isPseudoFocused: false
  				});
  			} else {
  				// otherwise, focus the input and open the menu
  				this._openAfterFocus = this.props.openOnClick;
  				this.focus();
  			}
  		}
  	}, {
  		key: 'handleMouseDownOnArrow',
  		value: function handleMouseDownOnArrow(event) {
  			// if the event was triggered by a mousedown and not the primary
  			// button, or if the component is disabled, ignore it.
  			if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
  				return;
  			}
  			// If the menu isn't open, let the event bubble to the main handleMouseDown
  			if (!this.state.isOpen) {
  				return;
  			}
  			// prevent default event handlers
  			event.stopPropagation();
  			event.preventDefault();
  			// close the menu
  			this.closeMenu();
  		}
  	}, {
  		key: 'handleMouseDownOnMenu',
  		value: function handleMouseDownOnMenu(event) {
  			// if the event was triggered by a mousedown and not the primary
  			// button, or if the component is disabled, ignore it.
  			if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
  				return;
  			}
  			event.stopPropagation();
  			event.preventDefault();

  			this._openAfterFocus = true;
  			this.focus();
  		}
  	}, {
  		key: 'closeMenu',
  		value: function closeMenu() {
  			if (this.props.onCloseResetsInput) {
  				this.setState({
  					isOpen: false,
  					isPseudoFocused: this.state.isFocused && !this.props.multi,
  					inputValue: this.handleInputValueChange('')
  				});
  			} else {
  				this.setState({
  					isOpen: false,
  					isPseudoFocused: this.state.isFocused && !this.props.multi
  				});
  			}
  			this.hasScrolledToOption = false;
  		}
  	}, {
  		key: 'handleInputFocus',
  		value: function handleInputFocus(event) {
  			if (this.props.disabled) return;
  			var isOpen = this.state.isOpen || this._openAfterFocus || this.props.openOnFocus;
  			if (this.props.onFocus) {
  				this.props.onFocus(event);
  			}
  			this.setState({
  				isFocused: true,
  				isOpen: isOpen
  			});
  			this._openAfterFocus = false;
  		}
  	}, {
  		key: 'handleInputBlur',
  		value: function handleInputBlur(event) {
  			// The check for menu.contains(activeElement) is necessary to prevent IE11's scrollbar from closing the menu in certain contexts.
  			if (this.menu && (this.menu === document.activeElement || this.menu.contains(document.activeElement))) {
  				this.focus();
  				return;
  			}

  			if (this.props.onBlur) {
  				this.props.onBlur(event);
  			}
  			var onBlurredState = {
  				isFocused: false,
  				isOpen: false,
  				isPseudoFocused: false
  			};
  			if (this.props.onBlurResetsInput) {
  				onBlurredState.inputValue = this.handleInputValueChange('');
  			}
  			this.setState(onBlurredState);
  		}
  	}, {
  		key: 'handleInputChange',
  		value: function handleInputChange(event) {
  			var newInputValue = event.target.value;

  			if (this.state.inputValue !== event.target.value) {
  				newInputValue = this.handleInputValueChange(newInputValue);
  			}

  			this.setState({
  				isOpen: true,
  				isPseudoFocused: false,
  				inputValue: newInputValue
  			});
  		}
  	}, {
  		key: 'handleInputValueChange',
  		value: function handleInputValueChange(newValue) {
  			if (this.props.onInputChange) {
  				var nextState = this.props.onInputChange(newValue);
  				// Note: != used deliberately here to catch undefined and null
  				if (nextState != null && (typeof nextState === 'undefined' ? 'undefined' : _typeof$2(nextState)) !== 'object') {
  					newValue = '' + nextState;
  				}
  			}
  			return newValue;
  		}
  	}, {
  		key: 'handleKeyDown',
  		value: function handleKeyDown(event) {
  			if (this.props.disabled) return;

  			if (typeof this.props.onInputKeyDown === 'function') {
  				this.props.onInputKeyDown(event);
  				if (event.defaultPrevented) {
  					return;
  				}
  			}

  			switch (event.keyCode) {
  				case 8:
  					// backspace
  					if (!this.state.inputValue && this.props.backspaceRemoves) {
  						event.preventDefault();
  						this.popValue();
  					}
  					return;
  				case 9:
  					// tab
  					if (event.shiftKey || !this.state.isOpen || !this.props.tabSelectsValue) {
  						return;
  					}
  					event.preventDefault();
  					this.selectFocusedOption();
  					return;
  				case 13:
  					// enter
  					event.preventDefault();
  					event.stopPropagation();
  					if (this.state.isOpen) {
  						this.selectFocusedOption();
  					} else {
  						this.focusNextOption();
  					}
  					return;
  					break;
  				case 27:
  					// escape
  					if (this.state.isOpen) {
  						this.closeMenu();
  						event.stopPropagation();
  					} else if (this.props.clearable && this.props.escapeClearsValue) {
  						this.clearValue(event);
  						event.stopPropagation();
  					}
  					break;
  				case 32:
  					// space
  					if (this.props.searchable) {
  						return;
  					}
  					event.preventDefault();
  					if (!this.state.isOpen) {
  						this.focusNextOption();
  						return;
  					}
  					event.stopPropagation();
  					this.selectFocusedOption();
  					break;
  				case 38:
  					// up
  					this.focusPreviousOption();
  					break;
  				case 40:
  					// down
  					this.focusNextOption();
  					break;
  				case 33:
  					// page up
  					this.focusPageUpOption();
  					break;
  				case 34:
  					// page down
  					this.focusPageDownOption();
  					break;
  				case 35:
  					// end key
  					if (event.shiftKey) {
  						return;
  					}
  					this.focusEndOption();
  					break;
  				case 36:
  					// home key
  					if (event.shiftKey) {
  						return;
  					}
  					this.focusStartOption();
  					break;
  				case 46:
  					// delete
  					if (!this.state.inputValue && this.props.deleteRemoves) {
  						event.preventDefault();
  						this.popValue();
  					}
  					return;
  				default:
  					return;
  			}
  			event.preventDefault();
  		}
  	}, {
  		key: 'handleValueClick',
  		value: function handleValueClick(option, event) {
  			if (!this.props.onValueClick) return;
  			this.props.onValueClick(option, event);
  		}
  	}, {
  		key: 'handleMenuScroll',
  		value: function handleMenuScroll(event) {
  			if (!this.props.onMenuScrollToBottom) return;
  			var target = event.target;

  			if (target.scrollHeight > target.offsetHeight && target.scrollHeight - target.offsetHeight - target.scrollTop <= 0) {
  				this.props.onMenuScrollToBottom();
  			}
  		}
  	}, {
  		key: 'handleRequired',
  		value: function handleRequired(value, multi) {
  			if (!value) return true;
  			return multi ? value.length === 0 : Object.keys(value).length === 0;
  		}
  	}, {
  		key: 'getOptionLabel',
  		value: function getOptionLabel(op) {
  			return op[this.props.labelKey];
  		}

  		/**
     * Turns a value into an array from the given options
     * @param	{String|Number|Array}	value		- the value of the select input
     * @param	{Object}		nextProps	- optionally specify the nextProps so the returned array uses the latest configuration
     * @returns	{Array}	the value of the select represented in an array
     */

  	}, {
  		key: 'getValueArray',
  		value: function getValueArray(value, nextProps) {
  			var _this2 = this;

  			/** support optionally passing in the `nextProps` so `componentWillReceiveProps` updates will function as expected */
  			var props = (typeof nextProps === 'undefined' ? 'undefined' : _typeof$2(nextProps)) === 'object' ? nextProps : this.props;
  			if (props.multi) {
  				if (typeof value === 'string') {
  					value = value.split(props.delimiter);
  				}
  				if (!Array.isArray(value)) {
  					if (value === null || value === undefined) return [];
  					value = [value];
  				}
  				return value.map(function (value) {
  					return _this2.expandValue(value, props);
  				}).filter(function (i) {
  					return i;
  				});
  			}
  			var expandedValue = this.expandValue(value, props);
  			return expandedValue ? [expandedValue] : [];
  		}

  		/**
     * Retrieve a value from the given options and valueKey
     * @param	{String|Number|Array}	value	- the selected value(s)
     * @param	{Object}		props	- the Select component's props (or nextProps)
     */

  	}, {
  		key: 'expandValue',
  		value: function expandValue(value, props) {
  			var valueType = typeof value === 'undefined' ? 'undefined' : _typeof$2(value);
  			if (valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') return value;
  			var options = props.options,
  			    valueKey = props.valueKey;

  			if (!options) return;
  			for (var i = 0; i < options.length; i++) {
  				if (String(options[i][valueKey]) === String(value)) return options[i];
  			}
  		}
  	}, {
  		key: 'setValue',
  		value: function setValue(value) {
  			var _this3 = this;

  			if (this.props.autoBlur) {
  				this.blurInput();
  			}
  			if (this.props.required) {
  				var required = this.handleRequired(value, this.props.multi);
  				this.setState({ required: required });
  			}
  			if (this.props.onChange) {
  				if (this.props.simpleValue && value) {
  					value = this.props.multi ? value.map(function (i) {
  						return i[_this3.props.valueKey];
  					}).join(this.props.delimiter) : value[this.props.valueKey];
  				}
  				this.props.onChange(value);
  			}
  		}
  	}, {
  		key: 'selectValue',
  		value: function selectValue(value) {
  			var _this4 = this;

  			// NOTE: we actually add/set the value in a callback to make sure the
  			// input value is empty to avoid styling issues in Chrome
  			if (this.props.closeOnSelect) {
  				this.hasScrolledToOption = false;
  			}
  			if (this.props.multi) {
  				var updatedValue = this.props.onSelectResetsInput ? '' : this.state.inputValue;
  				this.setState({
  					focusedIndex: null,
  					inputValue: this.handleInputValueChange(updatedValue),
  					isOpen: !this.props.closeOnSelect
  				}, function () {
  					var valueArray = _this4.getValueArray(_this4.props.value);
  					if (valueArray.some(function (i) {
  						return i[_this4.props.valueKey] === value[_this4.props.valueKey];
  					})) {
  						_this4.removeValue(value);
  					} else {
  						_this4.addValue(value);
  					}
  				});
  			} else {
  				this.setState({
  					inputValue: this.handleInputValueChange(''),
  					isOpen: !this.props.closeOnSelect,
  					isPseudoFocused: this.state.isFocused
  				}, function () {
  					_this4.setValue(value);
  				});
  			}
  		}
  	}, {
  		key: 'addValue',
  		value: function addValue(value) {
  			var valueArray = this.getValueArray(this.props.value);
  			var visibleOptions = this._visibleOptions.filter(function (val) {
  				return !val.disabled;
  			});
  			var lastValueIndex = visibleOptions.indexOf(value);
  			this.setValue(valueArray.concat(value));
  			if (visibleOptions.length - 1 === lastValueIndex) {
  				// the last option was selected; focus the second-last one
  				this.focusOption(visibleOptions[lastValueIndex - 1]);
  			} else if (visibleOptions.length > lastValueIndex) {
  				// focus the option below the selected one
  				this.focusOption(visibleOptions[lastValueIndex + 1]);
  			}
  		}
  	}, {
  		key: 'popValue',
  		value: function popValue() {
  			var valueArray = this.getValueArray(this.props.value);
  			if (!valueArray.length) return;
  			if (valueArray[valueArray.length - 1].clearableValue === false) return;
  			this.setValue(this.props.multi ? valueArray.slice(0, valueArray.length - 1) : null);
  		}
  	}, {
  		key: 'removeValue',
  		value: function removeValue(value) {
  			var _this5 = this;

  			var valueArray = this.getValueArray(this.props.value);
  			this.setValue(valueArray.filter(function (i) {
  				return i[_this5.props.valueKey] !== value[_this5.props.valueKey];
  			}));
  			this.focus();
  		}
  	}, {
  		key: 'clearValue',
  		value: function clearValue(event) {
  			// if the event was triggered by a mousedown and not the primary
  			// button, ignore it.
  			if (event && event.type === 'mousedown' && event.button !== 0) {
  				return;
  			}
  			event.stopPropagation();
  			event.preventDefault();
  			this.setValue(this.getResetValue());
  			this.setState({
  				isOpen: false,
  				inputValue: this.handleInputValueChange('')
  			}, this.focus);
  		}
  	}, {
  		key: 'getResetValue',
  		value: function getResetValue() {
  			if (this.props.resetValue !== undefined) {
  				return this.props.resetValue;
  			} else if (this.props.multi) {
  				return [];
  			} else {
  				return null;
  			}
  		}
  	}, {
  		key: 'focusOption',
  		value: function focusOption(option) {
  			this.setState({
  				focusedOption: option
  			});
  		}
  	}, {
  		key: 'focusNextOption',
  		value: function focusNextOption() {
  			this.focusAdjacentOption('next');
  		}
  	}, {
  		key: 'focusPreviousOption',
  		value: function focusPreviousOption() {
  			this.focusAdjacentOption('previous');
  		}
  	}, {
  		key: 'focusPageUpOption',
  		value: function focusPageUpOption() {
  			this.focusAdjacentOption('page_up');
  		}
  	}, {
  		key: 'focusPageDownOption',
  		value: function focusPageDownOption() {
  			this.focusAdjacentOption('page_down');
  		}
  	}, {
  		key: 'focusStartOption',
  		value: function focusStartOption() {
  			this.focusAdjacentOption('start');
  		}
  	}, {
  		key: 'focusEndOption',
  		value: function focusEndOption() {
  			this.focusAdjacentOption('end');
  		}
  	}, {
  		key: 'focusAdjacentOption',
  		value: function focusAdjacentOption(dir) {
  			var options = this._visibleOptions.map(function (option, index) {
  				return { option: option, index: index };
  			}).filter(function (option) {
  				return !option.option.disabled;
  			});
  			this._scrollToFocusedOptionOnUpdate = true;
  			if (!this.state.isOpen) {
  				this.setState({
  					isOpen: true,
  					inputValue: '',
  					focusedOption: this._focusedOption || (options.length ? options[dir === 'next' ? 0 : options.length - 1].option : null)
  				});
  				return;
  			}
  			if (!options.length) return;
  			var focusedIndex = -1;
  			for (var i = 0; i < options.length; i++) {
  				if (this._focusedOption === options[i].option) {
  					focusedIndex = i;
  					break;
  				}
  			}
  			if (dir === 'next' && focusedIndex !== -1) {
  				focusedIndex = (focusedIndex + 1) % options.length;
  			} else if (dir === 'previous') {
  				if (focusedIndex > 0) {
  					focusedIndex = focusedIndex - 1;
  				} else {
  					focusedIndex = options.length - 1;
  				}
  			} else if (dir === 'start') {
  				focusedIndex = 0;
  			} else if (dir === 'end') {
  				focusedIndex = options.length - 1;
  			} else if (dir === 'page_up') {
  				var potentialIndex = focusedIndex - this.props.pageSize;
  				if (potentialIndex < 0) {
  					focusedIndex = 0;
  				} else {
  					focusedIndex = potentialIndex;
  				}
  			} else if (dir === 'page_down') {
  				var potentialIndex = focusedIndex + this.props.pageSize;
  				if (potentialIndex > options.length - 1) {
  					focusedIndex = options.length - 1;
  				} else {
  					focusedIndex = potentialIndex;
  				}
  			}

  			if (focusedIndex === -1) {
  				focusedIndex = 0;
  			}

  			this.setState({
  				focusedIndex: options[focusedIndex].index,
  				focusedOption: options[focusedIndex].option
  			});
  		}
  	}, {
  		key: 'getFocusedOption',
  		value: function getFocusedOption() {
  			return this._focusedOption;
  		}
  	}, {
  		key: 'selectFocusedOption',
  		value: function selectFocusedOption() {
  			if (this._focusedOption) {
  				return this.selectValue(this._focusedOption);
  			}
  		}
  	}, {
  		key: 'renderLoading',
  		value: function renderLoading() {
  			if (!this.props.isLoading) return;
  			return react.createElement(
  				'span',
  				{ className: 'Select-loading-zone', 'aria-hidden': 'true' },
  				react.createElement('span', { className: 'Select-loading' })
  			);
  		}
  	}, {
  		key: 'renderValue',
  		value: function renderValue(valueArray, isOpen) {
  			var _this6 = this;

  			var renderLabel = this.props.valueRenderer || this.getOptionLabel;
  			var ValueComponent = this.props.valueComponent;
  			if (!valueArray.length) {
  				return !this.state.inputValue ? react.createElement(
  					'div',
  					{ className: 'Select-placeholder' },
  					this.props.placeholder
  				) : null;
  			}
  			var onClick = this.props.onValueClick ? this.handleValueClick : null;
  			if (this.props.multi) {
  				return valueArray.map(function (value, i) {
  					return react.createElement(
  						ValueComponent,
  						{
  							id: _this6._instancePrefix + '-value-' + i,
  							instancePrefix: _this6._instancePrefix,
  							disabled: _this6.props.disabled || value.clearableValue === false,
  							key: 'value-' + i + '-' + value[_this6.props.valueKey],
  							onClick: onClick,
  							onRemove: _this6.removeValue,
  							value: value
  						},
  						renderLabel(value, i),
  						react.createElement(
  							'span',
  							{ className: 'Select-aria-only' },
  							'\xA0'
  						)
  					);
  				});
  			} else if (!this.state.inputValue) {
  				if (isOpen) onClick = null;
  				return react.createElement(
  					ValueComponent,
  					{
  						id: this._instancePrefix + '-value-item',
  						disabled: this.props.disabled,
  						instancePrefix: this._instancePrefix,
  						onClick: onClick,
  						value: valueArray[0]
  					},
  					renderLabel(valueArray[0])
  				);
  			}
  		}
  	}, {
  		key: 'renderInput',
  		value: function renderInput(valueArray, focusedOptionIndex) {
  			var _classNames,
  			    _this7 = this;

  			var className = classnames('Select-input', this.props.inputProps.className);
  			var isOpen = !!this.state.isOpen;

  			var ariaOwns = classnames((_classNames = {}, defineProperty$3(_classNames, this._instancePrefix + '-list', isOpen), defineProperty$3(_classNames, this._instancePrefix + '-backspace-remove-message', this.props.multi && !this.props.disabled && this.state.isFocused && !this.state.inputValue), _classNames));
  			var inputProps = _extends$c({}, this.props.inputProps, {
  				role: 'combobox',
  				'aria-expanded': '' + isOpen,
  				'aria-owns': ariaOwns,
  				'aria-haspopup': '' + isOpen,
  				'aria-activedescendant': isOpen ? this._instancePrefix + '-option-' + focusedOptionIndex : this._instancePrefix + '-value',
  				'aria-describedby': this.props['aria-describedby'],
  				'aria-labelledby': this.props['aria-labelledby'],
  				'aria-label': this.props['aria-label'],
  				className: className,
  				tabIndex: this.props.tabIndex,
  				onBlur: this.handleInputBlur,
  				onChange: this.handleInputChange,
  				onFocus: this.handleInputFocus,
  				ref: function ref(_ref) {
  					return _this7.input = _ref;
  				},
  				required: this.state.required,
  				value: this.state.inputValue
  			});

  			if (this.props.inputRenderer) {
  				return this.props.inputRenderer(inputProps);
  			}

  			if (this.props.disabled || !this.props.searchable) {
  				var _props$inputProps = this.props.inputProps,
  				    inputClassName = _props$inputProps.inputClassName,
  				    divProps = objectWithoutProperties(_props$inputProps, ['inputClassName']);


  				var _ariaOwns = classnames(defineProperty$3({}, this._instancePrefix + '-list', isOpen));
  				return react.createElement('div', _extends$c({}, divProps, {
  					role: 'combobox',
  					'aria-expanded': isOpen,
  					'aria-owns': _ariaOwns,
  					'aria-activedescendant': isOpen ? this._instancePrefix + '-option-' + focusedOptionIndex : this._instancePrefix + '-value',
  					'aria-labelledby': this.props['aria-labelledby'],
  					'aria-label': this.props['aria-label'],
  					className: className,
  					tabIndex: this.props.tabIndex || 0,
  					onBlur: this.handleInputBlur,
  					onFocus: this.handleInputFocus,
  					ref: function ref(_ref2) {
  						return _this7.input = _ref2;
  					},
  					'aria-disabled': '' + !!this.props.disabled,
  					style: { border: 0, width: 1, display: 'inline-block' } }));
  			}

  			if (this.props.autosize) {
  				return react.createElement(AutosizeInput, _extends$c({ id: this.props.id }, inputProps, { minWidth: '5' }));
  			}
  			return react.createElement(
  				'div',
  				{ className: className, key: 'input-wrap' },
  				react.createElement('input', _extends$c({ id: this.props.id }, inputProps))
  			);
  		}
  	}, {
  		key: 'renderClear',
  		value: function renderClear() {
  			var valueArray = this.getValueArray(this.props.value);
  			if (!this.props.clearable || !valueArray.length || this.props.disabled || this.props.isLoading) return;
  			var clear = this.props.clearRenderer();

  			return react.createElement(
  				'span',
  				{ className: 'Select-clear-zone', title: this.props.multi ? this.props.clearAllText : this.props.clearValueText,
  					'aria-label': this.props.multi ? this.props.clearAllText : this.props.clearValueText,
  					onMouseDown: this.clearValue,
  					onTouchStart: this.handleTouchStart,
  					onTouchMove: this.handleTouchMove,
  					onTouchEnd: this.handleTouchEndClearValue
  				},
  				clear
  			);
  		}
  	}, {
  		key: 'renderArrow',
  		value: function renderArrow() {
  			if (!this.props.arrowRenderer) return;

  			var onMouseDown = this.handleMouseDownOnArrow;
  			var isOpen = this.state.isOpen;
  			var arrow = this.props.arrowRenderer({ onMouseDown: onMouseDown, isOpen: isOpen });

  			if (!arrow) {
  				return null;
  			}

  			return react.createElement(
  				'span',
  				{
  					className: 'Select-arrow-zone',
  					onMouseDown: onMouseDown
  				},
  				arrow
  			);
  		}
  	}, {
  		key: 'filterOptions',
  		value: function filterOptions$$1(excludeOptions) {
  			var filterValue = this.state.inputValue;
  			var options = this.props.options || [];
  			if (this.props.filterOptions) {
  				// Maintain backwards compatibility with boolean attribute
  				var filterOptions$$1 = typeof this.props.filterOptions === 'function' ? this.props.filterOptions : filterOptions;

  				return filterOptions$$1(options, filterValue, excludeOptions, {
  					filterOption: this.props.filterOption,
  					ignoreAccents: this.props.ignoreAccents,
  					ignoreCase: this.props.ignoreCase,
  					labelKey: this.props.labelKey,
  					matchPos: this.props.matchPos,
  					matchProp: this.props.matchProp,
  					valueKey: this.props.valueKey,
  					trimFilter: this.props.trimFilter
  				});
  			} else {
  				return options;
  			}
  		}
  	}, {
  		key: 'onOptionRef',
  		value: function onOptionRef(ref, isFocused) {
  			if (isFocused) {
  				this.focused = ref;
  			}
  		}
  	}, {
  		key: 'renderMenu',
  		value: function renderMenu(options, valueArray, focusedOption) {
  			if (options && options.length) {
  				return this.props.menuRenderer({
  					focusedOption: focusedOption,
  					focusOption: this.focusOption,
  					inputValue: this.state.inputValue,
  					instancePrefix: this._instancePrefix,
  					labelKey: this.props.labelKey,
  					onFocus: this.focusOption,
  					onSelect: this.selectValue,
  					optionClassName: this.props.optionClassName,
  					optionComponent: this.props.optionComponent,
  					optionRenderer: this.props.optionRenderer || this.getOptionLabel,
  					options: options,
  					selectValue: this.selectValue,
  					removeValue: this.removeValue,
  					valueArray: valueArray,
  					valueKey: this.props.valueKey,
  					onOptionRef: this.onOptionRef
  				});
  			} else if (this.props.noResultsText) {
  				return react.createElement(
  					'div',
  					{ className: 'Select-noresults' },
  					this.props.noResultsText
  				);
  			} else {
  				return null;
  			}
  		}
  	}, {
  		key: 'renderHiddenField',
  		value: function renderHiddenField(valueArray) {
  			var _this8 = this;

  			if (!this.props.name) return;
  			if (this.props.joinValues) {
  				var value = valueArray.map(function (i) {
  					return stringifyValue(i[_this8.props.valueKey]);
  				}).join(this.props.delimiter);
  				return react.createElement('input', {
  					type: 'hidden',
  					ref: function ref(_ref3) {
  						return _this8.value = _ref3;
  					},
  					name: this.props.name,
  					value: value,
  					disabled: this.props.disabled });
  			}
  			return valueArray.map(function (item, index) {
  				return react.createElement('input', { key: 'hidden.' + index,
  					type: 'hidden',
  					ref: 'value' + index,
  					name: _this8.props.name,
  					value: stringifyValue(item[_this8.props.valueKey]),
  					disabled: _this8.props.disabled });
  			});
  		}
  	}, {
  		key: 'getFocusableOptionIndex',
  		value: function getFocusableOptionIndex(selectedOption) {
  			var options = this._visibleOptions;
  			if (!options.length) return null;

  			var valueKey = this.props.valueKey;
  			var focusedOption = this.state.focusedOption || selectedOption;
  			if (focusedOption && !focusedOption.disabled) {
  				var focusedOptionIndex = -1;
  				options.some(function (option, index) {
  					var isOptionEqual = option[valueKey] === focusedOption[valueKey];
  					if (isOptionEqual) {
  						focusedOptionIndex = index;
  					}
  					return isOptionEqual;
  				});
  				if (focusedOptionIndex !== -1) {
  					return focusedOptionIndex;
  				}
  			}

  			for (var i = 0; i < options.length; i++) {
  				if (!options[i].disabled) return i;
  			}
  			return null;
  		}
  	}, {
  		key: 'renderOuter',
  		value: function renderOuter(options, valueArray, focusedOption) {
  			var _this9 = this;

  			var menu = this.renderMenu(options, valueArray, focusedOption);
  			if (!menu) {
  				return null;
  			}

  			return react.createElement(
  				'div',
  				{ ref: function ref(_ref5) {
  						return _this9.menuContainer = _ref5;
  					}, className: 'Select-menu-outer', style: this.props.menuContainerStyle },
  				react.createElement(
  					'div',
  					{ ref: function ref(_ref4) {
  							return _this9.menu = _ref4;
  						}, role: 'listbox', tabIndex: -1, className: 'Select-menu', id: this._instancePrefix + '-list',
  						style: this.props.menuStyle,
  						onScroll: this.handleMenuScroll,
  						onMouseDown: this.handleMouseDownOnMenu },
  					menu
  				)
  			);
  		}
  	}, {
  		key: 'render',
  		value: function render() {
  			var _this10 = this;

  			var valueArray = this.getValueArray(this.props.value);
  			var options = this._visibleOptions = this.filterOptions(this.props.multi && this.props.removeSelected ? valueArray : null);
  			var isOpen = this.state.isOpen;
  			if (this.props.multi && !options.length && valueArray.length && !this.state.inputValue) isOpen = false;
  			var focusedOptionIndex = this.getFocusableOptionIndex(valueArray[0]);

  			var focusedOption = null;
  			if (focusedOptionIndex !== null) {
  				focusedOption = this._focusedOption = options[focusedOptionIndex];
  			} else {
  				focusedOption = this._focusedOption = null;
  			}
  			var className = classnames('Select', this.props.className, {
  				'Select--multi': this.props.multi,
  				'Select--single': !this.props.multi,
  				'is-clearable': this.props.clearable,
  				'is-disabled': this.props.disabled,
  				'is-focused': this.state.isFocused,
  				'is-loading': this.props.isLoading,
  				'is-open': isOpen,
  				'is-pseudo-focused': this.state.isPseudoFocused,
  				'is-searchable': this.props.searchable,
  				'has-value': valueArray.length,
  				'Select--rtl': this.props.rtl
  			});

  			var removeMessage = null;
  			if (this.props.multi && !this.props.disabled && valueArray.length && !this.state.inputValue && this.state.isFocused && this.props.backspaceRemoves) {
  				removeMessage = react.createElement(
  					'span',
  					{ id: this._instancePrefix + '-backspace-remove-message', className: 'Select-aria-only', 'aria-live': 'assertive' },
  					this.props.backspaceToRemoveMessage.replace('{label}', valueArray[valueArray.length - 1][this.props.labelKey])
  				);
  			}

  			return react.createElement(
  				'div',
  				{ ref: function ref(_ref7) {
  						return _this10.wrapper = _ref7;
  					},
  					className: className,
  					style: this.props.wrapperStyle },
  				this.renderHiddenField(valueArray),
  				react.createElement(
  					'div',
  					{ ref: function ref(_ref6) {
  							return _this10.control = _ref6;
  						},
  						className: 'Select-control',
  						style: this.props.style,
  						onKeyDown: this.handleKeyDown,
  						onMouseDown: this.handleMouseDown,
  						onTouchEnd: this.handleTouchEnd,
  						onTouchStart: this.handleTouchStart,
  						onTouchMove: this.handleTouchMove
  					},
  					react.createElement(
  						'span',
  						{ className: 'Select-multi-value-wrapper', id: this._instancePrefix + '-value' },
  						this.renderValue(valueArray, isOpen),
  						this.renderInput(valueArray, focusedOptionIndex)
  					),
  					removeMessage,
  					this.renderLoading(),
  					this.renderClear(),
  					this.renderArrow()
  				),
  				isOpen ? this.renderOuter(options, valueArray, focusedOption) : null
  			);
  		}
  	}]);
  	return Select;
  }(react.Component);



  Select$1.propTypes = {
  	'aria-describedby': propTypes.string, // html id(s) of element(s) that should be used to describe this input (for assistive tech)
  	'aria-label': propTypes.string, // aria label (for assistive tech)
  	'aria-labelledby': propTypes.string, // html id of an element that should be used as the label (for assistive tech)
  	arrowRenderer: propTypes.func, // create the drop-down caret element
  	autoBlur: propTypes.bool, // automatically blur the component when an option is selected
  	autoFocus: propTypes.bool, // autofocus the component on mount
  	autofocus: propTypes.bool, // deprecated; use autoFocus instead
  	autosize: propTypes.bool, // whether to enable autosizing or not
  	backspaceRemoves: propTypes.bool, // whether backspace removes an item if there is no text input
  	backspaceToRemoveMessage: propTypes.string, // message to use for screenreaders to press backspace to remove the current item - {label} is replaced with the item label
  	className: propTypes.string, // className for the outer element
  	clearAllText: stringOrNode, // title for the "clear" control when multi: true
  	clearRenderer: propTypes.func, // create clearable x element
  	clearValueText: stringOrNode, // title for the "clear" control
  	clearable: propTypes.bool, // should it be possible to reset value
  	closeOnSelect: propTypes.bool, // whether to close the menu when a value is selected
  	deleteRemoves: propTypes.bool, // whether delete removes an item if there is no text input
  	delimiter: propTypes.string, // delimiter to use to join multiple values for the hidden field value
  	disabled: propTypes.bool, // whether the Select is disabled or not
  	escapeClearsValue: propTypes.bool, // whether escape clears the value when the menu is closed
  	filterOption: propTypes.func, // method to filter a single option (option, filterString)
  	filterOptions: propTypes.any, // boolean to enable default filtering or function to filter the options array ([options], filterString, [values])
  	id: propTypes.string, // html id to set on the input element for accessibility or tests
  	ignoreAccents: propTypes.bool, // whether to strip diacritics when filtering
  	ignoreCase: propTypes.bool, // whether to perform case-insensitive filtering
  	inputProps: propTypes.object, // custom attributes for the Input
  	inputRenderer: propTypes.func, // returns a custom input component
  	instanceId: propTypes.string, // set the components instanceId
  	isLoading: propTypes.bool, // whether the Select is loading externally or not (such as options being loaded)
  	joinValues: propTypes.bool, // joins multiple values into a single form field with the delimiter (legacy mode)
  	labelKey: propTypes.string, // path of the label value in option objects
  	matchPos: propTypes.string, // (any|start) match the start or entire string when filtering
  	matchProp: propTypes.string, // (any|label|value) which option property to filter on
  	menuBuffer: propTypes.number, // optional buffer (in px) between the bottom of the viewport and the bottom of the menu
  	menuContainerStyle: propTypes.object, // optional style to apply to the menu container
  	menuRenderer: propTypes.func, // renders a custom menu with options
  	menuStyle: propTypes.object, // optional style to apply to the menu
  	multi: propTypes.bool, // multi-value input
  	name: propTypes.string, // generates a hidden <input /> tag with this field name for html forms
  	noResultsText: stringOrNode, // placeholder displayed when there are no matching search results
  	onBlur: propTypes.func, // onBlur handler: function (event) {}
  	onBlurResetsInput: propTypes.bool, // whether input is cleared on blur
  	onChange: propTypes.func, // onChange handler: function (newValue) {}
  	onClose: propTypes.func, // fires when the menu is closed
  	onCloseResetsInput: propTypes.bool, // whether input is cleared when menu is closed through the arrow
  	onFocus: propTypes.func, // onFocus handler: function (event) {}
  	onInputChange: propTypes.func, // onInputChange handler: function (inputValue) {}
  	onInputKeyDown: propTypes.func, // input keyDown handler: function (event) {}
  	onMenuScrollToBottom: propTypes.func, // fires when the menu is scrolled to the bottom; can be used to paginate options
  	onOpen: propTypes.func, // fires when the menu is opened
  	onSelectResetsInput: propTypes.bool, // whether input is cleared on select (works only for multiselect)
  	onValueClick: propTypes.func, // onClick handler for value labels: function (value, event) {}
  	openOnClick: propTypes.bool, // boolean to control opening the menu when the control is clicked
  	openOnFocus: propTypes.bool, // always open options menu on focus
  	optionClassName: propTypes.string, // additional class(es) to apply to the <Option /> elements
  	optionComponent: propTypes.func, // option component to render in dropdown
  	optionRenderer: propTypes.func, // optionRenderer: function (option) {}
  	options: propTypes.array, // array of options
  	pageSize: propTypes.number, // number of entries to page when using page up/down keys
  	placeholder: stringOrNode, // field placeholder, displayed when there's no value
  	removeSelected: propTypes.bool, // whether the selected option is removed from the dropdown on multi selects
  	required: propTypes.bool, // applies HTML5 required attribute when needed
  	resetValue: propTypes.any, // value to use when you clear the control
  	rtl: propTypes.bool, // set to true in order to use react-select in right-to-left direction
  	scrollMenuIntoView: propTypes.bool, // boolean to enable the viewport to shift so that the full menu fully visible when engaged
  	searchable: propTypes.bool, // whether to enable searching feature or not
  	simpleValue: propTypes.bool, // pass the value to onChange as a simple value (legacy pre 1.0 mode), defaults to false
  	style: propTypes.object, // optional style to apply to the control
  	tabIndex: stringOrNumber, // optional tab index of the control
  	tabSelectsValue: propTypes.bool, // whether to treat tabbing out while focused to be value selection
  	trimFilter: propTypes.bool, // whether to trim whitespace around filter value
  	value: propTypes.any, // initial field value
  	valueComponent: propTypes.func, // value component to render
  	valueKey: propTypes.string, // path of the label value in option objects
  	valueRenderer: propTypes.func, // valueRenderer: function (option) {}
  	wrapperStyle: propTypes.object // optional style to apply to the component wrapper
  };

  Select$1.defaultProps = {
  	arrowRenderer: arrowRenderer,
  	autosize: true,
  	backspaceRemoves: true,
  	backspaceToRemoveMessage: 'Press backspace to remove {label}',
  	clearable: true,
  	clearAllText: 'Clear all',
  	clearRenderer: clearRenderer,
  	clearValueText: 'Clear value',
  	closeOnSelect: true,
  	deleteRemoves: true,
  	delimiter: ',',
  	disabled: false,
  	escapeClearsValue: true,
  	filterOptions: filterOptions,
  	ignoreAccents: true,
  	ignoreCase: true,
  	inputProps: {},
  	isLoading: false,
  	joinValues: false,
  	labelKey: 'label',
  	matchPos: 'any',
  	matchProp: 'any',
  	menuBuffer: 0,
  	menuRenderer: menuRenderer,
  	multi: false,
  	noResultsText: 'No results found',
  	onBlurResetsInput: true,
  	onSelectResetsInput: true,
  	onCloseResetsInput: true,
  	openOnClick: true,
  	optionComponent: Option,
  	pageSize: 5,
  	placeholder: 'Select...',
  	removeSelected: true,
  	required: false,
  	rtl: false,
  	scrollMenuIntoView: true,
  	searchable: true,
  	simpleValue: false,
  	tabSelectsValue: true,
  	trimFilter: true,
  	valueComponent: Value,
  	valueKey: 'value'
  };

  var propTypes$1c = {
  	autoload: propTypes.bool.isRequired, // automatically call the `loadOptions` prop on-mount; defaults to true
  	cache: propTypes.any, // object to use to cache results; set to null/false to disable caching
  	children: propTypes.func.isRequired, // Child function responsible for creating the inner Select component; (props: Object): PropTypes.element
  	ignoreAccents: propTypes.bool, // strip diacritics when filtering; defaults to true
  	ignoreCase: propTypes.bool, // perform case-insensitive filtering; defaults to true
  	loadOptions: propTypes.func.isRequired, // callback to load options asynchronously; (inputValue: string, callback: Function): ?Promise
  	loadingPlaceholder: propTypes.oneOfType([// replaces the placeholder while options are loading
  	propTypes.string, propTypes.node]),
  	multi: propTypes.bool, // multi-value input
  	noResultsText: propTypes.oneOfType([// field noResultsText, displayed when no options come back from the server
  	propTypes.string, propTypes.node]),
  	onChange: propTypes.func, // onChange handler: function (newValue) {}
  	onInputChange: propTypes.func, // optional for keeping track of what is being typed
  	options: propTypes.array.isRequired, // array of options
  	placeholder: propTypes.oneOfType([// field placeholder, displayed when there's no value (shared with Select)
  	propTypes.string, propTypes.node]),
  	searchPromptText: propTypes.oneOfType([// label to prompt for search input
  	propTypes.string, propTypes.node]),
  	value: propTypes.any // initial field value
  };

  var defaultCache = {};

  var defaultProps$1d = {
  	autoload: true,
  	cache: defaultCache,
  	children: defaultChildren,
  	ignoreAccents: true,
  	ignoreCase: true,
  	loadingPlaceholder: 'Loading...',
  	options: [],
  	searchPromptText: 'Type to search'
  };

  var Async = function (_Component) {
  	inherits(Async, _Component);

  	function Async(props, context) {
  		classCallCheck$1(this, Async);

  		var _this = possibleConstructorReturn(this, (Async.__proto__ || Object.getPrototypeOf(Async)).call(this, props, context));

  		_this._cache = props.cache === defaultCache ? {} : props.cache;

  		_this.state = {
  			inputValue: '',
  			isLoading: false,
  			options: props.options
  		};

  		_this.onInputChange = _this.onInputChange.bind(_this);
  		return _this;
  	}

  	createClass$1(Async, [{
  		key: 'componentDidMount',
  		value: function componentDidMount() {
  			var autoload = this.props.autoload;


  			if (autoload) {
  				this.loadOptions('');
  			}
  		}
  	}, {
  		key: 'componentWillReceiveProps',
  		value: function componentWillReceiveProps(nextProps) {
  			if (nextProps.options !== this.props.options) {
  				this.setState({
  					options: nextProps.options
  				});
  			}
  		}
  	}, {
  		key: 'componentWillUnmount',
  		value: function componentWillUnmount() {
  			this._callback = null;
  		}
  	}, {
  		key: 'loadOptions',
  		value: function loadOptions(inputValue) {
  			var _this2 = this;

  			var loadOptions = this.props.loadOptions;

  			var cache = this._cache;

  			if (cache && Object.prototype.hasOwnProperty.call(cache, inputValue)) {
  				this._callback = null;

  				this.setState({
  					isLoading: false,
  					options: cache[inputValue]
  				});

  				return;
  			}

  			var callback = function callback(error, data) {
  				var options = data && data.options || [];

  				if (cache) {
  					cache[inputValue] = options;
  				}

  				if (callback === _this2._callback) {
  					_this2._callback = null;

  					_this2.setState({
  						isLoading: false,
  						options: options
  					});
  				}
  			};

  			// Ignore all but the most recent request
  			this._callback = callback;

  			var promise = loadOptions(inputValue, callback);
  			if (promise) {
  				promise.then(function (data) {
  					return callback(null, data);
  				}, function (error) {
  					return callback(error);
  				});
  			}

  			if (this._callback && !this.state.isLoading) {
  				this.setState({
  					isLoading: true
  				});
  			}
  		}
  	}, {
  		key: 'onInputChange',
  		value: function onInputChange(inputValue) {
  			var _props = this.props,
  			    ignoreAccents = _props.ignoreAccents,
  			    ignoreCase = _props.ignoreCase,
  			    onInputChange = _props.onInputChange;

  			var newInputValue = inputValue;

  			if (onInputChange) {
  				var value = onInputChange(newInputValue);
  				// Note: != used deliberately here to catch undefined and null
  				if (value != null && (typeof value === 'undefined' ? 'undefined' : _typeof$2(value)) !== 'object') {
  					newInputValue = '' + value;
  				}
  			}

  			var transformedInputValue = newInputValue;

  			if (ignoreAccents) {
  				transformedInputValue = stripDiacritics(transformedInputValue);
  			}

  			if (ignoreCase) {
  				transformedInputValue = transformedInputValue.toLowerCase();
  			}

  			this.setState({ inputValue: newInputValue });
  			this.loadOptions(transformedInputValue);

  			// Return new input value, but without applying toLowerCase() to avoid modifying the user's view case of the input while typing.
  			return newInputValue;
  		}
  	}, {
  		key: 'noResultsText',
  		value: function noResultsText() {
  			var _props2 = this.props,
  			    loadingPlaceholder = _props2.loadingPlaceholder,
  			    noResultsText = _props2.noResultsText,
  			    searchPromptText = _props2.searchPromptText;
  			var _state = this.state,
  			    inputValue = _state.inputValue,
  			    isLoading = _state.isLoading;


  			if (isLoading) {
  				return loadingPlaceholder;
  			}
  			if (inputValue && noResultsText) {
  				return noResultsText;
  			}
  			return searchPromptText;
  		}
  	}, {
  		key: 'focus',
  		value: function focus() {
  			this.select.focus();
  		}
  	}, {
  		key: 'render',
  		value: function render() {
  			var _this3 = this;

  			var _props3 = this.props,
  			    children = _props3.children,
  			    loadingPlaceholder = _props3.loadingPlaceholder,
  			    multi = _props3.multi,
  			    onChange = _props3.onChange,
  			    placeholder = _props3.placeholder;
  			var _state2 = this.state,
  			    isLoading = _state2.isLoading,
  			    options = _state2.options;


  			var props = {
  				noResultsText: this.noResultsText(),
  				placeholder: isLoading ? loadingPlaceholder : placeholder,
  				options: isLoading && loadingPlaceholder ? [] : options,
  				ref: function ref(_ref) {
  					return _this3.select = _ref;
  				}
  			};

  			return children(_extends$c({}, this.props, props, {
  				isLoading: isLoading,
  				onInputChange: this.onInputChange
  			}));
  		}
  	}]);
  	return Async;
  }(react_2);

  Async.propTypes = propTypes$1c;
  Async.defaultProps = defaultProps$1d;

  function defaultChildren(props) {
  	return react.createElement(Select$1, props);
  }

  var CreatableSelect = function (_React$Component) {
  	inherits(CreatableSelect, _React$Component);

  	function CreatableSelect(props, context) {
  		classCallCheck$1(this, CreatableSelect);

  		var _this = possibleConstructorReturn(this, (CreatableSelect.__proto__ || Object.getPrototypeOf(CreatableSelect)).call(this, props, context));

  		_this.filterOptions = _this.filterOptions.bind(_this);
  		_this.menuRenderer = _this.menuRenderer.bind(_this);
  		_this.onInputKeyDown = _this.onInputKeyDown.bind(_this);
  		_this.onInputChange = _this.onInputChange.bind(_this);
  		_this.onOptionSelect = _this.onOptionSelect.bind(_this);
  		return _this;
  	}

  	createClass$1(CreatableSelect, [{
  		key: 'createNewOption',
  		value: function createNewOption() {
  			var _props = this.props,
  			    isValidNewOption = _props.isValidNewOption,
  			    newOptionCreator = _props.newOptionCreator,
  			    onNewOptionClick = _props.onNewOptionClick,
  			    _props$options = _props.options,
  			    options = _props$options === undefined ? [] : _props$options;


  			if (isValidNewOption({ label: this.inputValue })) {
  				var option = newOptionCreator({ label: this.inputValue, labelKey: this.labelKey, valueKey: this.valueKey });
  				var _isOptionUnique = this.isOptionUnique({ option: option });

  				// Don't add the same option twice.
  				if (_isOptionUnique) {
  					if (onNewOptionClick) {
  						onNewOptionClick(option);
  					} else {
  						options.unshift(option);

  						this.select.selectValue(option);
  					}
  				}
  			}
  		}
  	}, {
  		key: 'filterOptions',
  		value: function filterOptions$$1() {
  			var _props2 = this.props,
  			    filterOptions$$1 = _props2.filterOptions,
  			    isValidNewOption = _props2.isValidNewOption,
  			    options = _props2.options,
  			    promptTextCreator = _props2.promptTextCreator;

  			// TRICKY Check currently selected options as well.
  			// Don't display a create-prompt for a value that's selected.
  			// This covers async edge-cases where a newly-created Option isn't yet in the async-loaded array.

  			var excludeOptions = (arguments.length <= 2 ? undefined : arguments[2]) || [];

  			var filteredOptions = filterOptions$$1.apply(undefined, arguments) || [];

  			if (isValidNewOption({ label: this.inputValue })) {
  				var _newOptionCreator = this.props.newOptionCreator;


  				var option = _newOptionCreator({
  					label: this.inputValue,
  					labelKey: this.labelKey,
  					valueKey: this.valueKey
  				});

  				// TRICKY Compare to all options (not just filtered options) in case option has already been selected).
  				// For multi-selects, this would remove it from the filtered list.
  				var _isOptionUnique2 = this.isOptionUnique({
  					option: option,
  					options: excludeOptions.concat(filteredOptions)
  				});

  				if (_isOptionUnique2) {
  					var prompt = promptTextCreator(this.inputValue);

  					this._createPlaceholderOption = _newOptionCreator({
  						label: prompt,
  						labelKey: this.labelKey,
  						valueKey: this.valueKey
  					});

  					filteredOptions.unshift(this._createPlaceholderOption);
  				}
  			}

  			return filteredOptions;
  		}
  	}, {
  		key: 'isOptionUnique',
  		value: function isOptionUnique(_ref) {
  			var option = _ref.option,
  			    options = _ref.options;
  			var isOptionUnique = this.props.isOptionUnique;


  			options = options || this.props.options;

  			return isOptionUnique({
  				labelKey: this.labelKey,
  				option: option,
  				options: options,
  				valueKey: this.valueKey
  			});
  		}
  	}, {
  		key: 'menuRenderer',
  		value: function menuRenderer$$1(params) {
  			var menuRenderer$$1 = this.props.menuRenderer;


  			return menuRenderer$$1(_extends$c({}, params, {
  				onSelect: this.onOptionSelect,
  				selectValue: this.onOptionSelect
  			}));
  		}
  	}, {
  		key: 'onInputChange',
  		value: function onInputChange(input) {
  			var onInputChange = this.props.onInputChange;

  			// This value may be needed in between Select mounts (when this.select is null)

  			this.inputValue = input;

  			if (onInputChange) {
  				this.inputValue = onInputChange(input);
  			}

  			return this.inputValue;
  		}
  	}, {
  		key: 'onInputKeyDown',
  		value: function onInputKeyDown(event) {
  			var _props3 = this.props,
  			    shouldKeyDownEventCreateNewOption = _props3.shouldKeyDownEventCreateNewOption,
  			    onInputKeyDown = _props3.onInputKeyDown;

  			var focusedOption = this.select.getFocusedOption();

  			if (focusedOption && focusedOption === this._createPlaceholderOption && shouldKeyDownEventCreateNewOption({ keyCode: event.keyCode })) {
  				this.createNewOption();

  				// Prevent decorated Select from doing anything additional with this keyDown event
  				event.preventDefault();
  			} else if (onInputKeyDown) {
  				onInputKeyDown(event);
  			}
  		}
  	}, {
  		key: 'onOptionSelect',
  		value: function onOptionSelect(option, event) {
  			if (option === this._createPlaceholderOption) {
  				this.createNewOption();
  			} else {
  				this.select.selectValue(option);
  			}
  		}
  	}, {
  		key: 'focus',
  		value: function focus() {
  			this.select.focus();
  		}
  	}, {
  		key: 'render',
  		value: function render() {
  			var _this2 = this;

  			var _props4 = this.props,
  			    newOptionCreator = _props4.newOptionCreator,
  			    shouldKeyDownEventCreateNewOption = _props4.shouldKeyDownEventCreateNewOption,
  			    refProp = _props4.ref,
  			    restProps = objectWithoutProperties(_props4, ['newOptionCreator', 'shouldKeyDownEventCreateNewOption', 'ref']);
  			var children = this.props.children;

  			// We can't use destructuring default values to set the children,
  			// because it won't apply work if `children` is null. A falsy check is
  			// more reliable in real world use-cases.

  			if (!children) {
  				children = defaultChildren$2;
  			}

  			var props = _extends$c({}, restProps, {
  				allowCreate: true,
  				filterOptions: this.filterOptions,
  				menuRenderer: this.menuRenderer,
  				onInputChange: this.onInputChange,
  				onInputKeyDown: this.onInputKeyDown,
  				ref: function ref(_ref2) {
  					_this2.select = _ref2;

  					// These values may be needed in between Select mounts (when this.select is null)
  					if (_ref2) {
  						_this2.labelKey = _ref2.props.labelKey;
  						_this2.valueKey = _ref2.props.valueKey;
  					}
  					if (refProp) {
  						refProp(_ref2);
  					}
  				}
  			});

  			return children(props);
  		}
  	}]);
  	return CreatableSelect;
  }(react.Component);



  function defaultChildren$2(props) {
  	return react.createElement(Select$1, props);
  }

  function isOptionUnique(_ref3) {
  	var option = _ref3.option,
  	    options = _ref3.options,
  	    labelKey = _ref3.labelKey,
  	    valueKey = _ref3.valueKey;

  	return options.filter(function (existingOption) {
  		return existingOption[labelKey] === option[labelKey] || existingOption[valueKey] === option[valueKey];
  	}).length === 0;
  }

  function isValidNewOption(_ref4) {
  	var label = _ref4.label;

  	return !!label;
  }

  function newOptionCreator(_ref5) {
  	var label = _ref5.label,
  	    labelKey = _ref5.labelKey,
  	    valueKey = _ref5.valueKey;

  	var option = {};
  	option[valueKey] = label;
  	option[labelKey] = label;
  	option.className = 'Select-create-option-placeholder';
  	return option;
  }

  function promptTextCreator(label) {
  	return 'Create option "' + label + '"';
  }

  function shouldKeyDownEventCreateNewOption(_ref6) {
  	var keyCode = _ref6.keyCode;

  	switch (keyCode) {
  		case 9: // TAB
  		case 13: // ENTER
  		case 188:
  			// COMMA
  			return true;
  	}

  	return false;
  }

  // Default prop methods
  CreatableSelect.isOptionUnique = isOptionUnique;
  CreatableSelect.isValidNewOption = isValidNewOption;
  CreatableSelect.newOptionCreator = newOptionCreator;
  CreatableSelect.promptTextCreator = promptTextCreator;
  CreatableSelect.shouldKeyDownEventCreateNewOption = shouldKeyDownEventCreateNewOption;

  CreatableSelect.defaultProps = {
  	filterOptions: filterOptions,
  	isOptionUnique: isOptionUnique,
  	isValidNewOption: isValidNewOption,
  	menuRenderer: menuRenderer,
  	newOptionCreator: newOptionCreator,
  	promptTextCreator: promptTextCreator,
  	shouldKeyDownEventCreateNewOption: shouldKeyDownEventCreateNewOption
  };

  CreatableSelect.propTypes = {
  	// Child function responsible for creating the inner Select component
  	// This component can be used to compose HOCs (eg Creatable and Async)
  	// (props: Object): PropTypes.element
  	children: propTypes.func,

  	// See Select.propTypes.filterOptions
  	filterOptions: propTypes.any,

  	// Searches for any matching option within the set of options.
  	// This function prevents duplicate options from being created.
  	// ({ option: Object, options: Array, labelKey: string, valueKey: string }): boolean
  	isOptionUnique: propTypes.func,

  	// Determines if the current input text represents a valid option.
  	// ({ label: string }): boolean
  	isValidNewOption: propTypes.func,

  	// See Select.propTypes.menuRenderer
  	menuRenderer: propTypes.any,

  	// Factory to create new option.
  	// ({ label: string, labelKey: string, valueKey: string }): Object
  	newOptionCreator: propTypes.func,

  	// input change handler: function (inputValue) {}
  	onInputChange: propTypes.func,

  	// input keyDown handler: function (event) {}
  	onInputKeyDown: propTypes.func,

  	// new option click handler: function (option) {}
  	onNewOptionClick: propTypes.func,

  	// See Select.propTypes.options
  	options: propTypes.array,

  	// Creates prompt/placeholder option text.
  	// (filterText: string): string
  	promptTextCreator: propTypes.func,

  	ref: propTypes.func,

  	// Decides if a keyDown event (eg its `keyCode`) should result in the creation of a new option.
  	shouldKeyDownEventCreateNewOption: propTypes.func
  };

  var AsyncCreatableSelect = function (_React$Component) {
  	inherits(AsyncCreatableSelect, _React$Component);

  	function AsyncCreatableSelect() {
  		classCallCheck$1(this, AsyncCreatableSelect);
  		return possibleConstructorReturn(this, (AsyncCreatableSelect.__proto__ || Object.getPrototypeOf(AsyncCreatableSelect)).apply(this, arguments));
  	}

  	createClass$1(AsyncCreatableSelect, [{
  		key: 'focus',
  		value: function focus() {
  			this.select.focus();
  		}
  	}, {
  		key: 'render',
  		value: function render() {
  			var _this2 = this;

  			return react.createElement(
  				Async,
  				this.props,
  				function (_ref) {
  					var ref = _ref.ref,
  					    asyncProps = objectWithoutProperties(_ref, ['ref']);

  					var asyncRef = ref;
  					return react.createElement(
  						CreatableSelect,
  						asyncProps,
  						function (_ref2) {
  							var ref = _ref2.ref,
  							    creatableProps = objectWithoutProperties(_ref2, ['ref']);

  							var creatableRef = ref;
  							return _this2.props.children(_extends$c({}, creatableProps, {
  								ref: function ref(select) {
  									creatableRef(select);
  									asyncRef(select);
  									_this2.select = select;
  								}
  							}));
  						}
  					);
  				}
  			);
  		}
  	}]);
  	return AsyncCreatableSelect;
  }(react.Component);



  function defaultChildren$1(props) {
  	return react.createElement(Select$1, props);
  }

  AsyncCreatableSelect.propTypes = {
  	children: propTypes.func.isRequired // Child function responsible for creating the inner Select component; (props: Object): PropTypes.element
  };

  AsyncCreatableSelect.defaultProps = {
  	children: defaultChildren$1
  };

  Select$1.Async = Async;
  Select$1.AsyncCreatable = AsyncCreatableSelect;
  Select$1.Creatable = CreatableSelect;
  Select$1.Value = Value;
  Select$1.Option = Option;

  var toastr = createCommonjsModule(function (module) {
  /*
   * Toastr
   * Copyright 2012-2015
   * Authors: John Papa, Hans Fjällemark, and Tim Ferrell.
   * All Rights Reserved.
   * Use, reproduction, distribution, and modification of this code is subject to the terms and
   * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
   *
   * ARIA Support: Greta Krafsig
   *
   * Project: https://github.com/CodeSeven/toastr
   */
  /* global define */
  (function (define) {
      define(['jquery'], function ($) {
          return (function () {
              var $container;
              var listener;
              var toastId = 0;
              var toastType = {
                  error: 'error',
                  info: 'info',
                  success: 'success',
                  warning: 'warning'
              };

              var toastr = {
                  clear: clear,
                  remove: remove,
                  error: error,
                  getContainer: getContainer,
                  info: info,
                  options: {},
                  subscribe: subscribe,
                  success: success,
                  version: '2.1.4',
                  warning: warning
              };

              var previousToast;

              return toastr;

              ////////////////

              function error(message, title, optionsOverride) {
                  return notify({
                      type: toastType.error,
                      iconClass: getOptions().iconClasses.error,
                      message: message,
                      optionsOverride: optionsOverride,
                      title: title
                  });
              }

              function getContainer(options, create) {
                  if (!options) { options = getOptions(); }
                  $container = $('#' + options.containerId);
                  if ($container.length) {
                      return $container;
                  }
                  if (create) {
                      $container = createContainer(options);
                  }
                  return $container;
              }

              function info(message, title, optionsOverride) {
                  return notify({
                      type: toastType.info,
                      iconClass: getOptions().iconClasses.info,
                      message: message,
                      optionsOverride: optionsOverride,
                      title: title
                  });
              }

              function subscribe(callback) {
                  listener = callback;
              }

              function success(message, title, optionsOverride) {
                  return notify({
                      type: toastType.success,
                      iconClass: getOptions().iconClasses.success,
                      message: message,
                      optionsOverride: optionsOverride,
                      title: title
                  });
              }

              function warning(message, title, optionsOverride) {
                  return notify({
                      type: toastType.warning,
                      iconClass: getOptions().iconClasses.warning,
                      message: message,
                      optionsOverride: optionsOverride,
                      title: title
                  });
              }

              function clear($toastElement, clearOptions) {
                  var options = getOptions();
                  if (!$container) { getContainer(options); }
                  if (!clearToast($toastElement, options, clearOptions)) {
                      clearContainer(options);
                  }
              }

              function remove($toastElement) {
                  var options = getOptions();
                  if (!$container) { getContainer(options); }
                  if ($toastElement && $(':focus', $toastElement).length === 0) {
                      removeToast($toastElement);
                      return;
                  }
                  if ($container.children().length) {
                      $container.remove();
                  }
              }

              // internal functions

              function clearContainer (options) {
                  var toastsToClear = $container.children();
                  for (var i = toastsToClear.length - 1; i >= 0; i--) {
                      clearToast($(toastsToClear[i]), options);
                  }
              }

              function clearToast ($toastElement, options, clearOptions) {
                  var force = clearOptions && clearOptions.force ? clearOptions.force : false;
                  if ($toastElement && (force || $(':focus', $toastElement).length === 0)) {
                      $toastElement[options.hideMethod]({
                          duration: options.hideDuration,
                          easing: options.hideEasing,
                          complete: function () { removeToast($toastElement); }
                      });
                      return true;
                  }
                  return false;
              }

              function createContainer(options) {
                  $container = $('<div/>')
                      .attr('id', options.containerId)
                      .addClass(options.positionClass);

                  $container.appendTo($(options.target));
                  return $container;
              }

              function getDefaults() {
                  return {
                      tapToDismiss: true,
                      toastClass: 'toast',
                      containerId: 'toast-container',
                      debug: false,

                      showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
                      showDuration: 300,
                      showEasing: 'swing', //swing and linear are built into jQuery
                      onShown: undefined,
                      hideMethod: 'fadeOut',
                      hideDuration: 1000,
                      hideEasing: 'swing',
                      onHidden: undefined,
                      closeMethod: false,
                      closeDuration: false,
                      closeEasing: false,
                      closeOnHover: true,

                      extendedTimeOut: 1000,
                      iconClasses: {
                          error: 'toast-error',
                          info: 'toast-info',
                          success: 'toast-success',
                          warning: 'toast-warning'
                      },
                      iconClass: 'toast-info',
                      positionClass: 'toast-top-right',
                      timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
                      titleClass: 'toast-title',
                      messageClass: 'toast-message',
                      escapeHtml: false,
                      target: 'body',
                      closeHtml: '<button type="button">&times;</button>',
                      closeClass: 'toast-close-button',
                      newestOnTop: true,
                      preventDuplicates: false,
                      progressBar: false,
                      progressClass: 'toast-progress',
                      rtl: false
                  };
              }

              function publish(args) {
                  if (!listener) { return; }
                  listener(args);
              }

              function notify(map) {
                  var options = getOptions();
                  var iconClass = map.iconClass || options.iconClass;

                  if (typeof (map.optionsOverride) !== 'undefined') {
                      options = $.extend(options, map.optionsOverride);
                      iconClass = map.optionsOverride.iconClass || iconClass;
                  }

                  if (shouldExit(options, map)) { return; }

                  toastId++;

                  $container = getContainer(options, true);

                  var intervalId = null;
                  var $toastElement = $('<div/>');
                  var $titleElement = $('<div/>');
                  var $messageElement = $('<div/>');
                  var $progressElement = $('<div/>');
                  var $closeElement = $(options.closeHtml);
                  var progressBar = {
                      intervalId: null,
                      hideEta: null,
                      maxHideTime: null
                  };
                  var response = {
                      toastId: toastId,
                      state: 'visible',
                      startTime: new Date(),
                      options: options,
                      map: map
                  };

                  personalizeToast();

                  displayToast();

                  handleEvents();

                  publish(response);

                  if (options.debug && console) {
                      console.log(response);
                  }

                  return $toastElement;

                  function escapeHtml(source) {
                      if (source == null) {
                          source = '';
                      }

                      return source
                          .replace(/&/g, '&amp;')
                          .replace(/"/g, '&quot;')
                          .replace(/'/g, '&#39;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;');
                  }

                  function personalizeToast() {
                      setIcon();
                      setTitle();
                      setMessage();
                      setCloseButton();
                      setProgressBar();
                      setRTL();
                      setSequence();
                      setAria();
                  }

                  function setAria() {
                      var ariaValue = '';
                      switch (map.iconClass) {
                          case 'toast-success':
                          case 'toast-info':
                              ariaValue =  'polite';
                              break;
                          default:
                              ariaValue = 'assertive';
                      }
                      $toastElement.attr('aria-live', ariaValue);
                  }

                  function handleEvents() {
                      if (options.closeOnHover) {
                          $toastElement.hover(stickAround, delayedHideToast);
                      }

                      if (!options.onclick && options.tapToDismiss) {
                          $toastElement.click(hideToast);
                      }

                      if (options.closeButton && $closeElement) {
                          $closeElement.click(function (event) {
                              if (event.stopPropagation) {
                                  event.stopPropagation();
                              } else if (event.cancelBubble !== undefined && event.cancelBubble !== true) {
                                  event.cancelBubble = true;
                              }

                              if (options.onCloseClick) {
                                  options.onCloseClick(event);
                              }

                              hideToast(true);
                          });
                      }

                      if (options.onclick) {
                          $toastElement.click(function (event) {
                              options.onclick(event);
                              hideToast();
                          });
                      }
                  }

                  function displayToast() {
                      $toastElement.hide();

                      $toastElement[options.showMethod](
                          {duration: options.showDuration, easing: options.showEasing, complete: options.onShown}
                      );

                      if (options.timeOut > 0) {
                          intervalId = setTimeout(hideToast, options.timeOut);
                          progressBar.maxHideTime = parseFloat(options.timeOut);
                          progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                          if (options.progressBar) {
                              progressBar.intervalId = setInterval(updateProgress, 10);
                          }
                      }
                  }

                  function setIcon() {
                      if (map.iconClass) {
                          $toastElement.addClass(options.toastClass).addClass(iconClass);
                      }
                  }

                  function setSequence() {
                      if (options.newestOnTop) {
                          $container.prepend($toastElement);
                      } else {
                          $container.append($toastElement);
                      }
                  }

                  function setTitle() {
                      if (map.title) {
                          var suffix = map.title;
                          if (options.escapeHtml) {
                              suffix = escapeHtml(map.title);
                          }
                          $titleElement.append(suffix).addClass(options.titleClass);
                          $toastElement.append($titleElement);
                      }
                  }

                  function setMessage() {
                      if (map.message) {
                          var suffix = map.message;
                          if (options.escapeHtml) {
                              suffix = escapeHtml(map.message);
                          }
                          $messageElement.append(suffix).addClass(options.messageClass);
                          $toastElement.append($messageElement);
                      }
                  }

                  function setCloseButton() {
                      if (options.closeButton) {
                          $closeElement.addClass(options.closeClass).attr('role', 'button');
                          $toastElement.prepend($closeElement);
                      }
                  }

                  function setProgressBar() {
                      if (options.progressBar) {
                          $progressElement.addClass(options.progressClass);
                          $toastElement.prepend($progressElement);
                      }
                  }

                  function setRTL() {
                      if (options.rtl) {
                          $toastElement.addClass('rtl');
                      }
                  }

                  function shouldExit(options, map) {
                      if (options.preventDuplicates) {
                          if (map.message === previousToast) {
                              return true;
                          } else {
                              previousToast = map.message;
                          }
                      }
                      return false;
                  }

                  function hideToast(override) {
                      var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
                      var duration = override && options.closeDuration !== false ?
                          options.closeDuration : options.hideDuration;
                      var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
                      if ($(':focus', $toastElement).length && !override) {
                          return;
                      }
                      clearTimeout(progressBar.intervalId);
                      return $toastElement[method]({
                          duration: duration,
                          easing: easing,
                          complete: function () {
                              removeToast($toastElement);
                              clearTimeout(intervalId);
                              if (options.onHidden && response.state !== 'hidden') {
                                  options.onHidden();
                              }
                              response.state = 'hidden';
                              response.endTime = new Date();
                              publish(response);
                          }
                      });
                  }

                  function delayedHideToast() {
                      if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                          intervalId = setTimeout(hideToast, options.extendedTimeOut);
                          progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
                          progressBar.hideEta = new Date().getTime() + progressBar.maxHideTime;
                      }
                  }

                  function stickAround() {
                      clearTimeout(intervalId);
                      progressBar.hideEta = 0;
                      $toastElement.stop(true, true)[options.showMethod](
                          {duration: options.showDuration, easing: options.showEasing}
                      );
                  }

                  function updateProgress() {
                      var percentage = ((progressBar.hideEta - (new Date().getTime())) / progressBar.maxHideTime) * 100;
                      $progressElement.width(percentage + '%');
                  }
              }

              function getOptions() {
                  return $.extend({}, getDefaults(), toastr.options);
              }

              function removeToast($toastElement) {
                  if (!$container) { $container = getContainer(); }
                  if ($toastElement.is(':visible')) {
                      return;
                  }
                  $toastElement.remove();
                  $toastElement = null;
                  if ($container.children().length === 0) {
                      $container.remove();
                      previousToast = undefined;
                  }
              }

          })();
      });
  }(function (deps, factory) {
      if (module.exports) { //Node
          module.exports = factory(jquery);
      } else {
          window.toastr = factory(window.jQuery);
      }
  }));
  });

  var defaultWidth = 56;
  var defaultHeight = 56;
  var defaultFill = "#20a8d8";
  var tailSpin = function tailSpin(width, height, fill) {
    fill = fill || defaultFill;
    width = width || defaultWidth;
    height = height || defaultHeight || width;
    return react_9("svg", {
      width: width,
      height: height,
      viewBox: "0 0 38 38",
      xmlns: "http://www.w3.org/2000/svg"
    }, react_9("defs", null, react_9("linearGradient", {
      x1: "8.042%",
      y1: "0%",
      x2: "65.682%",
      y2: "23.865%",
      id: "a"
    }, react_9("stop", {
      stopColor: fill,
      stopOpacity: "0",
      offset: "0%"
    }), react_9("stop", {
      stopColor: fill,
      stopOpacity: ".631",
      offset: "63.146%"
    }), react_9("stop", {
      stopColor: fill,
      offset: "100%"
    }))), react_9("g", {
      fill: "none",
      fillRule: "evenodd"
    }, react_9("g", {
      transform: "translate(1 1)"
    }, react_9("path", {
      d: "M36 18c0-9.94-8.06-18-18-18",
      id: "Oval-2",
      stroke: "url(#a)",
      strokeWidth: "2"
    }, react_9("animateTransform", {
      attributeName: "transform",
      type: "rotate",
      from: "0 18 18",
      to: "360 18 18",
      dur: "0.9s",
      repeatCount: "indefinite"
    })), react_9("circle", {
      fill: fill,
      cx: "36",
      cy: "18",
      r: "1"
    }, react_9("animateTransform", {
      attributeName: "transform",
      type: "rotate",
      from: "0 18 18",
      to: "360 18 18",
      dur: "0.9s",
      repeatCount: "indefinite"
    })))));
  };
  var ballTriangle = function ballTriangle(width, height, fill) {
    fill = fill || defaultFill;
    width = width || defaultWidth;
    height = height || defaultHeight || width;
    return react_9("svg", {
      width: width,
      height: height,
      viewBox: "0 0 57 57",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: fill || defaultFill
    }, react_9("g", {
      fill: "none",
      fillRule: "evenodd"
    }, react_9("g", {
      transform: "translate(1 1)",
      strokeWidth: "2"
    }, react_9("circle", {
      cx: "5",
      cy: "50",
      r: "5"
    }, react_9("animate", {
      attributeName: "cy",
      begin: "0s",
      dur: "2.2s",
      values: "50;5;50;50",
      calcMode: "linear",
      repeatCount: "indefinite"
    }), react_9("animate", {
      attributeName: "cx",
      begin: "0s",
      dur: "2.2s",
      values: "5;27;49;5",
      calcMode: "linear",
      repeatCount: "indefinite"
    })), react_9("circle", {
      cx: "27",
      cy: "5",
      r: "5"
    }, react_9("animate", {
      attributeName: "cy",
      begin: "0s",
      dur: "2.2s",
      from: "5",
      to: "5",
      values: "5;50;50;5",
      calcMode: "linear",
      repeatCount: "indefinite"
    }), react_9("animate", {
      attributeName: "cx",
      begin: "0s",
      dur: "2.2s",
      from: "27",
      to: "27",
      values: "27;49;5;27",
      calcMode: "linear",
      repeatCount: "indefinite"
    })), react_9("circle", {
      cx: "49",
      cy: "50",
      r: "5"
    }, react_9("animate", {
      attributeName: "cy",
      begin: "0s",
      dur: "2.2s",
      values: "50;50;5;50",
      calcMode: "linear",
      repeatCount: "indefinite"
    }), react_9("animate", {
      attributeName: "cx",
      from: "49",
      to: "49",
      begin: "0s",
      dur: "2.2s",
      values: "49;5;27;49",
      calcMode: "linear",
      repeatCount: "indefinite"
    })))));
  };
  var puff = function puff(width, height, fill) {
    fill = fill || defaultFill;
    width = width || defaultWidth;
    height = height || defaultHeight || width;
    return react_9("svg", {
      width: width,
      height: height,
      viewBox: "0 0 44 44",
      xmlns: "http://www.w3.org/2000/svg",
      stroke: fill || defaultFill
    }, react_9("g", {
      fill: "none",
      fillRule: "evenodd",
      strokeWidth: "2"
    }, react_9("circle", {
      cx: "22",
      cy: "22",
      r: "1"
    }, react_9("animate", {
      attributeName: "r",
      begin: "0s",
      dur: "1.8s",
      values: "1; 20",
      calcMode: "spline",
      keyTimes: "0; 1",
      keySplines: "0.165, 0.84, 0.44, 1",
      repeatCount: "indefinite"
    }), react_9("animate", {
      attributeName: "stroke-opacity",
      begin: "0s",
      dur: "1.8s",
      values: "1; 0",
      calcMode: "spline",
      keyTimes: "0; 1",
      keySplines: "0.3, 0.61, 0.355, 1",
      repeatCount: "indefinite"
    })), react_9("circle", {
      cx: "22",
      cy: "22",
      r: "1"
    }, react_9("animate", {
      attributeName: "r",
      begin: "-0.9s",
      dur: "1.8s",
      values: "1; 20",
      calcMode: "spline",
      keyTimes: "0; 1",
      keySplines: "0.165, 0.84, 0.44, 1",
      repeatCount: "indefinite"
    }), react_9("animate", {
      attributeName: "stroke-opacity",
      begin: "-0.9s",
      dur: "1.8s",
      values: "1; 0",
      calcMode: "spline",
      keyTimes: "0; 1",
      keySplines: "0.3, 0.61, 0.355, 1",
      repeatCount: "indefinite"
    }))));
  };

  var index$6 = /*#__PURE__*/Object.freeze({
    defaultWidth: defaultWidth,
    defaultHeight: defaultHeight,
    defaultFill: defaultFill,
    tailSpin: tailSpin,
    ballTriangle: ballTriangle,
    puff: puff
  });

  var Aside =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Aside, _Component);

    function Aside(props) {
      var _this;

      _classCallCheck(this, Aside);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Aside).call(this, props));
      _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));
      _this.state = {
        users: false
      };
      iwb.asideToggleX = _this.toggle;
      return _this;
    }

    _createClass(Aside, [{
      key: "toggle",
      value: function toggle(e) {
        var c = document.body.classList;
        var v = c.contains("aside-menu-hidden");
        c.toggle("aside-menu-hidden");

        if (v) {
          var self = this;
          iwb.request({
            url: "../app/ajaxQueryData?_qid=142&.r=" + Math.random(),
            params: {},
            successCallback: function successCallback(result, cfg) {
              self.setState({
                users: result.data
              });
            }
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var users = this.state.users;
        return react_9("aside", {
          className: "aside-menu",
          style: {
            background: "transparent",
            borderLeft: "none"
          }
        }, //    		,createElement("div",{ style: {height:"23px"} })
        react_9("div", {
          className: "row"
        }, react_9("div", {
          className: "mb-4 col"
        },
        /*  createElement("ul",{ className: "nav nav-tabs" },
                    createElement("li",{ className: "nav-item", style: {borderTop: "1px solid #ccc", borderLeft: "1px solid #ccc"} },
                        createElement("a",{ className: "active nav-link", style: {background: "rgba(0,0,0,.05)", borderBottomColor: "#f2f4f6"} },
                        createElement("i", { className: "icon-bubbles" })
                        )
                    ),
                    createElement("li",{ className: "nav-item" },
                        createElement("a",{ k: "2", className: "nav-link" },
                        createElement("i", { className: "icon-settings" })
                        )
                    )
                    ),*/
        react_9("div", {
          style: {
            position: "relative",
            top: "0px",
            left: "122px",
            width: "51px",
            height: "55px",
            background: "#e7e8ea",
            marginTop: "-55px",
            borderBottom: "1px #e7e8ea solid",
            zIndex: "2",
            borderLeft: "1px solid rgb(204, 204, 204)",
            borderRight: "1px solid rgb(204, 204, 204)"
          }
        }), react_9("div", {
          className: "tab-content",
          style: {
            boxShadow: "none",
            background: "rgba(0,0,0,.05)",
            height: "calc(100vh - 2.375rem)",
            borderLeft: "1px solid #ccc",
            borderTop: "1px solid #ccc"
          }
        }, react_9("div", {
          className: "tab-pane pt-2 active"
        }, react_9("div", {
          className: "row"
        }, react_9("div", {
          className: "col",
          style: {
            padding: "2px 17px"
          }
        }, //    							,createElement('div',{className: "p-1"},createElement('h6',null,'KİŞİLER'))
        users && users.map(function (u, qi) {
          return react_9("div", {
            className: "card card-user"
          }, react_9("div", {
            className: "clearfix p-0 card-body"
          }, react_9("i", {
            className: "p-1-5 mr-1 float-left"
          }, react_9("img", {
            src: "../app/sf/pic" + u.user_id + ".png",
            className: "img-avatar",
            style: {
              border: "none",
              width: "36px",
              height: "36px"
            }
          })), react_9("div", {
            className: "pt-3",
            style: {
              color: "#777 !important"
            }
          }, u.adi_soyadi), 1 * u.chat_status_tip > 0 && react_9("i", {
            className: "float-right user-online"
          })));
        }))))))));
      }
    }]);

    return Aside;
  }(react_2);

  var base = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports['default'] = /*istanbul ignore end*/Diff;
  function Diff() {}

  Diff.prototype = {
    /*istanbul ignore start*/ /*istanbul ignore end*/diff: function diff(oldString, newString) {
      /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var callback = options.callback;
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      this.options = options;

      var self = this;

      function done(value) {
        if (callback) {
          setTimeout(function () {
            callback(undefined, value);
          }, 0);
          return true;
        } else {
          return value;
        }
      }

      // Allow subclasses to massage the input prior to running
      oldString = this.castInput(oldString);
      newString = this.castInput(newString);

      oldString = this.removeEmpty(this.tokenize(oldString));
      newString = this.removeEmpty(this.tokenize(newString));

      var newLen = newString.length,
          oldLen = oldString.length;
      var editLength = 1;
      var maxEditLength = newLen + oldLen;
      var bestPath = [{ newPos: -1, components: [] }];

      // Seed editLength = 0, i.e. the content starts with the same values
      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
        // Identity per the equality and tokenizer
        return done([{ value: this.join(newString), count: newString.length }]);
      }

      // Main worker method. checks all permutations of a given edit length for acceptance.
      function execEditLength() {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
          var addPath = bestPath[diagonalPath - 1],
              removePath = bestPath[diagonalPath + 1],
              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
          if (addPath) {
            // No one else is going to attempt to use this value, clear it
            bestPath[diagonalPath - 1] = undefined;
          }

          var canAdd = addPath && addPath.newPos + 1 < newLen,
              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
          if (!canAdd && !canRemove) {
            // If this path is a terminal then prune
            bestPath[diagonalPath] = undefined;
            continue;
          }

          // Select the diagonal that we want to branch from. We select the prior
          // path whose position in the new string is the farthest from the origin
          // and does not pass the bounds of the diff graph
          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
            basePath = clonePath(removePath);
            self.pushComponent(basePath.components, undefined, true);
          } else {
            basePath = addPath; // No need to clone, we've pulled it from the list
            basePath.newPos++;
            self.pushComponent(basePath.components, true, undefined);
          }

          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

          // If we have hit the end of both strings, then we are done
          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
          } else {
            // Otherwise track this path as a potential candidate and continue.
            bestPath[diagonalPath] = basePath;
          }
        }

        editLength++;
      }

      // Performs the length of edit iteration. Is a bit fugly as this has to support the
      // sync and async mode which is never fun. Loops over execEditLength until a value
      // is produced.
      if (callback) {
        (function exec() {
          setTimeout(function () {
            // This should not happen, but we want to be safe.
            /* istanbul ignore next */
            if (editLength > maxEditLength) {
              return callback();
            }

            if (!execEditLength()) {
              exec();
            }
          }, 0);
        })();
      } else {
        while (editLength <= maxEditLength) {
          var ret = execEditLength();
          if (ret) {
            return ret;
          }
        }
      }
    },
    /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {
      var last = components[components.length - 1];
      if (last && last.added === added && last.removed === removed) {
        // We need to clone here as the component clone operation is just
        // as shallow array clone
        components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };
      } else {
        components.push({ count: 1, added: added, removed: removed });
      }
    },
    /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
      var newLen = newString.length,
          oldLen = oldString.length,
          newPos = basePath.newPos,
          oldPos = newPos - diagonalPath,
          commonCount = 0;
      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
        newPos++;
        oldPos++;
        commonCount++;
      }

      if (commonCount) {
        basePath.components.push({ count: commonCount });
      }

      basePath.newPos = newPos;
      return oldPos;
    },
    /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {
      if (this.options.comparator) {
        return this.options.comparator(left, right);
      } else {
        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }
    },
    /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {
      var ret = [];
      for (var i = 0; i < array.length; i++) {
        if (array[i]) {
          ret.push(array[i]);
        }
      }
      return ret;
    },
    /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {
      return value;
    },
    /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {
      return value.split('');
    },
    /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {
      return chars.join('');
    }
  };

  function buildValues(diff, components, newString, oldString, useLongestToken) {
    var componentPos = 0,
        componentLen = components.length,
        newPos = 0,
        oldPos = 0;

    for (; componentPos < componentLen; componentPos++) {
      var component = components[componentPos];
      if (!component.removed) {
        if (!component.added && useLongestToken) {
          var value = newString.slice(newPos, newPos + component.count);
          value = value.map(function (value, i) {
            var oldValue = oldString[oldPos + i];
            return oldValue.length > value.length ? oldValue : value;
          });

          component.value = diff.join(value);
        } else {
          component.value = diff.join(newString.slice(newPos, newPos + component.count));
        }
        newPos += component.count;

        // Common case
        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
        oldPos += component.count;

        // Reverse add and remove so removes are output first to match common convention
        // The diffing algorithm is tied to add then remove output and this is the simplest
        // route to get the desired output with minimal overhead.
        if (componentPos && components[componentPos - 1].added) {
          var tmp = components[componentPos - 1];
          components[componentPos - 1] = components[componentPos];
          components[componentPos] = tmp;
        }
      }
    }

    // Special case handle for when one terminal is ignored (i.e. whitespace).
    // For this case we merge the terminal into the prior string and drop the change.
    // This is only available for string mode.
    var lastComponent = components[componentLen - 1];
    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
      components[componentLen - 2].value += lastComponent.value;
      components.pop();
    }

    return components;
  }

  function clonePath(path) {
    return { newPos: path.newPos, components: path.components.slice(0) };
  }

  });

  unwrapExports(base);

  var character = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.characterDiff = undefined;
  exports. /*istanbul ignore end*/diffChars = diffChars;



  /*istanbul ignore start*/var _base2 = _interopRequireDefault(base);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
  function diffChars(oldStr, newStr, options) {
    return characterDiff.diff(oldStr, newStr, options);
  }

  });

  unwrapExports(character);
  var character_1 = character.characterDiff;
  var character_2 = character.diffChars;

  var params = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports. /*istanbul ignore end*/generateOptions = generateOptions;
  function generateOptions(options, defaults) {
    if (typeof options === 'function') {
      defaults.callback = options;
    } else if (options) {
      for (var name in options) {
        /* istanbul ignore else */
        if (options.hasOwnProperty(name)) {
          defaults[name] = options[name];
        }
      }
    }
    return defaults;
  }

  });

  unwrapExports(params);
  var params_1 = params.generateOptions;

  var word = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.wordDiff = undefined;
  exports. /*istanbul ignore end*/diffWords = diffWords;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;



  /*istanbul ignore start*/var _base2 = _interopRequireDefault(base);

  /*istanbul ignore end*/

  /*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /*istanbul ignore end*/ // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
  //
  // Ranges and exceptions:
  // Latin-1 Supplement, 0080–00FF
  //  - U+00D7  × Multiplication sign
  //  - U+00F7  ÷ Division sign
  // Latin Extended-A, 0100–017F
  // Latin Extended-B, 0180–024F
  // IPA Extensions, 0250–02AF
  // Spacing Modifier Letters, 02B0–02FF
  //  - U+02C7  ˇ &#711;  Caron
  //  - U+02D8  ˘ &#728;  Breve
  //  - U+02D9  ˙ &#729;  Dot Above
  //  - U+02DA  ˚ &#730;  Ring Above
  //  - U+02DB  ˛ &#731;  Ogonek
  //  - U+02DC  ˜ &#732;  Small Tilde
  //  - U+02DD  ˝ &#733;  Double Acute Accent
  // Latin Extended Additional, 1E00–1EFF
  var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;

  var reWhitespace = /\S/;

  var wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
  wordDiff.equals = function (left, right) {
    if (this.options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }
    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
  };
  wordDiff.tokenize = function (value) {
    var tokens = value.split(/(\s+|\b)/);

    // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
    for (var i = 0; i < tokens.length - 1; i++) {
      // If we have an empty string in the next field and we have only word chars before and after, merge
      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
        tokens[i] += tokens[i + 2];
        tokens.splice(i + 1, 2);
        i--;
      }
    }

    return tokens;
  };

  function diffWords(oldStr, newStr, options) {
    options = /*istanbul ignore start*/(0, params.generateOptions) /*istanbul ignore end*/(options, { ignoreWhitespace: true });
    return wordDiff.diff(oldStr, newStr, options);
  }

  function diffWordsWithSpace(oldStr, newStr, options) {
    return wordDiff.diff(oldStr, newStr, options);
  }

  });

  unwrapExports(word);
  var word_1 = word.wordDiff;
  var word_2 = word.diffWords;
  var word_3 = word.diffWordsWithSpace;

  var line = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.lineDiff = undefined;
  exports. /*istanbul ignore end*/diffLines = diffLines;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;



  /*istanbul ignore start*/var _base2 = _interopRequireDefault(base);

  /*istanbul ignore end*/

  /*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
  lineDiff.tokenize = function (value) {
    var retLines = [],
        linesAndNewlines = value.split(/(\n|\r\n)/);

    // Ignore the final empty token that occurs if the string ends with a new line
    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
      linesAndNewlines.pop();
    }

    // Merge the content and line separators into single tokens
    for (var i = 0; i < linesAndNewlines.length; i++) {
      var line = linesAndNewlines[i];

      if (i % 2 && !this.options.newlineIsToken) {
        retLines[retLines.length - 1] += line;
      } else {
        if (this.options.ignoreWhitespace) {
          line = line.trim();
        }
        retLines.push(line);
      }
    }

    return retLines;
  };

  function diffLines(oldStr, newStr, callback) {
    return lineDiff.diff(oldStr, newStr, callback);
  }
  function diffTrimmedLines(oldStr, newStr, callback) {
    var options = /*istanbul ignore start*/(0, params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });
    return lineDiff.diff(oldStr, newStr, options);
  }

  });

  unwrapExports(line);
  var line_1 = line.lineDiff;
  var line_2 = line.diffLines;
  var line_3 = line.diffTrimmedLines;

  var sentence = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.sentenceDiff = undefined;
  exports. /*istanbul ignore end*/diffSentences = diffSentences;



  /*istanbul ignore start*/var _base2 = _interopRequireDefault(base);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
  sentenceDiff.tokenize = function (value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
  };

  function diffSentences(oldStr, newStr, callback) {
    return sentenceDiff.diff(oldStr, newStr, callback);
  }

  });

  unwrapExports(sentence);
  var sentence_1 = sentence.sentenceDiff;
  var sentence_2 = sentence.diffSentences;

  var css = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.cssDiff = undefined;
  exports. /*istanbul ignore end*/diffCss = diffCss;



  /*istanbul ignore start*/var _base2 = _interopRequireDefault(base);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
  cssDiff.tokenize = function (value) {
    return value.split(/([{}:;,]|\s+)/);
  };

  function diffCss(oldStr, newStr, callback) {
    return cssDiff.diff(oldStr, newStr, callback);
  }

  });

  unwrapExports(css);
  var css_1 = css.cssDiff;
  var css_2 = css.diffCss;

  var json = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.jsonDiff = undefined;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  exports. /*istanbul ignore end*/diffJson = diffJson;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;



  /*istanbul ignore start*/var _base2 = _interopRequireDefault(base);

  /*istanbul ignore end*/

  /*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /*istanbul ignore end*/var objectPrototypeToString = Object.prototype.toString;

  var jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
  jsonDiff.useLongestToken = true;

  jsonDiff.tokenize = /*istanbul ignore start*/line.lineDiff /*istanbul ignore end*/.tokenize;
  jsonDiff.castInput = function (value) {
    /*istanbul ignore start*/var _options = /*istanbul ignore end*/this.options,
        undefinedReplacement = _options.undefinedReplacement,
        _options$stringifyRep = _options.stringifyReplacer,
        stringifyReplacer = _options$stringifyRep === undefined ? function (k, v) /*istanbul ignore start*/{
      return (/*istanbul ignore end*/typeof v === 'undefined' ? undefinedReplacement : v
      );
    } : _options$stringifyRep;


    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
  };
  jsonDiff.equals = function (left, right) {
    return (/*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
    );
  };

  function diffJson(oldObj, newObj, options) {
    return jsonDiff.diff(oldObj, newObj, options);
  }

  // This function handles the presence of circular references by bailing out when encountering an
  // object that is already on the "stack" of items being processed. Accepts an optional replacer
  function canonicalize(obj, stack, replacementStack, replacer, key) {
    stack = stack || [];
    replacementStack = replacementStack || [];

    if (replacer) {
      obj = replacer(key, obj);
    }

    var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

    for (i = 0; i < stack.length; i += 1) {
      if (stack[i] === obj) {
        return replacementStack[i];
      }
    }

    var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

    if ('[object Array]' === objectPrototypeToString.call(obj)) {
      stack.push(obj);
      canonicalizedObj = new Array(obj.length);
      replacementStack.push(canonicalizedObj);
      for (i = 0; i < obj.length; i += 1) {
        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
      }
      stack.pop();
      replacementStack.pop();
      return canonicalizedObj;
    }

    if (obj && obj.toJSON) {
      obj = obj.toJSON();
    }

    if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {
      stack.push(obj);
      canonicalizedObj = {};
      replacementStack.push(canonicalizedObj);
      var sortedKeys = [],
          _key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
      for (_key in obj) {
        /* istanbul ignore else */
        if (obj.hasOwnProperty(_key)) {
          sortedKeys.push(_key);
        }
      }
      sortedKeys.sort();
      for (i = 0; i < sortedKeys.length; i += 1) {
        _key = sortedKeys[i];
        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
      }
      stack.pop();
      replacementStack.pop();
    } else {
      canonicalizedObj = obj;
    }
    return canonicalizedObj;
  }

  });

  unwrapExports(json);
  var json_1 = json.jsonDiff;
  var json_2 = json.diffJson;
  var json_3 = json.canonicalize;

  var array = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.arrayDiff = undefined;
  exports. /*istanbul ignore end*/diffArrays = diffArrays;



  /*istanbul ignore start*/var _base2 = _interopRequireDefault(base);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();
  arrayDiff.tokenize = function (value) {
    return value.slice();
  };
  arrayDiff.join = arrayDiff.removeEmpty = function (value) {
    return value;
  };

  function diffArrays(oldArr, newArr, callback) {
    return arrayDiff.diff(oldArr, newArr, callback);
  }

  });

  unwrapExports(array);
  var array_1 = array.arrayDiff;
  var array_2 = array.diffArrays;

  var parse$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports. /*istanbul ignore end*/parsePatch = parsePatch;
  function parsePatch(uniDiff) {
    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        list = [],
        i = 0;

    function parseIndex() {
      var index = {};
      list.push(index);

      // Parse diff metadata
      while (i < diffstr.length) {
        var line = diffstr[i];

        // File header found, end parsing diff metadata
        if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
          break;
        }

        // Diff index
        var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
        if (header) {
          index.index = header[1];
        }

        i++;
      }

      // Parse file headers if they are defined. Unified diff requires them, but
      // there's no technical issues to have an isolated hunk without file header
      parseFileHeader(index);
      parseFileHeader(index);

      // Parse hunks
      index.hunks = [];

      while (i < diffstr.length) {
        var _line = diffstr[i];

        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
          break;
        } else if (/^@@/.test(_line)) {
          index.hunks.push(parseHunk());
        } else if (_line && options.strict) {
          // Ignore unexpected content unless in strict mode
          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
        } else {
          i++;
        }
      }
    }

    // Parses the --- and +++ headers, if none are found, no lines
    // are consumed.
    function parseFileHeader(index) {
      var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
      if (fileHeader) {
        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
        var data = fileHeader[2].split('\t', 2);
        var fileName = data[0].replace(/\\\\/g, '\\');
        if (/^".*"$/.test(fileName)) {
          fileName = fileName.substr(1, fileName.length - 2);
        }
        index[keyPrefix + 'FileName'] = fileName;
        index[keyPrefix + 'Header'] = (data[1] || '').trim();

        i++;
      }
    }

    // Parses a hunk
    // This assumes that we are at the start of a hunk.
    function parseHunk() {
      var chunkHeaderIndex = i,
          chunkHeaderLine = diffstr[i++],
          chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);

      var hunk = {
        oldStart: +chunkHeader[1],
        oldLines: +chunkHeader[2] || 1,
        newStart: +chunkHeader[3],
        newLines: +chunkHeader[4] || 1,
        lines: [],
        linedelimiters: []
      };

      var addCount = 0,
          removeCount = 0;
      for (; i < diffstr.length; i++) {
        // Lines starting with '---' could be mistaken for the "remove line" operation
        // But they could be the header for the next file. Therefore prune such cases out.
        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
          break;
        }
        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
          hunk.lines.push(diffstr[i]);
          hunk.linedelimiters.push(delimiters[i] || '\n');

          if (operation === '+') {
            addCount++;
          } else if (operation === '-') {
            removeCount++;
          } else if (operation === ' ') {
            addCount++;
            removeCount++;
          }
        } else {
          break;
        }
      }

      // Handle the empty block count case
      if (!addCount && hunk.newLines === 1) {
        hunk.newLines = 0;
      }
      if (!removeCount && hunk.oldLines === 1) {
        hunk.oldLines = 0;
      }

      // Perform optional sanity checking
      if (options.strict) {
        if (addCount !== hunk.newLines) {
          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }
        if (removeCount !== hunk.oldLines) {
          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }
      }

      return hunk;
    }

    while (i < diffstr.length) {
      parseIndex();
    }

    return list;
  }

  });

  unwrapExports(parse$1);
  var parse_1$1 = parse$1.parsePatch;

  var distanceIterator = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports["default"] = /*istanbul ignore end*/function (start, minLine, maxLine) {
    var wantForward = true,
        backwardExhausted = false,
        forwardExhausted = false,
        localOffset = 1;

    return function iterator() {
      if (wantForward && !forwardExhausted) {
        if (backwardExhausted) {
          localOffset++;
        } else {
          wantForward = false;
        }

        // Check if trying to fit beyond text length, and if not, check it fits
        // after offset location (or desired location on first iteration)
        if (start + localOffset <= maxLine) {
          return localOffset;
        }

        forwardExhausted = true;
      }

      if (!backwardExhausted) {
        if (!forwardExhausted) {
          wantForward = true;
        }

        // Check if trying to fit before text beginning, and if not, check it fits
        // before offset location
        if (minLine <= start - localOffset) {
          return -localOffset++;
        }

        backwardExhausted = true;
        return iterator();
      }

      // We tried to fit hunk before text beginning and beyond text length, then
      // hunk can't fit on the text. Return undefined
    };
  };

  });

  unwrapExports(distanceIterator);

  var apply = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports. /*istanbul ignore end*/applyPatch = applyPatch;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;





  /*istanbul ignore start*/var _distanceIterator2 = _interopRequireDefault(distanceIterator);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /*istanbul ignore end*/function applyPatch(source, uniDiff) {
    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (typeof uniDiff === 'string') {
      uniDiff = /*istanbul ignore start*/(0, parse$1.parsePatch) /*istanbul ignore end*/(uniDiff);
    }

    if (Array.isArray(uniDiff)) {
      if (uniDiff.length > 1) {
        throw new Error('applyPatch only works with a single input.');
      }

      uniDiff = uniDiff[0];
    }

    // Apply the diff to the input
    var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        hunks = uniDiff.hunks,
        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{
      return (/*istanbul ignore end*/line === patchContent
      );
    },
        errorCount = 0,
        fuzzFactor = options.fuzzFactor || 0,
        minLine = 0,
        offset = 0,
        removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
        addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;

    /**
     * Checks if the hunk exactly fits on the provided location
     */
    function hunkFits(hunk, toPos) {
      for (var j = 0; j < hunk.lines.length; j++) {
        var line = hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line;

        if (operation === ' ' || operation === '-') {
          // Context sanity check
          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
            errorCount++;

            if (errorCount > fuzzFactor) {
              return false;
            }
          }
          toPos++;
        }
      }

      return true;
    }

    // Search best fit offsets for each hunk based on the previous ones
    for (var i = 0; i < hunks.length; i++) {
      var hunk = hunks[i],
          maxLine = lines.length - hunk.oldLines,
          localOffset = 0,
          toPos = offset + hunk.oldStart - 1;

      var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);

      for (; localOffset !== undefined; localOffset = iterator()) {
        if (hunkFits(hunk, toPos + localOffset)) {
          hunk.offset = offset += localOffset;
          break;
        }
      }

      if (localOffset === undefined) {
        return false;
      }

      // Set lower text limit to end of the current hunk, so next ones don't try
      // to fit over already patched text
      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
    }

    // Apply patch hunks
    var diffOffset = 0;
    for (var _i = 0; _i < hunks.length; _i++) {
      var _hunk = hunks[_i],
          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
      diffOffset += _hunk.newLines - _hunk.oldLines;

      if (_toPos < 0) {
        // Creating a new file
        _toPos = 0;
      }

      for (var j = 0; j < _hunk.lines.length; j++) {
        var line = _hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line,
            delimiter = _hunk.linedelimiters[j];

        if (operation === ' ') {
          _toPos++;
        } else if (operation === '-') {
          lines.splice(_toPos, 1);
          delimiters.splice(_toPos, 1);
          /* istanbul ignore else */
        } else if (operation === '+') {
          lines.splice(_toPos, 0, content);
          delimiters.splice(_toPos, 0, delimiter);
          _toPos++;
        } else if (operation === '\\') {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
          if (previousOperation === '+') {
            removeEOFNL = true;
          } else if (previousOperation === '-') {
            addEOFNL = true;
          }
        }
      }
    }

    // Handle EOFNL insertion/removal
    if (removeEOFNL) {
      while (!lines[lines.length - 1]) {
        lines.pop();
        delimiters.pop();
      }
    } else if (addEOFNL) {
      lines.push('');
      delimiters.push('\n');
    }
    for (var _k = 0; _k < lines.length - 1; _k++) {
      lines[_k] = lines[_k] + delimiters[_k];
    }
    return lines.join('');
  }

  // Wrapper that supports multiple file patches via callbacks.
  function applyPatches(uniDiff, options) {
    if (typeof uniDiff === 'string') {
      uniDiff = /*istanbul ignore start*/(0, parse$1.parsePatch) /*istanbul ignore end*/(uniDiff);
    }

    var currentIndex = 0;
    function processIndex() {
      var index = uniDiff[currentIndex++];
      if (!index) {
        return options.complete();
      }

      options.loadFile(index, function (err, data) {
        if (err) {
          return options.complete(err);
        }

        var updatedContent = applyPatch(data, index, options);
        options.patched(index, updatedContent, function (err) {
          if (err) {
            return options.complete(err);
          }

          processIndex();
        });
      });
    }
    processIndex();
  }

  });

  unwrapExports(apply);
  var apply_1 = apply.applyPatch;
  var apply_2 = apply.applyPatches;

  var create = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports. /*istanbul ignore end*/structuredPatch = structuredPatch;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;



  /*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  /*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    if (!options) {
      options = {};
    }
    if (typeof options.context === 'undefined') {
      options.context = 4;
    }

    var diff = /*istanbul ignore start*/(0, line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);
    diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier

    function contextLines(lines) {
      return lines.map(function (entry) {
        return ' ' + entry;
      });
    }

    var hunks = [];
    var oldRangeStart = 0,
        newRangeStart = 0,
        curRange = [],
        oldLine = 1,
        newLine = 1;

    /*istanbul ignore start*/var _loop = function _loop( /*istanbul ignore end*/i) {
      var current = diff[i],
          lines = current.lines || current.value.replace(/\n$/, '').split('\n');
      current.lines = lines;

      if (current.added || current.removed) {
        /*istanbul ignore start*/var _curRange;

        /*istanbul ignore end*/ // If we have previous context, start with that
        if (!oldRangeStart) {
          var prev = diff[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;

          if (prev) {
            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        }

        // Output our changes
        /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {
          return (current.added ? '+' : '-') + entry;
        })));

        // Track the updated file position
        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        // Identical context lines. Track line changes
        if (oldRangeStart) {
          // Close out any changes that have been output (or join overlapping)
          if (lines.length <= options.context * 2 && i < diff.length - 2) {
            /*istanbul ignore start*/var _curRange2;

            /*istanbul ignore end*/ // Overlapping
            /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));
          } else {
            /*istanbul ignore start*/var _curRange3;

            /*istanbul ignore end*/ // end the range and output
            var contextSize = Math.min(lines.length, options.context);
            /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));

            var hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };
            if (i >= diff.length - 2 && lines.length <= options.context) {
              // EOF is inside this hunk
              var oldEOFNewline = /\n$/.test(oldStr);
              var newEOFNewline = /\n$/.test(newStr);
              if (lines.length == 0 && !oldEOFNewline) {
                // special case: old has no eol and no trailing context; no-nl can end up before adds
                curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
              } else if (!oldEOFNewline || !newEOFNewline) {
                curRange.push('\\ No newline at end of file');
              }
            }
            hunks.push(hunk);

            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }
        oldLine += lines.length;
        newLine += lines.length;
      }
    };

    for (var i = 0; i < diff.length; i++) {
      /*istanbul ignore start*/_loop( /*istanbul ignore end*/i);
    }

    return {
      oldFileName: oldFileName, newFileName: newFileName,
      oldHeader: oldHeader, newHeader: newHeader,
      hunks: hunks
    };
  }

  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);

    var ret = [];
    if (oldFileName == newFileName) {
      ret.push('Index: ' + oldFileName);
    }
    ret.push('===================================================================');
    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

    for (var i = 0; i < diff.hunks.length; i++) {
      var hunk = diff.hunks[i];
      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
      ret.push.apply(ret, hunk.lines);
    }

    return ret.join('\n') + '\n';
  }

  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
  }

  });

  unwrapExports(create);
  var create_1 = create.structuredPatch;
  var create_2 = create.createTwoFilesPatch;
  var create_3 = create.createPatch;

  var array$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports. /*istanbul ignore end*/arrayEqual = arrayEqual;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayStartsWith = arrayStartsWith;
  function arrayEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    return arrayStartsWith(a, b);
  }

  function arrayStartsWith(array, start) {
    if (start.length > array.length) {
      return false;
    }

    for (var i = 0; i < start.length; i++) {
      if (start[i] !== array[i]) {
        return false;
      }
    }

    return true;
  }

  });

  unwrapExports(array$1);
  var array_1$1 = array$1.arrayEqual;
  var array_2$1 = array$1.arrayStartsWith;

  var merge_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports. /*istanbul ignore end*/calcLineCount = calcLineCount;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/merge = merge;







  /*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  /*istanbul ignore end*/function calcLineCount(hunk) {
    /*istanbul ignore start*/var _calcOldNewLineCount = /*istanbul ignore end*/calcOldNewLineCount(hunk.lines),
        oldLines = _calcOldNewLineCount.oldLines,
        newLines = _calcOldNewLineCount.newLines;

    if (oldLines !== undefined) {
      hunk.oldLines = oldLines;
    } else {
      delete hunk.oldLines;
    }

    if (newLines !== undefined) {
      hunk.newLines = newLines;
    } else {
      delete hunk.newLines;
    }
  }

  function merge(mine, theirs, base) {
    mine = loadPatch(mine, base);
    theirs = loadPatch(theirs, base);

    var ret = {};

    // For index we just let it pass through as it doesn't have any necessary meaning.
    // Leaving sanity checks on this to the API consumer that may know more about the
    // meaning in their own context.
    if (mine.index || theirs.index) {
      ret.index = mine.index || theirs.index;
    }

    if (mine.newFileName || theirs.newFileName) {
      if (!fileNameChanged(mine)) {
        // No header or no change in ours, use theirs (and ours if theirs does not exist)
        ret.oldFileName = theirs.oldFileName || mine.oldFileName;
        ret.newFileName = theirs.newFileName || mine.newFileName;
        ret.oldHeader = theirs.oldHeader || mine.oldHeader;
        ret.newHeader = theirs.newHeader || mine.newHeader;
      } else if (!fileNameChanged(theirs)) {
        // No header or no change in theirs, use ours
        ret.oldFileName = mine.oldFileName;
        ret.newFileName = mine.newFileName;
        ret.oldHeader = mine.oldHeader;
        ret.newHeader = mine.newHeader;
      } else {
        // Both changed... figure it out
        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
      }
    }

    ret.hunks = [];

    var mineIndex = 0,
        theirsIndex = 0,
        mineOffset = 0,
        theirsOffset = 0;

    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
      var mineCurrent = mine.hunks[mineIndex] || { oldStart: Infinity },
          theirsCurrent = theirs.hunks[theirsIndex] || { oldStart: Infinity };

      if (hunkBefore(mineCurrent, theirsCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
        mineIndex++;
        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
      } else if (hunkBefore(theirsCurrent, mineCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
        theirsIndex++;
        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
      } else {
        // Overlap, merge as best we can
        var mergedHunk = {
          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
          oldLines: 0,
          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
          newLines: 0,
          lines: []
        };
        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
        theirsIndex++;
        mineIndex++;

        ret.hunks.push(mergedHunk);
      }
    }

    return ret;
  }

  function loadPatch(param, base) {
    if (typeof param === 'string') {
      if (/^@@/m.test(param) || /^Index:/m.test(param)) {
        return (/*istanbul ignore start*/(0, parse$1.parsePatch) /*istanbul ignore end*/(param)[0]
        );
      }

      if (!base) {
        throw new Error('Must provide a base reference or pass in a patch');
      }
      return (/*istanbul ignore start*/(0, create.structuredPatch) /*istanbul ignore end*/(undefined, undefined, base, param)
      );
    }

    return param;
  }

  function fileNameChanged(patch) {
    return patch.newFileName && patch.newFileName !== patch.oldFileName;
  }

  function selectField(index, mine, theirs) {
    if (mine === theirs) {
      return mine;
    } else {
      index.conflict = true;
      return { mine: mine, theirs: theirs };
    }
  }

  function hunkBefore(test, check) {
    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
  }

  function cloneHunk(hunk, offset) {
    return {
      oldStart: hunk.oldStart, oldLines: hunk.oldLines,
      newStart: hunk.newStart + offset, newLines: hunk.newLines,
      lines: hunk.lines
    };
  }

  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
    // This will generally result in a conflicted hunk, but there are cases where the context
    // is the only overlap where we can successfully merge the content here.
    var mine = { offset: mineOffset, lines: mineLines, index: 0 },
        their = { offset: theirOffset, lines: theirLines, index: 0 };

    // Handle any leading content
    insertLeading(hunk, mine, their);
    insertLeading(hunk, their, mine);

    // Now in the overlap content. Scan through and select the best changes from each.
    while (mine.index < mine.lines.length && their.index < their.lines.length) {
      var mineCurrent = mine.lines[mine.index],
          theirCurrent = their.lines[their.index];

      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
        // Both modified ...
        mutualChange(hunk, mine, their);
      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
        /*istanbul ignore start*/var _hunk$lines;

        /*istanbul ignore end*/ // Mine inserted
        /*istanbul ignore start*/(_hunk$lines = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(mine)));
      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
        /*istanbul ignore start*/var _hunk$lines2;

        /*istanbul ignore end*/ // Theirs inserted
        /*istanbul ignore start*/(_hunk$lines2 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(their)));
      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
        // Mine removed or edited
        removal(hunk, mine, their);
      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
        // Their removed or edited
        removal(hunk, their, mine, true);
      } else if (mineCurrent === theirCurrent) {
        // Context identity
        hunk.lines.push(mineCurrent);
        mine.index++;
        their.index++;
      } else {
        // Context mismatch
        conflict(hunk, collectChange(mine), collectChange(their));
      }
    }

    // Now push anything that may be remaining
    insertTrailing(hunk, mine);
    insertTrailing(hunk, their);

    calcLineCount(hunk);
  }

  function mutualChange(hunk, mine, their) {
    var myChanges = collectChange(mine),
        theirChanges = collectChange(their);

    if (allRemoves(myChanges) && allRemoves(theirChanges)) {
      // Special case for remove changes that are supersets of one another
      if ( /*istanbul ignore start*/(0, array$1.arrayStartsWith) /*istanbul ignore end*/(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
        /*istanbul ignore start*/var _hunk$lines3;

        /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines3 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));
        return;
      } else if ( /*istanbul ignore start*/(0, array$1.arrayStartsWith) /*istanbul ignore end*/(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
        /*istanbul ignore start*/var _hunk$lines4;

        /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines4 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines4 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges));
        return;
      }
    } else if ( /*istanbul ignore start*/(0, array$1.arrayEqual) /*istanbul ignore end*/(myChanges, theirChanges)) {
      /*istanbul ignore start*/var _hunk$lines5;

      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines5 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines5 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));
      return;
    }

    conflict(hunk, myChanges, theirChanges);
  }

  function removal(hunk, mine, their, swap) {
    var myChanges = collectChange(mine),
        theirChanges = collectContext(their, myChanges);
    if (theirChanges.merged) {
      /*istanbul ignore start*/var _hunk$lines6;

      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines6 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines6 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges.merged));
    } else {
      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
    }
  }

  function conflict(hunk, mine, their) {
    hunk.conflict = true;
    hunk.lines.push({
      conflict: true,
      mine: mine,
      theirs: their
    });
  }

  function insertLeading(hunk, insert, their) {
    while (insert.offset < their.offset && insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
      insert.offset++;
    }
  }
  function insertTrailing(hunk, insert) {
    while (insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
    }
  }

  function collectChange(state) {
    var ret = [],
        operation = state.lines[state.index][0];
    while (state.index < state.lines.length) {
      var line = state.lines[state.index];

      // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.
      if (operation === '-' && line[0] === '+') {
        operation = '+';
      }

      if (operation === line[0]) {
        ret.push(line);
        state.index++;
      } else {
        break;
      }
    }

    return ret;
  }
  function collectContext(state, matchChanges) {
    var changes = [],
        merged = [],
        matchIndex = 0,
        contextChanges = false,
        conflicted = false;
    while (matchIndex < matchChanges.length && state.index < state.lines.length) {
      var change = state.lines[state.index],
          match = matchChanges[matchIndex];

      // Once we've hit our add, then we are done
      if (match[0] === '+') {
        break;
      }

      contextChanges = contextChanges || change[0] !== ' ';

      merged.push(match);
      matchIndex++;

      // Consume any additions in the other block as a conflict to attempt
      // to pull in the remaining context after this
      if (change[0] === '+') {
        conflicted = true;

        while (change[0] === '+') {
          changes.push(change);
          change = state.lines[++state.index];
        }
      }

      if (match.substr(1) === change.substr(1)) {
        changes.push(change);
        state.index++;
      } else {
        conflicted = true;
      }
    }

    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
      conflicted = true;
    }

    if (conflicted) {
      return changes;
    }

    while (matchIndex < matchChanges.length) {
      merged.push(matchChanges[matchIndex++]);
    }

    return {
      merged: merged,
      changes: changes
    };
  }

  function allRemoves(changes) {
    return changes.reduce(function (prev, change) {
      return prev && change[0] === '-';
    }, true);
  }
  function skipRemoveSuperset(state, removeChanges, delta) {
    for (var i = 0; i < delta; i++) {
      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
      if (state.lines[state.index + i] !== ' ' + changeContent) {
        return false;
      }
    }

    state.index += delta;
    return true;
  }

  function calcOldNewLineCount(lines) {
    var oldLines = 0;
    var newLines = 0;

    lines.forEach(function (line) {
      if (typeof line !== 'string') {
        var myCount = calcOldNewLineCount(line.mine);
        var theirCount = calcOldNewLineCount(line.theirs);

        if (oldLines !== undefined) {
          if (myCount.oldLines === theirCount.oldLines) {
            oldLines += myCount.oldLines;
          } else {
            oldLines = undefined;
          }
        }

        if (newLines !== undefined) {
          if (myCount.newLines === theirCount.newLines) {
            newLines += myCount.newLines;
          } else {
            newLines = undefined;
          }
        }
      } else {
        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
          newLines++;
        }
        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
          oldLines++;
        }
      }
    });

    return { oldLines: oldLines, newLines: newLines };
  }

  });

  unwrapExports(merge_1);
  var merge_2 = merge_1.calcLineCount;
  var merge_3 = merge_1.merge;

  var dmp = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;
  // See: http://code.google.com/p/google-diff-match-patch/wiki/API
  function convertChangesToDMP(changes) {
    var ret = [],
        change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
        operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;
    for (var i = 0; i < changes.length; i++) {
      change = changes[i];
      if (change.added) {
        operation = 1;
      } else if (change.removed) {
        operation = -1;
      } else {
        operation = 0;
      }

      ret.push([operation, change.value]);
    }
    return ret;
  }

  });

  unwrapExports(dmp);
  var dmp_1 = dmp.convertChangesToDMP;

  var xml = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;
  function convertChangesToXML(changes) {
    var ret = [];
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      if (change.added) {
        ret.push('<ins>');
      } else if (change.removed) {
        ret.push('<del>');
      }

      ret.push(escapeHTML(change.value));

      if (change.added) {
        ret.push('</ins>');
      } else if (change.removed) {
        ret.push('</del>');
      }
    }
    return ret.join('');
  }

  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, '&amp;');
    n = n.replace(/</g, '&lt;');
    n = n.replace(/>/g, '&gt;');
    n = n.replace(/"/g, '&quot;');

    return n;
  }

  });

  unwrapExports(xml);
  var xml_1 = xml.convertChangesToXML;

  var lib$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.merge = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;

  /*istanbul ignore end*/

  /*istanbul ignore start*/var _base2 = _interopRequireDefault(base);

  /*istanbul ignore end*/

























  /*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  /* See LICENSE file for terms of use */

  /*
   * Text diff implementation.
   *
   * This library supports the following APIS:
   * JsDiff.diffChars: Character by character diff
   * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
   * JsDiff.diffLines: Line based diff
   *
   * JsDiff.diffCss: Diff targeted at CSS content
   *
   * These methods are based on the implementation proposed in
   * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
   * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
   */
  exports. /*istanbul ignore end*/Diff = _base2['default'];
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = character.diffChars;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = word.diffWords;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = word.diffWordsWithSpace;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = line.diffLines;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = line.diffTrimmedLines;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = sentence.diffSentences;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = css.diffCss;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = json.diffJson;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = array.diffArrays;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = create.structuredPatch;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = create.createTwoFilesPatch;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = create.createPatch;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = apply.applyPatch;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = apply.applyPatches;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = parse$1.parsePatch;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/merge = merge_1.merge;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = dmp.convertChangesToDMP;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = xml.convertChangesToXML;
  /*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = json.canonicalize;

  });

  unwrapExports(lib$1);
  var lib_1 = lib$1.canonicalize;
  var lib_2 = lib$1.convertChangesToXML;
  var lib_3 = lib$1.convertChangesToDMP;
  var lib_4 = lib$1.merge;
  var lib_5 = lib$1.parsePatch;
  var lib_6 = lib$1.applyPatches;
  var lib_7 = lib$1.applyPatch;
  var lib_8 = lib$1.createPatch;
  var lib_9 = lib$1.createTwoFilesPatch;
  var lib_10 = lib$1.structuredPatch;
  var lib_11 = lib$1.diffArrays;
  var lib_12 = lib$1.diffJson;
  var lib_13 = lib$1.diffCss;
  var lib_14 = lib$1.diffSentences;
  var lib_15 = lib$1.diffTrimmedLines;
  var lib_16 = lib$1.diffLines;
  var lib_17 = lib$1.diffWordsWithSpace;
  var lib_18 = lib$1.diffWords;
  var lib_19 = lib$1.diffChars;
  var lib_20 = lib$1.Diff;

  var simpleIsEqual = function simpleIsEqual(a, b) {
    return a === b;
  };

  function index$7 (resultFn, isEqual) {
    if (isEqual === void 0) {
      isEqual = simpleIsEqual;
    }

    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;

    var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {
      return isEqual(newArg, lastArgs[index]);
    };

    var result = function result() {
      for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {
        newArgs[_key] = arguments[_key];
      }

      if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
        return lastResult;
      }

      lastResult = resultFn.apply(this, newArgs);
      calledOnce = true;
      lastThis = this;
      lastArgs = newArgs;
      return lastResult;
    };

    return result;
  }

  function memoize$1(fn) {
    var cache = {};
    return function (arg) {
      if (cache[arg] === undefined) cache[arg] = fn(arg);
      return cache[arg];
    };
  }

  var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };

  /* eslint-disable */
  // murmurhash2 via https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js
  function murmurhash2_32_gc(str) {
    var l = str.length,
        h = l ^ l,
        i = 0,
        k;

    while (l >= 4) {
      k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      k ^= k >>> 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
      l -= 4;
      ++i;
    }

    switch (l) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

      case 2:
        h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

      case 1:
        h ^= str.charCodeAt(i) & 0xff;
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    }

    h ^= h >>> 13;
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h ^= h >>> 15;
    return (h >>> 0).toString(36);
  }

  function stylis_min (W) {
    function M(d, c, e, h, a) {
      for (var m = 0, b = 0, v = 0, n = 0, q, g, x = 0, K = 0, k, u = k = q = 0, l = 0, r = 0, I = 0, t = 0, B = e.length, J = B - 1, y, f = '', p = '', F = '', G = '', C; l < B;) {
        g = e.charCodeAt(l);
        l === J && 0 !== b + n + v + m && (0 !== b && (g = 47 === b ? 10 : 47), n = v = m = 0, B++, J++);

        if (0 === b + n + v + m) {
          if (l === J && (0 < r && (f = f.replace(N, '')), 0 < f.trim().length)) {
            switch (g) {
              case 32:
              case 9:
              case 59:
              case 13:
              case 10:
                break;

              default:
                f += e.charAt(l);
            }

            g = 59;
          }

          switch (g) {
            case 123:
              f = f.trim();
              q = f.charCodeAt(0);
              k = 1;

              for (t = ++l; l < B;) {
                switch (g = e.charCodeAt(l)) {
                  case 123:
                    k++;
                    break;

                  case 125:
                    k--;
                    break;

                  case 47:
                    switch (g = e.charCodeAt(l + 1)) {
                      case 42:
                      case 47:
                        a: {
                          for (u = l + 1; u < J; ++u) {
                            switch (e.charCodeAt(u)) {
                              case 47:
                                if (42 === g && 42 === e.charCodeAt(u - 1) && l + 2 !== u) {
                                  l = u + 1;
                                  break a;
                                }

                                break;

                              case 10:
                                if (47 === g) {
                                  l = u + 1;
                                  break a;
                                }

                            }
                          }

                          l = u;
                        }

                    }

                    break;

                  case 91:
                    g++;

                  case 40:
                    g++;

                  case 34:
                  case 39:
                    for (; l++ < J && e.charCodeAt(l) !== g;) {
                    }

                }

                if (0 === k) break;
                l++;
              }

              k = e.substring(t, l);
              0 === q && (q = (f = f.replace(ca, '').trim()).charCodeAt(0));

              switch (q) {
                case 64:
                  0 < r && (f = f.replace(N, ''));
                  g = f.charCodeAt(1);

                  switch (g) {
                    case 100:
                    case 109:
                    case 115:
                    case 45:
                      r = c;
                      break;

                    default:
                      r = O;
                  }

                  k = M(c, r, k, g, a + 1);
                  t = k.length;
                  0 < A && (r = X(O, f, I), C = H(3, k, r, c, D, z, t, g, a, h), f = r.join(''), void 0 !== C && 0 === (t = (k = C.trim()).length) && (g = 0, k = ''));
                  if (0 < t) switch (g) {
                    case 115:
                      f = f.replace(da, ea);

                    case 100:
                    case 109:
                    case 45:
                      k = f + '{' + k + '}';
                      break;

                    case 107:
                      f = f.replace(fa, '$1 $2');
                      k = f + '{' + k + '}';
                      k = 1 === w || 2 === w && L('@' + k, 3) ? '@-webkit-' + k + '@' + k : '@' + k;
                      break;

                    default:
                      k = f + k, 112 === h && (k = (p += k, ''));
                  } else k = '';
                  break;

                default:
                  k = M(c, X(c, f, I), k, h, a + 1);
              }

              F += k;
              k = I = r = u = q = 0;
              f = '';
              g = e.charCodeAt(++l);
              break;

            case 125:
            case 59:
              f = (0 < r ? f.replace(N, '') : f).trim();
              if (1 < (t = f.length)) switch (0 === u && (q = f.charCodeAt(0), 45 === q || 96 < q && 123 > q) && (t = (f = f.replace(' ', ':')).length), 0 < A && void 0 !== (C = H(1, f, c, d, D, z, p.length, h, a, h)) && 0 === (t = (f = C.trim()).length) && (f = '\x00\x00'), q = f.charCodeAt(0), g = f.charCodeAt(1), q) {
                case 0:
                  break;

                case 64:
                  if (105 === g || 99 === g) {
                    G += f + e.charAt(l);
                    break;
                  }

                default:
                  58 !== f.charCodeAt(t - 1) && (p += P(f, q, g, f.charCodeAt(2)));
              }
              I = r = u = q = 0;
              f = '';
              g = e.charCodeAt(++l);
          }
        }

        switch (g) {
          case 13:
          case 10:
            47 === b ? b = 0 : 0 === 1 + q && 107 !== h && 0 < f.length && (r = 1, f += '\x00');
            0 < A * Y && H(0, f, c, d, D, z, p.length, h, a, h);
            z = 1;
            D++;
            break;

          case 59:
          case 125:
            if (0 === b + n + v + m) {
              z++;
              break;
            }

          default:
            z++;
            y = e.charAt(l);

            switch (g) {
              case 9:
              case 32:
                if (0 === n + m + b) switch (x) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y = '';
                    break;

                  default:
                    32 !== g && (y = ' ');
                }
                break;

              case 0:
                y = '\\0';
                break;

              case 12:
                y = '\\f';
                break;

              case 11:
                y = '\\v';
                break;

              case 38:
                0 === n + b + m && (r = I = 1, y = '\f' + y);
                break;

              case 108:
                if (0 === n + b + m + E && 0 < u) switch (l - u) {
                  case 2:
                    112 === x && 58 === e.charCodeAt(l - 3) && (E = x);

                  case 8:
                    111 === K && (E = K);
                }
                break;

              case 58:
                0 === n + b + m && (u = l);
                break;

              case 44:
                0 === b + v + n + m && (r = 1, y += '\r');
                break;

              case 34:
              case 39:
                0 === b && (n = n === g ? 0 : 0 === n ? g : n);
                break;

              case 91:
                0 === n + b + v && m++;
                break;

              case 93:
                0 === n + b + v && m--;
                break;

              case 41:
                0 === n + b + m && v--;
                break;

              case 40:
                if (0 === n + b + m) {
                  if (0 === q) switch (2 * x + 3 * K) {
                    case 533:
                      break;

                    default:
                      q = 1;
                  }
                  v++;
                }

                break;

              case 64:
                0 === b + v + n + m + u + k && (k = 1);
                break;

              case 42:
              case 47:
                if (!(0 < n + m + v)) switch (b) {
                  case 0:
                    switch (2 * g + 3 * e.charCodeAt(l + 1)) {
                      case 235:
                        b = 47;
                        break;

                      case 220:
                        t = l, b = 42;
                    }

                    break;

                  case 42:
                    47 === g && 42 === x && t + 2 !== l && (33 === e.charCodeAt(t + 2) && (p += e.substring(t, l + 1)), y = '', b = 0);
                }
            }

            0 === b && (f += y);
        }

        K = x;
        x = g;
        l++;
      }

      t = p.length;

      if (0 < t) {
        r = c;
        if (0 < A && (C = H(2, p, r, d, D, z, t, h, a, h), void 0 !== C && 0 === (p = C).length)) return G + p + F;
        p = r.join(',') + '{' + p + '}';

        if (0 !== w * E) {
          2 !== w || L(p, 2) || (E = 0);

          switch (E) {
            case 111:
              p = p.replace(ha, ':-moz-$1') + p;
              break;

            case 112:
              p = p.replace(Q, '::-webkit-input-$1') + p.replace(Q, '::-moz-$1') + p.replace(Q, ':-ms-input-$1') + p;
          }

          E = 0;
        }
      }

      return G + p + F;
    }

    function X(d, c, e) {
      var h = c.trim().split(ia);
      c = h;
      var a = h.length,
          m = d.length;

      switch (m) {
        case 0:
        case 1:
          var b = 0;

          for (d = 0 === m ? '' : d[0] + ' '; b < a; ++b) {
            c[b] = Z(d, c[b], e, m).trim();
          }

          break;

        default:
          var v = b = 0;

          for (c = []; b < a; ++b) {
            for (var n = 0; n < m; ++n) {
              c[v++] = Z(d[n] + ' ', h[b], e, m).trim();
            }
          }

      }

      return c;
    }

    function Z(d, c, e) {
      var h = c.charCodeAt(0);
      33 > h && (h = (c = c.trim()).charCodeAt(0));

      switch (h) {
        case 38:
          return c.replace(F, '$1' + d.trim());

        case 58:
          return d.trim() + c.replace(F, '$1' + d.trim());

        default:
          if (0 < 1 * e && 0 < c.indexOf('\f')) return c.replace(F, (58 === d.charCodeAt(0) ? '' : '$1') + d.trim());
      }

      return d + c;
    }

    function P(d, c, e, h) {
      var a = d + ';',
          m = 2 * c + 3 * e + 4 * h;

      if (944 === m) {
        d = a.indexOf(':', 9) + 1;
        var b = a.substring(d, a.length - 1).trim();
        b = a.substring(0, d).trim() + b + ';';
        return 1 === w || 2 === w && L(b, 1) ? '-webkit-' + b + b : b;
      }

      if (0 === w || 2 === w && !L(a, 1)) return a;

      switch (m) {
        case 1015:
          return 97 === a.charCodeAt(10) ? '-webkit-' + a + a : a;

        case 951:
          return 116 === a.charCodeAt(3) ? '-webkit-' + a + a : a;

        case 963:
          return 110 === a.charCodeAt(5) ? '-webkit-' + a + a : a;

        case 1009:
          if (100 !== a.charCodeAt(4)) break;

        case 969:
        case 942:
          return '-webkit-' + a + a;

        case 978:
          return '-webkit-' + a + '-moz-' + a + a;

        case 1019:
        case 983:
          return '-webkit-' + a + '-moz-' + a + '-ms-' + a + a;

        case 883:
          if (45 === a.charCodeAt(8)) return '-webkit-' + a + a;
          if (0 < a.indexOf('image-set(', 11)) return a.replace(ja, '$1-webkit-$2') + a;
          break;

        case 932:
          if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {
            case 103:
              return '-webkit-box-' + a.replace('-grow', '') + '-webkit-' + a + '-ms-' + a.replace('grow', 'positive') + a;

            case 115:
              return '-webkit-' + a + '-ms-' + a.replace('shrink', 'negative') + a;

            case 98:
              return '-webkit-' + a + '-ms-' + a.replace('basis', 'preferred-size') + a;
          }
          return '-webkit-' + a + '-ms-' + a + a;

        case 964:
          return '-webkit-' + a + '-ms-flex-' + a + a;

        case 1023:
          if (99 !== a.charCodeAt(8)) break;
          b = a.substring(a.indexOf(':', 15)).replace('flex-', '').replace('space-between', 'justify');
          return '-webkit-box-pack' + b + '-webkit-' + a + '-ms-flex-pack' + b + a;

        case 1005:
          return ka.test(a) ? a.replace(aa, ':-webkit-') + a.replace(aa, ':-moz-') + a : a;

        case 1e3:
          b = a.substring(13).trim();
          c = b.indexOf('-') + 1;

          switch (b.charCodeAt(0) + b.charCodeAt(c)) {
            case 226:
              b = a.replace(G, 'tb');
              break;

            case 232:
              b = a.replace(G, 'tb-rl');
              break;

            case 220:
              b = a.replace(G, 'lr');
              break;

            default:
              return a;
          }

          return '-webkit-' + a + '-ms-' + b + a;

        case 1017:
          if (-1 === a.indexOf('sticky', 9)) break;

        case 975:
          c = (a = d).length - 10;
          b = (33 === a.charCodeAt(c) ? a.substring(0, c) : a).substring(d.indexOf(':', 7) + 1).trim();

          switch (m = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {
            case 203:
              if (111 > b.charCodeAt(8)) break;

            case 115:
              a = a.replace(b, '-webkit-' + b) + ';' + a;
              break;

            case 207:
            case 102:
              a = a.replace(b, '-webkit-' + (102 < m ? 'inline-' : '') + 'box') + ';' + a.replace(b, '-webkit-' + b) + ';' + a.replace(b, '-ms-' + b + 'box') + ';' + a;
          }

          return a + ';';

        case 938:
          if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {
            case 105:
              return b = a.replace('-items', ''), '-webkit-' + a + '-webkit-box-' + b + '-ms-flex-' + b + a;

            case 115:
              return '-webkit-' + a + '-ms-flex-item-' + a.replace(ba, '') + a;

            default:
              return '-webkit-' + a + '-ms-flex-line-pack' + a.replace('align-content', '').replace(ba, '') + a;
          }
          break;

        case 973:
        case 989:
          if (45 !== a.charCodeAt(3) || 122 === a.charCodeAt(4)) break;

        case 931:
        case 953:
          if (!0 === la.test(d)) return 115 === (b = d.substring(d.indexOf(':') + 1)).charCodeAt(0) ? P(d.replace('stretch', 'fill-available'), c, e, h).replace(':fill-available', ':stretch') : a.replace(b, '-webkit-' + b) + a.replace(b, '-moz-' + b.replace('fill-', '')) + a;
          break;

        case 962:
          if (a = '-webkit-' + a + (102 === a.charCodeAt(5) ? '-ms-' + a : '') + a, 211 === e + h && 105 === a.charCodeAt(13) && 0 < a.indexOf('transform', 10)) return a.substring(0, a.indexOf(';', 27) + 1).replace(ma, '$1-webkit-$2') + a;
      }

      return a;
    }

    function L(d, c) {
      var e = d.indexOf(1 === c ? ':' : '{'),
          h = d.substring(0, 3 !== c ? e : 10);
      e = d.substring(e + 1, d.length - 1);
      return R(2 !== c ? h : h.replace(na, '$1'), e, c);
    }

    function ea(d, c) {
      var e = P(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));
      return e !== c + ';' ? e.replace(oa, ' or ($1)').substring(4) : '(' + c + ')';
    }

    function H(d, c, e, h, a, m, b, v, n, q) {
      for (var g = 0, x = c, w; g < A; ++g) {
        switch (w = S[g].call(B, d, x, e, h, a, m, b, v, n, q)) {
          case void 0:
          case !1:
          case !0:
          case null:
            break;

          default:
            x = w;
        }
      }

      if (x !== c) return x;
    }

    function T(d) {
      switch (d) {
        case void 0:
        case null:
          A = S.length = 0;
          break;

        default:
          switch (d.constructor) {
            case Array:
              for (var c = 0, e = d.length; c < e; ++c) {
                T(d[c]);
              }

              break;

            case Function:
              S[A++] = d;
              break;

            case Boolean:
              Y = !!d | 0;
          }

      }

      return T;
    }

    function U(d) {
      d = d.prefix;
      void 0 !== d && (R = null, d ? 'function' !== typeof d ? w = 1 : (w = 2, R = d) : w = 0);
      return U;
    }

    function B(d, c) {
      var e = d;
      33 > e.charCodeAt(0) && (e = e.trim());
      V = e;
      e = [V];

      if (0 < A) {
        var h = H(-1, c, e, e, D, z, 0, 0, 0, 0);
        void 0 !== h && 'string' === typeof h && (c = h);
      }

      var a = M(O, e, c, 0, 0);
      0 < A && (h = H(-2, a, e, e, D, z, a.length, 0, 0, 0), void 0 !== h && (a = h));
      V = '';
      E = 0;
      z = D = 1;
      return a;
    }

    var ca = /^\0+/g,
        N = /[\0\r\f]/g,
        aa = /: */g,
        ka = /zoo|gra/,
        ma = /([,: ])(transform)/g,
        ia = /,\r+?/g,
        F = /([\t\r\n ])*\f?&/g,
        fa = /@(k\w+)\s*(\S*)\s*/,
        Q = /::(place)/g,
        ha = /:(read-only)/g,
        G = /[svh]\w+-[tblr]{2}/,
        da = /\(\s*(.*)\s*\)/g,
        oa = /([\s\S]*?);/g,
        ba = /-self|flex-/g,
        na = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
        la = /stretch|:\s*\w+\-(?:conte|avail)/,
        ja = /([^-])(image-set\()/,
        z = 1,
        D = 1,
        E = 0,
        w = 1,
        O = [],
        S = [],
        A = 0,
        R = null,
        Y = 0,
        V = '';
    B.use = T;
    B.set = U;
    void 0 !== W && U(W);
    return B;
  }

  var stylisRuleSheet = createCommonjsModule(function (module, exports) {
  (function (factory) {
  	module['exports'] = factory();
  }(function () {

  	return function (insertRule) {
  		var delimiter = '/*|*/';
  		var needle = delimiter+'}';

  		function toSheet (block) {
  			if (block)
  				try {
  					insertRule(block + '}');
  				} catch (e) {}
  		}

  		return function ruleSheet (context, content, selectors, parents, line, column, length, ns, depth, at) {
  			switch (context) {
  				// property
  				case 1:
  					// @import
  					if (depth === 0 && content.charCodeAt(0) === 64)
  						return insertRule(content+';'), ''
  					break
  				// selector
  				case 2:
  					if (ns === 0)
  						return content + delimiter
  					break
  				// at-rule
  				case 3:
  					switch (ns) {
  						// @font-face, @page
  						case 102:
  						case 112:
  							return insertRule(selectors[0]+content), ''
  						default:
  							return content + (at === 0 ? delimiter : '')
  					}
  				case -2:
  					content.split(needle).forEach(toSheet);
  			}
  		}
  	}
  }));
  });

  var hyphenateRegex = /[A-Z]|^ms/g;
  var processStyleName = memoize$1(function (styleName) {
    return styleName.replace(hyphenateRegex, '-$&').toLowerCase();
  });
  var processStyleValue = function processStyleValue(key, value) {
    if (value == null || typeof value === 'boolean') {
      return '';
    }

    if (unitlessKeys[key] !== 1 && key.charCodeAt(1) !== 45 && // custom properties
    !isNaN(value) && value !== 0) {
      return value + 'px';
    }

    return value;
  };

  var classnames$1 = function classnames(args) {
    var len = args.length;
    var i = 0;
    var cls = '';

    for (; i < len; i++) {
      var arg = args[i];
      if (arg == null) continue;
      var toAdd = void 0;

      switch (typeof arg) {
        case 'boolean':
          break;

        case 'function':

          toAdd = classnames([arg()]);
          break;

        case 'object':
          {
            if (Array.isArray(arg)) {
              toAdd = classnames(arg);
            } else {
              toAdd = '';

              for (var k in arg) {
                if (arg[k] && k) {
                  toAdd && (toAdd += ' ');
                  toAdd += k;
                }
              }
            }

            break;
          }

        default:
          {
            toAdd = arg;
          }
      }

      if (toAdd) {
        cls && (cls += ' ');
        cls += toAdd;
      }
    }

    return cls;
  };
  var isBrowser$1 = typeof document !== 'undefined';

  /*

  high performance StyleSheet for css-in-js systems

  - uses multiple style tags behind the scenes for millions of rules
  - uses `insertRule` for appending in production for *much* faster performance
  - 'polyfills' on server side

  // usage

  import StyleSheet from 'glamor/lib/sheet'
  let styleSheet = new StyleSheet()

  styleSheet.inject()
  - 'injects' the stylesheet into the page (or into memory if on server)

  styleSheet.insert('#box { border: 1px solid red; }')
  - appends a css rule into the stylesheet

  styleSheet.flush()
  - empties the stylesheet of all its contents

  */
  // $FlowFixMe
  function sheetForTag(tag) {
    if (tag.sheet) {
      // $FlowFixMe
      return tag.sheet;
    } // this weirdness brought to you by firefox


    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        // $FlowFixMe
        return document.styleSheets[i];
      }
    }
  }

  function makeStyleTag(opts) {
    var tag = document.createElement('style');
    tag.setAttribute('data-emotion', opts.key || '');

    if (opts.nonce !== undefined) {
      tag.setAttribute('nonce', opts.nonce);
    }

    tag.appendChild(document.createTextNode('')) // $FlowFixMe
    ;
    (opts.container !== undefined ? opts.container : document.head).appendChild(tag);
    return tag;
  }

  var StyleSheet =
  /*#__PURE__*/
  function () {
    function StyleSheet(options) {
      this.isSpeedy = "production" === 'production'; // the big drawback here is that the css won't be editable in devtools

      this.tags = [];
      this.ctr = 0;
      this.opts = options;
    }

    var _proto = StyleSheet.prototype;

    _proto.inject = function inject() {
      if (this.injected) {
        throw new Error('already injected!');
      }

      this.tags[0] = makeStyleTag(this.opts);
      this.injected = true;
    };

    _proto.speedy = function speedy(bool) {
      if (this.ctr !== 0) {
        // cannot change speedy mode after inserting any rule to sheet. Either call speedy(${bool}) earlier in your app, or call flush() before speedy(${bool})
        throw new Error("cannot change speedy now");
      }

      this.isSpeedy = !!bool;
    };

    _proto.insert = function insert(rule, sourceMap) {
      // this is the ultrafast version, works across browsers
      if (this.isSpeedy) {
        var tag = this.tags[this.tags.length - 1];
        var sheet = sheetForTag(tag);

        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
        }
      } else {
        var _tag = makeStyleTag(this.opts);

        this.tags.push(_tag);

        _tag.appendChild(document.createTextNode(rule + (sourceMap || '')));
      }

      this.ctr++;

      if (this.ctr % 65000 === 0) {
        this.tags.push(makeStyleTag(this.opts));
      }
    };

    _proto.flush = function flush() {
      // $FlowFixMe
      this.tags.forEach(function (tag) {
        return tag.parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0; // todo - look for remnants in document.styleSheets

      this.injected = false;
    };

    return StyleSheet;
  }();

  function createEmotion(context, options) {
    if (context.__SECRET_EMOTION__ !== undefined) {
      return context.__SECRET_EMOTION__;
    }

    if (options === undefined) options = {};
    var key = options.key || 'css';

    var current;

    function insertRule(rule) {
      current += rule;

      if (isBrowser$1) {
        sheet.insert(rule, currentSourceMap);
      }
    }

    var insertionPlugin = stylisRuleSheet(insertRule);
    var stylisOptions;

    if (options.prefix !== undefined) {
      stylisOptions = {
        prefix: options.prefix
      };
    }

    var caches = {
      registered: {},
      inserted: {},
      nonce: options.nonce,
      key: key
    };
    var sheet = new StyleSheet(options);

    if (isBrowser$1) {
      // 🚀
      sheet.inject();
    }

    var stylis = new stylis_min(stylisOptions);
    stylis.use(options.stylisPlugins)(insertionPlugin);
    var currentSourceMap = '';

    function handleInterpolation(interpolation, couldBeSelectorInterpolation) {
      if (interpolation == null) {
        return '';
      }

      switch (typeof interpolation) {
        case 'boolean':
          return '';

        case 'function':
          if (interpolation.__emotion_styles !== undefined) {
            var selector = interpolation.toString();

            if (selector === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
              throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
            }

            return selector;
          }

          if (this === undefined && "production" !== 'production') {
            console.error('Interpolating functions in css calls is deprecated and will be removed in the next major version of Emotion.\n' + 'If you want to have a css call based on props, create a function that returns a css call like this\n' + 'let dynamicStyle = (props) => css`color: ${props.color}`\n' + 'It can be called directly with props or interpolated in a styled call like this\n' + "let SomeComponent = styled('div')`${dynamicStyle}`");
          }

          return handleInterpolation.call(this, this === undefined ? interpolation() : // $FlowFixMe
          interpolation(this.mergedProps, this.context), couldBeSelectorInterpolation);

        case 'object':
          return createStringFromObject.call(this, interpolation);

        default:
          var cached = caches.registered[interpolation];
          return couldBeSelectorInterpolation === false && cached !== undefined ? cached : interpolation;
      }
    }

    var objectToStringCache = new WeakMap();

    function createStringFromObject(obj) {
      if (objectToStringCache.has(obj)) {
        // $FlowFixMe
        return objectToStringCache.get(obj);
      }

      var string = '';

      if (Array.isArray(obj)) {
        obj.forEach(function (interpolation) {
          string += handleInterpolation.call(this, interpolation, false);
        }, this);
      } else {
        Object.keys(obj).forEach(function (key) {
          if (typeof obj[key] !== 'object') {
            if (caches.registered[obj[key]] !== undefined) {
              string += key + "{" + caches.registered[obj[key]] + "}";
            } else {
              string += processStyleName(key) + ":" + processStyleValue(key, obj[key]) + ";";
            }
          } else {
            if (key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
              throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');
            }

            if (Array.isArray(obj[key]) && typeof obj[key][0] === 'string' && caches.registered[obj[key][0]] === undefined) {
              obj[key].forEach(function (value) {
                string += processStyleName(key) + ":" + processStyleValue(key, value) + ";";
              });
            } else {
              string += key + "{" + handleInterpolation.call(this, obj[key], false) + "}";
            }
          }
        }, this);
      }

      objectToStringCache.set(obj, string);
      return string;
    }

    var name;
    var stylesWithLabel;
    var labelPattern = /label:\s*([^\s;\n{]+)\s*;/g;

    var createClassName = function createClassName(styles, identifierName) {
      return murmurhash2_32_gc(styles + identifierName) + identifierName;
    };

    var createStyles = function createStyles(strings) {
      var stringMode = true;
      var styles = '';
      var identifierName = '';

      if (strings == null || strings.raw === undefined) {
        stringMode = false;
        styles += handleInterpolation.call(this, strings, false);
      } else {
        styles += strings[0];
      }

      for (var _len = arguments.length, interpolations = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        interpolations[_key - 1] = arguments[_key];
      }

      interpolations.forEach(function (interpolation, i) {
        styles += handleInterpolation.call(this, interpolation, styles.charCodeAt(styles.length - 1) === 46 // .
        );

        if (stringMode === true && strings[i + 1] !== undefined) {
          styles += strings[i + 1];
        }
      }, this);
      stylesWithLabel = styles;
      styles = styles.replace(labelPattern, function (match, p1) {
        identifierName += "-" + p1;
        return '';
      });
      name = createClassName(styles, identifierName);
      return styles;
    };

    function insert(scope, styles) {
      if (caches.inserted[name] === undefined) {
        current = '';
        stylis(scope, styles);
        caches.inserted[name] = current;
      }
    }

    var css = function css() {
      var styles = createStyles.apply(this, arguments);
      var selector = key + "-" + name;

      if (caches.registered[selector] === undefined) {
        caches.registered[selector] = stylesWithLabel;
      }

      insert("." + selector, styles);
      return selector;
    };

    var keyframes = function keyframes() {
      var styles = createStyles.apply(this, arguments);
      var animation = "animation-" + name;
      insert('', "@keyframes " + animation + "{" + styles + "}");
      return animation;
    };

    var injectGlobal = function injectGlobal() {
      var styles = createStyles.apply(this, arguments);
      insert('', styles);
    };

    function getRegisteredStyles(registeredStyles, classNames) {
      var rawClassName = '';
      classNames.split(' ').forEach(function (className) {
        if (caches.registered[className] !== undefined) {
          registeredStyles.push(className);
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }

    function merge(className, sourceMap) {
      var registeredStyles = [];
      var rawClassName = getRegisteredStyles(registeredStyles, className);

      if (registeredStyles.length < 2) {
        return className;
      }

      return rawClassName + css(registeredStyles, sourceMap);
    }

    function cx() {
      for (var _len2 = arguments.length, classNames = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        classNames[_key2] = arguments[_key2];
      }

      return merge(classnames$1(classNames));
    }

    function hydrateSingleId(id) {
      caches.inserted[id] = true;
    }

    function hydrate(ids) {
      ids.forEach(hydrateSingleId);
    }

    function flush() {
      if (isBrowser$1) {
        sheet.flush();
        sheet.inject();
      }

      caches.inserted = {};
      caches.registered = {};
    }

    if (isBrowser$1) {
      var chunks = document.querySelectorAll("[data-emotion-" + key + "]");
      Array.prototype.forEach.call(chunks, function (node) {
        // $FlowFixMe
        sheet.tags[0].parentNode.insertBefore(node, sheet.tags[0]); // $FlowFixMe

        node.getAttribute("data-emotion-" + key).split(' ').forEach(hydrateSingleId);
      });
    }

    var emotion = {
      flush: flush,
      hydrate: hydrate,
      cx: cx,
      merge: merge,
      getRegisteredStyles: getRegisteredStyles,
      injectGlobal: injectGlobal,
      keyframes: keyframes,
      css: css,
      sheet: sheet,
      caches: caches
    };
    context.__SECRET_EMOTION__ = emotion;
    return emotion;
  }

  var context$1 = typeof global !== 'undefined' ? global : {};

  var _createEmotion = createEmotion(context$1),
      flush = _createEmotion.flush,
      hydrate = _createEmotion.hydrate,
      cx$1 = _createEmotion.cx,
      merge$1 = _createEmotion.merge,
      getRegisteredStyles = _createEmotion.getRegisteredStyles,
      injectGlobal = _createEmotion.injectGlobal,
      keyframes = _createEmotion.keyframes,
      css$1 = _createEmotion.css,
      sheet = _createEmotion.sheet,
      caches = _createEmotion.caches;

  var index_esm = /*#__PURE__*/Object.freeze({
    flush: flush,
    hydrate: hydrate,
    cx: cx$1,
    merge: merge$1,
    getRegisteredStyles: getRegisteredStyles,
    injectGlobal: injectGlobal,
    keyframes: keyframes,
    css: css$1,
    sheet: sheet,
    caches: caches
  });

  var styles$1 = createCommonjsModule(function (module, exports) {
  var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  var __rest = (commonjsGlobal && commonjsGlobal.__rest) || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
              t[p[i]] = s[p[i]];
      return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  exports.default = (function (styleOverride) {
      var _a, _b;
      var overrideVariables = styleOverride.variables, styles = __rest(styleOverride, ["variables"]);
      var variables = __assign({
          addedBackground: '#e6ffed',
          addedColor: '#24292e',
          removedBackground: '#ffeef0',
          removedColor: '#24292e',
          wordAddedBackground: '#acf2bd',
          wordRemovedBackground: '#fdb8c0',
          addedGutterBackground: '#cdffd8',
          removedGutterBackground: '#ffdce0',
          gutterBackground: '#f7f7f7',
          gutterBackgroundDark: '#f3f1f1',
          highlightBackground: '#fffbdd',
          highlightGutterBackground: '#fff5b1',
      }, overrideVariables);
      var diffContainer = index_esm.css({
          width: '100%',
          'pre': {
              margin: 0,
              whiteSpace: 'pre-wrap',
              lineHeight: '25px',
          },
          'tbody': {
              tr: {
                  '&:first-child': {
                      td: {
                          paddingTop: 15,
                      },
                  },
                  '&:last-child': {
                      td: {
                          paddingBottom: 15,
                      },
                  },
              },
          },
          label: 'diff-container',
      });
      var diffRemoved = index_esm.css({
          background: variables.removedBackground,
          color: variables.removedColor,
          pre: {
              color: variables.removedColor,
          },
          label: 'diff-removed',
      });
      var diffAdded = index_esm.css({
          background: variables.addedBackground,
          color: variables.addedColor,
          pre: {
              color: variables.addedColor,
          },
          label: 'diff-added',
      });
      var marker = index_esm.css((_a = {
              minWidth: 50,
              paddingLeft: 10,
              userSelect: 'none',
              label: 'marker'
          },
          _a["&." + diffAdded] = {
              pre: {
                  color: variables.addedColor,
              }
          },
          _a["&." + diffRemoved] = {
              pre: {
                  color: variables.removedColor,
              }
          },
          _a));
      var hightlightedLine = index_esm.css({
          background: variables.highlightBackground,
          label: 'hightlighted-line',
      });
      var hightlightedGutter = index_esm.css({
          label: 'hightlighted-gutter',
      });
      var gutter = index_esm.css((_b = {
              userSelect: 'none',
              minWidth: 40,
              padding: '0 10px',
              label: 'gutter',
              cursor: 'pointer',
              textAlign: 'right',
              background: variables.gutterBackground,
              '&:hover': {
                  background: variables.gutterBackgroundDark,
                  pre: {
                      opacity: 1,
                  },
              },
              pre: {
                  opacity: 0.5,
              }
          },
          _b["&." + diffAdded] = {
              background: variables.addedGutterBackground,
          },
          _b["&." + diffRemoved] = {
              background: variables.removedGutterBackground,
          },
          _b["&." + hightlightedGutter] = {
              background: variables.highlightGutterBackground,
              '&:hover': {
                  background: variables.highlightGutterBackground,
              },
          },
          _b));
      var line = index_esm.css({
          verticalAlign: 'baseline',
          label: 'line',
      });
      var wordDiff = index_esm.css({
          padding: 2,
          display: 'inline-flex',
          borderRadius: 1,
          label: 'word-diff',
      });
      var wordAdded = index_esm.css({
          background: variables.wordAddedBackground,
          label: 'word-added',
      });
      var wordRemoved = index_esm.css({
          background: variables.wordRemovedBackground,
          label: 'word-removed',
      });
      var leftGutter = index_esm.css({
          label: 'left-gutter',
      });
      var rightGutter = index_esm.css({
          label: 'right-gutter',
      });
      var defaultStyles = {
          diffContainer: diffContainer,
          diffRemoved: diffRemoved,
          diffAdded: diffAdded,
          marker: marker,
          hightlightedGutter: hightlightedGutter,
          hightlightedLine: hightlightedLine,
          gutter: gutter,
          line: line,
          wordDiff: wordDiff,
          wordAdded: wordAdded,
          wordRemoved: wordRemoved,
          leftGutter: leftGutter,
          rightGutter: rightGutter,
      };
      var computerOverrideStyles = Object.keys(styles)
          .reduce(function (acc, key) {
          var _a;
          return (__assign({}, acc, (_a = {},
              _a[key] = index_esm.css(styles[key]),
              _a)));
      }, {});
      return Object.keys(defaultStyles)
          .reduce(function (acc, key) {
          var _a;
          return (__assign({}, acc, (_a = {},
              _a[key] = computerOverrideStyles[key]
                  ? index_esm.cx(defaultStyles[key], computerOverrideStyles[key])
                  : defaultStyles[key],
              _a)));
      }, {});
  });
  });

  unwrapExports(styles$1);

  var line$1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });


  var rightLineNumberPrefix = 'R';
  var leftLineNumberPrefix = 'L';
  var onLineNumberClickProxy = function (onLineNumberClick, id) {
      return function (e) { return onLineNumberClick(id, e); };
  };
  var LineNumber = function (_a) {
      var prefix = _a.prefix, lineNumber = _a.lineNumber;
      return react.createElement("pre", { id: prefix + "-" + lineNumber }, lineNumber);
  };
  exports.InlineLine = function (_a) {
      var leftLineNumber = _a.leftLineNumber, rightLineNumber = _a.rightLineNumber, added = _a.added, removed = _a.removed, content = _a.content, _b = _a.onLineNumberClick, onLineNumberClick = _b === void 0 ? function () { } : _b, renderContent = _a.renderContent, _c = _a.hightlightLines, hightlightLines = _c === void 0 ? [] : _c, styles = _a.styles, hideLineNumbers = _a.hideLineNumbers;
      var _d, _e, _f, _g;
      var hightlightLine = (leftLineNumber !== true || rightLineNumber !== true)
          && (hightlightLines.includes(leftLineNumberPrefix + "-" + leftLineNumber)
              || hightlightLines.includes(rightLineNumberPrefix + "-" + rightLineNumber));
      return react.createElement("tr", { className: styles.line },
          !hideLineNumbers
              && react.createElement(react.Fragment, null,
                  react.createElement("td", { className: classnames.default(styles.gutter, styles.leftGutter, (_d = {},
                          _d[styles.diffAdded] = added,
                          _d[styles.diffRemoved] = removed,
                          _d[styles.hightlightedGutter] = hightlightLine,
                          _d)), onClick: onLineNumberClickProxy(onLineNumberClick, leftLineNumberPrefix + "-" + leftLineNumber) }, leftLineNumber !== true
                      && react.createElement(LineNumber, { lineNumber: leftLineNumber, prefix: leftLineNumberPrefix })),
                  react.createElement("td", { className: classnames.default(styles.gutter, styles.rightGutter, (_e = {},
                          _e[styles.diffAdded] = added,
                          _e[styles.diffRemoved] = removed,
                          _e[styles.hightlightedGutter] = hightlightLine,
                          _e)), onClick: onLineNumberClickProxy(onLineNumberClick, rightLineNumberPrefix + "-" + rightLineNumber) }, rightLineNumber !== true
                      && react.createElement(LineNumber, { lineNumber: rightLineNumber, prefix: rightLineNumberPrefix }))),
          react.createElement("td", { className: classnames.default(styles.marker, (_f = {},
                  _f[styles.diffAdded] = added,
                  _f[styles.diffRemoved] = removed,
                  _f[styles.hightlightedLine] = hightlightLine,
                  _f)) },
              added && react.createElement("pre", null, "+"),
              removed && react.createElement("pre", null, "-")),
          react.createElement("td", { className: classnames.default((_g = {},
                  _g[styles.diffAdded] = added,
                  _g[styles.diffRemoved] = removed,
                  _g[styles.hightlightedLine] = hightlightLine,
                  _g)) }, renderContent && typeof content === 'string'
              ? renderContent(content)
              : react.createElement("pre", null, content)));
  };
  exports.DefaultLine = function (_a) {
      var leftLineNumber = _a.leftLineNumber, rightLineNumber = _a.rightLineNumber, onLineNumberClick = _a.onLineNumberClick, rightContent = _a.rightContent, leftContent = _a.leftContent, added = _a.added, removed = _a.removed, renderContent = _a.renderContent, _b = _a.hightlightLines, hightlightLines = _b === void 0 ? [] : _b, styles = _a.styles, hideLineNumbers = _a.hideLineNumbers;
      var _c, _d, _e, _f, _g, _h;
      var hightlightLeftLine = leftLineNumber !== true
          && hightlightLines.includes(leftLineNumberPrefix + "-" + leftLineNumber);
      var hightlightRightLine = rightLineNumber !== true
          && hightlightLines.includes(rightLineNumberPrefix + "-" + rightLineNumber);
      return react.createElement("tr", { className: styles.line },
          !hideLineNumbers
              && react.createElement("td", { className: classnames.default(styles.gutter, styles.leftGutter, (_c = {},
                      _c[styles.diffRemoved] = removed,
                      _c[styles.hightlightedGutter] = hightlightLeftLine,
                      _c)), onClick: onLineNumberClickProxy(onLineNumberClick, leftLineNumberPrefix + "-" + leftLineNumber) }, leftLineNumber
                  && react.createElement(LineNumber, { lineNumber: leftLineNumber, prefix: leftLineNumberPrefix })),
          react.createElement("td", { className: classnames.default(styles.marker, (_d = {},
                  _d[styles.diffRemoved] = removed,
                  _d[styles.hightlightedLine] = hightlightLeftLine,
                  _d)) }, removed
              && react.createElement("pre", null, "-")),
          react.createElement("td", { className: classnames.default((_e = {},
                  _e[styles.diffRemoved] = removed,
                  _e[styles.hightlightedLine] = hightlightLeftLine,
                  _e)) }, typeof leftContent === 'string'
              && (renderContent
                  ? renderContent(leftContent)
                  : react.createElement("pre", null, leftContent))
              || leftContent),
          !hideLineNumbers
              && react.createElement("td", { className: classnames.default(styles.gutter, styles.rightGutter, (_f = {},
                      _f[styles.diffAdded] = added,
                      _f[styles.hightlightedGutter] = hightlightRightLine,
                      _f)), onClick: onLineNumberClickProxy(onLineNumberClick, rightLineNumberPrefix + "-" + rightLineNumber) },
                  react.createElement(LineNumber, { lineNumber: rightLineNumber, prefix: rightLineNumberPrefix })),
          react.createElement("td", { className: classnames.default(styles.marker, (_g = {},
                  _g[styles.diffAdded] = added,
                  _g[styles.hightlightedLine] = hightlightRightLine,
                  _g)) }, added
              && react.createElement("pre", null, "+")),
          react.createElement("td", { className: classnames.default((_h = {},
                  _h[styles.diffAdded] = added,
                  _h[styles.hightlightedLine] = hightlightRightLine,
                  _h)) }, typeof rightContent === 'string'
              && (renderContent
                  ? renderContent(rightContent)
                  : react.createElement("pre", null, rightContent))
              || rightContent));
  };
  });

  unwrapExports(line$1);
  var line_1$1 = line$1.InlineLine;
  var line_2$1 = line$1.DefaultLine;

  var lib$2 = createCommonjsModule(function (module, exports) {
  var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  Object.defineProperty(exports, "__esModule", { value: true });





  var memoize = index$7.default || index$7;


  var wordDiff = function (oldValue, newValue, hideType, styles, renderContent) {
      var charDiff = lib$1.diffWordsWithSpace(oldValue, newValue);
      return charDiff.map(function (obj, i) {
          var _a, _b;
          if (obj[hideType])
              return undefined;
          if (renderContent) {
              return react.createElement("span", { className: classnames.default(styles.wordDiff, (_a = {},
                      _a[styles.wordAdded] = obj.added,
                      _a[styles.wordRemoved] = obj.removed,
                      _a)), key: i }, renderContent(obj.value));
          }
          return react.createElement("pre", { className: classnames.default(styles.wordDiff, (_b = {},
                  _b[styles.wordAdded] = obj.added,
                  _b[styles.wordRemoved] = obj.removed,
                  _b)), key: i }, obj.value);
      });
  };
  var DiffViewer = /** @class */ (function (_super) {
      __extends(DiffViewer, _super);
      function DiffViewer() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.splitView = function (diffArray, styles) {
              var leftLineNumber = 0;
              var rightLineNumber = 0;
              return function () { return diffArray.map(function (obj, i) {
                  return react.createElement(react.Fragment, { key: i }, obj.value.split('\n')
                      .filter(function (ch) { return ch.length > 0; })
                      .map(function (ch, num) {
                      if (!obj.added && !obj.removed) {
                          rightLineNumber = rightLineNumber + 1;
                          leftLineNumber = leftLineNumber + 1;
                          return react.createElement(line$1.DefaultLine, { styles: styles, hideLineNumbers: _this.props.hideLineNumbers, leftLineNumber: leftLineNumber, rightLineNumber: rightLineNumber, leftContent: ch, rightContent: ch, key: num, hightlightLines: _this.props.highlightLines, renderContent: _this.props.renderContent, onLineNumberClick: _this.props.onLineNumberClick });
                      }
                      var leftContent;
                      var rightContent;
                      var removed = obj.removed;
                      var added = obj.added;
                      if (obj.added && diffArray[i - 1] && diffArray[i - 1].removed) {
                          var preValueCount = diffArray[i - 1].count;
                          if (num <= (preValueCount - 1))
                              return undefined;
                          rightLineNumber = rightLineNumber + 1;
                          rightContent = ch;
                      }
                      else if (obj.removed && diffArray[i + 1] && !diffArray[i + 1].added) {
                          leftLineNumber = leftLineNumber + 1;
                          leftContent = ch;
                      }
                      else if (obj.removed && diffArray[i + 1] && diffArray[i + 1].added) {
                          leftLineNumber = leftLineNumber + 1;
                          var nextVal = diffArray[i + 1].value
                              .split('\n')
                              .filter(Boolean)[num];
                          leftContent = (nextVal && !_this.props.disableWordDiff)
                              ? wordDiff(ch, nextVal, 'added', styles, _this.props.renderContent)
                              : ch;
                          rightContent = (nextVal && !_this.props.disableWordDiff)
                              ? wordDiff(ch, nextVal, 'removed', styles, _this.props.renderContent)
                              : nextVal;
                          if (nextVal) {
                              rightLineNumber = rightLineNumber + 1;
                              added = true;
                          }
                      }
                      else {
                          rightLineNumber = rightLineNumber + 1;
                          rightContent = ch;
                      }
                      return react.createElement(line$1.DefaultLine, { styles: styles, leftLineNumber: !removed || leftLineNumber, rightLineNumber: !added || rightLineNumber, removed: removed, added: added, key: num, hideLineNumbers: _this.props.hideLineNumbers, hightlightLines: _this.props.highlightLines, renderContent: _this.props.renderContent, leftContent: leftContent, rightContent: rightContent, onLineNumberClick: _this.props.onLineNumberClick });
                  }));
              }); };
          };
          _this.inlineView = function (diffArray, styles) {
              var leftLineNumber = 0;
              var rightLineNumber = 0;
              return function () {
                  return diffArray.map(function (diffObj, i) {
                      return diffObj.value.split('\n')
                          .filter(function (ch) { return ch.length > 0; })
                          .map(function (ch, num) {
                          var content;
                          if (diffObj.added) {
                              rightLineNumber = rightLineNumber + 1;
                              if (diffArray[i - 1] && diffArray[i - 1].removed) {
                                  var preValue = diffArray[i - 1].value
                                      .split('\n')
                                      .filter(Boolean)[num];
                                  content = (preValue && !_this.props.disableWordDiff) ? wordDiff(preValue, ch, 'removed', styles, _this.props.renderContent) : ch;
                              }
                              else {
                                  content = ch;
                              }
                          }
                          else if (diffObj.removed) {
                              leftLineNumber = leftLineNumber + 1;
                              if (diffArray[i + 1] && diffArray[i + 1].added) {
                                  var nextVal = diffArray[i + 1].value
                                      .split('\n')
                                      .filter(Boolean)[num];
                                  content = (nextVal && !_this.props.disableWordDiff) ? wordDiff(ch, nextVal, 'added', styles, _this.props.renderContent) : ch;
                              }
                              else {
                                  content = ch;
                              }
                          }
                          else {
                              rightLineNumber = rightLineNumber + 1;
                              leftLineNumber = leftLineNumber + 1;
                              content = ch;
                          }
                          return react.createElement(line$1.InlineLine, { styles: styles, onLineNumberClick: _this.props.onLineNumberClick, key: num, hideLineNumbers: _this.props.hideLineNumbers, renderContent: _this.props.renderContent, removed: diffObj.removed, leftLineNumber: diffObj.added || leftLineNumber, rightLineNumber: diffObj.removed || rightLineNumber, content: content, hightlightLines: _this.props.highlightLines, added: diffObj.added });
                      });
                  });
              };
          };
          _this.computeStyles = memoize(styles$1.default);
          _this.render = function () {
              var _a = _this.props, oldValue = _a.oldValue, newValue = _a.newValue, splitView = _a.splitView;
              if (typeof oldValue !== 'string' || typeof newValue !== 'string') {
                  throw Error('"oldValue" and "newValue" should be strings');
              }
              var newStyles = _this.computeStyles(_this.props.styles);
              var diffArray = lib$1.diffLines(oldValue, newValue, {
                  newlineIsToken: true,
                  ignoreWhitespace: false,
                  ignoreCase: false,
              });
              var nodes = splitView
                  ? _this.splitView(diffArray, newStyles)()
                  : _this.inlineView(diffArray, newStyles)();
              return (react.createElement("table", { className: newStyles.diffContainer },
                  react.createElement("tbody", null, nodes)));
          };
          return _this;
      }
      DiffViewer.defaultProps = {
          oldValue: '',
          newValue: '',
          splitView: true,
          highlightLines: [],
          disableWordDiff: false,
          styles: {},
          hideLineNumbers: false,
      };
      DiffViewer.propTypes = {
          oldValue: propTypes.string.isRequired,
          newValue: propTypes.string.isRequired,
          splitView: propTypes.bool,
          disableWordDiff: propTypes.bool,
          renderContent: propTypes.func,
          onLineNumberClick: propTypes.func,
          styles: propTypes.object,
          hideLineNumbers: propTypes.bool,
          highlightLines: propTypes.arrayOf(propTypes.string),
      };
      return DiffViewer;
  }(react.Component));
  exports.default = DiffViewer;
  });

  var ReactDiffViewer = unwrapExports(lib$2);

  window['ReactDiffViewer'] = ReactDiffViewer;
  var ReactDiff = function ReactDiff(props) {
    return react.createElement(ReactDiffViewer, props);
  };

  var ReactDiffViewer$1 = /*#__PURE__*/Object.freeze({
    ReactDiff: ReactDiff
  });

  // import "core-js/shim";
  var jQuery = jquery;
  var jquery$1 = jquery;
  var classnames$2 = classnames;

  var dgColors2 = ["primary", "info", "secondary", "gray-700", "gray-500", "gray-400", "gray-700"];

  exports.$ = jquery;
  exports.Aside = Aside;
  exports.AutosizeInput = AutosizeInput;
  exports.Breadcrumb2 = Breadcrumb2$1;
  exports.Breadcrumbs = Breadcrumbs;
  exports.BreadcrumbsItem = BreadcrumbsItem;
  exports.DXCore = dxCore_es;
  exports.DXGridCore = dxGridCore_es;
  exports.DXReactCore = dxReactCore_es;
  exports.DXReactGrid = dxReactGrid_es;
  exports.DXReactGridBootstrap4 = dxReactGridBootstrap4_es;
  exports.Datetime = DateTime;
  exports.Header = Header;
  exports.NumberFormat = number_format$1;
  exports.Popper = Popper;
  exports.PropTypes = propTypes;
  exports.React = react;
  exports.ReactDOM = index;
  exports.ReactDiff = ReactDiffViewer$1;
  exports.ReactPopper = index$3;
  exports.ReactRedux = index$1;
  exports.ReactRouterDOM = reactRouterDom;
  exports.ReactTransitionGroup = index$5;
  exports.Reactstrap = index$4;
  exports.Redux = redux;
  exports.ReduxThunk = index$2;
  exports.Select = Select$1;
  exports.XHTMLEditor = XHTMLEditor;
  exports.__moduleExports = lib$2;
  exports.bootstrap = bootstrap$1;
  exports.classNames = classnames;
  exports.classnames = classnames$2;
  exports.dgColors2 = dgColors2;
  exports.draftJs = Draft$1;
  exports.draftJsWzz = reactDraftWysiwyg$2;
  exports.draftToHtml = draftjsToHtml;
  exports.findRouteName = findRouteName;
  exports.getPaths = getPaths;
  exports.htmlToDraft = htmlToDraft;
  exports.jQuery = jQuery;
  exports.jquery = jquery$1;
  exports.loaders = index$6;
  exports.moment = moment$1;
  exports.reduxLogger = reduxLogger$2;
  exports.styleInject = styleInject;
  exports.toastr = toastr;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
